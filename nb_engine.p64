picotron cartridge // www.picotron.net
version 2

:: src/
:: tests/
:: src/config.lua
--[[pod_format="raw",created="2025-11-07 21:17:14",modified="2025-11-07 21:48:05",revision=1]]
-- engine configuration

-- screen constants
screen_width=480
screen_height=270
screen_center_x=screen_width/2
screen_center_y=screen_height/2
-- default ray budget: tuned for 480px wide viewport; adaptive governor in main.lua can lower this
ray_count=128
-- CRITICAL: screen_center_x must equal screen_width/2, screen_center_y must equal screen_height/2
-- ray_count is decoupled from screen_width and can be configured independently for performance tuning
sdist=200 -- default; computed dynamically in raycast_scene() based on fov
map_size=128
objgrid_size=5
objgrid_array_size=26
fov=0.5

-- sprite configuration
sprite_size=32

-- fog configuration (unified linear fog system)
fog_near=5.0 -- near fog distance where fog begins
fog_far=20.0 -- far fog distance where fog is maximum
fog_hysteresis=0.5 -- minimum z change required to update fog level (reduces palette thrashing)
screenbright=1.0 -- screen brightness multiplier (1.0=normal, <1.0=darker for atmosphere)

-- lod configuration (ratios of fog_far)
wall_lod_ratio=0.4 -- ratio of fog_far for wall LOD transition
sprite_lod_ratio=0.5 -- ratio of fog_far for sprite LOD transition
wall_lod_distance=fog_far*wall_lod_ratio -- computed: walls beyond this z use simplified rendering
wall_tiny_screen_px=6 -- walls shorter than this many pixels use LOD solid fill

-- rendering configuration
row_stride=1 -- floor/ceiling stride; keep at 1 for correct perspective (governor can relax if needed)
per_cell_floors_enabled=false -- enable per-cell floor type detection (false=render entire scanline with single texture)
-- tline quality flag (0x400) is expensive; keep off unless visual artifacts demand it
tline_high_quality_near=false

-- raycast configuration
far_plane=25.0 -- maximum raycast distance; must be >= fog_far + 2.0 to prevent geometry popping

-- ai and interaction constants
ai_update_rate=2 -- frames between AI updates
interaction_range=0.5 -- proximity for triggers
combat_trigger_range=0.3 -- distance to trigger combat

-- player movement constants
player_rotation_speed=0.008 -- radians per frame when turning (slower, smoother)
player_move_speed=0.04 -- units per frame when moving (reduced)

-- door animation constants
door_anim_speed=0.06 -- door open/close speed per frame
door_close_delay=90 -- frames before door auto-closes

-- floor/ceiling types (tex indexes from gfx/1_surfaces.gfx, offset 32)
planetyps={
 -- stone_tile
 {tex=32,scale=1,height=0.5,lit=true,xvel=0,yvel=0},
 -- dirt
 {tex=33,scale=1,height=0.5,lit=true,xvel=0,yvel=0},
 -- stone_ceiling
 {tex=34,scale=1,height=0.5,lit=false,xvel=0,yvel=0},
 -- sky
 {tex=35,scale=2,height=1,lit=false,xvel=0.01,yvel=0},
 -- night_sky
 {tex=36,scale=2,height=1,lit=false,xvel=0.005,yvel=0}
}

-- wall texture sets (sprite indexes from gfx/0_walls.gfx)
texsets={
 -- none (removed to avoid collision with brick variant 0)
 -- brick
 {base=0,variants={0,1,2,3}},
 -- cobblestone
 {base=4,variants={4,5,6,7}},
 -- wood_plank
 {base=8,variants={8,9,10,11}},
 -- stone
 {base=12,variants={12,13,14,15}},
 -- grass (outdoor)
 {base=16,variants={16,17,18,19}},
 -- earth (outdoor)
 {base=20,variants={20,21,22,23}}
}

-- door types (sprite indexes from gfx/0_walls.gfx)
door_normal=24
door_locked=25
door_stay_open=26

-- helper: check if tile is a door
function is_door(val)
 return val>=door_normal and val<=door_stay_open
end

-- exit types (tile IDs)
exit_start=67
exit_end=68

-- wall fill constant
wall_fill_tile=1

-- generation parameters
gen_params={
 min_rooms=5,
 max_rooms=15,
 min_size=4,
 max_size=12,
 spacing=2,
 corridor_texture=0,
 room_door_prob=0.3,
 erode_amount=50,
 difficulty=1,
 max_difficulty=9,
 max_enemies_per_room=8,
 max_decorations_per_room=12,
 npc_hostile_ratio=0.7,
 items_per_room=2,
 pickup_density=0.1
}

gen_observability={
 enable_console=false,
 capture_history=true,
 history_limit=400,
 log_seed=true,
 log_room_attempts=true,
 log_corridors=true,
 log_progression=true,
 log_repairs=true
}

gen_adaptive_settings={
 spacing_relax_threshold=4,
 spacing_relax_step=1,
 spacing_max_relax=4,
 spacing_restore_delay=2,
 spacing_restore_step=1,
 max_room_failures=24,
 offcenter_bias=0.65,
 bias_radius=12,
 junction_retry_limit=6,
 corridor_jog_chance=0.25
}

-- helper constants
max_spawn_attempts=50
max_room_attempts=100

-- door testing parameters
test_door_open=nil -- if set to a value 0.0-1.0, forces all doors to this open state for testing
test_door_x=nil -- if set, only affects door at this position
test_door_y=nil -- if set, only affects door at this position

-- object type definitions (mx=sprite index from gfx files, my deprecated, mw/mh use sprite_size)
-- NOTE: my=0 is deprecated and maintained for backward compatibility only; will be removed once rendering code migrates
obj_types={
 player={solid=true,w=0.4,mx=0,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.8,flat=false,lit=nil,framect=nil,animspd=nil,yoffs=nil,kind="player"},
 enemy={solid=true,w=0.4,mx=64,my=0,mw=sprite_size,mh=sprite_size,y=0.1,h=0.8,flat=false,lit=nil,framect=4,animspd=0.25,yoffs={0,-0.01,0,-0.01},kind="hostile_npc",ai_type="follow",follow_speed=0.05,follow_range=20,patrol_speed=0.03},
 item={solid=false,w=0.3,mx=128,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.2,flat=false,lit=nil,framect=nil,animspd=nil,yoffs=nil,kind="direct_pickup",subtype="generic"},
 key={solid=false,w=0.3,mx=129,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.2,flat=false,lit=nil,framect=nil,animspd=nil,yoffs=nil,kind="direct_pickup",subtype="key"},
 heart={solid=false,w=0.3,mx=130,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.2,flat=false,lit=nil,framect=2,animspd=0.1,yoffs={0,0.05},kind="direct_pickup",subtype="heart"},
 decoration={solid=false,w=0.3,mx=148,my=0,mw=sprite_size,mh=sprite_size,y=0.3,h=0.4,flat=false,lit=0,framect=4,animspd=0.25,yoffs=nil,kind="decorative"},
 hostile_npc={solid=true,w=0.4,mx=64,my=0,mw=sprite_size,mh=sprite_size,y=0.1,h=0.8,flat=false,lit=nil,framect=4,animspd=0.25,yoffs={0,-0.01,0,-0.01},kind="hostile_npc",ai_type="follow",follow_speed=0.05,follow_range=20,patrol_speed=0.03},
 non_hostile_npc={solid=false,w=0.4,mx=73,my=0,mw=sprite_size,mh=sprite_size,y=0.1,h=0.8,flat=false,lit=nil,framect=1,animspd=0,yoffs=nil,kind="non_hostile_npc"},
 direct_pickup={solid=false,w=0.2,mx=128,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.2,flat=false,lit=nil,framect=2,animspd=0.1,yoffs={0,0.05},kind="direct_pickup"},
 interactable_chest={solid=false,w=0.3,mx=131,my=0,mw=sprite_size,mh=sprite_size,y=0.3,h=0.3,flat=false,lit=nil,framect=1,animspd=0,yoffs=nil,kind="interactable",subtype="chest"},
 interactable_shrine={solid=false,w=0.4,mx=132,my=0,mw=sprite_size,mh=sprite_size,y=0.3,h=0.5,flat=false,lit=nil,framect=1,animspd=0,yoffs=nil,kind="interactable",subtype="shrine"},
 interactable_trap={solid=false,w=0.2,mx=133,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.1,flat=true,lit=nil,framect=1,animspd=0,yoffs=nil,kind="interactable",subtype="trap"},
 interactable_note={solid=false,w=0.3,mx=134,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.2,flat=true,lit=nil,framect=1,animspd=0,yoffs=nil,kind="interactable",subtype="note"},
 interactable_exit={solid=false,w=0.3,mx=135,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.2,flat=false,lit=nil,framect=1,animspd=0,yoffs=nil,kind="interactable",subtype="exit"}
}

-- enemy type definitions (sprite indexes from gfx/2_characters.gfx, offset 64)
enemy_types={
 {name="rat",difficulty=1,min_count=1,max_count=3,obj_type=obj_types.hostile_npc,sprite=64,hp=1},
 {name="bat",difficulty=2,min_count=1,max_count=4,obj_type=obj_types.hostile_npc,sprite=65,hp=1},
 {name="slime",difficulty=3,min_count=2,max_count=5,obj_type=obj_types.hostile_npc,sprite=66,hp=2},
 {name="skeleton",difficulty=4,min_count=1,max_count=3,obj_type=obj_types.hostile_npc,sprite=67,hp=3},
 {name="goblin",difficulty=5,min_count=2,max_count=4,obj_type=obj_types.hostile_npc,sprite=68,hp=3},
 {name="orc",difficulty=6,min_count=1,max_count=3,obj_type=obj_types.hostile_npc,sprite=69,hp=4},
 {name="troll",difficulty=7,min_count=1,max_count=2,obj_type=obj_types.hostile_npc,sprite=70,hp=5},
 {name="demon",difficulty=8,min_count=1,max_count=2,obj_type=obj_types.hostile_npc,sprite=71,hp=6},
 {name="dragon",difficulty=9,min_count=1,max_count=1,obj_type=obj_types.hostile_npc,sprite=72,hp=10}
}

-- decoration type definitions (sprite indexes from gfx/3_props.gfx, offset 148)
decoration_types={
 {name="torch",difficulty=1,obj_type=obj_types.decoration,gen_tags={"lit","uni"},theme_tags={"dng","lit"},sprite=148},
 {name="barrel",difficulty=1,obj_type=obj_types.decoration,gen_tags={"uni"},theme_tags={"dng","house"},sprite=149},
 {name="crate",difficulty=1,obj_type=obj_types.decoration,gen_tags={"uni2"},theme_tags={"dng","house"},sprite=150},
 {name="pillar",difficulty=2,obj_type=obj_types.decoration,gen_tags={"big"},theme_tags={"dng","dem"},sprite=151},
 {name="statue",difficulty=3,obj_type=obj_types.decoration,gen_tags={"rare"},theme_tags={"dng","dem"},sprite=152},
 {name="chest",difficulty=2,obj_type=obj_types.decoration,gen_tags={"scatter"},theme_tags={"dng","house"},sprite=153},
 {name="tree",difficulty=1,obj_type=obj_types.decoration,gen_tags={"scatter"},theme_tags={"out"},sprite=154},
 {name="rock",difficulty=1,obj_type=obj_types.decoration,gen_tags={"uni"},theme_tags={"out"},sprite=155}
}

-- theme definitions
themes={
 dng={
  floor="stone_tile",
  roof="stone_ceiling",
  decor_prob=0.8,
  rules={
   room_shape_weights={square=0.5,hall_horizontal=0.25,hall_vertical=0.2,grand=0.1},
   room_extra_size=1,
   bias_radius=10,
   center_bias=0.55,
   corridor_jog_chance=0.2,
   erosion_intensity=1.0
  }
 },
 out={
  floor="dirt",
  roof="sky",
  decor_prob=0.5,
  rules={
   room_shape_weights={hall_horizontal=0.45,square=0.35,grand=0.05,hall_vertical=0.15},
   room_extra_size=0,
   bias_radius=14,
   center_bias=0.7,
   corridor_jog_chance=0.35,
   erosion_intensity=1.2
  }
 },
 dem={
  floor="stone_tile",
  roof="night_sky",
  decor_prob=0.9,
  rules={
   room_shape_weights={square=0.4,hall_vertical=0.3,hall_horizontal=0.2,grand=0.15},
   room_extra_size=2,
   bias_radius=8,
   center_bias=0.5,
   corridor_jog_chance=0.15,
   erosion_intensity=0.8
  }
 },
 house={
  floor="stone_tile",
  roof="stone_ceiling",
  decor_prob=0.7,
  rules={
   room_shape_weights={square=0.6,hall_horizontal=0.2,hall_vertical=0.2},
   room_extra_size=0,
   bias_radius=9,
   center_bias=0.6,
   corridor_jog_chance=0.1,
   erosion_intensity=0.5
  }
 },
 dark={
  floor="stone_tile",
  roof="night_sky",
  decor_prob=0.6,
  rules={
   room_shape_weights={square=0.35,hall_vertical=0.35,hall_horizontal=0.2,grand=0.1},
   room_extra_size=1,
   bias_radius=8,
   center_bias=0.5,
   corridor_jog_chance=0.25,
   erosion_intensity=0.9
  }
 }
}

-- fog palettes (distance-based)
-- extended to support all 64 colors in Picotron
-- base colors 0-15 are remapped per fog level; colors 16-63 map to their fogged equivalents
pals={
 -- level 0: no fog
 {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63},
 -- level 1
 {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,5,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,5,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,5,48,49,50,51,52,53,54,5,56,57,58,59,60,61,62,5},
 -- level 2
 {0,1,2,3,4,5,6,7,8,9,10,11,12,13,5,5,16,17,18,19,20,21,22,23,24,25,26,27,28,29,5,5,32,33,34,35,36,37,38,39,40,41,42,43,44,45,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,61,5,5},
 -- level 3
 {0,1,2,3,4,5,6,7,8,9,10,11,12,5,5,5,16,17,18,19,20,21,22,23,24,25,26,27,28,5,5,5,32,33,34,35,36,37,38,39,40,41,42,43,44,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 4
 {0,1,2,3,4,5,6,7,8,9,10,11,5,5,5,5,16,17,18,19,20,21,22,23,24,25,26,27,5,5,5,5,32,33,34,35,36,37,38,39,40,41,42,43,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 5
 {0,1,2,3,4,5,6,7,8,9,10,5,5,5,5,5,16,17,18,19,20,21,22,23,24,25,26,5,5,5,5,5,32,33,34,35,36,37,38,39,40,41,42,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 6
 {0,1,2,3,4,5,6,7,8,9,5,5,5,5,5,5,16,17,18,19,20,21,22,23,24,25,5,5,5,5,5,5,32,33,34,35,36,37,38,39,40,41,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 7
 {0,1,2,3,4,5,6,7,8,5,5,5,5,5,5,5,16,17,18,19,20,21,22,23,24,5,5,5,5,5,5,5,32,33,34,35,36,37,38,39,40,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 8
 {0,1,2,3,4,5,6,7,5,5,5,5,5,5,5,5,16,17,18,19,20,21,22,23,5,5,5,5,5,5,5,5,32,33,34,35,36,37,38,39,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 9
 {0,1,2,3,4,5,6,5,5,5,5,5,5,5,5,5,16,17,18,19,20,21,5,5,5,5,5,5,5,5,5,5,32,33,34,35,36,37,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 10
 {0,1,2,3,4,5,5,5,5,5,5,5,5,5,5,5,16,17,18,19,20,21,5,5,5,5,5,5,5,5,5,5,32,33,34,35,36,37,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 11
 {0,1,2,3,4,5,5,5,5,5,5,5,5,5,5,5,16,17,18,19,20,21,5,5,5,5,5,5,5,5,5,5,32,33,34,35,36,37,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 12
 {0,1,2,3,5,5,5,5,5,5,5,5,5,5,5,5,16,17,18,19,5,5,5,5,5,5,5,5,5,5,5,5,32,33,34,35,5,5,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 13
 {0,1,2,5,5,5,5,5,5,5,5,5,5,5,5,5,16,17,18,5,5,5,5,5,5,5,5,5,5,5,5,5,32,33,34,5,5,5,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 14
 {0,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,16,17,5,5,5,5,5,5,5,5,5,5,5,5,5,5,32,33,5,5,5,5,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 15: maximum fog
 {0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,16,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,32,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5}
}

:: src/door_system.lua
--[[pod_format="raw",created="2025-11-07 21:17:14",modified="2025-11-07 21:48:06",revision=1]]
-- door animation system
-- test mode state (to avoid permanent mutation)
test_mode_prev=false
test_mode_saved_state={}

-- create a door
function create_door(x,y,dtype,key_id)
 local door={
  x=x,
  y=y,
  open=0, -- 0=closed, 1=fully open
  opening=false, -- animation state
  timer=0,
  dtype=dtype or door_normal,
  keynum=key_id, -- nil if unlocked, key id if locked
  stayopen=(dtype==door_stay_open) -- doors with door_stay_open dtype stay open
 }
 
 -- prevent duplicates at same grid cell
 local existing = doorgrid[x] and doorgrid[x][y] or nil
 if existing then
  printh("warning: duplicate door at ("..x..","..y..") - replacing")
  del(doors, existing)
 end
 add(doors,door)
 doorgrid[x][y]=door
	-- walls layer already set by generation to door tile ID (authoritative)
 
 return door
end

-- update all doors
function update_doors()
 -- handle test mode transitions to avoid permanent state mutation
 if test_door_mode and not test_mode_prev then
  -- entering test mode: save states
  test_mode_saved_state={}
  for door in all(doors) do
   test_mode_saved_state[door]={open=door.open,opening=door.opening,timer=door.timer}
  end
 elseif (not test_door_mode) and test_mode_prev then
  -- exiting test mode: restore states
  for door in all(doors) do
   local st=test_mode_saved_state[door]
   if st~=nil then
    door.open=st.open
    door.opening=st.opening
    door.timer=st.timer
   end
  end
  test_mode_saved_state={}
 end
 
 -- in test mode, temporarily override open values (restored on exit)
 if test_door_mode then
  for door in all(doors) do
   door.open=test_door_open or 0
  end
  -- keep early return to skip normal animation while testing
  test_mode_prev=true
  return
 end
 
 test_mode_prev=false
 
 for door in all(doors) do
  if door.opening then
   -- play sound on start
   if door.open==0 then
    -- sfx(10) -- door open sound
   end
   -- animate opening
   door.open+=door_anim_speed
   if door.open>1 then
    door.open=1
    door.opening=false
    door.timer=door_close_delay
   end
  else
   -- not opening
   if door.timer>0 then
    door.timer-=1
   elseif not door.stayopen then
    -- close door
    door.open=max(door.open-door_anim_speed,0)
   end
  end
 end
end



-- remove a door
function remove_door(x,y)
 local door=doorgrid[x][y]
 if door then
  del(doors,door)
  doorgrid[x][y]=nil
		set_wall(x,y,0)
 end
end

:: src/dungeon_gen.lua
--[[pod_format="raw",created="2025-11-07 21:17:13",modified="2025-11-07 21:48:06",revision=1]]
-- procedural dungeon generation

-- generation state
gen_rects={}
gen_nodes={}
gen_edges={}
gen_inventory={}
gen_objects={}
gen_locked_edges={}

-- theme-specific floor id used during carving/eroding; initialized to stone_tile (1)
local gen_floor_id=1

-- observability + diagnostics configuration (defaults if config.lua did not define them)
local observability = rawget(_G,"gen_observability") or {
 enable_console=false,
 capture_history=true,
 history_limit=400,
 log_seed=true,
 log_room_attempts=true,
 log_corridors=true,
 log_progression=true,
 log_repairs=true
}

local gen_history={}
local protected_tiles={}
local dynamic_spacing=0
local base_spacing=0
local spacing_restore_timer=0
local spacing_relaxations=0
local active_theme_rules=nil
local adaptive_settings=rawget(_G,"gen_adaptive_settings") or {
 spacing_relax_threshold=4,
 spacing_relax_step=1,
 spacing_max_relax=4,
 spacing_restore_delay=2,
 spacing_restore_step=1,
 max_room_failures=20,
 offcenter_bias=0.65,
 bias_radius=12,
 junction_retry_limit=4,
 corridor_jog_chance=0.25
}

local room_failure_streak=0
local total_room_failures=0

local function hist_push(entry)
 if not observability.capture_history then return end
 add(gen_history,entry)
 if #gen_history>(observability.history_limit or 400) then
  deli(gen_history,1)
 end
end

local tick_spacing

local function register_room_failure(reason)
 room_failure_streak+=1
 total_room_failures+=1
 tick_spacing(false)
 if observability.log_room_attempts then
  gen_log("room_fail",reason.." (streak="..room_failure_streak..")")
 end
 if room_failure_streak>=(adaptive_settings.spacing_relax_threshold or 4) then
  relax_spacing()
  room_failure_streak=0
 end
end

local function register_room_success()
 room_failure_streak=0
 tick_spacing(true)
end

local function gen_log(tag,msg)
 local line="["..tag.."] "..msg
 hist_push(line)
 if observability.enable_console then printh(line) end
end

local function clear_protected()
 protected_tiles={}
end

local function protect_tile(x,y)
 if not x or not y then return end
 protected_tiles[x]=protected_tiles[x] or {}
 protected_tiles[x][y]=true
end

local function is_tile_protected(x,y)
 return protected_tiles[x] and protected_tiles[x][y] or false
end

local function reset_adaptive_spacing()
 base_spacing=gen_params.spacing or 0
 dynamic_spacing=base_spacing
 spacing_restore_timer=0
 spacing_relaxations=0
 room_failure_streak=0
 total_room_failures=0
end

local function relax_spacing()
 if spacing_relaxations>=(adaptive_settings.spacing_max_relax or 4) then return end
 dynamic_spacing=max(0,dynamic_spacing-(adaptive_settings.spacing_relax_step or 1))
 spacing_relaxations+=1
 spacing_restore_timer=adaptive_settings.spacing_restore_delay or 2
 gen_log("spacing","relaxed spacing to "..dynamic_spacing)
end

local function tick_spacing(success)
 if success then
  if spacing_restore_timer>0 then
   spacing_restore_timer-=1
  elseif dynamic_spacing<base_spacing then
   dynamic_spacing=min(base_spacing,dynamic_spacing+(adaptive_settings.spacing_restore_step or 1))
   if dynamic_spacing==base_spacing then
    spacing_relaxations=0
   end
   gen_log("spacing","restored spacing to "..dynamic_spacing)
  end
 else
  if spacing_restore_timer>0 then
   spacing_restore_timer-=1
  end
 end
end

local function rect_area(rect)
 return (rect[3]-rect[1]+1)*(rect[4]-rect[2]+1)
end

local function classify_room_style(rect)
 local w=rect[3]-rect[1]+1
 local h=rect[4]-rect[2]+1
 local ratio=w/h
 if ratio>=1.8 then
  return "hall_horizontal"
 elseif ratio<=0.55 then
  return "hall_vertical"
 elseif w*h>=120 then
  return "grand"
 elseif w<=6 and h<=6 then
  return "compact"
 else
  return "square"
 end
end

local function choose_weighted(weights,default_key)
 if not weights then return default_key end
 local total=0
 for _,v in pairs(weights) do
  total+=v
 end
 if total<=0 then return default_key end
 local roll=rnd(total)
 local acc=0
 for key,v in pairs(weights) do
  acc+=v
  if roll<=acc then return key end
 end
 return default_key
end

local function get_edge_between(a,b)
 for e in all(gen_edges) do
  if (e.n1==a and e.n2==b) or (e.n1==b and e.n2==a) then
   return e
  end
 end
 return nil
end

local function locate_room_for_position(x,y)
 for node in all(gen_nodes) do
  local r=node.rect
  if x>=r[1] and x<=r[3] and y>=r[2] and y<=r[4] then
   return node
  end
 end
 return nil
end

local function relocate_key_to_room(keynum,target_node)
 if not target_node then return false end
 local sx,sy=find_spawn_point(target_node.rect)
 if not sx then
  sx=target_node.midx+0.5
  sy=target_node.midy+0.5
 end
 for ob in all(gen_objects) do
  if ob.typ==obj_types.key and ob.keynum==keynum then
   ob.pos={sx,sy}
   ob.room_index=target_node.index
   if observability.log_progression then
    gen_log("progression","relocated key#"..keynum.." to room "..target_node.index)
   end
   return true
  end
 end
 return false
end

local function validate_and_repair_progression(start_node,locked_edges)
 if not locked_edges or #locked_edges==0 then return end
 local key_rooms={}
 for ob in all(gen_objects) do
  if ob.typ==obj_types.key and ob.keynum then
   if not ob.room_index then
    local node=locate_room_for_position(ob.pos[1],ob.pos[2])
    ob.room_index=node and node.index or nil
   end
   key_rooms[ob.keynum]=ob.room_index
  end
 end

 local acquired={}
 local visited={}
 local queue={start_node}
 visited[start_node]=true
 local function collect_keys(node)
  for ob in all(gen_objects) do
   if ob.typ==obj_types.key and ob.keynum and ob.room_index==node.index then
    acquired[ob.keynum]=true
   end
  end
 end
 collect_keys(start_node)
 local progressed=true
 while progressed do
  progressed=false
  for edge in all(gen_edges) do
   local a,b=edge.n1,edge.n2
   local a_vis=visited[a]
   local b_vis=visited[b]
   if a_vis and not b_vis then
    local can_traverse=true
    if edge.locked and edge.keynum and not acquired[edge.keynum] then
     can_traverse=false
    end
    if can_traverse then
     visited[b]=true
     collect_keys(b)
     progressed=true
    end
   elseif b_vis and not a_vis then
    local can_traverse=true
    if edge.locked and edge.keynum and not acquired[edge.keynum] then
     can_traverse=false
    end
    if can_traverse then
     visited[a]=true
     collect_keys(a)
     progressed=true
    end
   end
  end
 end

 local relocated=false
 for edge in all(locked_edges) do
  if edge.locked and edge.keynum then
   local n1_vis=visited[edge.n1]
   local n2_vis=visited[edge.n2]
   if not (n1_vis and n2_vis) then
    if relocate_key_to_room(edge.keynum,start_node) then
     relocated=true
     acquired[edge.keynum]=true
     visited[edge.n1]=true
     visited[edge.n2]=true
    end
   end
  end
 end
 if relocated then
  validate_and_repair_progression(start_node,locked_edges)
 end
end

local function ensure_theme_rules(theme)
 local rules=(themes[theme] and themes[theme].rules) or nil
 active_theme_rules=rules or {
  room_aspect_bias=0.35,
  room_extra_size=0,
  spacing_floor=0,
  corridor_width=1,
  corridor_jog_chance=adaptive_settings.corridor_jog_chance or 0.25
 }
end

-- helper: check if tile is a wall
function is_wall(val)
 return val>0 and val<door_normal
end

-- helper: check if tile is a door
function is_door(val)
 return val>=door_normal and val<=door_stay_open
end

-- helper: check if tile is an exit
function is_exit(val)
 return val>=exit_start and val<=exit_end
end

-- helper: boundary cell is reserved if it has a door/exit in either layer
function is_reserved_boundary(x,y)
 local w=get_wall(x,y)
 if is_door(w) or is_exit(w) then return true end
 -- defensive: should always be 0 if walls layer is authoritative
 if get_door(x,y)>0 then return true end
 if doorgrid[x] and doorgrid[x][y] then return true end
 return false
end

-- helper: check if rectangles overlap
function rect_overlaps(rect)
 -- reject out-of-bounds rectangles upfront (map is 0..127)
 if rect[1]<0 or rect[3]>=128 or rect[2]<0 or rect[4]>=128 then
  return true
 end
 for r in all(gen_rects) do
  local spacing=dynamic_spacing or 0
  if not (rect[3]+spacing<r[1] or rect[1]>r[3]+spacing or
          rect[4]+spacing<r[2] or rect[2]>r[4]+spacing) then
   return true
  end
 end
 return false
end

local function rect_conflicts(rect,ignore_nodes,spacing_override)
 if rect[1]<0 or rect[3]>=map_size or rect[2]<0 or rect[4]>=map_size then
  return true
 end
 local ignore={}
 if ignore_nodes then
  for n in all(ignore_nodes) do
   if n and n.index then
    ignore[n.index]=true
   end
  end
 end
 local spacing=(spacing_override~=nil) and spacing_override or (dynamic_spacing or 0)
 for idx=1,#gen_rects do
  if not ignore[idx] then
   local r=gen_rects[idx]
   if r and not (rect[3]+spacing<r[1] or rect[1]>r[3]+spacing or rect[4]+spacing<r[2] or rect[2]>r[4]+spacing) then
    return true
   end
  end
 end
 return false
end

-- helper: fill rectangle using set_wall
-- Note: Uses Lua loops with userdata:set() calls; potential optimization:
-- batch userdata operations or memset() if available per Picotron guidelines
function fill_rect(rect,val)
 local x0=max(0,rect[1])
 local x1=min(127,rect[3])
 local y0=max(0,rect[2])
 local y1=min(127,rect[4])
 local fill_val=(val or 0)
 for x=x0,x1 do
  for y=y0,y1 do
   set_wall(x,y,fill_val)
  end
 end
end

-- helper: try place door with fallback positions
function try_place_door_with_fallback(x,y,dtype)
 dtype=dtype or door_normal
 local attempts={{0,0},{-1,0},{1,0},{0,-1},{0,1},{-2,0},{2,0},{0,-2},{0,2}}
 local should_place=rnd(1)<gen_params.room_door_prob
 if not should_place then
  gen_log("door","skipped optional door at "..x..","..y)
  return false
 end
 for i=1,#attempts do
  local off=attempts[i]
  local ax,ay=x+off[1],y+off[2]
  if ax>=0 and ax<map_size and ay>=0 and ay<map_size then
   local existing=get_wall(ax,ay)
   if is_wall(existing) then
    set_wall(ax,ay,dtype)
    create_door(ax,ay,dtype)
    protect_tile(ax,ay)
    if observability.log_corridors then
     gen_log("door","placed door at "..ax..","..ay.." after "..i.." attempts")
    end
    return true
   end
  end
 end
 if observability.log_repairs then
  gen_log("door","failed to place door near "..x..","..y)
 end
 return false
end

-- helper: generate random room
function random_room(base_node,is_special)
 local min_size=gen_params.min_size or 4
 local max_size=gen_params.max_size or 12
 if active_theme_rules and active_theme_rules.room_extra_size then
  max_size+=active_theme_rules.room_extra_size
 end
 if max_size<min_size then max_size=min_size end
 local shape_weights=active_theme_rules and active_theme_rules.room_shape_weights
 local shape=choose_weighted(shape_weights,"square")
 local w,h
 if is_special then
  w,h=12,12
 else
  if shape=="hall_horizontal" then
   w=flr(rnd(max_size-min_size+1))+min_size
   h=max(min_size,flr(w*0.5))
  elseif shape=="hall_vertical" then
   h=flr(rnd(max_size-min_size+1))+min_size
   w=max(min_size,flr(h*0.5))
  elseif shape=="grand" then
   w=max_size
   h=max(min_size,max_size-2)
  else
   w=flr(rnd(max_size-min_size+1))+min_size
   h=flr(rnd(max_size-min_size+1))+min_size
  end
 end
 w=min(w, max_size)
 h=min(h, max_size)
 w=max(w,min_size)
 h=max(h,min_size)

 local function sample_offset(range)
  local bias=(active_theme_rules and active_theme_rules.center_bias) or adaptive_settings.offcenter_bias or 0.65
  local magnitude=flr(range*(rnd()^bias))
  if rnd(1)<0.5 then magnitude=-magnitude end
  return magnitude
 end

 local x,y
 if base_node then
  local radius=(active_theme_rules and active_theme_rules.bias_radius) or adaptive_settings.bias_radius or 12
  local dx=sample_offset(radius)
  local dy=sample_offset(radius)
  x=base_node.midx+dx-flr(w/2)
  y=base_node.midy+dy-flr(h/2)
 else
  local margin=4
  x=flr(rnd(map_size-w-margin*2))+margin
  y=flr(rnd(map_size-h-margin*2))+margin
 end

 x=max(1,min(map_size-w-2,x))
 y=max(1,min(map_size-h-2,y))

 return {x,y,x+w-1,y+h-1}
end

-- helper: add room to generation state
function add_room(rect,is_junction)
 local index=#gen_nodes+1
 gen_rects[index]=rect
 local style=classify_room_style(rect)
 local node={
  rect=rect,
  midx=flr((rect[1]+rect[3])/2),
  midy=flr((rect[2]+rect[4])/2),
  edges={},
  is_junction=is_junction or false,
  style=style,
  area=rect_area(rect),
  theme=gen_params.theme,
  metadata={},
  index=index
 }
 if observability.log_room_attempts then
  gen_log("room","added room "..(#gen_nodes+1).." style="..style.." rect=("..rect[1]..","..rect[2]..")-("..rect[3]..","..rect[4]..")")
 end
 add(gen_nodes,node)
 return node
end

-- helper: determine corridor type between two rooms
function get_corridor_type(r1,r2)
 local ox=not (r1[3]<r2[1] or r1[1]>r2[3])
 local oy=not (r1[4]<r2[2] or r1[2]>r2[4])
 if ox and not oy then return "vert" end
 if oy and not ox then return "horiz" end
 return "l_shape"
end

-- helper: place door at exact boundary wall tile with retry
function place_boundary_door_with_retry(bx,by,dtype,max_attempts)
 dtype=dtype or door_normal
 local offsets={{0,0},{-1,0},{1,0},{0,-1},{0,1},{-2,0},{2,0},{0,-2},{0,2}}
 local attempts=max_attempts or #offsets
 for i=1,attempts do
  local off=offsets[i] or offsets[#offsets]
  local ax,ay=bx+off[1],by+off[2]
  if ax>=0 and ax<map_size and ay>=0 and ay<map_size then
   local tile=get_wall(ax,ay)
   if is_wall(tile) then
    set_wall(ax,ay,dtype)
    create_door(ax,ay,dtype)
    protect_tile(ax,ay)
    if observability.log_corridors then
     gen_log("door","boundary door placed at "..ax..","..ay.." (from "..bx..","..by..")")
    end
    return true
   end
  end
 end
 return false
end

-- helper: place door at exact boundary wall tile
function place_boundary_door(bx,by,dtype)
 -- bx,by = boundary wall tile (between corridor and room)
 if bx>=0 and bx<128 and by>=0 and by<128 then
  if is_wall(get_wall(bx,by)) then
   set_wall(bx,by,dtype or door_normal)
   create_door(bx,by,dtype)
   protect_tile(bx,by)
   return true
  end
 end
 return false
end

-- helper: ensure boundary passage (fallback for failed door placement)
function ensure_boundary_passage(bx,by)
 if bx>=0 and bx<128 and by>=0 and by<128 then
  local tile=get_wall(bx,by)
  -- if wall is still blocking and not a door, clear it
  if tile>0 and not is_door(tile) and not is_exit(tile) then
   set_wall(bx,by,0)
   set_floor(bx,by,gen_floor_id)
   protect_tile(bx,by)
   if observability.log_repairs then
    gen_log("door","fallback cleared wall at ("..bx..","..by..")")
   end
   return true
  end
 end
 return false
end

local function verify_boundary_door(bx,by,dtype)
 if not bx or not by then return end
 dtype=dtype or door_normal
 if bx<0 or bx>=map_size or by<0 or by>=map_size then return end
 local tile=get_wall(bx,by)
 if is_door(tile) then
  protect_tile(bx,by)
  return
 end
 if tile==0 then
  set_wall(bx,by,dtype)
  create_door(bx,by,dtype)
  protect_tile(bx,by)
  if observability.log_repairs then
   gen_log("door","repaired missing door at "..bx..","..by)
  end
 else
  local ok=place_boundary_door_with_retry(bx,by,dtype,6)
  if not ok then
   ensure_boundary_passage(bx,by)
  end
 end
end

local function carve_horizontal_span(y,x_start,x_end,floor_id)
 if not floor_id then floor_id=gen_floor_id end
 if y<0 or y>=map_size then return end
 local a=min(x_start,x_end)
 local b=max(x_start,x_end)
 a=max(0,a)
 b=min(map_size-1,b)
 for x=a,b do
  set_wall(x,y,0)
  set_floor(x,y,floor_id)
 end
end

local function carve_vertical_span(x,y_start,y_end,floor_id)
 if not floor_id then floor_id=gen_floor_id end
 if x<0 or x>=map_size then return end
 local a=min(y_start,y_end)
 local b=max(y_start,y_end)
 a=max(0,a)
 b=min(map_size-1,b)
 for y=a,b do
  set_wall(x,y,0)
  set_floor(x,y,floor_id)
 end
end

local function create_horizontal_corridor(n1,n2,edge)
 local left,right=n1,n2
 if n1.midx>n2.midx then left,right=n2,n1 end
 local r_left,r_right=left.rect,right.rect
 local y_start=max(r_left[2],r_right[2])
 local y_end=min(r_left[4],r_right[4])
 local y
 if y_start<=y_end then
  y=flr((y_start+y_end)/2)
 else
  y=flr((n1.midy+n2.midy)/2)
 end
 local jog_offset=0
 local jog_chance=(active_theme_rules and active_theme_rules.corridor_jog_chance) or adaptive_settings.corridor_jog_chance or 0.25
 if rnd(1)<jog_chance then
  local offset=(rnd(1)<0.5) and -1 or 1
  local candidate=y+offset
  if candidate>1 and candidate<map_size-2 then
   y=candidate
   jog_offset=offset
  end
 end
 local bx_left=r_left[3]+1
 local bx_right=r_right[1]-1
 local success=true
 if not place_boundary_door_with_retry(bx_left,y,door_normal,5) then
  success=false
  ensure_boundary_passage(bx_left,y)
 end
 if not place_boundary_door_with_retry(bx_right,y,door_normal,5) then
  success=false
  ensure_boundary_passage(bx_right,y)
 end
 carve_horizontal_span(y,bx_left+1,bx_right-1,gen_floor_id)
 verify_boundary_door(bx_left,y,door_normal)
 verify_boundary_door(bx_right,y,door_normal)
 edge.b1={x=bx_left,y=y}
 edge.b2={x=bx_right,y=y}
 edge.shape=jog_offset~=0 and "jog" or "straight"
 edge.metadata.corridor_y=y
 edge.metadata.jog_offset=jog_offset
 return success
end

local function create_vertical_corridor(n1,n2,edge)
 local top,bottom=n1,n2
 if n1.midy>n2.midy then top,bottom=n2,n1 end
 local r_top,r_bottom=top.rect,bottom.rect
 local x_start=max(r_top[1],r_bottom[1])
 local x_end=min(r_top[3],r_bottom[3])
 local x
 if x_start<=x_end then
  x=flr((x_start+x_end)/2)
 else
  x=flr((n1.midx+n2.midx)/2)
 end
 local jog_offset=0
 local jog_chance=(active_theme_rules and active_theme_rules.corridor_jog_chance) or adaptive_settings.corridor_jog_chance or 0.25
 if rnd(1)<jog_chance then
  local offset=(rnd(1)<0.5) and -1 or 1
  local candidate=x+offset
  if candidate>1 and candidate<map_size-2 then
   x=candidate
   jog_offset=offset
  end
 end
 local by_top=r_top[4]+1
 local by_bottom=r_bottom[2]-1
 local success=true
 if not place_boundary_door_with_retry(x,by_top,door_normal,5) then
  success=false
  ensure_boundary_passage(x,by_top)
 end
 if not place_boundary_door_with_retry(x,by_bottom,door_normal,5) then
  success=false
  ensure_boundary_passage(x,by_bottom)
 end
 carve_vertical_span(x,by_top+1,by_bottom-1,gen_floor_id)
 verify_boundary_door(x,by_top,door_normal)
 verify_boundary_door(x,by_bottom,door_normal)
 edge.b1={x=x,y=by_top}
 edge.b2={x=x,y=by_bottom}
 edge.shape=jog_offset~=0 and "jog" or "straight"
 edge.metadata.corridor_x=x
 edge.metadata.jog_offset=jog_offset
 return success
end

local function create_l_shaped_corridor(n1,n2,edge)
local orient_horizontal_first=rnd(1)<0.5
local anchor_x=orient_horizontal_first and n2.midx or n1.midx
local anchor_y=orient_horizontal_first and n1.midy or n2.midy
local jrect
local offsets={{0,0},{1,0},{-1,0},{0,1},{0,-1},{2,0},{-2,0},{0,2},{0,-2}}
local attempt_limit=adaptive_settings.junction_retry_limit or 4
for i=1,#offsets do
 local off=offsets[i]
 local cx=max(1,min(map_size-2,anchor_x+off[1]))
 local cy=max(1,min(map_size-2,anchor_y+off[2]))
 local candidate={cx-1,cy-1,cx+1,cy+1}
 if not rect_conflicts(candidate,{n1,n2},0) then
  jrect=candidate
  anchor_x=cx
  anchor_y=cy
  break
 end
 if i>=attempt_limit then break end
end
 local success=true
 if not jrect then
  -- fallback: carve direct manhattan path without junction
  orient_horizontal_first=true
  anchor_x=n2.midx
  anchor_y=n1.midy
  jrect=nil
  success=false
  if observability.log_corridors then
   gen_log("corridor","fallback L-shape without junction between rooms")
  end
 else
  fill_rect(jrect,0)
  for x=jrect[1],jrect[3] do
   for y=jrect[2],jrect[4] do
    set_floor(x,y,gen_floor_id)
   end
  end
  local jnode=add_room(jrect,true)
  edge.metadata.junction_node=jnode
 end

 local function connect_horizontal(from_node, target_x, y)
  local rect=from_node.rect
  local side=target_x>from_node.midx and 1 or -1
  local boundary_from=(side==1) and rect[3]+1 or rect[1]-1
  local boundary_to=side==1 and target_x-1 or target_x+1
  local door_pos=boundary_from
  if not place_boundary_door_with_retry(door_pos, y, door_normal,5) then
   success=false
   ensure_boundary_passage(door_pos,y)
  end
  carve_horizontal_span(y, boundary_from+side, boundary_to, gen_floor_id)
  verify_boundary_door(door_pos,y,door_normal)
  return {x=door_pos,y=y}
 end

 local function connect_vertical(from_node, x, target_y)
  local rect=from_node.rect
  local side=target_y>from_node.midy and 1 or -1
  local boundary_from=(side==1) and rect[4]+1 or rect[2]-1
  local boundary_to=side==1 and target_y-1 or target_y+1
  local door_pos=boundary_from
  if not place_boundary_door_with_retry(x,door_pos,door_normal,5) then
   success=false
   ensure_boundary_passage(x,door_pos)
  end
  carve_vertical_span(x, boundary_from+side, boundary_to, gen_floor_id)
  verify_boundary_door(x,door_pos,door_normal)
  return {x=x,y=door_pos}
 end

 local b1,b2
 if orient_horizontal_first then
  local horizontal_y=n1.midy
  b1=connect_horizontal(n1, anchor_x, horizontal_y)
  local vertical_x=jrect and anchor_x or b1.x+(anchor_x>b1.x and 1 or -1)
  b2=connect_vertical(n2, vertical_x, anchor_y)
 else
  local vertical_x=n1.midx
  b1=connect_vertical(n1, vertical_x, anchor_y)
  local horizontal_y=jrect and anchor_y or b1.y+(anchor_y>b1.y and 1 or -1)
  b2=connect_horizontal(n2, anchor_x, horizontal_y)
 end

 edge.b1=b1
 edge.b2=b2
 edge.shape="l_shape"
 edge.metadata.anchor={x=anchor_x,y=anchor_y}
 edge.metadata.orientation=orient_horizontal_first and "hv" or "vh"
 return success
end

function create_corridor(n1,n2)
 local edge={n1=n1,n2=n2,metadata={}}
 local ctype=get_corridor_type(n1.rect,n2.rect)
 local success=true
 if ctype=="horiz" then
  success=create_horizontal_corridor(n1,n2,edge)
 elseif ctype=="vert" then
  success=create_vertical_corridor(n1,n2,edge)
 else
  success=create_l_shaped_corridor(n1,n2,edge)
 end
 edge.success=success
 add(gen_edges,edge)
 add(n1.edges,n2)
 add(n2.edges,n1)
 if observability.log_corridors then
  local status=success and "ok" or "fallback"
  gen_log("corridor","linked nodes "..n1.index.." <-> "..n2.index.." ("..ctype..","..status..")")
 end
 return success
end

-- helper: try to generate and connect a room
function try_generate_room()
 if #gen_nodes==0 then return false end
 local base=gen_nodes[flr(rnd(#gen_nodes))+1]
 if not base then return false end
 local rect=random_room(base,false)
 
 if rect[1]<2 or rect[3]>map_size-3 or rect[2]<2 or rect[4]>map_size-3 then
  register_room_failure("bounds")
  return false
 end
 
 if rect_overlaps(rect) then
  register_room_failure("overlap")
  return false
 end
 
 local node=add_room(rect)
 fill_rect(rect,0)
 for x=max(0,rect[1]),min(map_size-1,rect[3]) do
  for y=max(0,rect[2]),min(map_size-1,rect[4]) do
   set_floor(x, y, gen_floor_id)
  end
 end
 local corridor_ok=create_corridor(base,node)
 if not corridor_ok and observability.log_corridors then
  gen_log("corridor","degenerate corridor between nodes "..base.index.." and "..node.index)
 end
 register_room_success()
 return true
end

-- helper: apply wall textures to room perimeter
function apply_room_walls(rect,tex)
 -- ensure tex is never 0
 if tex==0 then tex=1 end
 
 for x=rect[1],rect[3] do
  if rect[2]-1>=0 and rect[2]-1<128 and x>=0 and x<128 then
   -- skip reserved cells (doors/exits in any layer)
		if not is_reserved_boundary(x,rect[2]-1) then
     set_wall(x,rect[2]-1,tex)
   end
  end
  if rect[4]+1>=0 and rect[4]+1<128 and x>=0 and x<128 then
   -- skip reserved cells (doors/exits in any layer)
		if not is_reserved_boundary(x,rect[4]+1) then
     set_wall(x,rect[4]+1,tex)
   end
  end
 end
 for y=rect[2],rect[4] do
  if rect[1]-1>=0 and rect[1]-1<128 and y>=0 and y<128 then
   -- skip reserved cells (doors/exits in any layer)
		if not is_reserved_boundary(rect[1]-1,y) then
     set_wall(rect[1]-1,y,tex)
   end
  end
  if rect[3]+1>=0 and rect[3]+1<128 and y>=0 and y<128 then
   -- skip reserved cells (doors/exits in any layer)
		if not is_reserved_boundary(rect[3]+1,y) then
     set_wall(rect[3]+1,y,tex)
   end
  end
 end
end

-- repair step: ensure door tiles exist on walls layer for all logical doors
function enforce_door_tiles()
 for door in all(doors) do
  if not is_door(get_wall(door.x,door.y)) then
   set_wall(door.x,door.y,door.dtype or door_normal)
  end
 end
 
 -- also check doorgrid consistency
 for x=0,map_size-1 do
  if doorgrid[x] then
   for y=0,map_size-1 do
    if doorgrid[x][y] then
     local tile=get_wall(x,y)
     if not is_door(tile) then
      -- restore door tile from doorgrid or use default
      local correct_tile=doorgrid[x][y].tile or door_normal
      set_wall(x,y,correct_tile)
      if observability.log_repairs then
       gen_log("door","restored door tile at ("..x..","..y..")")
      end
     end
    end
   end
  end
 end
end

-- border ring enforcement: set outermost ring to walls while preserving doors/exits
function enforce_border_ring()
 -- top and bottom edges (y=0 and y=map_size-1)
 for x=0,map_size-1 do
  -- top edge
  local top_tile=get_wall(x,0)
  if not is_door(top_tile) and not is_exit(top_tile) then
  set_wall(x,0,wall_fill_tile)
  end
  
  -- bottom edge
  local bottom_tile=get_wall(x,map_size-1)
  if not is_door(bottom_tile) and not is_exit(bottom_tile) then
  set_wall(x,map_size-1,wall_fill_tile)
  end
 end
 
 -- left and right edges (x=0 and x=map_size-1)
 for y=0,map_size-1 do
  -- left edge
  local left_tile=get_wall(0,y)
  if not is_door(left_tile) and not is_exit(left_tile) then
  set_wall(0,y,wall_fill_tile)
  end
  
  -- right edge
  local right_tile=get_wall(map_size-1,y)
  if not is_door(right_tile) and not is_exit(right_tile) then
  set_wall(map_size-1,y,wall_fill_tile)
  end
 end
end

-- helper: random wall texture (never returns 0)
function random_wall_texture()
 local set=texsets[flr(rnd(#texsets-1))+2] -- skip texsets[1] which is floor
 return set.variants[flr(rnd(#set.variants))+1]
end

-- helper: get theme-appropriate wall texture set
function theme_wall_texture(theme)
 if theme=="out" then
  -- outdoor: grass or earth variants
  -- indices in texsets: 5=grass, 6=earth
  local idx=rnd(1)<0.5 and 5 or 6
  return texsets[idx] or texsets[1]
 elseif theme=="dem" then
  -- demon: stone or cobblestone
  -- indices: 4=stone, 2=cobblestone
  local idx=rnd(1)<0.5 and 4 or 2
  return texsets[idx] or texsets[1]
 elseif theme=="house" then
  -- house: wood plank
  -- index: 3=wood_plank
  return texsets[3] or texsets[1]
 else
  -- default dungeon: brick or cobblestone
  -- indices: 1=brick, 2=cobblestone
  local idx=rnd(1)<0.5 and 1 or 2
  return texsets[idx] or texsets[1]
 end
end

-- helper: find accessible rooms from start via edges
function find_accessible_rooms(start_node,locked_edges)
 local accessible={}
 local queue={start_node}
 local visited={}
 visited[start_node]=true
 
 while #queue>0 do
  local node=queue[1]
  deli(queue,1)
  add(accessible,node)
  
  for edge_node in all(node.edges) do
   if not visited[edge_node] then
    local is_locked=false
    if locked_edges then
     for le in all(locked_edges) do
					if (le.n1==node and le.n2==edge_node) or (le.n1==edge_node and le.n2==node) then
       is_locked=true
       break
      end
     end
    end
    
    if not is_locked then
     visited[edge_node]=true
     add(queue,edge_node)
    end
   end
  end
 end
 
 return accessible
end

-- helper: find spawn point in room
function find_spawn_point(rect)
 for attempt=1,max_spawn_attempts do
  local x=rect[1]+1+flr(rnd(rect[3]-rect[1]-1))
  local y=rect[2]+1+flr(rnd(rect[4]-rect[2]-1))
  
  if x>=0 and x<128 and y>=0 and y<128 and get_wall(x,y)==0 then
   local valid=true
   for obj in all(gen_objects) do
    local ox=obj.pos and obj.pos[1] or obj.x
    local oy=obj.pos and obj.pos[2] or obj.y
    if ox and oy then
     local dx,dy=abs(ox-x),abs(oy-y)
     if dx<1 and dy<1 then
      valid=false
      break
     end
    end
   end
   
   if valid then
    return x+0.5,y+0.5
   end
  end
 end
 return nil,nil
end

-- helper: erode map for organic feel (generalized for all wall types)
function erode_map(amount)
 local intensity=(active_theme_rules and active_theme_rules.erosion_intensity) or 1
 local target=flr(amount*intensity)
 local removed=0
 for i=1,target do
  local x,y=flr(rnd(map_size)),flr(rnd(map_size))
  if is_tile_protected(x,y) then goto continue end
  if is_wall(get_wall(x,y)) then
   local neighbors=0
   local near_protected=false
   for dx=-1,1 do
    for dy=-1,1 do
     local nx,ny=x+dx,y+dy
     if nx>=0 and nx<map_size and ny>=0 and ny<map_size then
      if is_tile_protected(nx,ny) then
       near_protected=true
      end
      if get_wall(nx,ny)==0 then
       neighbors+=1
      end
     end
    end
   end
   if not near_protected and neighbors>=3 then
    set_wall(x,y,0)
    set_floor(x,y,gen_floor_id)
    removed+=1
   end
  end
 ::continue::
 end
 if observability.log_corridors and removed>target*0.7 then
  gen_log("erosion","high erosion count "..removed.."/"..target)
 end
end

-- helper: generate exit portal on wall
function generate_exit(rect,exit_type)
 local walls={}
 for x=rect[1],rect[3] do
		if rect[2]-1>=0 and is_wall(get_wall(x,rect[2]-1)) then
   add(walls,{x,rect[2]})
  end
		if rect[4]+1<128 and is_wall(get_wall(x,rect[4]+1)) then
   add(walls,{x,rect[4]})
  end
 end
 for y=rect[2],rect[4] do
		if rect[1]-1>=0 and is_wall(get_wall(rect[1]-1,y)) then
   add(walls,{rect[1],y})
  end
		if rect[3]+1<128 and is_wall(get_wall(rect[3]+1,y)) then
   add(walls,{rect[3],y})
  end
 end
 
 if #walls>0 then
  local pos=walls[flr(rnd(#walls))+1]
  -- write exit tile to map
  local exit_tile=exit_type==3 and exit_start or exit_end
  set_wall(pos[1],pos[2],exit_tile or 0)
  -- also add interactable exit object
  local ob={
   pos={pos[1]+0.5,pos[2]+0.5},
   typ=obj_types.interactable_exit,
   rel={0,0},
   frame=0,
   animloop=true,
   autoanim=false,
   exit_type=exit_type
  }
  add(gen_objects,ob)
 end
end

-- gameplay generation: enemies, items, decorations, npcs
function generate_gameplay()
 -- guard against empty gen_nodes to avoid nil dereference
 if not gen_nodes or #gen_nodes==0 then
  gen_log("error","generate_gameplay() called with no rooms")
  printh("error: generate_gameplay() called with no rooms")
  return
 end
 local start_node=gen_nodes[1]
 local exit_node=gen_nodes[#gen_nodes]
 
 -- place start/exit portals
 generate_exit(start_node.rect,3)
 generate_exit(exit_node.rect,4)
 
 -- erode map
 erode_map(gen_params.erode_amount)
 
 -- populate inventory with health items
 for i=1,3 do
  add(gen_inventory,{type="heart"})
 end
 
 -- generate progression loop (simplified - no locking yet)
 generate_progression_loop(start_node)
 
 -- generate npcs (includes hostile and non-hostile)
 generate_npcs()
 
 -- generate items
 generate_items()
 
 -- generate decorations
 generate_decorations()
end

-- generate progression: items and locked doors
function generate_progression_loop(start_node)
 local locked_edges={}
 local key_counter=1
 
 -- cache accessible rooms for current locked_edges; recompute only after a successful lock
 local full_accessible=find_accessible_rooms(start_node,locked_edges)
 
 -- prepare shuffled edge order to avoid duplicate selection and ensure coverage
 local edges_shuffled={}
 for e in all(gen_edges) do add(edges_shuffled,e) end
 -- fisher-yates shuffle
 for i=#edges_shuffled,2,-1 do
  local j=flr(rnd(i))+1
  edges_shuffled[i],edges_shuffled[j]=edges_shuffled[j],edges_shuffled[i]
 end
 
 -- attempt to create progression gates
 for gate_idx=1,#edges_shuffled do
  if key_counter>3 then break end
  
  -- try to lock an edge
  local edge=edges_shuffled[gate_idx]
  local n1,n2=edge.n1,edge.n2
  
  -- check if this edge would gate content
  local combined_locked={}
  for le in all(locked_edges) do add(combined_locked,le) end
  add(combined_locked,edge)
  local test_accessible=find_accessible_rooms(start_node,combined_locked)
  
  -- if locking this edge hides new rooms, add it as a gate
  if #test_accessible<#full_accessible then
   local candidates={edge.b1,edge.b2}
   local chosen=nil
   for c in all(candidates) do
    if c and c.x and c.y then
     local wt=get_wall(c.x,c.y)
     if is_door(wt) then
      chosen=c
      break
     end
    end
   end
   if chosen then
    local x,y=chosen.x,chosen.y
    local door=doorgrid[x] and doorgrid[x][y] or nil
    if door then
     set_wall(x,y,door_locked)
     door.dtype=door_locked
     door.keynum=key_counter
     door.locked=true
    else
     set_wall(x,y,door_locked)
     create_door(x,y,door_locked,key_counter)
    end
    protect_tile(x,y)
    edge.locked=true
    edge.keynum=key_counter
    edge.lock_tile={x=x,y=y}
    add(locked_edges,edge)
    full_accessible=find_accessible_rooms(start_node,locked_edges)
    add(gen_inventory,{type="key",keynum=key_counter})
    if observability.log_progression then
     gen_log("progression","locked edge "..n1.index.." <-> "..n2.index.." key#"..key_counter)
    end
    key_counter+=1
   else
    if observability.log_progression then
     gen_log("progression","edge "..n1.index.." <-> "..n2.index.." missing door; skipped")
    end
   end
  end
 end
 
 -- place inventory items in accessible rooms
 local failed_placements=0
 -- compute accessible rooms once (does not change during item placement)
 local accessible=find_accessible_rooms(start_node,locked_edges)
 while #gen_inventory>0 do
  
  if #accessible>0 then
   local room=accessible[flr(rnd(#accessible))+1]
   local item=gen_inventory[1]
   deli(gen_inventory,1)
   
   local x,y=find_spawn_point(room.rect)
   if x then
    failed_placements=0
    if item.type=="key" then
     local ob={pos={x,y},typ=obj_types.key,rel={0,0},frame=0,animloop=true,autoanim=true,keynum=item.keynum,room_index=room.index}
     add(gen_objects,ob)
    else
     local ob={pos={x,y},typ=obj_types[item.type],rel={0,0},frame=0,animloop=true,autoanim=true}
     add(gen_objects,ob)
    end
   else
    -- handle failed placement
    if item.type=="key" then
     -- retry a limited number of times across different rooms
     local attempts=0
     local placed=false
     while attempts<15 and not placed do
      local rr=accessible[flr(rnd(#accessible))+1]
      local kx,ky=find_spawn_point(rr.rect)
      if kx then
       local ob={pos={kx,ky},typ=obj_types.key,rel={0,0},frame=0,animloop=true,autoanim=true,keynum=item.keynum,room_index=rr.index}
       add(gen_objects,ob)
       placed=true
       break
      end
      attempts+=1
     end
     if not placed then
      -- fallback: force place in start room (center if needed)
      local sx,sy=find_spawn_point(start_node.rect)
      if not sx then
       sx=start_node.midx+0.5
       sy=start_node.midy+0.5
      end
      local ob={pos={sx,sy},typ=obj_types.key,rel={0,0},frame=0,animloop=true,autoanim=true,keynum=item.keynum,room_index=start_node.index}
      add(gen_objects,ob)
     end
    else
     failed_placements+=1
     if failed_placements>10 then
      gen_log("items","failed to place items after multiple attempts; stopping")
      break
     end
    end
   end
  else
   break
  end
 end

validate_and_repair_progression(start_node,locked_edges)
gen_locked_edges=locked_edges
end

-- generate npcs (hostile and non-hostile) in rooms
function generate_npcs()
 for node in all(gen_nodes) do
  local rect=node.rect
  local num_npcs=flr(rnd(3))+1
  
  for i=1,num_npcs do
   local x,y=find_spawn_point(rect)
   if x then
    -- 70% hostile, 30% non-hostile
    if rnd(1)<gen_params.npc_hostile_ratio then
     -- select enemy type based on current difficulty level
     local available_enemies = {}
     for enemy in all(enemy_types) do
      if enemy.difficulty <= gen_params.difficulty then
       add(available_enemies, enemy)
      end
     end
     -- fallback to rat if no enemies available
     if #available_enemies == 0 then
      available_enemies = {enemy_types[1]}
     end
     local enemy_type = available_enemies[flr(rnd(#available_enemies))+1]
     
     -- hostile npc with patrol or follow behavior
     local ai_type=rnd(1)<0.5 and "patrol" or "follow"
     -- sprite_index from enemy_types configuration (64-72 range)
     local ob={
      pos={x,y},
      typ=obj_types.hostile_npc,
      rel={0,0},
      frame=0,
      animloop=true,
      autoanim=true,
      ai_type=ai_type,
      patrol_index=0,
      patrol_points={},
      sprite_index=enemy_type.sprite
     }
     -- generate patrol points if patrol mode
     if ai_type=="patrol" then
      for j=1,4 do
       local px,py=find_spawn_point(rect)
       if px then
        add(ob.patrol_points,{x=px,y=py})
       end
      end
      if #ob.patrol_points==0 then
       add(ob.patrol_points,{x=x,y=y})
      end
     end
     add(gen_objects,ob)
    else
     -- non-hostile NPCs use sprite 73
     local ob={
      pos={x,y},
      typ=obj_types.non_hostile_npc,
      rel={0,0},
      frame=0,
      animloop=true,
      autoanim=false,
      sprite_index=obj_types.non_hostile_npc.mx
     }
     add(gen_objects,ob)
    end
   end
  end
 end
end

-- generate items (pickups and interactables) in rooms
function generate_items()
 for node in all(gen_nodes) do
  local rect=node.rect
  local num_items=flr(rnd(gen_params.items_per_room))+1
  
  for i=1,num_items do
   local x,y=find_spawn_point(rect)
   if x then
    -- choose item type: 60% pickup, 40% interactable
    if rnd(1)<0.6 then
     -- direct pickup (heart or generic item)
     local pickup_type=rnd(1)<0.5 and "heart" or "direct_pickup"
     local obj_type=pickup_type=="heart" and obj_types.heart or obj_types.direct_pickup
     local ob={
      pos={x,y},
      typ=obj_type,
      rel={0,0},
      frame=0,
      animloop=true,
      autoanim=true
     }
     add(gen_objects,ob)
    else
     -- interactable (chest, shrine, trap, note)
     local subtypes={"chest","shrine","trap","note"}
     local subtype=subtypes[flr(rnd(#subtypes))+1]
     local obj_type
     if subtype=="chest" then
      obj_type=obj_types.interactable_chest
     elseif subtype=="shrine" then
      obj_type=obj_types.interactable_shrine
     elseif subtype=="trap" then
      obj_type=obj_types.interactable_trap
     else
      obj_type=obj_types.interactable_note
     end
     local ob={
      pos={x,y},
      typ=obj_type,
      rel={0,0},
      frame=0,
      animloop=true,
      autoanim=false,
      subtype=subtype
     }
     add(gen_objects,ob)
    end
   end
  end
 end
end

-- generate decorations in rooms
function generate_decorations()
 local current_theme=gen_params.theme or "dng"
 local theme_config=themes[current_theme] or themes.dng
 local decor_prob=theme_config.decor_prob or 0.8
 
 for node in all(gen_nodes) do
  local rect=node.rect
  local w,h=rect[3]-rect[1]+1,rect[4]-rect[2]+1
  local room_decor_count=0
  local max_decor=gen_params.max_decorations_per_room or 12
  
  -- uniform grid pattern
  for dec in all(decoration_types) do
   if room_decor_count>=max_decor then break end
   
   -- filter by theme: check if any theme_tags match current_theme
   local theme_match=false
   if dec.theme_tags then
    for tag in all(dec.theme_tags) do
     if tag==current_theme then
      theme_match=true
      break
     end
    end
   else
    theme_match=true -- no theme_tags means always match
   end
   
   if theme_match and dec.gen_tags then
    for tag in all(dec.gen_tags) do
     if room_decor_count>=max_decor then break end
     
     if tag=="uni" and rnd(1)<0.3*decor_prob then
      for dx=2,w-2,3 do
       for dy=2,h-2,3 do
        if room_decor_count>=max_decor then break end
        if rnd(1)<0.5 then
         local x,y=rect[1]+dx+0.5,rect[2]+dy+0.5
         -- sprite_index from decoration_types configuration (148-155 range)
         local ob={pos={x,y},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,sprite_index=dec.sprite}
         add(gen_objects,ob)
         room_decor_count+=1
        end
       end
       if room_decor_count>=max_decor then break end
      end
      
     elseif tag=="uni2" and rnd(1)<0.4*decor_prob then
      -- denser uniform grid
      for dx=1,w-1,2 do
       for dy=1,h-1,2 do
        if room_decor_count>=max_decor then break end
        if rnd(1)<0.6 then
         local x,y=rect[1]+dx+0.5,rect[2]+dy+0.5
         local ob={pos={x,y},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,sprite_index=dec.sprite}
         add(gen_objects,ob)
         room_decor_count+=1
        end
       end
       if room_decor_count>=max_decor then break end
      end
      
     elseif tag=="scatter" and rnd(1)<0.2*decor_prob then
      local count=flr(rnd(3))+1
      for i=1,count do
       if room_decor_count>=max_decor then break end
       local x,y=find_spawn_point(rect)
       if x then
        local ob={pos={x,y},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,sprite_index=dec.sprite}
        add(gen_objects,ob)
        room_decor_count+=1
       end
      end
      
     elseif tag=="big" and rnd(1)<0.15*decor_prob then
      if room_decor_count>=max_decor then break end
      -- large object: place at room center or corner
      local cx,cy=flr((rect[1]+rect[3])/2)+0.5,flr((rect[2]+rect[4])/2)+0.5
      if rnd(1)<0.5 then
       -- center
       local ob={pos={cx,cy},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,sprite_index=dec.sprite}
       add(gen_objects,ob)
       room_decor_count+=1
      else
       -- random corner
       local corners={{rect[1]+1.5,rect[2]+1.5},{rect[3]-0.5,rect[2]+1.5},{rect[1]+1.5,rect[4]-0.5},{rect[3]-0.5,rect[4]-0.5}}
       local corner=corners[flr(rnd(#corners))+1]
       local ob={pos={corner[1],corner[2]},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,sprite_index=dec.sprite}
       add(gen_objects,ob)
       room_decor_count+=1
      end
      
     elseif tag=="rare" and rnd(1)<0.05*decor_prob then
      if room_decor_count>=max_decor then break end
      -- rare: single spawn
      local x,y=find_spawn_point(rect)
      if x then
       local ob={pos={x,y},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,sprite_index=dec.sprite}
       add(gen_objects,ob)
       room_decor_count+=1
      end
      
     elseif tag=="lit" and rnd(1)<0.25*decor_prob then
      if room_decor_count>=max_decor then break end
      -- lit: bias toward walls or doorways
      local walls={}
      -- collect wall-adjacent floor tiles
      for x=rect[1]+1,rect[3]-1 do
       if get_wall(x,rect[2])>0 then add(walls,{x+0.5,rect[2]+1.5}) end
       if get_wall(x,rect[4])>0 then add(walls,{x+0.5,rect[4]-0.5}) end
      end
      for y=rect[2]+1,rect[4]-1 do
       if get_wall(rect[1],y)>0 then add(walls,{rect[1]+1.5,y+0.5}) end
       if get_wall(rect[3],y)>0 then add(walls,{rect[3]-0.5,y+0.5}) end
      end
      if #walls>0 then
       local pos=walls[flr(rnd(#walls))+1]
       local ob={pos={pos[1],pos[2]},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,sprite_index=dec.sprite}
       add(gen_objects,ob)
       room_decor_count+=1
      end
     end
    end
   end
  end
 end
end

-- generate a complete dungeon
function generate_dungeon(opts)
 opts=opts or {}
 local seed=opts.seed or flr(rnd(1000000))
 srand(seed)
 gen_history={}
 clear_protected()
 reset_adaptive_spacing()
 if gen_params.spacing==nil then gen_params.spacing=0 end
 if observability.log_seed then
  gen_log("seed","generation seed "..seed)
 end
 
 -- initialize state
 gen_rects={}
 gen_nodes={}
 gen_edges={}
 gen_inventory={}
 gen_objects={}
 doors={}
 animated_objects={}
 -- clear doorgrid
 for x=0,map_size-1 do
  if doorgrid[x] then
   for y=0,map_size-1 do
    doorgrid[x][y]=nil
   end
  end
 end
 
 -- fill with walls (non-zero tile)
 fill_rect({0,0,map_size-1,map_size-1},wall_fill_tile)
 
 -- assign global theme before carving (ensures theme floor id is available)
 local selected_theme=opts.theme or "dng"
 if not opts.theme then
  local theme_roll=rnd(1)
  if theme_roll<0.7 then
   selected_theme="dng"
  elseif theme_roll<0.9 then
   selected_theme="out"
  else
   selected_theme="dem"
  end
 end
 gen_params.theme=selected_theme
 ensure_theme_rules(selected_theme)
 local theme_config=themes[selected_theme] or themes.dng
 
 -- set floor and ceiling types based on theme
 local floor_idx=1
 local roof_idx=3
 if theme_config.floor=="stone_tile" then floor_idx=1
 elseif theme_config.floor=="dirt" then floor_idx=2
 end
 if theme_config.roof=="stone_ceiling" then roof_idx=3
 elseif theme_config.roof=="sky" then roof_idx=4
 elseif theme_config.roof=="night_sky" then roof_idx=5
 end
 floor.typ=planetyps[floor_idx]
 roof.typ=planetyps[roof_idx]
 floor.x,floor.y=0,0
 roof.x,roof.y=0,0
 -- theme-specific floor id used by generator when carving/eroding
 gen_floor_id=floor_idx
 
 -- generate first room
 local first_rect=random_room(nil,false)
 local first_node=add_room(first_rect)
 fill_rect(first_rect,0)
 for x=max(0,first_rect[1]),min(map_size-1,first_rect[3]) do
  for y=max(0,first_rect[2]),min(map_size-1,first_rect[4]) do
   set_floor(x, y, gen_floor_id)
  end
 end
 register_room_success()
 
 -- generate additional rooms
 local target_rooms=flr(rnd(gen_params.max_rooms-gen_params.min_rooms+1))+gen_params.min_rooms
 for i=2,target_rooms do
  local placed=false
  for attempt=1,max_room_attempts do
   if try_generate_room() then
    placed=true
    break
   end
  end
  if not placed and observability.log_room_attempts then
   gen_log("room","failed to place room "..i.." after "..max_room_attempts.." attempts")
  end
 end
 
 -- apply wall textures based on theme
 for node in all(gen_nodes) do
  if not node.is_junction then
   local texset=theme_wall_texture(selected_theme)
   local tex=texset.variants[flr(rnd(#texset.variants))+1]
   apply_room_walls(node.rect,tex)
  end
 end
 
 -- ensure any doors placed earlier remain doors on the walls layer
 enforce_door_tiles()
 
 -- generate gameplay content (now aware of theme)
 generate_gameplay()
 -- gameplay may lock doors; re-assert tiles
 enforce_door_tiles()
 
 -- enforce border ring while preserving doors/exits
 enforce_border_ring()
 -- re-assert door tiles after border enforcement
 enforce_door_tiles()
 if observability.enable_console then
  gen_log("summary","border ring enforced")
 end
 
 -- export objects to global arrays (flat iteration, no spatial grid)
 objects=gen_objects
 
 -- populate animated_objects list for frame updates
 animated_objects={}
 for ob in all(objects) do
  if ob.autoanim then
   add(animated_objects, ob)
  end
 end
 
 -- set player start
 player.x=first_node.midx+0.5
 player.y=first_node.midy+0.5
 
 if observability.enable_console then
  gen_log("summary","rooms="..#gen_nodes.." objects="..#gen_objects)
 end
 
 return {x=player.x,y=player.y},{rooms=#gen_nodes,objects=#gen_objects,seed=seed,history=gen_history}
end


:: src/raycast.lua
--[[pod_format="raw",created="2025-11-07 21:17:12",modified="2025-11-07 21:48:07",revision=1]]
-- raycasting core

-- sign helper
function sgn(n)
 if n<0 then return -1 end
 if n>0 then return 1 end
 return 0
end

-- vector length
function length(x,y)
 x/=16
 y/=16
 return sqrt(x*x+y*y)*16
end

-- vector normalization
function normalise(x,y)
 local l=length(x,y)
 if l<=0.0001 then return 0,1 end
 return x/l,y/l
end

-- dda raycast with z-depth tracking
-- fx,fy represent the forward/depth axis used for perpendicular distance:
--  - In main scene: fx,fy = camera forward = (cos(a), sin(a))
--  - In hitscan:    fx,fy = normalized ray direction
function raycast(x,y,dx,dy,fx,fy)
 -- clamp near-zero components before normalization
 if abs(dx)<0.01 then dx=0.01 end
 if abs(dy)<0.01 then dy=0.01 end
 
 -- normalize direction if forward axis not provided
 if not fx then
  fx,fy=normalise(dx,dy)
 end
 
 -- horizontal ray initialization
 local hx,hy,hdx,hdy=x,y,sgn(dx),dy/abs(dx)
 local hdz,hz=hdx*fx+hdy*fy,0
 
 -- initial step to grid boundary
 local fracx=hx%1
 local hstep
 if hdx>0 then
  hstep=1-fracx
 else
  hstep=fracx
 end
 hx+=hdx*hstep
 hy+=hdy*hstep
 hz+=hdz*hstep
 
 -- vertical ray initialization
 local vx,vy,vdx,vdy=x,y,dx/abs(dy),sgn(dy)
 local vdz,vz=vdx*fx+vdy*fy,0
 
 -- initial step to grid boundary
 local fracy=vy%1
 local vstep
 if vdy>0 then
  vstep=1-fracy
 else
  vstep=fracy
 end
 vx+=vdx*vstep
 vy+=vdy*vstep
 vz+=vdz*vstep
 
 -- compute iteration limit from remaining grid crossings to map edges
 -- compute remaining crossings to nearest boundary per axis based on current positions
 local horizontal_crossings
 if hdx>0 then
  horizontal_crossings=map_size-flr(hx)
 else
  horizontal_crossings=flr(hx)+1
 end
 
 local vertical_crossings
 if vdy>0 then
  vertical_crossings=map_size-flr(vy)
 else
  vertical_crossings=flr(vy)+1
 end
 
 local iteration_limit=min(256,horizontal_crossings+vertical_crossings+10)
 
 -- track DDA steps for diagnostics
 local dda_steps=0
 
 -- ray marching
 for iter=1,iteration_limit do
  -- increment step counter
  dda_steps+=1
  
  -- far-plane check: early-out if both candidates exceed far_plane
  if min(hz, vz) > far_plane then
   -- if debug_mode then
   --  diag_dda_steps_total+=dda_steps
   --  diag_dda_early_outs+=1
   -- end
   return 999,hx,hy,0,0
  end
  
  if hz<vz then
   -- horizontal closer
   -- crossing a vertical gridline (x changes): choose the cell we are entering
   local gx=flr(hx)+(hdx<0 and -1 or 0)
   local gy=flr(hy)
   
   -- irreversible OOB check for horizontal candidate
   if (gx<0 and hdx<0) or (gx>=map_size and hdx>0) or (gy<0 and hdy<0) or (gy>=map_size and hdy>0) then
    -- if debug_mode then
    --  diag_dda_steps_total+=dda_steps
    --  diag_dda_early_outs+=1
    -- end
    return 999,hx,hy,0,0
   end
   
   if gx>=0 and gx<map_size and gy>=0 and gy<map_size then
    local m=get_wall(gx,gy)
    if m>0 then
     -- check if door
     if is_door(m) and doorgrid[gx][gy] then
     local dz=((hx+hdx/2-x)*fx+(hy+hdy/2-y)*fy)
      if dz<=vz then
       local open = test_door_mode and (test_door_open or 0) or doorgrid[gx][gy].open
       local dy_off=(hy+hdy/2)%1-open
       if dy_off>=0 then
        return dz,hx,hy,m,dy_off
       end
      end
     else
      -- wall hit
     -- if debug_mode then
     --  diag_dda_steps_total+=dda_steps
     -- end
     local z=((hx-x)*fx+(hy-y)*fy)
     -- texture coordinate from y-fraction; flip when rayDirX > 0
     local frac=hy-flr(hy)
     local tx=(hdx>0) and (1-frac) or frac
     return z,hx,hy,m,tx
     end
    end
   end
   hx+=hdx
   hy+=hdy
   hz+=hdz
  else
   -- vertical closer or equal
   -- crossing a horizontal gridline (y changes): choose the cell we are entering
   local gx=flr(vx)
   local gy=flr(vy)+(vdy<0 and -1 or 0)
   
   -- irreversible OOB check for vertical candidate
   if (gx<0 and vdx<0) or (gx>=map_size and vdx>0) or (gy<0 and vdy<0) or (gy>=map_size and vdy>0) then
    -- if debug_mode then
    --  diag_dda_steps_total+=dda_steps
    --  diag_dda_early_outs+=1
    -- end
    return 999,vx,vy,0,0
   end
   
   if gx>=0 and gx<map_size and gy>=0 and gy<map_size then
    local m=get_wall(gx,gy)
    if m>0 then
     -- check if door
     if is_door(m) and doorgrid[gx][gy] then
     local dz=((vx+vdx/2-x)*fx+(vy+vdy/2-y)*fy)
      if dz<=hz then
       local open = test_door_mode and (test_door_open or 0) or doorgrid[gx][gy].open
       local dx_off=(vx+vdx/2)%1-open
       if dx_off>=0 then
        return dz,vx,vy,m,dx_off
       end
      end
     else
      -- wall hit
     -- if debug_mode then
     --  diag_dda_steps_total+=dda_steps
     -- end
     local z=((vx-x)*fx+(vy-y)*fy)
     -- texture coordinate from x-fraction; flip when rayDirY < 0
     local frac=vx-flr(vx)
     local tx=(vdy<0) and (1-frac) or frac
     return z,vx,vy,m,tx
     end
    end
   end
   vx+=vdx
   vy+=vdy
   vz+=vdz
  end
 end
 
 -- fallback if iteration limit reached
-- if debug_mode then
--  diag_dda_steps_total+=dda_steps
--  diag_dda_early_outs+=1
-- end
 return 999,hx,hy,0,0
end

-- raycast entire scene
-- Note: ray arrays (ray_z, ray_x0, ray_x1, ray_dx, ray_dy, rbuf_tile, rbuf_tx)
-- use userdata for 24x performance gain per Picotron optimization guidelines
function raycast_scene()
 -- compute projection distance from FOV (fov is half-angle in radians)
 -- sdist = screen_center_x / tan(half_fov) ensures proper perspective mapping
 sdist=screen_center_x/math.tan(fov)
 
 -- classic forward basis: forward = (cos(a), sin(a))
 -- use cached cos/sin from _draw() if available
 local fwdx=(ca_cached or cos(player.a))
 local fwdy=(sa_cached or sin(player.a))
 maxz=0
 
  -- precompute per-ray screen spans (decouples ray_count from screen_width)
  -- only when active_ray_count changes
  local span_count = active_ray_count or ray_count
  if _last_span_count ~= span_count then
    for i=0,span_count-1 do
      ray_x0:set(i, flr(i*screen_width/span_count))
      ray_x1:set(i, max(ray_x0:get(i), flr((i+1)*screen_width/span_count)-1))
      -- precompute pixel center for camera-space offset (eliminates per-frame computation)
      local pixel_x=(ray_x0:get(i)+ray_x1:get(i))/2+0.5
      ray_px_center:set(i, pixel_x)
    end
    _last_span_count = span_count
  end
 
 for i=0,span_count-1 do
  -- use precomputed pixel center for camera-space offset
  local dx=ray_px_center:get(i)-screen_center_x
  local dy=sdist
  
  -- map camera-space to world-space and cache direction
  ray_dx:set(i, (-fwdy)*dx+fwdx*dy)
  ray_dy:set(i, ( fwdx)*dx+fwdy*dy)
  
  -- cast ray using cached direction
  local z,hx,hy,tile,tx=raycast(player.x,player.y,ray_dx:get(i),ray_dy:get(i),fwdx,fwdy)
  
  -- store hit data in dedicated per-ray arrays
  ray_z:set(i, z)
  rbuf_tile:set(i, tile)
  rbuf_tx:set(i, tx)
  ray_hitx:set(i, hx)
  ray_hity:set(i, hy)
  
  maxz=max(maxz,z)
 end
 
 -- frustum AABB computation removed; sprite culling now uses distance checks
end

-- compute_frustum_aabb removed (distance-based culling is used instead)

-- hitscan for projectiles/line-of-sight
function hitscan(x,y,dx,dy)
 -- normalize and get wall depth
 local sa,ca=normalise(dx,dy)
 local d,hx,hy,tile,tx=raycast(x,y,dx,dy,sa,ca)
 
 local closest_obj=nil
 local closest_dist=d
 
 -- iterate all objects; check solid intersections before wall hit
 for ob in all(objects) do
  if ob and ob.pos and ob.typ and ob.typ.solid then
   local ox=ob.pos[1]-x
   local oy=ob.pos[2]-y
   local dn=ox*ca-oy*sa
   local dt=ox*sa+oy*ca
   if abs(dn)<= (ob.typ.w or 0)*0.5 and dt>0 and dt<d then
    if dt<closest_dist then
     closest_dist=dt
     closest_obj=ob
    end
   end
  end
 end
 
 return closest_obj,closest_dist
end

:: src/render.lua
 local function clamped_blit(src_row,dst_row)
  if dst_row>y1 then return end
  local dst_y=screen_center_y+dst_row
  if dst_y<0 or dst_y>=screen_height then return end
  local src_y=screen_center_y+src_row
  if src_y<0 or src_y>=screen_height then return end
  blit(get_draw_target(),get_draw_target(),0,src_y,0,dst_y,screen_width,1)
  diag_floor_rows+=1
  diag_floor_batches+=1
 end
--[[pod_format="raw",created="2025-11-07 21:17:11",modified="2025-11-07 21:48:08",revision=1]]
-- rendering pipeline

-- track warned sprite indices to avoid per-frame spam
warned_sprites={}

-- lazy initialization flag for error texture
error_texture_initialized=false

-- persistent caches for textures and average colors across frames
tex_cache={}
avg_color_cache={}
-- Cache size limits to prevent unbounded growth (Picotron optimization guideline)
local CACHE_CAPACITY = 256  -- Max entries per cache (covers all game sprites + buffer)
local tex_cache_index = 0   -- Circular buffer write index for tex_cache
local avg_cache_index = 0   -- Circular buffer write index for avg_color_cache
local tex_cache_keys = {}   -- Array of tile IDs in insertion order (max 256)
local avg_cache_keys = {}   -- Array of tile IDs in insertion order (max 256)

-- bounded cache insert helpers
function cache_tex(tile, src, is_fallback)
 if not tile or not src then return end
 if #tex_cache_keys < CACHE_CAPACITY then
  tex_cache[tile]={src=src,is_fallback=is_fallback}
  add(tex_cache_keys, tile)
 else
  local evict_idx = (tex_cache_index % CACHE_CAPACITY) + 1
  local evict_tile = tex_cache_keys[evict_idx]
  tex_cache[evict_tile] = nil
  tex_cache[tile]={src=src,is_fallback=is_fallback}
  tex_cache_keys[evict_idx] = tile
  tex_cache_index += 1
 end
end

function cache_avg(tile, color)
 if tile==nil or color==nil then return end
 if #avg_cache_keys < CACHE_CAPACITY then
  avg_color_cache[tile]=color
  add(avg_cache_keys, tile)
 else
  local evict_idx = (avg_cache_index % CACHE_CAPACITY) + 1
  local evict_tile = avg_cache_keys[evict_idx]
  avg_color_cache[evict_tile] = nil
  avg_color_cache[tile]=color
  avg_cache_keys[evict_idx] = tile
  avg_cache_index += 1
 end
end

-- clear caches when tiles/floor/ceiling change (e.g., on new floor)
function clear_texture_caches()
 -- Log cache statistics before clearing (useful for tuning CACHE_CAPACITY)
 if enable_diagnostics_logging then
  printh("tex_cache size: "..#tex_cache_keys.." / "..CACHE_CAPACITY)
  printh("avg_color_cache size: "..#avg_cache_keys.." / "..CACHE_CAPACITY)
 end
 tex_cache={}
 avg_color_cache={}
 warned_sprites={}
 
 -- Reset circular buffer tracking
 tex_cache_keys={}
 avg_cache_keys={}
 tex_cache_index=0
 avg_cache_index=0
end

-- initialize error texture on first access (defensive fallback)
function init_error_texture()
 if not error_texture_initialized and not error_texture then
  -- create default error texture if none exists
  error_texture = userdata("u8", 32, 32)
  for y=0,31 do
   for x=0,31 do
    local color = ((flr(x/4) + flr(y/4)) % 2 == 0) and 8 or 14
    error_texture:set(x, y, color)
   end
  end
  error_texture_initialized=true
 end
end

-- get appropriate error texture for object type
function get_error_texture(obj_type)
 if error_textures then
  return error_textures[obj_type] or error_textures.default
 end
 init_error_texture()
 return error_texture
end

-- get individual sprite userdata for tline3d by sprite index
function get_texture_source(sprite_index, obj_type)
 -- default to sprite 0 for backward compatibility
 sprite_index=sprite_index or 0
 obj_type=obj_type or "default"
 
 -- return sprite sheet userdata
 local src=get_spr(sprite_index)
 if not src then
  -- warn once per sprite index to avoid per-frame spam
  if not warned_sprites[sprite_index] then
   printh("warning: sprite "..sprite_index.." not found, using "..obj_type.." error texture")
   warned_sprites[sprite_index]=true
  end
  -- return appropriate error texture for object type
  return get_error_texture(obj_type),true
 end
 return src,false
end



-- =========================
-- Batched tline3d utilities
-- =========================
-- Each row: sprite_index, x0,y0,x1,y1, u0,v0,u1,v1, w0,w1, flags  (13 columns)
local TLINE_COLS=13
local tline_buf_capacity=screen_width*2
local tline_args=userdata("f64", TLINE_COLS, tline_buf_capacity)
local tline_count=0

local function batch_reset()
	tline_count=0
end

local function batch_push(idx,x0,y0,x1,y1,u0,v0,u1,v1,w0,w1,flags)
	if tline_count>=tline_buf_capacity then
		tline3d(tline_args, 0, tline_count, TLINE_COLS)
		tline_count=0
	end
	tline_args:set(0, tline_count, idx, x0, y0, x1, y1, u0, v0, u1, v1, w0 or 1, w1 or 1, flags or 0)
	tline_count+=1
end

local function batch_submit()
	if tline_count>0 then
		tline3d(tline_args, 0, tline_count, TLINE_COLS)
		tline_count=0
	end
end

-- =========================
-- Batched rectfill utility
-- =========================
-- Each row: x0,y0,x1,y1,c (5 columns)
local RECT_COLS=5
local rect_buf_capacity=screen_width*4
local rect_args=userdata("f64", RECT_COLS, rect_buf_capacity)
local rect_count=0
function rbatch_reset() rect_count=0 end
function rbatch_push(x0,y0,x1,y1,c)
	if rect_count>=rect_buf_capacity then
		rectfill(rect_args, 0, rect_count, RECT_COLS)
		rect_count=0
	end
	rect_args:set(0, rect_count, x0, y0, x1, y1, c)
	rect_count+=1
end
function rbatch_submit()
	if rect_count>0 then
		rectfill(rect_args, 0, rect_count, RECT_COLS)
		rect_count=0
	end
end

local function resolve_sprite_index(idx, kind)
	if idx and get_spr(idx) then
		return idx
	end
	if ERROR_IDX then
		if kind=="floor" then return ERROR_IDX.floor
		elseif kind=="ceiling" then return ERROR_IDX.ceiling
		elseif kind=="sprite" then return ERROR_IDX.sprite
		elseif kind=="door" then return ERROR_IDX.door
		else return ERROR_IDX.wall end
	end
	return 0
end

-- preallocated buffers for per-cell floor runs (avoid per-frame table allocations)
local RUN_CAP=1024
local runs_x0=userdata("i16", RUN_CAP)
local runs_x1=userdata("i16", RUN_CAP)
local runs_id=userdata("i16", RUN_CAP)
local merged_x0=userdata("i16", RUN_CAP)
local merged_x1=userdata("i16", RUN_CAP)
local merged_id=userdata("i16", RUN_CAP)

-- Precomputed wall y-ranges for merged rendering (avoid per-scanline recalculation)
-- render perspective floor/ceiling and walls (flat shading, fog removed)
function render_floor_ceiling()
 palt(0,false)
 
 local fwdx=(ca_cached or cos(player.a))
 local fwdy=(sa_cached or sin(player.a))
 local tex_size=sprite_size or 32
 local _rc = active_ray_count or ray_count
 
 -- Draw ceiling and floor first so walls overlay them
 batch_reset()
 local roof_typ=roof.typ
 local roof_src,roof_fallback=get_texture_source(roof_typ.tex,"ceiling")
 if roof_fallback then roof_src=get_error_texture("ceiling") end
 draw_rows(roof_src,-screen_center_y,-1,roof_typ.scale,roof_typ.height,cam[1]-roof.x,cam[2]-roof.y,roof_typ.lit,fwdy,fwdx,roof_typ.tex,false)
 
 local floor_typ=floor.typ
 local floor_src,floor_fallback=get_texture_source(floor_typ.tex,"floor")
 if floor_fallback then floor_src=get_error_texture("floor") end
 draw_rows(floor_src,0,screen_center_y-1,floor_typ.scale,floor_typ.height,cam[1]-floor.x,cam[2]-floor.y,floor_typ.lit,fwdy,fwdx,floor_typ.tex,false)
 batch_submit()

 -- Render walls per-ray in a single vertical pass (drawn after floors)
 rbatch_reset()
 batch_reset()
 local span_start=nil
 local span_tile=nil
 local span_spr=nil
 local span_avg=nil
 local span_tx0=nil
 local span_tx1=nil
 local span_hitx0=nil
 local span_hity0=nil
 local span_hitx1=nil
 local span_hity1=nil
 local function flush_span(span_end)
  if not span_start then return end
  local x0=ray_x0:get(span_start)
  local x1=ray_x1:get(span_end)
  if x0>x1 then span_start=nil return end
  local spr_idx=span_spr
  local avg_color=span_avg
  local hx0=span_hitx0
  local hy0=span_hity0
  local hx1=span_hitx1
  local hy1=span_hity1
  local tx0=span_tx0
  local tx1=span_tx1
  local span_width=x1-x0
  local base_z=nil
  local base_tdy0=nil
  local base_tdy1=nil
  local first_wall=false
  if span_width<=0 then
   span_width=0
   local rel_x=hx0-player.x
   local rel_y=hy0-player.y
   base_z=rel_x*fwdx+rel_y*fwdy
   if base_z<=0.0001 then base_z=0.0001 end
   local h=sdist/base_z
   local y0=screen_center_y-h/2
   local y1=screen_center_y+h/2
   base_tdy0=ceil(y0)
   base_tdy1=min(flr(y1),screen_height-1)
   if base_tdy0<=base_tdy1 then
    local wall_height=base_tdy1-base_tdy0
    if base_z>wall_lod_distance or wall_height<wall_tiny_screen_px then
     rbatch_push(x0, base_tdy0, x1, base_tdy1, avg_color)
     diag_wall_lod_columns+=x1-x0+1
    else
     local u0=tx0*tex_size
     local v0=0
     local full_h=y1-y0
     if full_h>0 and base_tdy0<y1 then
      v0=((base_tdy0-y0)/full_h)*tex_size
     end
     local w0=1/base_z
     batch_push(spr_idx,x0,base_tdy0,x1,base_tdy1,u0,v0,u0,v0+tex_size,w0,w0,0)
     diag_wall_columns+=x1-x0+1
    end
    if zwrite then zwrite(x0,base_z) else zbuf:set(x0,base_z) end
   end
   span_start=nil
   return
  end
  local rel_x0=hx0-player.x
  local rel_y0=hy0-player.y
  local z0=rel_x0*fwdx+rel_y0*fwdy
  if z0<=0.0001 then z0=0.0001 end
  local h0=sdist/z0
  local base_y0=screen_center_y-h0/2
  local base_y1=screen_center_y+h0/2
  local tdy0=ceil(base_y0)
  local tdy1=min(flr(base_y1),screen_height-1)
  if tdy0>tdy1 then
   span_start=nil
   return
  end
  local rel_x1=hx1-player.x
  local rel_y1=hy1-player.y
  local z1=rel_x1*fwdx+rel_y1*fwdy
  if z1<=0.0001 then z1=0.0001 end
  local h1=sdist/z1
  local y1_top=screen_center_y-h1/2
  local y1_bot=screen_center_y+h1/2
  local tdy1_alt=ceil(y1_top)
  local tdy1_bot=min(flr(y1_bot),screen_height-1)
  tdy0=min(tdy0,tdy1_alt)
  tdy1=max(tdy1,tdy1_bot)
  tdy0=max(tdy0,0)
  tdy1=min(tdy1,screen_height-1)
  if tdy0>tdy1 then
   span_start=nil
   return
  end
  local wall_height=tdy1-tdy0
  local column_count=x1-x0+1
  if z0>wall_lod_distance and z1>wall_lod_distance then
   rbatch_push(x0, tdy0, x1, tdy1, avg_color)
   diag_wall_lod_columns+=column_count
  else
   local u0=tx0*tex_size
   local u1=tx1*tex_size
   local v0=((tdy0-base_y0)/(base_y1-base_y0))*tex_size
   if base_y1-base_y0<=0 then v0=0 end
   if v0<0 then v0=0 elseif v0>tex_size then v0=tex_size end
   local v1=v0+tex_size
   batch_push(spr_idx, x0, tdy0, x1, tdy1, u0, v0, u1, v1, 1/z0, 1/z1, 0)
   diag_wall_columns+=column_count
  end
  for col=x0,x1 do
   local t=(span_width>0) and ((col-x0)/span_width) or 0
   local world_x=hx0+(hx1-hx0)*t
   local world_y=hy0+(hy1-hy0)*t
   local rel_x=world_x-player.x
   local rel_y=world_y-player.y
   local z=rel_x*fwdx+rel_y*fwdy
   if z<=0.0001 then z=0.0001 end
   if zwrite then zwrite(col,z) else zbuf:set(col,z) end
  end
  span_start=nil
 end
 for ray_idx=0,_rc-1 do
  local tile=rbuf_tile:get(ray_idx)
  if tile and tile>0 then
   if span_start and tile==span_tile then
    span_tx1=rbuf_tx:get(ray_idx)
    span_hitx1=ray_hitx:get(ray_idx)
    span_hity1=ray_hity:get(ray_idx)
   else
    if span_start then flush_span(ray_idx-1) end
    span_start=ray_idx
    span_tile=tile
    span_spr=resolve_sprite_index(tile,(is_door and is_door(tile)) and "door" or "wall")
    local avg=avg_color_cache[tile]
    if not avg then
     local cached=tex_cache[tile]
     local src,is_fallback
     if cached then
      src,is_fallback=cached.src,cached.is_fallback
     else
      local obj_type=is_door and is_door(tile) and "door" or "wall"
      src,is_fallback=get_texture_source(tile,obj_type)
      cache_tex(tile, src, is_fallback)
     end
     avg=5
     if src and src.get then
      avg=src:get(16,16) or 5
     end
     cache_avg(tile, avg)
    end
    span_avg=avg
    span_tx0=rbuf_tx:get(ray_idx)
    span_tx1=span_tx0
    span_hitx0=ray_hitx:get(ray_idx)
    span_hity0=ray_hity:get(ray_idx)
    span_hitx1=span_hitx0
    span_hity1=span_hity0
   end
  else
   if span_start then flush_span(ray_idx-1) end
  end
 end
 if span_start then flush_span(_rc-1) end
 batch_submit()
 
 palt()
end

-- draw horizontal scanlines with 32x32 sprite sampling and optional wall rendering (flat shading)
function draw_rows(src,y0,y1,tilesize,height,cx,cy,lit,sa,ca,tex,render_walls)
 local size=sprite_size or 32
 local function draw_single_row(row)
  diag_floor_rows+=1
  local y=row
  local y_offset=y>=0 and (y+0.5) or abs(y-0.5)
  local g=y_offset/sdist
  if g<0.0001 then g=0.0001 end
  local z=(height or 0.5)/g
  local mx=(cx+z*sa)/tilesize
  local my=(cy+z*ca)/tilesize
  local s=sdist/z*tilesize
  local mdx=-ca/s
  local mdy=sa/s
  mx-=screen_center_x*mdx
  my-=screen_center_x*mdy
  if per_cell_floors_enabled then
   local sample_interval=12
   local rcount=0
   local cur_id=-1
   local cur_x0=0
   for x=0,screen_width-1,sample_interval do
    local wx=mx+x*mdx
    local wy=my+x*mdy
    local gx=flr(wx)
    local gy=flr(wy)
    local fid=get_floor(gx,gy)
    if cur_id<0 then
     cur_id=fid
     cur_x0=x
    elseif fid~=cur_id then
     if rcount<RUN_CAP then
      runs_x0:set(rcount, cur_x0)
      runs_x1:set(rcount, x-1)
      runs_id:set(rcount, cur_id)
      rcount+=1
     end
     cur_id=fid
     cur_x0=x
    end
   end
   if rcount<RUN_CAP then
    runs_x0:set(rcount, cur_x0)
    runs_x1:set(rcount, screen_width-1)
    runs_id:set(rcount, cur_id)
    rcount+=1
   end
   local mcount=0
   for i=0,rcount-1 do
    local x0i=runs_x0:get(i)
    local x1i=runs_x1:get(i)
    local fidi=runs_id:get(i)
    local width=x1i-x0i+1
    if width<4 and mcount>0 then
     local prev_x1=merged_x1:get(mcount-1)
     if x1i>prev_x1 then merged_x1:set(mcount-1, x1i) end
    else
     if mcount<RUN_CAP then
      merged_x0:set(mcount, x0i)
      merged_x1:set(mcount, x1i)
      merged_id:set(mcount, fidi)
      mcount+=1
     end
    end
   end
   for i=0,mcount-1 do
    local rx0=merged_x0:get(i)
    local rx1=merged_x1:get(i)
    local fid=merged_id:get(i)
    local run_tex=tex
    if fid>0 and fid<=#planetyps then
     run_tex=planetyps[fid].tex
    end
    local idx=resolve_sprite_index(run_tex,"floor")
    local u0=(mx+rx0*mdx)%1*size
    local v0=(my+rx0*mdy)%1*size
    u0=max(0,min(size-0.001,u0))
    v0=max(0,min(size-0.001,v0))
    local u1=u0+(rx1-rx0)*mdx*size
    local v1=v0+(rx1-rx0)*mdy*size
    batch_push(idx, rx0, screen_center_y+y, rx1, screen_center_y+y, u0, v0, u1, v1, 1, 1)
    diag_floor_batches+=1
   end
  else
   local idx=resolve_sprite_index(tex,"floor")
   local u0=(mx)%1*size
   local v0=(my)%1*size
   u0=max(0,min(size-0.001,u0))
   v0=max(0,min(size-0.001,v0))
   local u1=u0+(screen_width-1)*mdx*size
   local v1=v0+(screen_width-1)*mdy*size
   batch_push(idx, 0, screen_center_y+y, screen_width-1, screen_center_y+y, u0, v0, u1, v1, 1, 1)
   diag_floor_batches+=1
  end
 end
 local function duplicate_rows(src_row, count)
  if count<=0 then return end
  local y0=screen_center_y+src_row+1
  local y1=y0+count-1
  if y0>screen_center_y+y1 then return end
  y1=min(y1,screen_center_y+y1)
  if y0>screen_height-1 then return end
 end
 local function blit_rows(src_row,rep_count)
  if rep_count<=0 then return end
  for k=1,rep_count do
   local row=src_row+k
  if row>y1 then break end
   diag_floor_rows+=1
   diag_floor_batches+=1
   blit(get_draw_target(),get_draw_target(),0,screen_center_y+src_row,0,screen_center_y+row,screen_width,1)
  end
 end
 local near_end = min(y1, -16)
 local mid_end = min(y1, 32)
 for y=y0, near_end do
  draw_single_row(y)
 end
 local y=near_end+1
 while y<=mid_end do
  draw_single_row(y)
 clamped_blit(y,y+1)
  y+=2
 end
 while y<=y1 do
  draw_single_row(y)
 clamped_blit(y,y+1)
 clamped_blit(y,y+2)
 clamped_blit(y,y+3)
  y+=4
 end
end


:: src/render_sprite.lua
--[[pod_format="raw",created="2025-11-07 21:17:10",modified="2025-11-07 21:48:08",revision=1]]
-- sprite rendering pipeline

-- global sprite tline batch (12 cols: idx,x0,y0,x1,y1,u0,v0,u1,v1,w0,w1)
local SPR_TLINE_COLS=12
local spr_tline_capacity=screen_width*2
local spr_tline_args=userdata("f64", SPR_TLINE_COLS, spr_tline_capacity)
local spr_tline_count=0
local function sbatch_reset() spr_tline_count=0 end
local function sbatch_push(idx,x0,y0,x1,y1,u0,v0,u1,v1,w0,w1)
 if spr_tline_count>=spr_tline_capacity then
  tline3d(spr_tline_args, 0, spr_tline_count, SPR_TLINE_COLS)
  spr_tline_count=0
 end
 spr_tline_args:set(0, spr_tline_count, idx, x0, y0, x1, y1, u0, v0, u1, v1, w0 or 1, w1 or 1)
 spr_tline_count+=1
end
local function sbatch_submit()
 if spr_tline_count>0 then
  tline3d(spr_tline_args, 0, spr_tline_count, SPR_TLINE_COLS)
  spr_tline_count=0
 end
end

-- persistent depth buckets (0..15) reused each frame
sprite_buckets=sprite_buckets or {}
for i=0,7 do sprite_buckets[i]=sprite_buckets[i] or {} end
local function clear_buckets()
 for i=0,7 do
  local b=sprite_buckets[i]
  for j=#b,1,-1 do b[j]=nil end
 end
end

-- render sprites with z-buffer occlusion (flat array iteration with distance culling)
function render_sprites()
 -- use cached sin/cos from _draw() if available
 local sa,ca=sa_cached or sin(player.a),ca_cached or cos(player.a)
 
 -- frustum bounds check removed (distance-based culling in use)
 
 -- initialize depth buckets for sprite sorting
-- 8 total buckets: 0-7 for all sprites (upright and flat treated uniformly)
-- bucket size = far_plane / 8 (e.g., 25.0 / 8 = 3.125 units per bucket)
-- iterate all objects with distance culling (no spatial grid)
local bucket_size = far_plane / 8
 clear_buckets()
 
 -- iterate all objects with simple distance culling (no spatial grid)
 for ob in all(objects) do
  if ob and ob.pos and ob.typ then
   -- transform to view space
   local rx=ob.pos[1]-player.x
   local ry=ob.pos[2]-player.y
   
   -- simple distance culling using axis-aligned bound
   if abs(rx)>=far_plane or abs(ry)>=far_plane then
    goto skip_sprite
   end
   
   -- rotate to view-aligned coordinates (camera space)
   -- right = (-sin a, cos a), forward = (cos a, sin a)
   local x_cam = -sa*rx + ca*ry
   local z_cam =  ca*rx + sa*ry
   ob.rel[1]=x_cam
   ob.rel[2]=z_cam
   
   -- far-plane culling: skip sprites beyond far_plane
   if ob.rel[2]>far_plane then
    goto skip_sprite
   end
   
   -- depth culling: skip sprites beyond max wall depth
   if ob.rel[2]>=maxz then
    goto skip_sprite
   end
   
   -- cull behind camera and outside frustum
   local t=ob.typ
   local pass_frustum=false
   if ob.rel[2]>0.1 then
    if t.flat then
     -- flat sprites: require minimum distance to prevent z-division issues
     if ob.rel[2]>=t.w/2 then
      pass_frustum=true
     end
    else
     -- upright sprites: horizontal frustum culling
     if abs(ob.rel[1])-(t.w/2)<ob.rel[2]*(screen_center_x/sdist) then
      pass_frustum=true
     end
    end
   end
   
   if pass_frustum then
    -- compute bucket index based on depth
    -- bucket 0 = 0.0-6.25, bucket 1 = 6.25-12.5, ..., bucket 7 = 43.75-50.0+
    local bucket_idx = min(7, flr(ob.rel[2] / bucket_size))
    
    -- add to bucket
    add(sprite_buckets[bucket_idx], ob)
   end
   
   ::skip_sprite::
  end
 end
 
 -- draw sprites back-to-front using bucket iteration
-- bucket 7-0: farthest to nearest (bucket 7 = all sprites at far distance)
 palt(0,false)
 palt(14,true)
 
for bucket_idx=7,0,-1 do
  -- sort non-empty bucket by z descending (far to near) for correct sprite-sprite occlusion
  local bucket = sprite_buckets[bucket_idx]
 if #bucket > 4 then
   -- insertion sort by ob.rel[2] descending
   for i=2,#bucket do
    local ob = bucket[i]
    local z = ob.rel[2]
    local j = i - 1
    while j >= 1 and bucket[j].rel[2] < z do
     bucket[j+1] = bucket[j]
     j = j - 1
    end
    bucket[j+1] = ob
   end
  end
  
  for ob in all(bucket) do
   drawobj_single(ob, sa, ca)
  end
 end
 
 palt()
 clip()
end

-- draw single sprite object with z-buffer occlusion (color 0=opaque, color 14=transparent)
function drawobj_single(ob, sa, ca)
 if not ob or not ob.typ or not ob.rel then
  return
 end
  
  local t=ob.typ
  local x=ob.rel[1]
  local z=ob.rel[2]
  
  -- fetch sprite for this object
  local base_sprite_index = ob.sprite_index or t.mx
  local sprite_index = base_sprite_index
  
  -- handle animation with sequential sprite indexes
  if t.framect then
   local fr=flr(ob.frame or 0)
   if ob.animloop then
    fr=fr%t.framect
   else
    fr=min(fr,t.framect-1)
   end
   sprite_index = base_sprite_index + fr
  end
  
  -- validate sprite exists; if animation overflow, reset to base
  local test_src = get_spr(sprite_index)
  if not test_src then
   if sprite_index ~= base_sprite_index then
    -- animation frame overflow detected
    if not warned_sprites[base_sprite_index] then
     printh("warning: animation frame overflow for sprite "..base_sprite_index..", clamping to base")
     warned_sprites[base_sprite_index]=true
    end
    sprite_index = base_sprite_index
   end
  end
  
  local src,is_fallback = get_texture_source(sprite_index,"sprite")
  if is_fallback then
   src = get_error_texture("sprite")
  end
  
  -- get vertical offset (can be animated)
  local y=ob.y or t.y
  if t.yoffs then
   local frame = ob.frame or 0
   local frame_idx=flr(frame%#t.yoffs)+1
   if frame_idx>0 and frame_idx<=#t.yoffs then
    y+=t.yoffs[frame_idx]
   end
  end
  
  -- LOD: impostor rendering for distant sprites
  local sprite_lod_distance=fog_far*sprite_lod_ratio
  if z>sprite_lod_distance then
   -- sample average color from sprite center (defaults to fog color 5)
   local avg_color=5
   if src and src.get then
    avg_color=src:get(16,16) or 5
   end
   
   -- apply fog uniformly
  -- fog disabled
   
   -- project to screen space
   local f_lod=sdist/z
   local sx_lod=x*f_lod+screen_center_x
   local w_lod=t.w*f_lod
   
   -- compute vertical span
   local y0_lod,y1_lod
   if t.flat then
    local z0=z+t.w/2
    local z1=z-t.w/2
    y0_lod=y*sdist/z0+screen_center_y
    y1_lod=y*sdist/z1+screen_center_y
   else
    local sy_lod=y*f_lod+screen_center_y
    local h_lod=t.h*f_lod
    y0_lod=sy_lod-h_lod/2
    y1_lod=sy_lod+h_lod/2
   end
   
   -- clamp to screen bounds
   local x0=max(0,ceil(sx_lod-w_lod/2))
   local x1=min(screen_width-1,flr(sx_lod+w_lod/2))
   y0_lod=max(0,ceil(y0_lod))
   y1_lod=min(screen_height-1,flr(y1_lod))
   
  -- draw solid impostor columns with z-test (batched rectfill)
   if y1_lod>y0_lod and x1>=x0 then
   rbatch_reset()
   for px=x0,x1 do
    local zb=(zread and zread(px)) or (zbuf.get and zbuf:get(px)) or 999
    if z<zb then
      rbatch_push(px,y0_lod,px,y1_lod,avg_color)
      if zwrite then
       zwrite(px, z)
      elseif zbuf.set then
       zbuf:set(px, z)
      end
    end
   end
   rbatch_submit()
   diag_sprite_impostor_columns+=max(0,x1-x0+1)
   end
   
   return
  end
  
  -- calculate scale factor (perspective)
  local f=sdist/z
  
  -- project to screen space
  local sx=x*f+screen_center_x
  local w=t.w*f
  
  -- calculate y coordinates (different for flat vs upright)
  local y0,y1
  if t.flat then
   -- floor-aligned sprite
   local z0=z+t.w/2
   local z1=z-t.w/2
   y0=y*sdist/z0+screen_center_y
   y1=y*sdist/z1+screen_center_y
  else
   -- upright sprite (use world-space height t.h, not pixel size sprite_size)
   local sy=y*f+screen_center_y
   local h=t.h*f
   y0=sy-h/2
   y1=sy+h/2
  end
  
  -- map screen dimensions to 32x32 sprite UV space
  local size=sprite_size or 32
  local sxd=size/w
  local syd=size/(y1-y0+0.01)
  
  -- UV coordinates start at (0,0) for top-left of 32x32 sprite
  local u0 = 0
  local v0 = 0
  
  -- compute floating left/top edges for sub-pixel adjustment
  local lx=sx-w/2
  local fy0=y0
  
  -- clamp to screen bounds (0 to screen_width-1 for X, 0 to screen_height-1 for Y)
  local x0=max(0,ceil(lx))
  local x1=min(screen_width-1,flr(sx+w/2))
  -- adjust u0 for x clipping
  if x0>lx then
   u0+=(x0-lx)*sxd
  end
  
  y0=max(0,ceil(fy0))
  y1=min(screen_height-1,flr(y1))
  -- adjust v0 for y clipping
  if y0>fy0 then
   v0+=(y0-fy0)*syd
  end
  
  -- guard against degenerate vertical or horizontal span
  if y1<=y0 or x1<x0 then
   return
  end
  
  -- set fog and palette
  if ob.pal then
   pal(ob.pal)
  else
   -- fog disabled
  end
  
  -- draw sprite column-by-column with z-buffer (no diagonal batching)
  local function resolve_sprite_index(idx, kind)
   if idx and get_spr(idx) then
    return idx
   end
   if ERROR_IDX then
    if kind=="sprite" then return ERROR_IDX.sprite else return ERROR_IDX.default end
   end
   return 0
  end
  local spr_idx=resolve_sprite_index(sprite_index,"sprite")
  sbatch_reset()
  for px=x0,x1 do
  local zb=(zread and zread(px)) or (zbuf.get and zbuf:get(px)) or 999
   if z<zb then
    local u=u0+(px-x0)*sxd
    sbatch_push(spr_idx, px, y0, px, y1, u, v0, u, v0+size, 1, 1)
    -- diagnostics removed for production
    if zwrite then
     zwrite(px, z)
    elseif zbuf.set then
     zbuf:set(px, z)
    end
   diag_sprite_columns+=1
   end
  end
  sbatch_submit()
  
  -- if a custom palette was applied, restore fog mapping for subsequent draws
  if ob.pal then
   -- fog state removed
  end
end

:: tests/dungeon_harness.lua
-- deterministic dungeon generation harness
local harness={}

harness.default_seeds={1111,2222,3333,4444,5555}

local function validate_locked_edges(issues)
 if not gen_locked_edges then return end
 for edge in all(gen_locked_edges) do
  if edge.locked and edge.keynum then
   local lt=edge.lock_tile
   if not lt then
    add(issues,"edge "..edge.n1.index.."->"..edge.n2.index.." missing lock tile")
   else
    local tile=get_wall(lt.x,lt.y)
    if tile~=door_locked then
     add(issues,"door at "..lt.x..","..lt.y.." not locked")
    end
   end
   local key_found=false
   for ob in all(gen_objects) do
    if ob.typ==obj_types.key and ob.keynum==edge.keynum then
     key_found=true
     break
    end
   end
   if not key_found then
    add(issues,"missing key#"..edge.keynum.." for edge "..edge.n1.index.."->"..edge.n2.index)
   end
  end
 end
end

function harness.run(seeds)
 seeds=seeds or harness.default_seeds
 local summary={
  total=#seeds,
  failures=0,
  results={}
 }
 local original_seed=nil
 for _,seed in ipairs(seeds) do
  local ok,meta=pcall(function()
   local _,stats=generate_dungeon({seed=seed})
   return stats
  end)
  local record={seed=seed,issues={},rooms=0,objects=0}
  if not ok then
   record.error=meta
   summary.failures+=1
  else
   record.rooms=meta.rooms or 0
   record.objects=meta.objects or 0
   if record.rooms<(gen_params.min_rooms or 0) then
    add(record.issues,"room count "..record.rooms.." below min "..gen_params.min_rooms)
   end
   validate_locked_edges(record.issues)
   if #record.issues>0 then
    summary.failures+=1
   end
  end
  add(summary.results,record)
 end
 return summary
end

dungeon_harness=harness
return harness


:: .info.pod
--[[pod,created="2025-11-07 22:14:20",modified="2025-11-10 12:35:37",runtime=21,workspaces={{location="main.lua#828",workspace_index=1}}]]
:: main.lua
b64$LS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNS0xMS0wNyAyMTowNDowNiIsbW9k
aWZpZWQ9IjIwMjUtMTEtMDcgMjI6MTg6NTEiLHJldmlzaW9uPTVdXQotLSBub25ib3kgcmF5Y2Fz
dCBlbmdpbmUgdjEuMAotLSBtYWluIGVudHJ5IHBvaW50CgppbmNsdWRlInNyYy9jb25maWcubHVh
IgppbmNsdWRlInNyYy9yYXljYXN0Lmx1YSIKaW5jbHVkZSJzcmMvcmVuZGVyLmx1YSIKaW5jbHVk
ZSJzcmMvcmVuZGVyX3Nwcml0ZS5sdWEiCmluY2x1ZGUic3JjL2Rvb3Jfc3lzdGVtLmx1YSIKaW5j
bHVkZSJzcmMvZHVuZ2Vvbl9nZW4ubHVhIgppbmNsdWRlInRlc3RzL2R1bmdlb25faGFybmVzcy5s
dWEiCgpsb2NhbCBzY2VuZXM9e30KbG9jYWwgc2NlbmVfc3RhdGU9e30KbG9jYWwgY3VycmVudF9z
Y2VuZT1uaWwKCmxvY2FsIGZ1bmN0aW9uIGdldF9zY2VuZV9zdGF0ZShuYW1lKQogc2NlbmVfc3Rh
dGVbbmFtZV09c2NlbmVfc3RhdGVbbmFtZV0gb3Ige30KIHJldHVybiBzY2VuZV9zdGF0ZVtuYW1l
XQplbmQKCmxvY2FsIGZ1bmN0aW9uIHN3aXRjaF9zY2VuZShuYW1lLHBhcmFtcykKIGxvY2FsIHNj
ZW5lPXNjZW5lc1tuYW1lXQogaWYgbm90IHNjZW5lIHRoZW4KICBwcmludGgoIndhcm5pbmc6IHVu
a25vd24gc2NlbmUgIi4udG9zdHJpbmcobmFtZSkpCiAgcmV0dXJuCiBlbmQKIGlmIGN1cnJlbnRf
c2NlbmUgYW5kIHNjZW5lc1tjdXJyZW50X3NjZW5lXSBhbmQgc2NlbmVzW2N1cnJlbnRfc2NlbmVd
LmxlYXZlIHRoZW4KICBzY2VuZXNbY3VycmVudF9zY2VuZV0ubGVhdmUoZ2V0X3NjZW5lX3N0YXRl
KGN1cnJlbnRfc2NlbmUpKQogZW5kCiBjdXJyZW50X3NjZW5lPW5hbWUKIGxvY2FsIHN0YXRlPWdl
dF9zY2VuZV9zdGF0ZShuYW1lKQogaWYgc2NlbmUuZW50ZXIgdGhlbgogIHNjZW5lLmVudGVyKHN0
YXRlLHBhcmFtcyBvciB7fSkKIGVuZAplbmQKCmxvY2FsIGZ1bmN0aW9uIHNjZW5lX3VwZGF0ZSgp
CiBpZiBjdXJyZW50X3NjZW5lIGFuZCBzY2VuZXNbY3VycmVudF9zY2VuZV0gYW5kIHNjZW5lc1tj
dXJyZW50X3NjZW5lXS51cGRhdGUgdGhlbgogIHNjZW5lc1tjdXJyZW50X3NjZW5lXS51cGRhdGUo
Z2V0X3NjZW5lX3N0YXRlKGN1cnJlbnRfc2NlbmUpKQogZW5kCmVuZAoKbG9jYWwgZnVuY3Rpb24g
c2NlbmVfZHJhdygpCiBpZiBjdXJyZW50X3NjZW5lIGFuZCBzY2VuZXNbY3VycmVudF9zY2VuZV0g
YW5kIHNjZW5lc1tjdXJyZW50X3NjZW5lXS5kcmF3IHRoZW4KICBzY2VuZXNbY3VycmVudF9zY2Vu
ZV0uZHJhdyhnZXRfc2NlbmVfc3RhdGUoY3VycmVudF9zY2VuZSkpCiBlbHNlCiAgY2xzKDApCiBl
bmQKZW5kCgotLSBjb25zdGFudHMKcGxheWVyX2NvbGxpc2lvbl9yYWRpdXM9MC4xNQoKZnVuY3Rp
b24gX2luaXQoKQogd2luZG93KHNjcmVlbl93aWR0aCxzY3JlZW5faGVpZ2h0KQogCiAtLSBwaW4g
bWFza3MgdG8gZGVmYXVsdHMgZm9yIHNpbmdsZSBjb2xvdXItdGFibGUgZmFzdCBwYXRoCiBwb2tl
KDB4NTUwOCwweDNmKSBwb2tlKDB4NTUwOSwweDNmKSBwb2tlKDB4NTUwYSwweDNmKSBwb2tlKDB4
NTUwYiwweDAwKQogCiAtLSB0aWxlIDAgZHJhd2luZyBzdGF0ZTogdmVyaWZpZWQgbm90IHJlcXVp
cmVkOyBsZWF2ZSAweDVmMzYgYXQgZGVmYXVsdCAobm8gZXhwbGljaXQgcG9rZSkKIC0tIHNzcHIo
KSB1c2FnZSB2ZXJpZmllZDogTm9uZSBpbiBwcm9kdWN0aW9uIGNvZGUgKG9ubHkgaW4gc2FtcGxl
IGZpbGVzKQogLS0gUGVyIFBpY290cm9uIGd1aWRlbGluZXM6IGJsaXQoKSBpcyBmYXN0ZXI7IEhV
RC9taW5pbWFwIHVzZSBkaXJlY3QgZHJhd2luZwogLS0gY29uZmlndXJhdGlvbiBndWFyZDogcHJl
dmVudCBmb2cgcG9wcGluZyBiZXlvbmQgZmFyLXBsYW5lCiBhc3NlcnQoZmFyX3BsYW5lPj1mb2df
ZmFyKzEsImNvbmZpZyBlcnJvcjogZmFyX3BsYW5lIG11c3QgYmUgPj0gZm9nX2ZhciArIDEiKQog
CiAtLSBkZWZlbnNpdmUgZGVmYXVsdHMgaWYgY29uZmlnIGluY2x1ZGUgZmFpbGVkIHRvIHNldCB0
aGVtIGZvciBhbnkgcmVhc29uCiBpZiBub3Qgb2JqZ3JpZF9zaXplIHRoZW4gb2JqZ3JpZF9zaXpl
PTUgZW5kCiBpZiBub3Qgb2JqZ3JpZF9hcnJheV9zaXplIHRoZW4gb2JqZ3JpZF9hcnJheV9zaXpl
PTI2IGVuZAogCiAtLSBmcmFtZSBjb3VudGVyIGZvciBhaSB0aW1pbmcKIGZyYW1lX2N0PTAKIAog
LS0gcGxheWVyIHN0YXRlCiBwbGF5ZXI9ewogIHg9NjQseT02NCwKICBhPTAsCiAgc3BkPXBsYXll
cl9tb3ZlX3NwZWVkLAogIGtleXM9e30sCiAgaHA9MTAwCiB9CiAKIC0tIGludGVyYWN0aW9uIHN0
YXRlCiBpbnRlcmFjdGlvbl9hY3RpdmU9ZmFsc2UKIGN1cnJlbnRfaW50ZXJhY3Q9bmlsCiAKIC0t
IGNvbWJhdCBzdGF0ZQogaW5fY29tYmF0PWZhbHNlCiBjdXJyZW50X3RhcmdldD1uaWwKIAogLS0g
dHJhcCBtZXNzYWdlIHRpbWVyCiB0cmFwX21zZ190aW1lcj0wCiAKIC0tIGNhbWVyYQogY2FtPXtw
bGF5ZXIueCxwbGF5ZXIueX0KIAogLS0gbWFwIGFic3RyYWN0aW9uIHdpdGggdXNlcmRhdGEgbGF5
ZXJzCiBtYXA9e30KIG1hcC53YWxscz11c2VyZGF0YSgiaTE2IiwxMjgsMTI4KQogbWFwLmRvb3Jz
PXVzZXJkYXRhKCJpMTYiLDEyOCwxMjgpCiBtYXAuZmxvb3JzPXVzZXJkYXRhKCJpMTYiLDEyOCwx
MjgpCiAKIC0tIGhlbHBlcjogZ2V0IHdhbGwgdGlsZQotLSBQdXJwb3NlOiBSZXRyaWV2ZSB3YWxs
IHRpbGUgSUQgYXQgZ3JpZCBwb3NpdGlvbgogLS0gUGFyYW1ldGVyczogeCwgeSAoZ3JpZCBjb29y
ZGluYXRlcyAwLTEyNykKIC0tIFJldHVybnM6IHRpbGUgSUQgKDA9ZW1wdHksID4wPXdhbGwvZG9v
ci9leGl0KQogZnVuY3Rpb24gZ2V0X3dhbGwoeCx5KQogaWYgeD49MCBhbmQgeDwxMjggYW5kIHk_
PTAgYW5kIHk8MTI4IHRoZW4KICByZXR1cm4gbWFwLndhbGxzOmdldCh4LHkpIG9yIDAKIGVuZAog
cmV0dXJuIDAKIGVuZAogCiAtLSBoZWxwZXI6IHNldCB3YWxsIHRpbGUKIGZ1bmN0aW9uIHNldF93
YWxsKHgseSx2YWwpCiAgaWYgeD49MCBhbmQgeDwxMjggYW5kIHk_PTAgYW5kIHk8MTI4IHRoZW4K
CQltYXAud2FsbHM6c2V0KHgseSx2YWwgb3IgMCkKICBlbmQKIGVuZAogCiAtLSBoZWxwZXI6IGdl
dCBkb29yIHRpbGUKIGZ1bmN0aW9uIGdldF9kb29yKHgseSkKICBpZiB4Pj0wIGFuZCB4PDEyOCBh
bmQgeT49MCBhbmQgeTwxMjggdGhlbgogICByZXR1cm4gbWFwLmRvb3JzOmdldCh4LHkpIG9yIDAK
ICBlbmQKICByZXR1cm4gMAogZW5kCiAKIC0tIGhlbHBlcjogc2V0IGRvb3IgdGlsZQogZnVuY3Rp
b24gc2V0X2Rvb3IoeCx5LHZhbCkKICBpZiB4Pj0wIGFuZCB4PDEyOCBhbmQgeT49MCBhbmQgeTwx
MjggdGhlbgogICBtYXAuZG9vcnM6c2V0KHgseSx2YWwgb3IgMCkKICBlbmQKIGVuZAoKIC0tIGhl
bHBlcjogZ2V0IGZsb29yIHRpbGUKIC0tIFB1cnBvc2U6IFJldHJpZXZlIGZsb29yIHR5cGUgSUQg
YXQgZ3JpZCBwb3NpdGlvbgogLS0gUGFyYW1ldGVyczogeCwgeSAoZ3JpZCBjb29yZGluYXRlcyAw
LTEyNykKIC0tIFJldHVybnM6IGZsb29yIHR5cGUgSUQgKDA9dXNlIGdsb2JhbCBkZWZhdWx0LCAx
LTg9c3BlY2lmaWMgZmxvb3IgdHlwZSBmcm9tIHBsYW5ldHlwcykKIC0tIE5vdGVzOiBGbG9vciB0
eXBlIElEcyBtYXAgdG8gaW5kaWNlcyBpbiB0aGUgcGxhbmV0eXBzIHRhYmxlIGRlZmluZWQgaW4g
Y29uZmlnLmx1YQogZnVuY3Rpb24gZ2V0X2Zsb29yKHgseSkKICBpZiB4Pj0wIGFuZCB4PDEyOCBh
bmQgeT49MCBhbmQgeTwxMjggdGhlbgogICByZXR1cm4gbWFwLmZsb29yczpnZXQoeCx5KSBvciAw
CiAgZW5kCiAgcmV0dXJuIDAKIGVuZAoKIC0tIGhlbHBlcjogc2V0IGZsb29yIHRpbGUKIC0tIFB1
cnBvc2U6IFN0b3JlIHBlci1jZWxsIGZsb29yIHR5cGUgSURzIGZvciB2YXJpZWQgZmxvb3IgdGV4
dHVyZXMKIC0tIFBhcmFtZXRlcnM6IHgsIHkgKGdyaWQgY29vcmRpbmF0ZXMgMC0xMjcpLCB2YWwg
KGZsb29yIHR5cGUgSUQgMC04KQogLS0gTm90ZXM6IDA9dXNlIGdsb2JhbCBkZWZhdWx0IGZsb29y
IHR5cGUsIDEtOD1zcGVjaWZpYyBmbG9vciB0eXBlIGZyb20gcGxhbmV0eXBzCiBmdW5jdGlvbiBz
ZXRfZmxvb3IoeCx5LHZhbCkKICBpZiB4Pj0wIGFuZCB4PDEyOCBhbmQgeT49MCBhbmQgeTwxMjgg
dGhlbgogICAtLSBub3JtYWxpemUgdmFsIHRvIHZhbGlkIHJhbmdlIDAtOAogICBpZiB0eXBlKHZh
bCl_PSJudW1iZXIiIG9yIHZhbD09bmlsIHRoZW4KICAgIHZhbD0wCiAgIGVsc2VpZiB2YWw8MCB0
aGVuCiAgICB2YWw9MAogICBlbHNlaWYgdmFsPjggdGhlbgogICAgdmFsPTgKICAgZW5kCiAgIG1h
cC5mbG9vcnM6c2V0KHgseSx2YWwpCiAgZW5kCiBlbmQKIAogZG9vcmdyaWQ9e30KIGZvciBpPTAs
MTI3IGRvCiAgZG9vcmdyaWRbaV09e30KICBmb3Igaj0wLDEyNyBkbwogICBkb29yZ3JpZFtpXVtq
XT1uaWwKICBlbmQKIGVuZAogCiAtLSBpbml0aWFsaXplIGZsb29yIGRhdGEKIGZvciBpPTAsMTI3
IGRvCiAgZm9yIGo9MCwxMjcgZG8KICAgc2V0X2Zsb29yKGksaiwwKQogIGVuZAogZW5kCiAgCiBk
b29ycz17fQogb2JqZWN0cz17fQogYW5pbWF0ZWRfb2JqZWN0cz17fQogCi0tIHotYnVmZmVyIGFu
ZCBmcmFtZS1zdGFtcCBhcyB0eXBlZCB1c2VyZGF0YSBmb3Igc3BlZWQKLS0gemJ1ZjogcGVyLWNv
bHVtbiBkZXB0aCB2YWx1ZXMgKG9uZSB6IHBlciBzY3JlZW4geCk7IHpzdGFtcDogZnJhbWUtc3Rh
bXAgdG8gYXZvaWQgcGVyLWZyYW1lIGNsZWFycwogemJ1Zj11c2VyZGF0YSgiZjY0Iiwgc2NyZWVu
X3dpZHRoKQogenN0YW1wPXVzZXJkYXRhKCJpMzIiLCBzY3JlZW5fd2lkdGgpCiBmb3IgaT0wLHNj
cmVlbl93aWR0aC0xIGRvCiAgLS0gaW5pdGlhbGl6ZSBzdGFtcHMgdG8gMDsgeiB2YWx1ZXMgYXJl
IGNvbnNpZGVyZWQgaW52YWxpZCB1bnRpbCBzdGFtcGVkCiAgenN0YW1wOnNldChpLCAwKQogZW5k
CiAKIC0tIGR5bmFtaWMgYnVkZ2V0cwogYWN0aXZlX3JheV9jb3VudD1yYXlfY291bnQKIHJvd19z
dHJpZGVfZHluYW1pYz1yb3dfc3RyaWRlCiAKIC0tIENvbnZlcnQgdG8gdXNlcmRhdGEgZm9yIDI0
eCBwZXJmb3JtYW5jZSBnYWluIChQaWNvdHJvbiBvcHRpbWl6YXRpb24gZ3VpZGVsaW5lKQogcmF5
X3ogPSB1c2VyZGF0YSgiZjY0IiwgcmF5X2NvdW50KQogcmF5X3gwID0gdXNlcmRhdGEoImkxNiIs
IHJheV9jb3VudCkKIHJheV94MSA9IHVzZXJkYXRhKCJpMTYiLCByYXlfY291bnQpCiByYXlfZHgg
PSB1c2VyZGF0YSgiZjY0IiwgcmF5X2NvdW50KQogcmF5X2R5ID0gdXNlcmRhdGEoImY2NCIsIHJh
eV9jb3VudCkKIHJheV9oaXR4ID0gdXNlcmRhdGEoImY2NCIsIHJheV9jb3VudCkKIHJheV9oaXR5
ID0gdXNlcmRhdGEoImY2NCIsIHJheV9jb3VudCkKIAogLS0gUHJlY29tcHV0ZWQgcGl4ZWwgY2Vu
dGVycyBmb3IgY2FtZXJhLXNwYWNlIHJheSBvZmZzZXRzIChlbGltaW5hdGVzIHBlci1mcmFtZSBj
b21wdXRhdGlvbikKIHJheV9weF9jZW50ZXIgPSB1c2VyZGF0YSgiZjY0IiwgcmF5X2NvdW50KQog
CiAtLSBJbml0aWFsaXplIHdpdGggZGVmYXVsdHMKIGZvciBpPTAscmF5X2NvdW50LTEgZG8KICAg
cmF5X3o6c2V0KGksIDk5OSkKICAgcmF5X3gwOnNldChpLCAwKQogICByYXlfeDE6c2V0KGksIDAp
CiAgIHJheV9keDpzZXQoaSwgMCkKICAgcmF5X2R5OnNldChpLCAwKQogZW5kCiAKIC0tIHJidWY6
IHVzZSBzZXBhcmF0ZSB1c2VyZGF0YSBhcnJheXMgZm9yIHRpbGUgYW5kIHR4IChhdm9pZCBuZXN0
ZWQgc3RydWN0dXJlcykKIHJidWZfdGlsZSA9IHVzZXJkYXRhKCJpMTYiLCByYXlfY291bnQpCiBy
YnVmX3R4ID0gdXNlcmRhdGEoImY2NCIsIHJheV9jb3VudCkKIGZvciBpPTAscmF5X2NvdW50LTEg
ZG8KICAgcmJ1Zl90aWxlOnNldChpLCAwKQogICByYnVmX3R4OnNldChpLCAwKQogZW5kCiAKIC0t
IGZvZyBzdGF0ZSBmb3IgaHlzdGVyZXNpcwogbGFzdF9mb2dfej0wCiAKIC0tIHByb2plY3Rpb24g
Y29uc3RhbnQgZGVmaW5lZCBpbiBjb25maWcubHVhCiAKIC0tIGZsb29yIGFuZCByb29mIHN0YXRl
CiBmbG9vcj17dHlwPXBsYW5ldHlwc1sxXSx4PTAseT0wfQogcm9vZj17dHlwPXBsYW5ldHlwc1sz
XSx4PTAseT0wfQogCiBnZW5fc3RhdHM9e3Jvb21zPTAsb2JqZWN0cz0wLHNlZWQ9MCxoaXN0b3J5
PXt9fQogc3RhcnRfcG9zPXt4PXBsYXllci54LHk9cGxheWVyLnl9CiAtLSBtb2RlOiAzZCBvciAy
ZCBtYXAKIHZpZXdfbW9kZT0iM2QiCiAKIC0tIGRlYnVnIG1vZGUgZm9yIHJheSBjYXN0aW5nCiBk
ZWJ1Z19tb2RlPWZhbHNlCnNob3dfZGlhZ25vc3RpY3M9ZmFsc2UKZW5hYmxlX2RpYWdub3N0aWNz
X2xvZ2dpbmc9ZmFsc2UgIC0tIFBlcm1hbmVudGx5IGRpc2FibGVkIGZvciBwcm9kdWN0aW9uIHBl
cmZvcm1hbmNlCi0tIE9wdGlvbmFsOiByZS1lbmFibGUgYSBub24tcmVuZGVyIENQVSBnb3Zlcm5v
ciAoc2FtcGxlcyBDUFUgb3V0c2lkZSBfZHJhdygpKQplbmFibGVfbm9ucmVuZGVyX2dvdmVybm9y
PWZhbHNlCnJlY2VudF9jcHU9MAogCiAtLSBwZXJmb3JtYW5jZSB2YWxpZGF0aW9uIG1vZGU6IGRp
c2FibGVzIENQVSBnb3Zlcm5vciB0byBzdGFiaWxpemUgbWVhc3VyZW1lbnRzCiBwZXJmX3ZhbGlk
YXRpb249ZmFsc2UKIAogLS0gZGlhZ25vc3RpYyBjb3VudGVycyBmb3IgcGVyZm9ybWFuY2UgdHJh
Y2tpbmcgKHJlZnJlc2hlZCBlYWNoIGZyYW1lKQogZGlhZ19mcmFtZV9jb3VudD0wCiBkaWFnX3dh
bGxfY29sdW1ucz0wCiBkaWFnX3dhbGxfbG9kX2NvbHVtbnM9MAogZGlhZ19mbG9vcl9yb3dzPTAK
IGRpYWdfZmxvb3JfYmF0Y2hlcz0wCiBkaWFnX3Nwcml0ZV9jb2x1bW5zPTAKIGRpYWdfc3ByaXRl
X2ltcG9zdG9yX2NvbHVtbnM9MAogZGlhZ19hY3RpdmVfcmF5cz1yYXlfY291bnQKIGxhc3RfY3B1
X3NhbXBsZT0wCiAKIC0tIHRlc3QgZG9vciBtb2RlCiB0ZXN0X2Rvb3JfbW9kZT1mYWxzZQoKIC0t
IGNyZWF0ZSB0aW50ZWQgZXJyb3IgdGV4dHVyZXMgZm9yIGRpZmZlcmVudCBvYmplY3QgdHlwZXMg
KGNoZWNrZXJib2FyZCBwYXR0ZXJuKQogLS0gd2FsbHM6IG1hZ2VudGEvcGluayAoOC8xNCksIGZs
b29yOiBibHVlL2N5YW4gKDEyLzEzKSwgY2VpbGluZzogZ3JlZW4vZGFyayBncmVlbiAoMTEvMykK
IC0tIHNwcml0ZXM6IHllbGxvdy9vcmFuZ2UgKDEwLzkpLCBwcm9wczogcmVkL2Jyb3duICg4LzQp
CiBlcnJvcl90ZXh0dXJlcyA9IHsKICB3YWxsID0gdXNlcmRhdGEoInU4IiwgMzIsIDMyKSwKIGRv
b3IgPSB1c2VyZGF0YSgidTgiLCAzMiwgMzIpLAogIGZsb29yID0gdXNlcmRhdGEoInU4IiwgMzIs
IDMyKSwKICBjZWlsaW5nID0gdXNlcmRhdGEoInU4IiwgMzIsIDMyKSwKICBzcHJpdGUgPSB1c2Vy
ZGF0YSgidTgiLCAzMiwgMzIpLAogIGRlZmF1bHQgPSB1c2VyZGF0YSgidTgiLCAzMiwgMzIpCiB9
CiAKIC0tIGdlbmVyYXRlIHRpbnRlZCBjaGVja2VyYm9hcmRzIGZvciBlYWNoIHR5cGUKIGxvY2Fs
IHRpbnRzID0gewogIHdhbGwgPSB7OCwgMTR9LCAgICAgIC0tIG1hZ2VudGEvcGluawogZG9vciA9
IHsyLCA2fSwgICAgICAgLS0gcHVycGxlL2JsdWUgKGRpc3RpbmN0IGZyb20gd2FsbHMpCiAgZmxv
b3IgPSB7MTIsIDEzfSwgICAgLS0gYmx1ZS9jeWFuCiAgY2VpbGluZyA9IHsxMSwgM30sICAgLS0g
Z3JlZW4vZGFyayBncmVlbgogIHNwcml0ZSA9IHsxMCwgOX0sICAgIC0tIHllbGxvdy9vcmFuZ2UK
ICBkZWZhdWx0ID0gezgsIDE0fSAgICAtLSBtYWdlbnRhL3BpbmsgKGZhbGxiYWNrKQogfQogCiBm
b3IgdHlwZV9uYW1lLCBjb2xvcnMgaW4gcGFpcnModGludHMpIGRvCiAgZm9yIHk9MCwzMSBkbwog
ICBmb3IgeD0wLDMxIGRvCiAgICBsb2NhbCBjb2xvciA9ICgoZmxyKHgvNCkgKyBmbHIoeS80KSkg
JSAyID09IDApIGFuZCBjb2xvcnNbMV0gb3IgY29sb3JzWzJdCiAgICBlcnJvcl90ZXh0dXJlc1t0
eXBlX25hbWVdOnNldCh4LCB5LCBjb2xvcikKICAgZW5kCiAgZW5kCiBlbmQKIAogLS0gbWFpbnRh
aW4gYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIHNpbmdsZSBlcnJvcl90ZXh0dXJlCiBlcnJv
cl90ZXh0dXJlID0gZXJyb3JfdGV4dHVyZXMuZGVmYXVsdAoKIC0tIHJlc2VydmUgc3ByaXRlIGlu
ZGV4ZXMgZm9yIGVycm9yIHRleHR1cmVzIChiYXRjaGluZyBwcmVmZXJzIHNwcml0ZSBpbmRleGVz
KQogRVJST1JfSURYID0geyB3YWxsPTgwMDAsIGRvb3I9ODAwMSwgZmxvb3I9ODAwMiwgY2VpbGlu
Zz04MDAzLCBzcHJpdGU9ODAwNCwgZGVmYXVsdD04MDA1IH0KIGZvciBuYW1lLCB1ZCBpbiBwYWly
cyhlcnJvcl90ZXh0dXJlcykgZG8KICBsb2NhbCBpZHggPSBFUlJPUl9JRFhbbmFtZV0gb3IgRVJS
T1JfSURYLmRlZmF1bHQKICBzZXRfc3ByKGlkeCwgdWQpCiBlbmQKIAogLS0gUHJlbG9hZCB0ZXh0
dXJlIGNhY2hlIGZvciBjb21tb25seS11c2VkIHNwcml0ZXMgKDAtMjAwKQogLS0gUG9wdWxhdGUg
dGV4X2NhY2hlIGRpcmVjdGx5IHVzaW5nIGdldF9zcHIoKSB0byBhdm9pZCB3YXJuaW5ncwogcHJp
bnRoKCJwcmVsb2FkaW5nIHRleHR1cmUgY2FjaGUuLi4iKQogbG9jYWwgcHJlbG9hZF9zdGFydCA9
IHRpbWUoKQogZm9yIGk9MCwyMDAgZG8KICBsb2NhbCBzcmM9Z2V0X3NwciBhbmQgZ2V0X3Nwcihp
KQogIGlmIHNyYyBhbmQgY2FjaGVfdGV4IHRoZW4KICAgY2FjaGVfdGV4KGksIHNyYywgZmFsc2Up
CiAgZW5kCiBlbmQKIGxvY2FsIHByZWxvYWRfdGltZSA9ICh0aW1lKCkgLSBwcmVsb2FkX3N0YXJ0
KSAqIDEwMDAKIHByaW50aCgidGV4dHVyZSBjYWNoZSBwcmVsb2FkZWQ6ICIuLnByZWxvYWRfdGlt
ZS4uIm1zIikKIC0tIFRyaWdnZXIgR0MgYWZ0ZXIgcHJlbG9hZGluZyAoUGljb3Ryb24gZ3VpZGVs
aW5lOiBzdGF0KDApIGR1cmluZyBwYXVzZXMgb25seSkKIHN0YXQoMCkKIAogLS0gbG9nZ2luZyBo
ZWxwZXI6IGNvbnNvbGUgKyByaW5nIGJ1ZmZlciBmb3Igb3B0aW9uYWwgb24tc2NyZWVuIGVjaG8K
IGxvZ19saW5lcyA9IHt9CiBmdW5jdGlvbiBsb2coc3RyKQogIHByaW50aChzdHIpCiAgYWRkKGxv
Z19saW5lcywgc3RyKQogIGlmICNsb2dfbGluZXMgPiAyMDAgdGhlbiBkZWxpKGxvZ19saW5lcywg
MSkgZW5kCiBlbmQKCiAtLSB2YWxpZGF0ZSBhbGwgY29uZmlndXJlZCBzcHJpdGVzIGV4aXN0IChj
b21tZW50IG91dCBmb3IgcHJvZHVjdGlvbikKIHZhbGlkYXRlX3Nwcml0ZV9jb25maWd1cmF0aW9u
KCkKCiBwcmludGgoInBpY290cm9uIHJheWNhc3QgZW5naW5lIHYxLjAiKQogc3dpdGNoX3NjZW5l
KCJtZW51IikKZW5kCgotLSB2YWxpZGF0ZSBzcHJpdGUgY29uZmlndXJhdGlvbiBhdCBzdGFydHVw
IChvcHRpb25hbCwgY2FuIGJlIGRpc2FibGVkIGZvciBwZXJmb3JtYW5jZSkKZnVuY3Rpb24gdmFs
aWRhdGVfc3ByaXRlX2NvbmZpZ3VyYXRpb24oKQogLS0gY2hlY2sgZW5lbXkgc3ByaXRlcwogZm9y
IGVuZW15IGluIGFsbChlbmVteV90eXBlcykgZG8KICBpZiBub3QgZ2V0X3NwcihlbmVteS5zcHJp
dGUpIHRoZW4KICAgcHJpbnRoKCJXQVJOSU5HOiBlbmVteSBzcHJpdGUgIi4uZW5lbXkuc3ByaXRl
Li4iICgiLi5lbmVteS5uYW1lLi4iKSBub3QgZm91bmQgaW4gR0ZYIGZpbGVzIikKICBlbmQKIGVu
ZAogCiAtLSBjaGVjayBkZWNvcmF0aW9uIHNwcml0ZXMKIGZvciBkZWMgaW4gYWxsKGRlY29yYXRp
b25fdHlwZXMpIGRvCiAgaWYgbm90IGdldF9zcHIoZGVjLnNwcml0ZSkgdGhlbgogICBwcmludGgo
IldBUk5JTkc6IGRlY29yYXRpb24gc3ByaXRlICIuLmRlYy5zcHJpdGUuLiIgKCIuLmRlYy5uYW1l
Li4iKSBub3QgZm91bmQgaW4gR0ZYIGZpbGVzIikKICBlbmQKIGVuZAogCiAtLSBjaGVjayB3YWxs
IHRleHR1cmUgc3ByaXRlcwogZm9yIHRleHNldCBpbiBhbGwodGV4c2V0cykgZG8KICBmb3IgdmFy
aWFudCBpbiBhbGwodGV4c2V0LnZhcmlhbnRzKSBkbwogICBpZiBub3QgZ2V0X3Nwcih2YXJpYW50
KSB0aGVuCiAgICBwcmludGgoIldBUk5JTkc6IHdhbGwgdGV4dHVyZSBzcHJpdGUgIi4udmFyaWFu
dC4uIiBub3QgZm91bmQgaW4gR0ZYIGZpbGVzIikKICAgZW5kCiAgZW5kCiBlbmQKIAogLS0gY2hl
Y2sgZmxvb3IvY2VpbGluZyBzcHJpdGVzCiBmb3IgdHlwIGluIGFsbChwbGFuZXR5cHMpIGRvCiAg
aWYgbm90IGdldF9zcHIodHlwLnRleCkgdGhlbgogICBwcmludGgoIldBUk5JTkc6IGZsb29yL2Nl
aWxpbmcgc3ByaXRlICIuLnR5cC50ZXguLiIgbm90IGZvdW5kIGluIEdGWCBmaWxlcyIpCiAgZW5k
CiBlbmQKZW5kCgpmdW5jdGlvbiB1cGRhdGVfZ2FtZXBsYXkoKQogLS0gaW5jcmVtZW50IGZyYW1l
IGNvdW50ZXIKIGZyYW1lX2N0Kz0xCiAKIC0tIG9wdGlvbmFsOiBzYW1wbGUgQ1BVIG91dHNpZGUg
cmVuZGVyIGZyYW1lIChldmVyeSAzMCBmcmFtZXMpIGZvciBub24tcmVuZGVyIGdvdmVybm9yCiBp
ZiBlbmFibGVfbm9ucmVuZGVyX2dvdmVybm9yIGFuZCAoZnJhbWVfY3QlMzA9PTApIHRoZW4KICBy
ZWNlbnRfY3B1PXN0YXQoMSkgb3IgMAogZW5kCiAKIC0tIGNvbWJhdCBnYXRpbmc6IHNraXAgbm9y
bWFsIHVwZGF0ZXMgd2hlbiBpbiBjb21iYXQKIGlmIGluX2NvbWJhdCB0aGVuCiAgdXBkYXRlX2Nv
bWJhdCgpCiAgcmV0dXJuCiBlbmQKIAogdXBkYXRlX2lucHV0KCkKIHVwZGF0ZV9kb29ycygpCiAK
IC0tIHVwZGF0ZSBucGMgYWkgKHJhdGUgbGltaXRlZCwgZGV0ZXJtaW5pc3RpYyBmcmFtZSBjaGVj
aykKIGlmIGZyYW1lX2N0JWFpX3VwZGF0ZV9yYXRlPT0wIHRoZW4KICB1cGRhdGVfbnBjX2FpKCkK
IGVuZAogCiBjYW09e3BsYXllci54LHBsYXllci55fQogCiAtLSB1cGRhdGUgZmxvb3IvY2VpbGlu
ZyBzY3JvbGxpbmcKIGZsb29yLngrPWZsb29yLnR5cC54dmVsIG9yIDAKIGZsb29yLnkrPWZsb29y
LnR5cC55dmVsIG9yIDAKIHJvb2YueCs9cm9vZi50eXAueHZlbCBvciAwCiByb29mLnkrPXJvb2Yu
dHlwLnl2ZWwgb3IgMAogCiAtLSB1cGRhdGUgb2JqZWN0IGFuaW1hdGlvbnMKIGZvciBvYiBpbiBh
bGwoYW5pbWF0ZWRfb2JqZWN0cykgZG8KICBpZiBvYi50eXAgYW5kIG9iLnR5cC5mcmFtZWN0IHRo
ZW4KICAgb2IuZnJhbWUrPW9iLnR5cC5hbmltc3BkCiAgIGlmIG9iLmFuaW1sb29wIHRoZW4KICAg
IG9iLmZyYW1lPW9iLmZyYW1lJW9iLnR5cC5mcmFtZWN0CiAgIGVsc2UKICAgIG9iLmZyYW1lPW1p
bihvYi5mcmFtZSxvYi50eXAuZnJhbWVjdC0xKQogICBlbmQKICBlbmQKIGVuZAogCiAtLSB0b2dn
bGUgdmlldyBtb2RlIChkZWJ1ZyBvbmx5KQogaWYgZGVidWdfbW9kZSBhbmQgKGtleXAoIngiKSBv
ciBidG5wKDUpKSB0aGVuCiAgdmlld19tb2RlPXZpZXdfbW9kZT09IjNkIiBhbmQgIjJkIiBvciAi
M2QiCiBlbmQKIAogLS0gZGVidWcgbW9kZSB0b2dnbGUgKG1vdmVkIGZyb20gYnRucCg0KSB0byBh
dm9pZCBjb25mbGljdCkKIGlmIGtleXAoInRhYiIpIHRoZW4KICBkZWJ1Z19tb2RlPW5vdCBkZWJ1
Z19tb2RlCiBlbmQKIAogLS0gZGlhZ25vc3RpY3Mgb3ZlcmxheSByZW1vdmVkOyBtZXJnZWQgaW50
byBkZWJ1ZyBwYW5lbCAoVGFiKQogCiAtLSB0b2dnbGUgZGlhZ25vc3RpY3MgbG9nZ2luZyAoY29u
dHJvbGxlciBidXR0b24gMTIpCiBpZiBidG5wKDEyKSB0aGVuCiAgZW5hYmxlX2RpYWdub3N0aWNz
X2xvZ2dpbmc9bm90IGVuYWJsZV9kaWFnbm9zdGljc19sb2dnaW5nCiAgcHJpbnRoKCJEaWFnbm9z
dGljcyBsb2dnaW5nOiAiLi50b3N0cmluZyhlbmFibGVfZGlhZ25vc3RpY3NfbG9nZ2luZykpCiBl
bmQKIAogLS0gZGVjcmVtZW50IHRyYXAgbWVzc2FnZSB0aW1lcgogaWYgdHJhcF9tc2dfdGltZXI_
MCB0aGVuCiAgdHJhcF9tc2dfdGltZXItPTEKIGVuZAogCiAtLSB0b2dnbGUgdGVzdCBkb29yIG1v
ZGUgKHdoZW4gbm90IGluIDJkIG1hcCB2aWV3KQogaWYgdmlld19tb2RlPT0iM2QiIGFuZCAoa2V5
cCgidiIpIG9yIGJ0bnAoMTUpKSB0aGVuCiAgdGVzdF9kb29yX21vZGU9bm90IHRlc3RfZG9vcl9t
b2RlCiBlbmQKIAogLS0gY3ljbGUgdGVzdCBkb29yIG9wZW4gdmFsdWUgKDAuMCB0byAxLjApCiBp
ZiB0ZXN0X2Rvb3JfbW9kZSB0aGVuCiAgaWYga2V5cCgiYyIpIHRoZW4KICAgdGVzdF9kb29yX29w
ZW49KHRlc3RfZG9vcl9vcGVuIG9yIDApKzAuMQogICBpZiB0ZXN0X2Rvb3Jfb3Blbj4xIHRoZW4g
dGVzdF9kb29yX29wZW49MCBlbmQKICBlbmQKICBpZiBrZXlwKCJkIikgdGhlbgogICB0ZXN0X2Rv
b3Jfb3Blbj0odGVzdF9kb29yX29wZW4gb3IgMCktMC4xCiAgIGlmIHRlc3RfZG9vcl9vcGVuPDAg
dGhlbiB0ZXN0X2Rvb3Jfb3Blbj0xIGVuZAogIGVuZAogZW5kCiAKIC0tIGN5Y2xlIGZsb29yIHR5
cGUgKGZvciB0ZXN0aW5nKSB3aGVuIG5vdCBpbiBkb29yIHRlc3QgbW9kZQogaWYgbm90IHRlc3Rf
ZG9vcl9tb2RlIGFuZCBrZXlwKCJjIikgdGhlbgogIGxvY2FsIGN1cnJlbnRfaWR4PTEKICBmb3Ig
aT0xLCNwbGFuZXR5cHMgZG8KICAgaWYgcGxhbmV0eXBzW2ldLnRleD09Zmxvb3IudHlwLnRleCB0
aGVuCiAgICBjdXJyZW50X2lkeD1pCiAgICBicmVhawogICBlbmQKICBlbmQKICBmbG9vci50eXA9
cGxhbmV0eXBzWyhjdXJyZW50X2lkeCAlICNwbGFuZXR5cHMpKzFdCiAgZmxvb3IueCxmbG9vci55
PTAsMAogIC0tIFRlc3QgbW9kZTogY2xlYXIgY2FjaGUgd2hlbiBjeWNsaW5nIGZsb29yIHR5cGVz
IChjYW4gYmUgZGlzYWJsZWQgaW4gcHJvZHVjdGlvbikKICBpZiBjbGVhcl90ZXh0dXJlX2NhY2hl
cyB0aGVuIGNsZWFyX3RleHR1cmVfY2FjaGVzKCkgZW5kCiBlbmQKIAogLS0gY3ljbGUgcm9vZiB0
eXBlIChmb3IgdGVzdGluZykgd2hlbiBub3QgaW4gZG9vciB0ZXN0IG1vZGUKIGlmIG5vdCB0ZXN0
X2Rvb3JfbW9kZSBhbmQga2V5cCgiZCIpIHRoZW4KICBsb2NhbCBjdXJyZW50X2lkeD0xCiAgZm9y
IGk9MSwjcGxhbmV0eXBzIGRvCiAgIGlmIHBsYW5ldHlwc1tpXS50ZXg9PXJvb2YudHlwLnRleCB0
aGVuCiAgICBjdXJyZW50X2lkeD1pCiAgICBicmVhawogICBlbmQKICBlbmQKICByb29mLnR5cD1w
bGFuZXR5cHNbKGN1cnJlbnRfaWR4ICUgI3BsYW5ldHlwcykrMV0KICByb29mLngscm9vZi55PTAs
MAogIC0tIFRlc3QgbW9kZTogY2xlYXIgY2FjaGUgd2hlbiBjeWNsaW5nIHJvb2YgdHlwZXMgKGNh
biBiZSBkaXNhYmxlZCBpbiBwcm9kdWN0aW9uKQogIGlmIGNsZWFyX3RleHR1cmVfY2FjaGVzIHRo
ZW4gY2xlYXJfdGV4dHVyZV9jYWNoZXMoKSBlbmQKIGVuZAogCiAtLSBkZWJ1ZyByYXkgY2FzdGlu
ZwogIGlmIGRlYnVnX21vZGUgdGhlbgogICBsb2NhbCBzYSxjYT1zaW4ocGxheWVyLmEpLGNvcyhw
bGF5ZXIuYSkKICAgbG9jYWwgeixoeCxoeSx0aWxlLHR4PXJheWNhc3QocGxheWVyLngscGxheWVy
LnksY2Esc2Esc2EsY2EpCiAgIHByaW50aCgiZGVidWc6IHo9Ii4uKGZscih6KjEwMCkvMTAwKS4u
IiBoeD0iLi4oZmxyKGh4KjEwMCkvMTAwKS4uIiBoeT0iLi4oZmxyKGh5KjEwMCkvMTAwKS4uIiB0
aWxlPSIuLnRpbGUuLiIgdHg9Ii4uKGZscih0eCoxMDApLzEwMCkpCiAgIGxvY2FsIG9iLGRpc3Q9
aGl0c2NhbihwbGF5ZXIueCxwbGF5ZXIueSxjYSxzYSkKICAgaWYgb2IgdGhlbgogICAgcHJpbnRo
KCJkZWJ1Zzogb2JqIGZvdW5kIGF0IGRpc3Q9Ii4uKGZscihkaXN0KjEwMCkvMTAwKS4uIiBraW5k
PSIuLihvYi5raW5kIG9yICJ1bmtub3duIikpCiAgIGVsc2UKICAgIHByaW50aCgiZGVidWc6IG5v
IG9iaiBoaXQiKQogICBlbmQKICBlbmQKZW5kCgpmdW5jdGlvbiBkcmF3X2dhbWVwbGF5KCkKIGNs
aXAoMCwwLHNjcmVlbl93aWR0aCxzY3JlZW5faGVpZ2h0KQogY2xzKDApCiAKIGxvY2FsIGZyYW1l
X3N0YXJ0PXRpbWUoKQogCiBkaWFnX2ZyYW1lX2NvdW50Kz0xCiAKLS0gcmVzZXQgcGVyLWZyYW1l
IGRpYWdub3N0aWNzCmRpYWdfd2FsbF9jb2x1bW5zPTAKZGlhZ193YWxsX2xvZF9jb2x1bW5zPTAK
ZGlhZ19mbG9vcl9yb3dzPTAKZGlhZ19mbG9vcl9iYXRjaGVzPTAKZGlhZ19zcHJpdGVfY29sdW1u
cz0wCmRpYWdfc3ByaXRlX2ltcG9zdG9yX2NvbHVtbnM9MAoKLS0gRW5zdXJlIGFkYXB0aXZlIGNv
bnRyb2xzIGFyZSBpbml0aWFsaXplZCBvbmNlCmlmIG5vdCBhY3RpdmVfcmF5X2NvdW50IHRoZW4g
YWN0aXZlX3JheV9jb3VudD1yYXlfY291bnQgZW5kCmlmIG5vdCByb3dfc3RyaWRlX2R5bmFtaWMg
dGhlbiByb3dfc3RyaWRlX2R5bmFtaWM9cm93X3N0cmlkZSBlbmQKCmxvY2FsIGZ1bmN0aW9uIGFk
anVzdF9yYXlfYnVkZ2V0KGNwdV9zYW1wbGUpCiBsb2NhbCBtaW5fcmF5cz1tYXgoNDgsIGZscihy
YXlfY291bnQqMC4yNSkpCiBpZiBjcHVfc2FtcGxlPjAuOTAgdGhlbgogIGFjdGl2ZV9yYXlfY291
bnQ9bWF4KG1pbl9yYXlzLCBhY3RpdmVfcmF5X2NvdW50LTE2KQogZWxzZWlmIGNwdV9zYW1wbGU8
MC43MCB0aGVuCiAgYWN0aXZlX3JheV9jb3VudD1taW4ocmF5X2NvdW50LCBhY3RpdmVfcmF5X2Nv
dW50KzgpCiBlbmQKZW5kCgotLSBDb250aW51b3VzIENQVSBzYW1wbGluZyBmb3IgYWRhcHRpdmUg
YnVkZ2V0CmxvY2FsIGNwdV9zYW1wbGUgPSBzdGF0KDEpIG9yIGxhc3RfY3B1X3NhbXBsZSBvciAw
CmlmIG5vdCBwZXJmX3ZhbGlkYXRpb24gYW5kIG5vdCBlbmFibGVfbm9ucmVuZGVyX2dvdmVybm9y
IHRoZW4KIGFkanVzdF9yYXlfYnVkZ2V0KGNwdV9zYW1wbGUpCmVuZAoKLS0gT3B0aW9uYWwgbm9u
LXJlbmRlciBnb3Zlcm5vcjogdXNlcyBDUFUgc2FtcGxlZCBpbiBfdXBkYXRlKCkKaWYgZW5hYmxl
X25vbnJlbmRlcl9nb3Zlcm5vciB0aGVuCiBhZGp1c3RfcmF5X2J1ZGdldChyZWNlbnRfY3B1IG9y
IGNwdV9zYW1wbGUpCmVuZApsYXN0X2NwdV9zYW1wbGU9Y3B1X3NhbXBsZQpkaWFnX2FjdGl2ZV9y
YXlzPWFjdGl2ZV9yYXlfY291bnQKIAogLS0gei1idWZmZXIgaGVscGVycyAodXNlIGZyYW1lLXN0
YW1wLCBkZWZpbmVkIG9uY2UpCiBpZiBub3QgenJlYWQgdGhlbgogIGZ1bmN0aW9uIHpyZWFkKHgp
CiAgIC0tIHggaXMgMC1iYXNlZDsgcmV0dXJuIDk5OSB1bmxlc3Mgc3RhbXBlZCB0aGlzIGZyYW1l
CiAgIGxvY2FsIHN0YW1wPXpzdGFtcDpnZXQoeCkgb3IgMAogICBpZiBzdGFtcD09ZGlhZ19mcmFt
ZV9jb3VudCB0aGVuCiAgICBsb2NhbCB6PXpidWY6Z2V0KHgpCiAgICByZXR1cm4geiBvciA5OTkK
ICAgZW5kCiAgIHJldHVybiA5OTkKICBlbmQKICBmdW5jdGlvbiB6d3JpdGUoeCx6KQogICB6YnVm
OnNldCh4LHopCiAgIHpzdGFtcDpzZXQoeCxkaWFnX2ZyYW1lX2NvdW50KQogIGVuZAogZW5kCiAK
IC0tIGNhY2hlIHNpbi9jb3MgZm9yIGVudGlyZSBmcmFtZSB0byBhdm9pZCByZWNvbXB1dGF0aW9u
CiBzYV9jYWNoZWQ9c2luKHBsYXllci5hKQogY2FfY2FjaGVkPWNvcyhwbGF5ZXIuYSkKIAogaWYg
dmlld19tb2RlPT0iM2QiIHRoZW4KICByYXljYXN0X3NjZW5lKCkKICBsb2NhbCB0X3JheWNhc3Q9
dGltZSgpCiAgcmVuZGVyX2Zsb29yX2NlaWxpbmcoKSAgLS0gTm93IGluY2x1ZGVzIHdhbGwgcmVu
ZGVyaW5nCiAgbG9jYWwgdF9mbG9vcl93YWxscz10aW1lKCkKICByZW5kZXJfc3ByaXRlcygpCiAg
bG9jYWwgdF9zcHJpdGVzPXRpbWUoKQogIAogIGxvY2FsIG1zX3JheWNhc3Q9KHRfcmF5Y2FzdC1m
cmFtZV9zdGFydCkqMTAwMAogIGxvY2FsIG1zX2Zsb29yX3dhbGxzPSh0X2Zsb29yX3dhbGxzLXRf
cmF5Y2FzdCkqMTAwMAogIGxvY2FsIG1zX3Nwcml0ZXM9KHRfc3ByaXRlcy10X2Zsb29yX3dhbGxz
KSoxMDAwCiAgbG9jYWwgZnJhbWVfbXM9KHRfc3ByaXRlcy1mcmFtZV9zdGFydCkqMTAwMAogIAog
IC0tIGh1ZCAobWluaW1hbCkKICBwcmludCgicG9zOiIuLmZscihwbGF5ZXIueCkuLiIsIi4uZmxy
KHBsYXllci55KSwyLDIsNykKICBwcmludCgiYW5nOiIuLihmbHIocGxheWVyLmEqMTAwKS8xMDAp
LDIsMTAsNykKICBwcmludCgiZnBzOiIuLnN0YXQoNyksMiwxOCw3KQogIHByaW50KCJocDoiLi5w
bGF5ZXIuaHAsMiwyNiw3KQogIAogIC0tIGludGVyYWN0aW9uIHByb21wdAogIGlmIGludGVyYWN0
aW9uX2FjdGl2ZSBhbmQgY3VycmVudF9pbnRlcmFjdCB0aGVuCiAgIHByaW50KCJbRV0vWjogaW50
ZXJhY3QiLHNjcmVlbl9jZW50ZXJfeC00MCxzY3JlZW5faGVpZ2h0LTIwLDExKQogIGVuZAogIAog
IC0tIHRyYXAgbWVzc2FnZQogIGlmIHRyYXBfbXNnX3RpbWVyPjAgdGhlbgogICBwcmludCgidHJh
cCBzcHJ1bmchIixzY3JlZW5fY2VudGVyX3gtMzAsc2NyZWVuX2NlbnRlcl95LDgpCiAgZW5kCiAg
CiAtLVtbIERFQlVHIFBBTkVMIFJFTU9WRUQgRk9SIFBST0RVQ1RJT04gUEVSRk9STUFOQ0UKIGlm
IGRlYnVnX21vZGUgdGhlbgogIC0tIHJlbW92ZWQKIGVuZAogXV0KICAKIC0tW1sgUEVSSU9ESUMg
TE9HR0lORyBSRU1PVkVEIEZPUiBQUk9EVUNUSU9OIFBFUkZPUk1BTkNFCiBpZiBlbmFibGVfZGlh
Z25vc3RpY3NfbG9nZ2luZyBhbmQgZGlhZ19mcmFtZV9jb3VudCU2MD09MCB0aGVuCiAgLS0gcmVt
b3ZlZAogZW5kCiBdXQogIAogIC0tIG1pbmltYXAgSFVEIG92ZXJsYXkKICBkcmF3X21pbmltYXBf
aHVkKCkKIGVsc2UKICBkcmF3X21pbmltYXAoKQogZW5kCiAKIC0tIGNvbWJhdCBvdmVybGF5CiBp
ZiBpbl9jb21iYXQgdGhlbgogIHJlY3RmaWxsKDAsc2NyZWVuX2hlaWdodC00MCxzY3JlZW5fd2lk
dGgsc2NyZWVuX2hlaWdodCwwKQogIHByaW50KCJlbnRlcmluZyBjb21iYXQuLi4iLHNjcmVlbl9j
ZW50ZXJfeC00MCxzY3JlZW5fY2VudGVyX3ksOCkKICBwcmludCgiW2VudGVyXSBleGl0ICh0ZW1w
KSIsc2NyZWVuX2NlbnRlcl94LTQwLHNjcmVlbl9jZW50ZXJfeSsxMCw3KQogZW5kCiAKIC0tIHJl
c3RvcmUgcGFsZXR0ZSBmcm9tIGZvZyByZW1hcHBpbmcgKHNpbmdsZSByZXN0b3JlIHBlciBmcmFt
ZSkKIHBhbCgpCiAtLSByZXNldCBmb2cgc3RhdGUgc28gZmlyc3Qgc2V0X2ZvZyBhcHBsaWVzIG1h
cHBpbmcgbmV4dCBmcmFtZQogbGFzdF9mb2dfbGV2ZWw9LTEKIHByZXZfcGFsPXt9CgppZiBkZWJ1
Z19tb2RlIHRoZW4KIGRyYXdfZGlhZ25vc3RpY3NfcGFuZWwoZnJhbWVfbXMsIGNwdV9zYW1wbGUp
CiBlbmQKZW5kCgpmdW5jdGlvbiBkcmF3X2RpYWdub3N0aWNzX3BhbmVsKGZyYW1lX21zLCBjcHVf
c2FtcGxlKQogZnJhbWVfbXMgPSBmcmFtZV9tcyBvciAwCiBjcHVfc2FtcGxlID0gY3B1X3NhbXBs
ZSBvciBsYXN0X2NwdV9zYW1wbGUgb3IgMAogbG9jYWwgY3B1X3BjdD1mbHIoY3B1X3NhbXBsZSox
MDAwKzAuNSkvMTAKIGxvY2FsIGZyYW1lX21zX2ZtdD1mbHIoZnJhbWVfbXMqMTArMC41KS8xMAog
bG9jYWwgcmF5c190ZXh0PShkaWFnX2FjdGl2ZV9yYXlzIG9yIGFjdGl2ZV9yYXlfY291bnQgb3Ig
MCkgLi4gIi8iIC4uIHJheV9jb3VudAogbG9jYWwgd2FsbF90ZXg9ZGlhZ193YWxsX2NvbHVtbnMg
b3IgMAogbG9jYWwgd2FsbF9sb2Q9ZGlhZ193YWxsX2xvZF9jb2x1bW5zIG9yIDAKIGxvY2FsIHdh
bGxfdG90YWw9d2FsbF90ZXgrd2FsbF9sb2QKIGxvY2FsIGxvZF9wY3Q9d2FsbF90b3RhbD4wIGFu
ZCBmbHIoKHdhbGxfbG9kL3dhbGxfdG90YWwpKjEwMCswLjUpIG9yIDAKIGxvY2FsIGxpbmVzPXsK
ICB7dGV4dD0iZGlhZzogbWV0cmljcyIsY29sb3I9MTF9LAogIHt0ZXh0PSJmcmFtZV9tczogIi4u
ZnJhbWVfbXNfZm10LGNvbG9yPTExfSwKICB7dGV4dD0iY3B1JTogIi4uY3B1X3BjdCxjb2xvcj0g
Y3B1X3BjdD45MCBhbmQgOCBvciAoY3B1X3BjdD43MCBhbmQgMTAgb3IgMTEpfSwKICB7dGV4dD0i
cmF5czogIi4ucmF5c190ZXh0LGNvbG9yPTd9LAogIHt0ZXh0PSJyb3dfc3RyaWRlOiAiLi4ocm93
X3N0cmlkZV9keW5hbWljIG9yIHJvd19zdHJpZGUpLGNvbG9yPTd9LAogIHt0ZXh0PSJmbG9vciBy
b3dzOiAiLi4oZGlhZ19mbG9vcl9yb3dzIG9yIDApLGNvbG9yPTd9LAogIHt0ZXh0PSJmbG9vciBk
cmF3czogIi4uKGRpYWdfZmxvb3JfYmF0Y2hlcyBvciAwKSxjb2xvcj03fSwKICB7dGV4dD0id2Fs
bCB0ZXg6ICIuLndhbGxfdGV4LGNvbG9yPTd9LAogIHt0ZXh0PSJ3YWxsIGxvZDogIi4ud2FsbF9s
b2QuLiIgKCIuLmxvZF9wY3QuLiIlKSIsY29sb3I9N30sCiAge3RleHQ9InNwcml0ZSB0ZXg6ICIu
LihkaWFnX3Nwcml0ZV9jb2x1bW5zIG9yIDApLGNvbG9yPTd9LAogIHt0ZXh0PSJzcHJpdGUgbG9k
OiAiLi4oZGlhZ19zcHJpdGVfaW1wb3N0b3JfY29sdW1ucyBvciAwKSxjb2xvcj03fQogfQogbG9j
YWwgbWF4X2xlbj0wCiBmb3IgZW50cnkgaW4gYWxsKGxpbmVzKSBkbwogIGlmICNlbnRyeS50ZXh0
Pm1heF9sZW4gdGhlbiBtYXhfbGVuPSNlbnRyeS50ZXh0IGVuZAogZW5kCiBsb2NhbCBwYW5lbF94
PTQKIGxvY2FsIHBhbmVsX3k9ODAKIGxvY2FsIHBhbmVsX3c9bWF4X2xlbio0KzYKIGxvY2FsIHBh
bmVsX2g9I2xpbmVzKjgrNgogcmVjdGZpbGwocGFuZWxfeC0yLHBhbmVsX3ktMixwYW5lbF94K3Bh
bmVsX3cscGFuZWxfeStwYW5lbF9oLDEpCiByZWN0KHBhbmVsX3gtMyxwYW5lbF95LTMscGFuZWxf
eCtwYW5lbF93KzEscGFuZWxfeStwYW5lbF9oKzEsNykKIGZvciBpPTEsI2xpbmVzIGRvCiAgbG9j
YWwgZW50cnk9bGluZXNbaV0KICBwcmludChlbnRyeS50ZXh0LHBhbmVsX3gscGFuZWxfeSsoaS0x
KSo4LGVudHJ5LmNvbG9yKQogZW5kCmVuZAoKbG9jYWwgZnVuY3Rpb24gZ2VuZXJhdGVfbGFiX2R1
bmdlb24oc3RhdGUsc2VlZCkKIGxvY2FsIHRhcmdldF9zZWVkPXNlZWQgb3IgKDErZmxyKHJuZCg5
OTk5OTkpKSkKIGlmIHRhcmdldF9zZWVkPDEgdGhlbiB0YXJnZXRfc2VlZD0xIGVuZAogc3RhcnRf
cG9zLGdlbl9zdGF0cz1nZW5lcmF0ZV9kdW5nZW9uKHtzZWVkPXRhcmdldF9zZWVkfSkKIHN0YXRl
LnNlZWQ9Z2VuX3N0YXRzLnNlZWQKIHN0YXRlLmdlbl9zdGF0cz1nZW5fc3RhdHMKIHN0YXRlLmhp
c3Rvcnk9Z2VuX3N0YXRzLmhpc3Rvcnkgb3Ige30KIHN0YXRlLmhpc3RvcnlfY3Vyc29yPW1heCgw
LCNzdGF0ZS5oaXN0b3J5LTIwKQogc3RhdGUuaGFybmVzc19yZXN1bHQ9c3RhdGUuaGFybmVzc19y
ZXN1bHQgb3IgbmlsCiB2aWV3X21vZGU9IjJkIgplbmQKCmxvY2FsIGZ1bmN0aW9uIGRyYXdfbGFi
X21hcChzdGF0ZSkKIGxvY2FsIHNjYWxlPTMKIGxvY2FsIG94PTgKIGxvY2FsIG95PTgKIGxvY2Fs
IG1hcF9weD1tYXBfc2l6ZSpzY2FsZQogcmVjdGZpbGwoMCwwLHNjcmVlbl93aWR0aC0xLHNjcmVl
bl9oZWlnaHQtMSwwKQogcmVjdGZpbGwob3gtMixveS0yLG94K21hcF9weCsxLG95K21hcF9weCsx
LDEpCiBmb3IgeD0wLG1hcF9zaXplLTEgZG8KICBmb3IgeT0wLG1hcF9zaXplLTEgZG8KICAgbG9j
YWwgd2FsbD1nZXRfd2FsbCh4LHkpCiAgIGxvY2FsIGZsb29yX3ZhbD1nZXRfZmxvb3IoeCx5KQog
ICBsb2NhbCBjb2xvcgogICBpZiB3YWxsPjAgdGhlbgogICAgY29sb3I9NQogICBlbHNlaWYgZmxv
b3JfdmFsPjAgdGhlbgogICAgY29sb3I9NgogICBlbHNlCiAgICBjb2xvcj0wCiAgIGVuZAogICBy
ZWN0ZmlsbChveCt4KnNjYWxlLG95K3kqc2NhbGUsb3greCpzY2FsZStzY2FsZS0xLG95K3kqc2Nh
bGUrc2NhbGUtMSxjb2xvcikKICBlbmQKIGVuZAogZm9yIG5vZGUgaW4gYWxsKGdlbl9ub2Rlcykg
ZG8KICBsb2NhbCByPW5vZGUucmVjdAogIHJlY3Qob3grclsxXSpzY2FsZSxveStyWzJdKnNjYWxl
LG94K3JbM10qc2NhbGUsb3krcls0XSpzY2FsZSwxMSkKIGVuZAogZm9yIGVkZ2UgaW4gYWxsKGdl
bl9lZGdlcykgZG8KICBsb2NhbCBjPWVkZ2UubG9ja2VkIGFuZCA4IG9yIDEyCiAgbG9jYWwgeDE9
b3grZWRnZS5uMS5taWR4KnNjYWxlCiAgbG9jYWwgeTE9b3krZWRnZS5uMS5taWR5KnNjYWxlCiAg
bG9jYWwgeDI9b3grZWRnZS5uMi5taWR4KnNjYWxlCiAgbG9jYWwgeTI9b3krZWRnZS5uMi5taWR5
KnNjYWxlCiAgbGluZSh4MSx5MSx4Mix5MixjKQogIGlmIGVkZ2UuYjEgdGhlbgogICByZWN0Zmls
bChveCtlZGdlLmIxLngqc2NhbGUsb3krZWRnZS5iMS55KnNjYWxlLG94K2VkZ2UuYjEueCpzY2Fs
ZStzY2FsZS0xLG95K2VkZ2UuYjEueSpzY2FsZStzY2FsZS0xLGMpCiAgZW5kCiAgaWYgZWRnZS5i
MiB0aGVuCiAgIHJlY3RmaWxsKG94K2VkZ2UuYjIueCpzY2FsZSxveStlZGdlLmIyLnkqc2NhbGUs
b3grZWRnZS5iMi54KnNjYWxlK3NjYWxlLTEsb3krZWRnZS5iMi55KnNjYWxlK3NjYWxlLTEsYykK
ICBlbmQKIGVuZAogZm9yIGRvb3IgaW4gYWxsKGRvb3JzKSBkbwogIGxvY2FsIGM9ZG9vci5kdHlw
ZT09ZG9vcl9sb2NrZWQgYW5kIDggb3IgMTAKICByZWN0ZmlsbChveCtkb29yLngqc2NhbGUsb3kr
ZG9vci55KnNjYWxlLG94K2Rvb3IueCpzY2FsZStzY2FsZS0xLG95K2Rvb3IueSpzY2FsZStzY2Fs
ZS0xLGMpCiBlbmQKIGZvciBvYiBpbiBhbGwob2JqZWN0cykgZG8KICBpZiBvYi5wb3MgdGhlbgog
ICBsb2NhbCBjeD1veCtvYi5wb3NbMV0qc2NhbGUKICAgbG9jYWwgY3k9b3krb2IucG9zWzJdKnNj
YWxlCiAgIGxvY2FsIGNvbG9yPTcKICAgaWYgb2IudHlwPT1vYmpfdHlwZXMua2V5IHRoZW4gY29s
b3I9OQogICBlbHNlaWYgb2IudHlwPT1vYmpfdHlwZXMuaG9zdGlsZV9ucGMgdGhlbiBjb2xvcj04
CiAgIGVsc2VpZiBvYi50eXA9PW9ial90eXBlcy5ub25faG9zdGlsZV9ucGMgdGhlbiBjb2xvcj0x
MwogICBlbHNlaWYgb2IudHlwIGFuZCBvYi50eXAua2luZD09ImludGVyYWN0YWJsZSIgdGhlbiBj
b2xvcj0xMgogICBlbmQKICAgY2lyY2ZpbGwoY3gsY3ksMSxjb2xvcikKICBlbmQKIGVuZAogcHJp
bnQoInNlZWQ6Ii4uKHN0YXRlLnNlZWQgb3IgIj8iKSxveCttYXBfcHgrOCxveSw3KQogcHJpbnQo
InJvb21zOiIuLigjZ2VuX25vZGVzIG9yIDApLG94K21hcF9weCs4LG95KzgsNykKIGxvY2FsIGxv
Y2tlZF9jb3VudD0wCiBpZiBnZW5fbG9ja2VkX2VkZ2VzIHRoZW4KICBmb3IgZSBpbiBhbGwoZ2Vu
X2xvY2tlZF9lZGdlcykgZG8KICAgaWYgZS5sb2NrZWQgdGhlbiBsb2NrZWRfY291bnQrPTEgZW5k
CiAgZW5kCiBlbmQKIHByaW50KCJsb2NrZWQgZWRnZXM6Ii4ubG9ja2VkX2NvdW50LG94K21hcF9w
eCs4LG95KzE2LDcpCiBwcmludCgiW3pdIHJhbmRvbSAgW3hdIHJlcGxheSAgW_KGkC-ihpJdIHNl
ZWQgIFtoXSBoYXJuZXNzICBbai9rXSBsb2cgIFttXSBtZW51Iiw4LHNjcmVlbl9oZWlnaHQtMTYs
NykKZW5kCgpsb2NhbCBmdW5jdGlvbiBkcmF3X2xhYl9oaXN0b3J5KHN0YXRlKQogbG9jYWwgaGlz
dG9yeT1zdGF0ZS5oaXN0b3J5IG9yIHt9CiBsb2NhbCBjdXJzb3I9c3RhdGUuaGlzdG9yeV9jdXJz
b3Igb3IgMAogbG9jYWwgbGluZXM9MTUKIGxvY2FsIHN0YXJ0PW1heCgxLCNoaXN0b3J5LWxpbmVz
KzEpCiBjdXJzb3I9bWF4KDAsbWluKGN1cnNvciwjaGlzdG9yeS1saW5lcykpCiBsb2NhbCB5PTI0
CiBwcmludCgiZ2VuZXJhdGlvbiBsb2c6IixzY3JlZW5fd2lkdGgtMTQwLHksMTEpCiB5Kz04CiBm
b3IgaT1jdXJzb3IrMSxtaW4oI2hpc3RvcnksY3Vyc29yK2xpbmVzKSBkbwogIGxvY2FsIGxpbmU9
aGlzdG9yeVtpXQogIGlmIGxpbmUgdGhlbgogICBwcmludChzdHJpbmcuc3ViKGxpbmUsMSwyOCks
c2NyZWVuX3dpZHRoLTE0MCx5LDcpCiAgIHkrPTgKICBlbmQKIGVuZAogc3RhdGUuaGlzdG9yeV9j
dXJzb3I9Y3Vyc29yCiBpZiAjaGlzdG9yeT5saW5lcyB0aGVuCiAgcHJpbnQoImxvZyBzY3JvbGwg
W0ovS10iLHNjcmVlbl93aWR0aC0xNDAsc2NyZWVuX2hlaWdodC0zMiw3KQogZW5kCiBpZiBzdGF0
ZS5oYXJuZXNzX3Jlc3VsdCB0aGVuCiAgbG9jYWwgcmVzPXN0YXRlLmhhcm5lc3NfcmVzdWx0CiAg
bG9jYWwgZmFpbHVyZXM9cmVzLmZhaWx1cmVzIG9yIDAKICBsb2NhbCBjb2xvcj1mYWlsdXJlcz4w
IGFuZCA4IG9yIDExCiAgcHJpbnQoImhhcm5lc3M6ICIuLihyZXMudG90YWwgb3IgMCkuLiIgc2Vl
ZHMiLHNjcmVlbl93aWR0aC0xNDAsc2NyZWVuX2hlaWdodC00OCxjb2xvcikKICBwcmludCgiZmFp
bHVyZXM6ICIuLmZhaWx1cmVzLHNjcmVlbl93aWR0aC0xNDAsc2NyZWVuX2hlaWdodC00MCxjb2xv
cikKIGVuZAplbmQKCnNjZW5lcy5tZW51PXsKIGVudGVyPWZ1bmN0aW9uKHN0YXRlKQogIHN0YXRl
Lm9wdGlvbnM9eyJTdGFydCBHYW1lcGxheSIsIkR1bmdlb24gTGFiIn0KICBzdGF0ZS5pbmRleD1z
dGF0ZS5pbmRleCBvciAxCiAgc3RhdGUubWVzc2FnZT0iIgogZW5kLAogdXBkYXRlPWZ1bmN0aW9u
KHN0YXRlKQogIGxvY2FsIG1vdmVfdXA9YnRucCgyKSBvciBrZXlwKCJ1cCIpIG9yIGtleXAoInci
KQogIGxvY2FsIG1vdmVfZG93bj1idG5wKDMpIG9yIGtleXAoImRvd24iKSBvciBrZXlwKCJzIikK
ICBpZiBtb3ZlX3VwIHRoZW4KICAgc3RhdGUuaW5kZXg9bWF4KDEsc3RhdGUuaW5kZXgtMSkKICBl
bHNlaWYgbW92ZV9kb3duIHRoZW4KICAgc3RhdGUuaW5kZXg9bWluKCNzdGF0ZS5vcHRpb25zLHN0
YXRlLmluZGV4KzEpCiAgZW5kCgogIGxvY2FsIGNvbmZpcm09YnRucCg0KSBvciBidG5wKDUpIG9y
IGtleXAoInoiKSBvciBrZXlwKCJ4Iikgb3Iga2V5cCgiZW50ZXIiKSBvciBrZXlwKCJyZXR1cm4i
KQogIGlmIGNvbmZpcm0gdGhlbgogICBsb2NhbCBjaG9pY2U9c3RhdGUub3B0aW9uc1tzdGF0ZS5p
bmRleF0KICAgaWYgY2hvaWNlPT0iU3RhcnQgR2FtZXBsYXkiIHRoZW4KICAgIHN3aXRjaF9zY2Vu
ZSgiZ2FtZXBsYXkiLHt9KQogICBlbHNlaWYgY2hvaWNlPT0iRHVuZ2VvbiBMYWIiIHRoZW4KICAg
IHN3aXRjaF9zY2VuZSgiZHVuZ2Vvbl9sYWIiLHt9KQogICBlbmQKICBlbmQKIGVuZCwKIGRyYXc9
ZnVuY3Rpb24oc3RhdGUpCiAgY2xzKDApCiAgcHJpbnQoIlJheWNhc3QgRW5naW5lIixzY3JlZW5f
Y2VudGVyX3gtNDgsNDAsMTEpCiAgcHJpbnQoIk1haW4gTWVudSIsc2NyZWVuX2NlbnRlcl94LTMy
LDU2LDcpCiAgZm9yIGlkeCxvcHQgaW4gaXBhaXJzKHN0YXRlLm9wdGlvbnMpIGRvCiAgIGxvY2Fs
IHk9ODArKGlkeC0xKSoxMgogICBsb2NhbCBjb2xvcj0oaWR4PT1zdGF0ZS5pbmRleCkgYW5kIDEw
IG9yIDcKICAgcHJpbnQoKGlkeD09c3RhdGUuaW5kZXggYW5kICI_IiBvciAiICIpLi4iICIuLm9w
dCxzY3JlZW5fY2VudGVyX3gtNDAseSxjb2xvcikKICBlbmQKICBwcmludCgiW1pdIGNvbmZpcm0g
IFtVUC9ET1dOXSBuYXZpZ2F0ZSIsc2NyZWVuX2NlbnRlcl94LTY0LHNjcmVlbl9oZWlnaHQtMzIs
NykKIGVuZAp9CgpzY2VuZXMuZ2FtZXBsYXk9ewogZW50ZXI9ZnVuY3Rpb24oc3RhdGUscGFyYW1z
KQogIGxvY2FsIHNlZWQ9cGFyYW1zIGFuZCBwYXJhbXMuc2VlZAogIHN0YXJ0X3BvcyxnZW5fc3Rh
dHM9Z2VuZXJhdGVfZHVuZ2Vvbih7c2VlZD1zZWVkfSkKICBwbGF5ZXIueD1zdGFydF9wb3MueAog
IHBsYXllci55PXN0YXJ0X3Bvcy55CiAgdmlld19tb2RlPSIzZCIKICBzdGF0ZS5zZWVkPWdlbl9z
dGF0cy5zZWVkCiBlbmQsCiB1cGRhdGU9ZnVuY3Rpb24oc3RhdGUpCiAgaWYga2V5cCgibSIpIHRo
ZW4KICAgc3dpdGNoX3NjZW5lKCJtZW51IikKICAgcmV0dXJuCiAgZW5kCiAgdXBkYXRlX2dhbWVw
bGF5KCkKIGVuZCwKIGRyYXc9ZnVuY3Rpb24oc3RhdGUpCiAgZHJhd19nYW1lcGxheSgpCiAgcHJp
bnQoIltNXSBtZW51IixzY3JlZW5fd2lkdGgtNTYsc2NyZWVuX2hlaWdodC0xMCw3KQogZW5kCn0K
CnNjZW5lcy5kdW5nZW9uX2xhYj17CiBlbnRlcj1mdW5jdGlvbihzdGF0ZSxwYXJhbXMpCiAgc3Rh
dGUuc2VlZD1wYXJhbXMgYW5kIHBhcmFtcy5zZWVkCiAgZ2VuZXJhdGVfbGFiX2R1bmdlb24oc3Rh
dGUsc3RhdGUuc2VlZCkKIGVuZCwKIHVwZGF0ZT1mdW5jdGlvbihzdGF0ZSkKICBpZiBrZXlwKCJt
IikgdGhlbgogICBzd2l0Y2hfc2NlbmUoIm1lbnUiKQogICByZXR1cm4KICBlbmQKICBpZiBrZXlw
KCJ6IikgdGhlbgogICBnZW5lcmF0ZV9sYWJfZHVuZ2VvbihzdGF0ZSxuaWwpCiAgZWxzZWlmIGtl
eXAoIngiKSB0aGVuCiAgIGdlbmVyYXRlX2xhYl9kdW5nZW9uKHN0YXRlLHN0YXRlLnNlZWQpCiAg
ZWxzZWlmIGtleXAoImxlZnQiKSBvciBidG5wKDApIHRoZW4KICAgbG9jYWwgc2VlZD0oc3RhdGUu
c2VlZCBvciAxKS0xCiAgIGlmIHNlZWQ8MSB0aGVuIHNlZWQ9MSBlbmQKICAgZ2VuZXJhdGVfbGFi
X2R1bmdlb24oc3RhdGUsc2VlZCkKICBlbHNlaWYga2V5cCgicmlnaHQiKSBvciBidG5wKDEpIHRo
ZW4KICAgbG9jYWwgc2VlZD0oc3RhdGUuc2VlZCBvciAxKSsxCiAgIGdlbmVyYXRlX2xhYl9kdW5n
ZW9uKHN0YXRlLHNlZWQpCiAgZWxzZWlmIGtleXAoImgiKSB0aGVuCiAgIGxvY2FsIHByZXZpb3Vz
X3NlZWQ9c3RhdGUuc2VlZAogICBzdGF0ZS5oYXJuZXNzX3Jlc3VsdD1kdW5nZW9uX2hhcm5lc3Mu
cnVuKCkKICAgZ2VuZXJhdGVfbGFiX2R1bmdlb24oc3RhdGUscHJldmlvdXNfc2VlZCkKICBlbHNl
aWYga2V5cCgiaiIpIHRoZW4KICAgc3RhdGUuaGlzdG9yeV9jdXJzb3I9bWF4KDAsKHN0YXRlLmhp
c3RvcnlfY3Vyc29yIG9yIDApLTMpCiAgZWxzZWlmIGtleXAoImsiKSB0aGVuCiAgIGxvY2FsIGhp
c3Rvcnk9c3RhdGUuaGlzdG9yeSBvciB7fQogICBzdGF0ZS5oaXN0b3J5X2N1cnNvcj1taW4obWF4
KDAsI2hpc3RvcnktMjApLChzdGF0ZS5oaXN0b3J5X2N1cnNvciBvciAwKSszKQogIGVuZAogZW5k
LAogZHJhdz1mdW5jdGlvbihzdGF0ZSkKICBkcmF3X2xhYl9tYXAoc3RhdGUpCiAgZHJhd19sYWJf
aGlzdG9yeShzdGF0ZSkKIGVuZAp9CgpmdW5jdGlvbiBfdXBkYXRlKCkKIHNjZW5lX3VwZGF0ZSgp
CmVuZAoKZnVuY3Rpb24gX2RyYXcoKQogc2NlbmVfZHJhdygpCmVuZAoKLS0gZHJhdyAyZCBtaW5p
bWFwIGZvciB0ZXN0aW5nCi0tIFB1cnBvc2U6IFJlbmRlciAyRCB0b3AtZG93biBkZWJ1ZyB2aWV3
IG9mIGR1bmdlb24KLS0gQWxnb3JpdGhtOiBTY2FsZSAxMjjDlzEyOCBtYXAgdG8gMjU2w5cyNTYg
cGl4ZWxzIChzY2FsZT0yKQotLSBEaXNwbGF5czogV2FsbHMsIHJvb21zLCBkb29ycywgb2JqZWN0
cywgcGxheWVyIHBvc2l0aW9uIGFuZCBmYWNpbmcKLS0gTm90ZXM6IFRvZ2dsZWQgd2l0aCBYIGJ1
dHRvbiwgdXNlZnVsIGZvciBkZWJ1Z2dpbmcgZ2VuZXJhdGlvbgpmdW5jdGlvbiBkcmF3X21pbmlt
YXAoKQogbG9jYWwgc2NhbGU9MgogbG9jYWwgb3gsb3k9MTAsMTAKIAogLS0gYmF0Y2ggYWxsIHRp
bGUgZHJhd2luZyB0byByZWR1Y2UgZHJhdyBjYWxsIGNvdW50CiByYmF0Y2hfcmVzZXQoKQogCiAt
LSBkcmF3IHdhbGxzIGZyb20gbWFwLndhbGxzIHVzZXJkYXRhIHdpdGggZmxvb3IgZGF0YSB0byBk
aXN0aW5ndWlzaCBjb3JyaWRvcnMgZnJvbSB2b2lkCiBmb3IgeD0wLDEyNyBkbwogIGZvciB5PTAs
MTI3IGRvCiAgIGxvY2FsIHdhbGw9Z2V0X3dhbGwoeCx5KQogICBsb2NhbCBmbG9vcl92YWw9Z2V0
X2Zsb29yKHgseSkKICAgbG9jYWwgY29sb3IKICAgaWYgd2FsbD4wIHRoZW4KICAgIC0tIHdhbGwg
dGlsZQogICAgY29sb3I9NQogICBlbHNlaWYgZmxvb3JfdmFsPjAgdGhlbgogICAgLS0gY2FydmVk
IGNvcnJpZG9yL3Jvb20gZmxvb3IgKGZsb29yIHR5cGUgc2V0IGR1cmluZyBnZW5lcmF0aW9uKQog
ICAgY29sb3I9NgogICBlbHNlCiAgICAtLSB1bmNhcnZlZCB2b2lkICh3YWxsPTAsIGZsb29yPTAp
CiAgICBjb2xvcj0xCiAgIGVuZAogICByYmF0Y2hfcHVzaChveCt4KnNjYWxlLG95K3kqc2NhbGUs
b3greCpzY2FsZStzY2FsZS0xLG95K3kqc2NhbGUrc2NhbGUtMSxjb2xvcikKICBlbmQKIGVuZAog
CiByYmF0Y2hfc3VibWl0KCkKIAogLS0gZHJhdyByb29tcwogZm9yIG5vZGUgaW4gYWxsKGdlbl9u
b2RlcykgZG8KICBsb2NhbCByPW5vZGUucmVjdAogIHJlY3Qob3grclsxXSpzY2FsZSxveStyWzJd
KnNjYWxlLG94K3JbM10qc2NhbGUsb3krcls0XSpzY2FsZSwxMSkKIGVuZAogCiAtLSBiYXRjaCBk
b29yIGRyYXdpbmcKIHJiYXRjaF9yZXNldCgpCiBmb3IgZG9vciBpbiBhbGwoZG9vcnMpIGRvCiAg
bG9jYWwgYz1kb29yLmR0eXBlPT1kb29yX2xvY2tlZCBhbmQgOCBvciAxMgogIHJiYXRjaF9wdXNo
KG94K2Rvb3IueCpzY2FsZSxveStkb29yLnkqc2NhbGUsb3grZG9vci54KnNjYWxlK3NjYWxlLTEs
b3krZG9vci55KnNjYWxlK3NjYWxlLTEsYykKIGVuZAogcmJhdGNoX3N1Ym1pdCgpCiAKIC0tIGRy
YXcgb2JqZWN0cwogZm9yIG9iIGluIGFsbChvYmplY3RzKSBkbwogIGxvY2FsIGM9NwogIGlmIG9i
LnR5cCBhbmQgb2IudHlwLmtpbmQ9PSJob3N0aWxlX25wYyIgdGhlbiBjPTgKICBlbHNlaWYgb2Iu
dHlwIGFuZCBvYi50eXAua2luZD09ImRpcmVjdF9waWNrdXAiIHRoZW4KICAgaWYgb2IudHlwLnN1
YnR5cGU9PSJoZWFydCIgdGhlbiBjPTE0CiAgIGVsc2VpZiBvYi50eXAuc3VidHlwZT09ImtleSIg
dGhlbiBjPTkKICAgZW5kCiAgZWxzZWlmIG9iLnR5cCBhbmQgb2IudHlwLmtpbmQ9PSJpbnRlcmFj
dGFibGUiIHRoZW4KICAgaWYgb2IudHlwLnN1YnR5cGU9PSJleGl0IiB0aGVuIGM9MTIgZW5kCiAg
ZWxzZWlmIG9iLnR5cCBhbmQgb2IudHlwLmtpbmQ9PSJkZWNvcmF0aXZlIiB0aGVuIGM9MTMKICBl
bmQKICBsb2NhbCB4PW9iLnBvc1sxXQogIGxvY2FsIHk9b2IucG9zWzJdCiAgY2lyY2ZpbGwob3gr
eCpzY2FsZSxveSt5KnNjYWxlLDEsYykKIGVuZAogCiAtLSBkcmF3IHBsYXllcgogbG9jYWwgcHgs
cHk9b3grcGxheWVyLngqc2NhbGUsb3krcGxheWVyLnkqc2NhbGUKIGNpcmNmaWxsKHB4LHB5LDIs
MTApCiBsb2NhbCBzYSxjYT1zaW4ocGxheWVyLmEpLGNvcyhwbGF5ZXIuYSkKIGxpbmUocHgscHks
cHgrY2EqNixweStzYSo2LDEwKQogCiAtLSBzdGF0cwogcHJpbnQoIjJkIG1hcCB2aWV3IiwxMCwy
LDcpCiBwcmludCgicm9vbXM6ICIuLmdlbl9zdGF0cy5yb29tcywxMCwxMCw3KQogcHJpbnQoIm9i
amVjdHM6ICIuLmdlbl9zdGF0cy5vYmplY3RzLDEwLDE4LDcpCiBwcmludCgic2VlZDogIi4uZ2Vu
X3N0YXRzLnNlZWQsMTAsMjYsNykKIGlmIGRlYnVnX21vZGUgdGhlbgogIHByaW50KCJbeF0gdG9n
Z2xlIDNkIiwxMCwzNCw3KQogZW5kCmVuZAoKLS0gZHJhdyBodWQgbWluaW1hcCBvdmVybGF5Ci0t
IFB1cnBvc2U6IFJlbmRlciBzY3JvbGxpbmcgdmlld3BvcnQgbWluaW1hcCBpbiB0b3AtcmlnaHQg
Y29ybmVyIGR1cmluZyAzRCB2aWV3Ci0tIEFsZ29yaXRobTogUGxheWVyLWNlbnRlcmVkIGNhbWVy
YSB3aXRoIGNsaXBwZWQgZHJhd2luZyBvZiB2aXNpYmxlIHRpbGVzIG9ubHkKLS0gRGlzcGxheXM6
IFdhbGxzLCBmbG9vcnMsIGRvb3JzLCBvYmplY3RzLCBwbGF5ZXIgKGF1dG8tc2Nyb2xscyBhcyBw
bGF5ZXIgbW92ZXMpCi0tIE5vdGVzOiBGaXhlZCAxMjDDlzY4cHggdmlld3BvcnQgYXQgdG9wLXJp
Z2h0LCBzY2FsZT0yLCBvbmx5IGRyYXdzIHZpc2libGUgdGlsZSByYW5nZQpmdW5jdGlvbiBkcmF3
X21pbmltYXBfaHVkKCkKIGxvY2FsIGh1ZF93PWNlaWwoc2NyZWVuX3dpZHRoKjAuMjUpCiBsb2Nh
bCBodWRfaD1jZWlsKHNjcmVlbl9oZWlnaHQqMC4yNSkKIGxvY2FsIGh1ZF94PXNjcmVlbl93aWR0
aC1odWRfdy04CiBsb2NhbCBodWRfeT04CiBsb2NhbCBzY2FsZT0yCiAKIC0tIGNhbWVyYSBvZmZz
ZXQgdG8gY2VudGVyIHBsYXllciBpbiB2aWV3cG9ydAogbG9jYWwgY2FtX3g9cGxheWVyLngqc2Nh
bGUtaHVkX3cvMgogbG9jYWwgY2FtX3k9cGxheWVyLnkqc2NhbGUtaHVkX2gvMgogCiAtLSBjYWxj
dWxhdGUgdmlzaWJsZSB0aWxlIHJhbmdlCiBsb2NhbCB4X21pbj1tYXgoMCxmbHIoY2FtX3gvc2Nh
bGUpKQogbG9jYWwgeF9tYXg9bWluKDEyNyxmbHIoKGNhbV94K2h1ZF93KS9zY2FsZSkpCiBsb2Nh
bCB5X21pbj1tYXgoMCxmbHIoY2FtX3kvc2NhbGUpKQogbG9jYWwgeV9tYXg9bWluKDEyNyxmbHIo
KGNhbV95K2h1ZF9oKS9zY2FsZSkpCiAKIC0tIHNldCBjbGlwIHJlZ2lvbgogY2xpcChodWRfeCxo
dWRfeSxodWRfdyxodWRfaCkKIAogLS0gZHJhdyBiYWNrZ3JvdW5kCiByZWN0ZmlsbChodWRfeCxo
dWRfeSxodWRfeCtodWRfdy0xLGh1ZF95K2h1ZF9oLTEsMCkKIAogLS0gYmF0Y2ggbWFwIHRpbGVz
IChvbmx5IHZpc2libGUgcmFuZ2UpCiByYmF0Y2hfcmVzZXQoKQogZm9yIHg9eF9taW4seF9tYXgg
ZG8KICBmb3IgeT15X21pbix5X21heCBkbwogICBsb2NhbCBzeD1odWRfeCsoeCpzY2FsZS1jYW1f
eCkKICAgbG9jYWwgc3k9aHVkX3krKHkqc2NhbGUtY2FtX3kpCiAgIAogICAtLSBhZGRpdGlvbmFs
IGJvdW5kcyBjaGVjawogICBpZiBzeD49aHVkX3ggYW5kIHN4PGh1ZF94K2h1ZF93IGFuZCBzeT49
aHVkX3kgYW5kIHN5PGh1ZF95K2h1ZF9oIHRoZW4KICAgIGxvY2FsIHdhbGw9Z2V0X3dhbGwoeCx5
KQogICAgbG9jYWwgZmxvb3JfdmFsPWdldF9mbG9vcih4LHkpCiAgICBsb2NhbCBjb2xvcgogICAg
CiAgICBpZiB3YWxsPjAgdGhlbgogICAgIGNvbG9yPTUKICAgIGVsc2VpZiBmbG9vcl92YWw_MCB0
aGVuCiAgICAgY29sb3I9NgogICAgZWxzZQogICAgIGNvbG9yPTEKICAgIGVuZAogICAgCiAgICBy
YmF0Y2hfcHVzaChzeCxzeSxzeCtzY2FsZS0xLHN5K3NjYWxlLTEsY29sb3IpCiAgIGVuZAogIGVu
ZAogZW5kCiByYmF0Y2hfc3VibWl0KCkKIAogLS0gYmF0Y2ggZG9vciBkcmF3aW5nIHZpYSBzcGF0
aWFsIHF1ZXJ5IG92ZXIgdmlzaWJsZSB0aWxlcwogcmJhdGNoX3Jlc2V0KCkKIGZvciB4PXhfbWlu
LHhfbWF4IGRvCiAgZm9yIHk9eV9taW4seV9tYXggZG8KICAgbG9jYWwgZG9vcj1kb29yZ3JpZFt4
XSBhbmQgZG9vcmdyaWRbeF1beV0gb3IgbmlsCiAgIGlmIGRvb3IgdGhlbgogICAgbG9jYWwgc3g9
aHVkX3grKHgqc2NhbGUtY2FtX3gpCiAgICBsb2NhbCBzeT1odWRfeSsoeSpzY2FsZS1jYW1feSkK
ICAgIGlmIHN4Pj1odWRfeCBhbmQgc3g8aHVkX3graHVkX3cgYW5kIHN5Pj1odWRfeSBhbmQgc3k8
aHVkX3kraHVkX2ggdGhlbgogICAgIGxvY2FsIGM9ZG9vci5kdHlwZT09ZG9vcl9sb2NrZWQgYW5k
IDggb3IgMTIKICAgICByYmF0Y2hfcHVzaChzeCxzeSxzeCtzY2FsZS0xLHN5K3NjYWxlLTEsYykK
ICAgIGVuZAogICBlbmQKICBlbmQKIGVuZAogcmJhdGNoX3N1Ym1pdCgpCiAKIC0tIGRyYXcgb2Jq
ZWN0cyB2aWEgZmxhdCBhcnJheSBpdGVyYXRpb24gd2l0aGluIHZpZXdwb3J0IGJvdW5kcwogZm9y
IG9iIGluIGFsbChvYmplY3RzKSBkbwogIGlmIG9iLnBvcyB0aGVuCiAgIGxvY2FsIHN4PWh1ZF94
KyhvYi5wb3NbMV0qc2NhbGUtY2FtX3gpCiAgIGxvY2FsIHN5PWh1ZF95KyhvYi5wb3NbMl0qc2Nh
bGUtY2FtX3kpCiAgIGlmIHN4Pj1odWRfeCBhbmQgc3g8aHVkX3graHVkX3cgYW5kIHN5Pj1odWRf
eSBhbmQgc3k8aHVkX3kraHVkX2ggdGhlbgogICAgbG9jYWwgYz03CiAgICBpZiBvYi50eXAgYW5k
IG9iLnR5cC5raW5kPT0iaG9zdGlsZV9ucGMiIHRoZW4gYz04CiAgICBlbHNlaWYgb2IudHlwIGFu
ZCBvYi50eXAua2luZD09ImRpcmVjdF9waWNrdXAiIHRoZW4KICAgICBpZiBvYi50eXAuc3VidHlw
ZT09ImhlYXJ0IiB0aGVuIGM9MTQKICAgICBlbHNlaWYgb2IudHlwLnN1YnR5cGU9PSJrZXkiIHRo
ZW4gYz05CiAgICAgZW5kCiAgICBlbHNlaWYgb2IudHlwIGFuZCBvYi50eXAua2luZD09ImludGVy
YWN0YWJsZSIgdGhlbgogICAgIGlmIG9iLnR5cC5zdWJ0eXBlPT0iZXhpdCIgdGhlbiBjPTEyIGVu
ZAogICAgZWxzZWlmIG9iLnR5cCBhbmQgb2IudHlwLmtpbmQ9PSJkZWNvcmF0aXZlIiB0aGVuIGM9
MTMKICAgIGVuZAogICAgY2lyY2ZpbGwoc3gsc3ksMSxjKQogICBlbmQKICBlbmQKIGVuZAogCiAt
LSBkcmF3IHBsYXllciAoYWx3YXlzIGNlbnRlcmVkIGJ5IGNhbWVyYSBkZXNpZ24pCiBsb2NhbCBw
eD1odWRfeCsocGxheWVyLngqc2NhbGUtY2FtX3gpCiBsb2NhbCBweT1odWRfeSsocGxheWVyLnkq
c2NhbGUtY2FtX3kpCiBjaXJjZmlsbChweCxweSwyLDEwKQogbGluZShweCxweSxweCtjYV9jYWNo
ZWQqNixweStzYV9jYWNoZWQqNiwxMCkKIAogLS0gb3B0aW9uYWwgZnJhbWUKIHJlY3QoaHVkX3gs
aHVkX3ksaHVkX3graHVkX3ctMSxodWRfeStodWRfaC0xLDcpCiAKIC0tIHJlc2V0IGNsaXAKIGNs
aXAoKQplbmQKCi0tIHVuaWZpZWQgY29sbGlzaW9uIGNoZWNrIGZvciB3YWxscywgZG9vcnMsIGFu
ZCBvYmplY3RzCi0tIFB1cnBvc2U6IFVuaWZpZWQgY29sbGlzaW9uIGRldGVjdGlvbiBmb3Igd2Fs
bHMsIGRvb3JzLCBhbmQgb2JqZWN0cwotLSBQYXJhbWV0ZXJzOiBweCwgcHkgKHdvcmxkIHBvc2l0
aW9uKSwgcmFkaXVzIChjb2xsaXNpb24gcmFkaXVzKSwgb3BlbmRvb3JzIChhdXRvLW9wZW4gZG9v
cnMpLCBpc3BsYXllciAoZW5hYmxlIGtleSBjaGVja2luZykKLS0gUmV0dXJuczogYm9vbGVhbiAo
dHJ1ZSBpZiBjb2xsaXNpb24gZGV0ZWN0ZWQpCi0tIEFsZ29yaXRobTogR3JpZC1iYXNlZCB3YWxs
IGNoZWNrICsgc3BhdGlhbCBwYXJ0aXRpb25pbmcgZm9yIG9iamVjdHMKLS0gU2lkZSBlZmZlY3Rz
OiBPcGVucyBkb29ycywgcHJldmVudHMgZG9vciBjbG9zaW5nIHdoZW4gcGxheWVyIGluc2lkZQpm
dW5jdGlvbiBpc2NvbChweCxweSxyYWRpdXMsb3BlbmRvb3JzLGlzcGxheWVyKQogbG9jYWwgY29s
PWZhbHNlCiBvcGVuZG9vcnM9b3BlbmRvb3JzIG9yIGZhbHNlCiBpc3BsYXllcj1pc3BsYXllciBv
ciBmYWxzZQogCiAtLSBjaGVjayBncmlkIGNlbGxzIGFyb3VuZCBwb3NpdGlvbgogZm9yIHg9Zmxy
KHB4LXJhZGl1cyksZmxyKHB4K3JhZGl1cykgZG8KICBmb3IgeT1mbHIocHktcmFkaXVzKSxmbHIo
cHkrcmFkaXVzKSBkbwogICAtLSBib3VuZHMgY2hlY2sKICAgaWYgeDwwIG9yIHg_PTEyOCBvciB5
PDAgb3IgeT49MTI4IHRoZW4KICAgIGNvbD10cnVlCiAgICBicmVhawogICBlbHNlCiAgICBsb2Nh
bCB0aWxlPWdldF93YWxsKHgseSkKICAgIAogICAgLS0gY2hlY2sgaWYgZG9vciB0aWxlCiAgICBp
ZiB0aWxlPT1kb29yX25vcm1hbCBvciB0aWxlPT1kb29yX2xvY2tlZCBvciB0aWxlPT1kb29yX3N0
YXlfb3BlbiB0aGVuCiAgICAgbG9jYWwgZG9vcj1kb29yZ3JpZFt4XVt5XQogICAgIGlmIGRvb3Ig
dGhlbgogICAgICBpZiBkb29yLm9wZW49PTEgdGhlbgogICAgICAgLS0gZnVsbHkgb3BlbjogcHJl
dmVudCBjbG9zaW5nCiAgICAgICBkb29yLm9wZW5pbmc9dHJ1ZQogICAgICBlbHNlCiAgICAgICAt
LSBkb29yIHBhcnRpYWxseSBvcGVuIG9yIGNsb3NlZDogY29sbGlzaW9uIGRldGVjdGVkCiAgICAg
ICBjb2w9dHJ1ZQogICAgICAgLS0gaGFuZGxlIHVubG9ja2luZy9vcGVuaW5nIGJlZm9yZSBleGl0
aW5nIGlubmVyIGxvb3AKICAgICAgIGlmIG9wZW5kb29ycyB0aGVuCiAgICAgICAgaWYgZG9vci5r
ZXludW0gdGhlbgogICAgICAgICAtLSBjaGVjayBpbnZlbnRvcnkgZm9yIGtleQogICAgICAgICBp
ZiBpc3BsYXllciB0aGVuCiAgICAgICAgICBmb3IgaSxpdGVtIGluIGlwYWlycyhwbGF5ZXIua2V5
cykgZG8KICAgICAgICAgICBpZiBpdGVtLmtleW51bT09ZG9vci5rZXludW0gdGhlbgogICAgICAg
ICAgICAtLSByZW1vdmUga2V5CiAgICAgICAgICAgIGRlbGkocGxheWVyLmtleXMsaSkKICAgICAg
ICAgICAgZG9vci5rZXludW09bmlsCiAgICAgICAgICAgIGRvb3Iub3BlbmluZz10cnVlCiAgICAg
ICAgICAgIC0tIGtlZXAgY29sPXRydWUsIGRvbid0IGNsZWFyIGltbWVkaWF0ZWx5CiAgICAgICAg
ICAgIGJyZWFrCiAgICAgICAgICAgZW5kCiAgICAgICAgICBlbmQKICAgICAgICAgZW5kCiAgICAg
ICAgZWxzZQogICAgICAgICAtLSB1bmxvY2tlZAogICAgICAgICBkb29yLm9wZW5pbmc9dHJ1ZQog
ICAgICAgICAtLSBrZWVwIGNvbD10cnVlLCBkb24ndCBjbGVhciBpbW1lZGlhdGVseQogICAgICAg
IGVuZAogICAgICAgZW5kCiAgICAgICAtLSBlYXJseSBleGl0IGZyb20gaW5uZXIgbG9vcCBvbiBj
b2xsaXNpb24gKGFmdGVyIG9wZW5kb29ycyBoYW5kbGluZykKICAgICAgIGJyZWFrCiAgICAgIGVu
ZAogICAgIGVuZAogICAgLS0gY2hlY2sgaWYgZXhpdCBwb3J0YWwKICAgIGVsc2VpZiAodGlsZT09
ZXhpdF9zdGFydCBvciB0aWxlPT1leGl0X2VuZCkgYW5kIGlzcGxheWVyIHRoZW4KICAgICAtLSBw
bGFjZWhvbGRlciBmb3IgbGV2ZWwgY29tcGxldGlvbgogICAgLS0gY2hlY2sgaWYgd2FsbAogICAg
ZWxzZWlmIHRpbGU_MCB0aGVuCiAgICAgY29sPXRydWUKICAgICBicmVhawogICAgZW5kCiAgIGVu
ZAogIGVuZAogIGlmIGNvbCB0aGVuIGJyZWFrIGVuZAogZW5kCiAKIC0tIGNoZWNrIHNvbGlkIG9i
amVjdHMgYXJvdW5kIHBvc2l0aW9uIHZpYSBmbGF0IGFycmF5IHdpdGggZWFybHkgZGlzdGFuY2Ug
Y3VsbAogZm9yIG9iIGluIGFsbChvYmplY3RzKSBkbwogIGlmIG9iLnR5cCBhbmQgb2IudHlwLnNv
bGlkIGFuZCBvYi5wb3MgdGhlbgogICBsb2NhbCBveD1vYi5wb3NbMV0tcHgKICAgbG9jYWwgb3k9
b2IucG9zWzJdLXB5CiAgIC0tIGVhcmx5IGF4aXMtYWxpZ25lZCBjdWxsCiAgIGlmIGFicyhveCk8
KHJhZGl1cysob2IudHlwLncgb3IgMCkpIGFuZCBhYnMob3kpPChyYWRpdXMrKG9iLnR5cC53IG9y
IDApKSB0aGVuCiAgICBpZiBtYXgoYWJzKG94KSxhYnMob3kpKTwob2IudHlwLncgb3IgMCkgdGhl
bgogICAgIGNvbD10cnVlCiAgICAgLS0gdHJpZ2dlciBpbnRlcmFjdGlvbiBvbiBzb2xpZCBjb250
YWN0IGlmIHBsYXllcgogICAgIGlmIGlzcGxheWVyIHRoZW4KICAgICAgY2hlY2tfaW50ZXJhY3Rp
b25zX2F0KHB4LHB5KQogICAgIGVuZAogICAgIGJyZWFrCiAgICBlbmQKICAgZW5kCiAgZW5kCiBl
bmQKIAogcmV0dXJuIGNvbAplbmQKCi0tIG1vdmVtZW50IHdyYXBwZXIgd2l0aCBzbGlkaW5nIGNv
bGxpc2lvbgotLSBQdXJwb3NlOiBNb3ZlbWVudCB3aXRoIHNsaWRpbmcgY29sbGlzaW9uICh0cnkg
ZGlhZ29uYWwsIHRoZW4gWCwgdGhlbiBZKQotLSBQYXJhbWV0ZXJzOiBwb3MgKHRhYmxlIHdpdGgg
eCx5KSwgdGFyZ2V0X3gsIHRhcmdldF95LCByYWRpdXMsIG9wZW5kb29ycywgaXNwbGF5ZXIKLS0g
UmV0dXJuczogYm9vbGVhbiAodHJ1ZSBpZiBhbnkgbW92ZW1lbnQgc3VjY2VlZGVkKQotLSBBbGdv
cml0aG06IFRocmVlLXBoYXNlIGNvbGxpc2lvbiBjaGVjayBmb3Igc21vb3RoIHdhbGwgc2xpZGlu
ZwpmdW5jdGlvbiB0cnltb3ZldG8ocG9zLHRhcmdldF94LHRhcmdldF95LHJhZGl1cyxvcGVuZG9v
cnMsaXNwbGF5ZXIpCiByYWRpdXM9cmFkaXVzIG9yIHBsYXllcl9jb2xsaXNpb25fcmFkaXVzCiBv
cGVuZG9vcnM9b3BlbmRvb3JzIG9yIGZhbHNlCiBpc3BsYXllcj1pc3BsYXllciBvciBmYWxzZQog
CiAtLSB0cnkgZGlyZWN0IG1vdmVtZW50CiBpZiBub3QgcmFkaXVzIG9yIG5vdCBpc2NvbCh0YXJn
ZXRfeCx0YXJnZXRfeSxyYWRpdXMsb3BlbmRvb3JzLGlzcGxheWVyKSB0aGVuCiAgcG9zLngscG9z
Lnk9dGFyZ2V0X3gsdGFyZ2V0X3kKICByZXR1cm4gdHJ1ZQogZW5kCiAKIC0tIHRyeSB4LW9ubHkg
bW92ZW1lbnQKIGlmIGFicyhwb3MueC10YXJnZXRfeCk_MC4wMSBhbmQgbm90IGlzY29sKHRhcmdl
dF94LHBvcy55LHJhZGl1cyxvcGVuZG9vcnMsaXNwbGF5ZXIpIHRoZW4KICBwb3MueD10YXJnZXRf
eAogIHJldHVybiB0cnVlCiBlbmQKIAogLS0gdHJ5IHktb25seSBtb3ZlbWVudAogaWYgYWJzKHBv
cy55LXRhcmdldF95KT4wLjAxIGFuZCBub3QgaXNjb2wocG9zLngsdGFyZ2V0X3kscmFkaXVzLG9w
ZW5kb29ycyxpc3BsYXllcikgdGhlbgogIHBvcy55PXRhcmdldF95CiAgcmV0dXJuIHRydWUKIGVu
ZAogCiByZXR1cm4gZmFsc2UKZW5kCgotLSBtb3ZlbWVudCB3cmFwcGVyIGZvciBwb3NbMV0vcG9z
WzJdIGFycmF5IHBvc2l0aW9ucwpmdW5jdGlvbiB0cnltb3ZldG9fcG9zKHBvc19hcnJheSx0YXJn
ZXRfeCx0YXJnZXRfeSxyYWRpdXMsb3BlbmRvb3JzLGlzcGxheWVyKQogcmFkaXVzPXJhZGl1cyBv
ciBwbGF5ZXJfY29sbGlzaW9uX3JhZGl1cwogb3BlbmRvb3JzPW9wZW5kb29ycyBvciBmYWxzZQog
aXNwbGF5ZXI9aXNwbGF5ZXIgb3IgZmFsc2UKIAogLS0gdHJ5IGRpcmVjdCBtb3ZlbWVudAogaWYg
bm90IHJhZGl1cyBvciBub3QgaXNjb2wodGFyZ2V0X3gsdGFyZ2V0X3kscmFkaXVzLG9wZW5kb29y
cyxpc3BsYXllcikgdGhlbgogIHBvc19hcnJheVsxXSxwb3NfYXJyYXlbMl09dGFyZ2V0X3gsdGFy
Z2V0X3kKICByZXR1cm4gdHJ1ZQogZW5kCiAKIC0tIHRyeSB4LW9ubHkgbW92ZW1lbnQKIGlmIGFi
cyhwb3NfYXJyYXlbMV0tdGFyZ2V0X3gpPjAuMDEgYW5kIG5vdCBpc2NvbCh0YXJnZXRfeCxwb3Nf
YXJyYXlbMl0scmFkaXVzLG9wZW5kb29ycyxpc3BsYXllcikgdGhlbgogIHBvc19hcnJheVsxXT10
YXJnZXRfeAogIHJldHVybiB0cnVlCiBlbmQKIAogLS0gdHJ5IHktb25seSBtb3ZlbWVudAogaWYg
YWJzKHBvc19hcnJheVsyXS10YXJnZXRfeSk_MC4wMSBhbmQgbm90IGlzY29sKHBvc19hcnJheVsx
XSx0YXJnZXRfeSxyYWRpdXMsb3BlbmRvb3JzLGlzcGxheWVyKSB0aGVuCiAgcG9zX2FycmF5WzJd
PXRhcmdldF95CiAgcmV0dXJuIHRydWUKIGVuZAogCiByZXR1cm4gZmFsc2UKZW5kCgpmdW5jdGlv
biB1cGRhdGVfaW5wdXQoKQogbG9jYWwgc2EsY2E9c2luKHBsYXllci5hKSxjb3MocGxheWVyLmEp
CiAKIC0tIG1vdmVtZW50CiAtLSBjb21iaW5lIGtleXMgdG8gYXZvaWQgZG91YmxlLXByb2Nlc3Np
bmcgYW5kIGZpeCBkaXJlY3Rpb246CiAtLSBwb3NpdGl2ZSB0dXJuID0gbGVmdCwgbmVnYXRpdmUg
dHVybiA9IHJpZ2h0CiBsb2NhbCB0dXJuPShidG4oMCkgYW5kIDEgb3IgMCktKGJ0bigxKSBhbmQg
MSBvciAwKQogaWYgdHVybn49MCB0aGVuCiAgcGxheWVyLmErPXR1cm4qcGxheWVyX3JvdGF0aW9u
X3NwZWVkCiBlbmQKIGlmIGJ0bigyKSB0aGVuIC0tIHVwCiAgbG9jYWwgbng9cGxheWVyLngrY2Eq
cGxheWVyLnNwZAogIGxvY2FsIG55PXBsYXllci55K3NhKnBsYXllci5zcGQKICB0cnltb3ZldG8o
cGxheWVyLG54LG55LHBsYXllcl9jb2xsaXNpb25fcmFkaXVzLHRydWUsdHJ1ZSkKIGVuZAogaWYg
YnRuKDMpIHRoZW4gLS0gZG93bgogIGxvY2FsIG54PXBsYXllci54LWNhKnBsYXllci5zcGQKICBs
b2NhbCBueT1wbGF5ZXIueS1zYSpwbGF5ZXIuc3BkCiAgdHJ5bW92ZXRvKHBsYXllcixueCxueSxw
bGF5ZXJfY29sbGlzaW9uX3JhZGl1cyx0cnVlLHRydWUpCiBlbmQKIAogLS0gY2hlY2sgZm9yIGlu
dGVyYWN0aW9ucyBldmVyeSBmcmFtZQogY2hlY2tfaW50ZXJhY3Rpb25zKCkKIAogLS0gaW50ZXJh
Y3Rpb24gaW5wdXQ6IEUga2V5IG9yIFogYnV0dG9uCiBpZiBrZXlwKCJlIikgb3IgYnRucCg0KSB0
aGVuCiAgaGFuZGxlX2ludGVyYWN0KCkKIGVuZAplbmQKCiAKCi0tIGNoZWNrIGludGVyYWN0aW9u
cyBhcm91bmQgcGxheWVyIHBvc2l0aW9uCi0tIFB1cnBvc2U6IFNjYW4gbmVhcmJ5IG9iamVjdHMg
Zm9yIHByb3hpbWl0eS1iYXNlZCBpbnRlcmFjdGlvbnMKLS0gQWxnb3JpdGhtOiAzw5czIG9iamdy
aWQgY2VsbCBzY2FuIGFyb3VuZCBwbGF5ZXIKLS0gU2lkZSBlZmZlY3RzOiBBdXRvLWNvbGxlY3Rz
IHBpY2t1cHMsIHRyaWdnZXJzIGNvbWJhdCwgc2V0cyBpbnRlcmFjdGlvbiBmbGFncwotLSBOb3Rl
czogQ2FsbGVkIGV2ZXJ5IGZyYW1lIGluIF91cGRhdGUoKQpmdW5jdGlvbiBjaGVja19pbnRlcmFj
dGlvbnMoKQogY2hlY2tfaW50ZXJhY3Rpb25zX2F0KHBsYXllci54LHBsYXllci55KQplbmQKCi0t
IGNoZWNrIGludGVyYWN0aW9ucyBhdCBzcGVjaWZpYyBwb3NpdGlvbiAoYXZvaWRzIHJlY3Vyc2lv
bikKZnVuY3Rpb24gY2hlY2tfaW50ZXJhY3Rpb25zX2F0KHB4LHB5KQogLS0gc2NhbiBhbGwgb2Jq
ZWN0cyB3aXRoIGRpc3RhbmNlIGN1bGxpbmcKIGxvY2FsIGNsb3Nlc3RfaW50ZXJhY3Q9bmlsCiBs
b2NhbCBjbG9zZXN0X2Rpc3Q9OTk5CiAKIGZvciBvYiBpbiBhbGwob2JqZWN0cykgZG8KICBpZiBv
Yi5wb3MgYW5kIG9iLnR5cCB0aGVuCiAgIGxvY2FsIGR4PW9iLnBvc1sxXS1weAogICBsb2NhbCBk
eT1vYi5wb3NbMl0tcHkKICAgbG9jYWwgZGlzdD1hYnMoZHgpK2FicyhkeSkKICAgCiAgIC0tIGRp
cmVjdCBwaWNrdXA6IGF1dG8tY29sbGVjdAogICBpZiBvYi50eXAua2luZD09ImRpcmVjdF9waWNr
dXAiIGFuZCBkaXN0PGludGVyYWN0aW9uX3JhbmdlIHRoZW4KICAgIGNvbGxlY3RfaXRlbShvYikK
ICAgIGRlbChvYmplY3RzLG9iKQogICAgaWYgb2IuYXV0b2FuaW0gdGhlbiBkZWwoYW5pbWF0ZWRf
b2JqZWN0cyxvYikgZW5kCiAgIAogICAtLSBob3N0aWxlIG5wYzogdHJpZ2dlciBjb21iYXQKICAg
ZWxzZWlmIG9iLnR5cC5raW5kPT0iaG9zdGlsZV9ucGMiIGFuZCBkaXN0PGNvbWJhdF90cmlnZ2Vy
X3JhbmdlIHRoZW4KICAgIGluX2NvbWJhdD10cnVlCiAgICBjdXJyZW50X3RhcmdldD1vYgogICAK
ICAgLS0gaW50ZXJhY3RhYmxlOiBzZXQgZmxhZyBmb3IgY2xvc2VzdAogICBlbHNlaWYgb2IudHlw
LmtpbmQ9PSJpbnRlcmFjdGFibGUiIGFuZCBkaXN0PGludGVyYWN0aW9uX3JhbmdlIHRoZW4KICAg
IC0tIHRyYXA6IGltbWVkaWF0ZSBlZmZlY3QKICAgIGlmIG9iLnR5cC5zdWJ0eXBlPT0idHJhcCIg
dGhlbgogICAgIHBsYXllci5ocD1tYXgoMCxwbGF5ZXIuaHAtMTApCiAgICAgdHJhcF9tc2dfdGlt
ZXI9NjAKICAgICBkZWwob2JqZWN0cyxvYikKICAgICBpZiBvYi5hdXRvYW5pbSB0aGVuIGRlbChh
bmltYXRlZF9vYmplY3RzLG9iKSBlbmQKICAgIGVsc2VpZiBkaXN0PGNsb3Nlc3RfZGlzdCB0aGVu
CiAgICAgY2xvc2VzdF9pbnRlcmFjdD1vYgogICAgIGNsb3Nlc3RfZGlzdD1kaXN0CiAgICBlbmQK
ICAgZW5kCiAgZW5kCiBlbmQKIAogLS0gdXBkYXRlIGludGVyYWN0aW9uIHN0YXRlCiBpZiBjbG9z
ZXN0X2ludGVyYWN0IHRoZW4KICBpbnRlcmFjdGlvbl9hY3RpdmU9dHJ1ZQogIGN1cnJlbnRfaW50
ZXJhY3Q9Y2xvc2VzdF9pbnRlcmFjdAogZWxzZQogIGludGVyYWN0aW9uX2FjdGl2ZT1mYWxzZQog
IGN1cnJlbnRfaW50ZXJhY3Q9bmlsCiBlbmQKZW5kCgotLSBjb2xsZWN0IGl0ZW0gKHBpY2t1cCkK
LS0gUHVycG9zZTogSGFuZGxlIHBpY2t1cCBjb2xsZWN0aW9uIGFuZCBpbnZlbnRvcnkgdXBkYXRl
cwotLSBQYXJhbWV0ZXJzOiBvYiAob2JqZWN0IHdpdGggdHlwLnN1YnR5cGUpCi0tIFNpZGUgZWZm
ZWN0czogQWRkcyB0byBwbGF5ZXIua2V5cywgaW5jcmVhc2VzIHBsYXllci5ocAotLSBOb3Rlczog
Q2FsbGVkIGJ5IGNoZWNrX2ludGVyYWN0aW9uc19hdCgpIGZvciBkaXJlY3RfcGlja3VwIG9iamVj
dHMKZnVuY3Rpb24gY29sbGVjdF9pdGVtKG9iKQogaWYgb2IudHlwLnN1YnR5cGU9PSJrZXkiIGFu
ZCBvYi5rZXludW0gdGhlbgogIGFkZChwbGF5ZXIua2V5cyx7a2V5bnVtPW9iLmtleW51bX0pCiAg
cHJpbnRoKCJjb2xsZWN0ZWQga2V5ICIuLm9iLmtleW51bSkKIGVsc2VpZiBvYi50eXAuc3VidHlw
ZT09ImhlYXJ0IiB0aGVuCiAgcGxheWVyLmhwPW1pbigxMDAscGxheWVyLmhwKzIwKQogIHByaW50
aCgiY29sbGVjdGVkIGhlYXJ0IikKIGVsc2UKICBwcmludGgoImNvbGxlY3RlZCBpdGVtIikKIGVu
ZAplbmQKCi0tIGhhbmRsZSBpbnRlcmFjdGlvbiB3aGVuIHBsYXllciBwcmVzc2VzIEUvWgotLSBQ
dXJwb3NlOiBQcm9jZXNzIHBsYXllci1pbml0aWF0ZWQgaW50ZXJhY3Rpb25zIChFIGtleSAvIFog
YnV0dG9uKQotLSBBbGdvcml0aG06IFN3aXRjaCBvbiBjdXJyZW50X2ludGVyYWN0LnR5cC5zdWJ0
eXBlCi0tIFNpZGUgZWZmZWN0czogT3BlbnMgY2hlc3RzLCBhY3RpdmF0ZXMgc2hyaW5lcywgcmVh
ZHMgbm90ZXMsIHRyaWdnZXJzIGZsb29yIHRyYW5zaXRpb24KLS0gTm90ZXM6IE9ubHkgcnVucyB3
aGVuIGludGVyYWN0aW9uX2FjdGl2ZSBmbGFnIGlzIHRydWUKZnVuY3Rpb24gaGFuZGxlX2ludGVy
YWN0KCkKIGlmIG5vdCBpbnRlcmFjdGlvbl9hY3RpdmUgb3Igbm90IGN1cnJlbnRfaW50ZXJhY3Qg
dGhlbiByZXR1cm4gZW5kCiAKIGxvY2FsIHN1YnR5cGU9Y3VycmVudF9pbnRlcmFjdC50eXAgYW5k
IGN1cnJlbnRfaW50ZXJhY3QudHlwLnN1YnR5cGUgb3IgInVua25vd24iCiAKIGlmIHN1YnR5cGU9
PSJjaGVzdCIgdGhlbgogIC0tIG9wZW4gY2hlc3QgKHBsYWNlaG9sZGVyKQogIHBsYXllci5ocD1t
aW4oMTAwLHBsYXllci5ocCsxMCkKICBwcmludGgoIm9wZW5lZCBjaGVzdCIpCiAgZGVsKG9iamVj
dHMsY3VycmVudF9pbnRlcmFjdCkKICBpZiBjdXJyZW50X2ludGVyYWN0LmF1dG9hbmltIHRoZW4g
ZGVsKGFuaW1hdGVkX29iamVjdHMsY3VycmVudF9pbnRlcmFjdCkgZW5kCiAgCiBlbHNlaWYgc3Vi
dHlwZT09InNocmluZSIgdGhlbgogIC0tIGFjdGl2YXRlIHNocmluZSAocGxhY2Vob2xkZXIpCiAg
cGxheWVyLmhwPTEwMAogIHByaW50aCgiYWN0aXZhdGVkIHNocmluZSIpCiAgCiBlbHNlaWYgc3Vi
dHlwZT09Im5vdGUiIHRoZW4KICAtLSByZWFkIG5vdGUgKHBsYWNlaG9sZGVyKQogIHByaW50aCgi
cmVhZCBub3RlIikKICBkZWwob2JqZWN0cyxjdXJyZW50X2ludGVyYWN0KQogIGlmIGN1cnJlbnRf
aW50ZXJhY3QuYXV0b2FuaW0gdGhlbiBkZWwoYW5pbWF0ZWRfb2JqZWN0cyxjdXJyZW50X2ludGVy
YWN0KSBlbmQKICAKIGVsc2VpZiBzdWJ0eXBlPT0iZXhpdCIgdGhlbgogIC0tIHRyaWdnZXIgbmV4
dCBmbG9vcgogIHByaW50aCgidXNpbmcgZXhpdCBwb3J0YWwiKQogIGdlbmVyYXRlX25ld19mbG9v
cigpCiAgCiBlbmQKIAogLS0gY2xlYXIgaW50ZXJhY3Rpb24gc3RhdGUgYWZ0ZXIgaGFuZGxpbmcK
IGludGVyYWN0aW9uX2FjdGl2ZT1mYWxzZQogY3VycmVudF9pbnRlcmFjdD1uaWwKZW5kCgotLSBn
ZW5lcmF0ZSBuZXcgZmxvb3IgKHJlZ2VuZXJhdGUgZHVuZ2VvbikKZnVuY3Rpb24gZ2VuZXJhdGVf
bmV3X2Zsb29yKCkKIC0tIGluY3JlbWVudCBkaWZmaWN1bHR5CiBnZW5fcGFyYW1zLmRpZmZpY3Vs
dHk9bWluKGdlbl9wYXJhbXMubWF4X2RpZmZpY3VsdHksZ2VuX3BhcmFtcy5kaWZmaWN1bHR5KzEp
CiAKIC0tIGNsZWFyIGV4aXN0aW5nIG9iamVjdHMKIG9iamVjdHM9e30KIGFuaW1hdGVkX29iamVj
dHM9e30KIGRvb3JzPXt9CiAtLSBhbHNvIGNsZWFyIGRvb3JncmlkIHRvIHByZXZlbnQgc3RhbGUg
cmVmZXJlbmNlcwogZm9yIGk9MCwxMjcgZG8KICBpZiBkb29yZ3JpZFtpXSB0aGVuCiAgIGZvciBq
PTAsMTI3IGRvCiAgICBkb29yZ3JpZFtpXVtqXT1uaWwKICAgZW5kCiAgZW5kCiBlbmQKIAogLS0g
cmVnZW5lcmF0ZSBkdW5nZW9uCiBzdGFydF9wb3MsZ2VuX3N0YXRzPWdlbmVyYXRlX2R1bmdlb24o
KQotLSBUcmlnZ2VyIEdDIGFmdGVyIGR1bmdlb24gZ2VuZXJhdGlvbiAoUGljb3Ryb24gZ3VpZGVs
aW5lOiBhdm9pZCBtaWQtZ2FtZXBsYXkgc3R1dHRlcikKc3RhdCgwKQogLS0gaW52YWxpZGF0ZSBw
ZXJzaXN0ZW50IHJlbmRlciBjYWNoZXMgZm9yIG5ldyBmbG9vcgotLSBQcm9kdWN0aW9uOiBjbGVh
ciBjYWNoZSBvbiBsZXZlbCBsb2FkIHRvIHByZXZlbnQgc3RhbGUgdGV4dHVyZSByZWZlcmVuY2Vz
CmlmIGNsZWFyX3RleHR1cmVfY2FjaGVzIHRoZW4gY2xlYXJfdGV4dHVyZV9jYWNoZXMoKSBlbmQK
IAogcHJpbnRoKCJmbG9vciBjb21wbGV0ZSEgZGlmZmljdWx0eTogIi4uZ2VuX3BhcmFtcy5kaWZm
aWN1bHR5KQogCiAtLSBsZXZlbCBsb2FkIGRpYWdub3N0aWMgc3VtbWFyeQogcHJpbnRoKCI9PT0g
TEVWRUwgTE9BRCBESUFHTk9TVElDUyA9PT0iKQogcHJpbnRoKCJGbG9vcjogIi4uKGN1cnJlbnRf
Zmxvb3Igb3IgInVua25vd24iKSkKIHByaW50aCgiRGlmZmljdWx0eTogIi4uZ2VuX3BhcmFtcy5k
aWZmaWN1bHR5KQogcHJpbnRoKCJSb29tczogIi4uZ2VuX3N0YXRzLnJvb21zKQogcHJpbnRoKCJP
YmplY3RzOiAiLi5nZW5fc3RhdHMub2JqZWN0cykKIHByaW50aCgiU2VlZDogIi4uZ2VuX3N0YXRz
LnNlZWQpCmVuZAoKLS0gdXBkYXRlIGNvbWJhdCAocGxhY2Vob2xkZXIpCmZ1bmN0aW9uIHVwZGF0
ZV9jb21iYXQoKQogLS0gdGVtcCBleGl0OiBwcmVzcyBRIG9yIEVudGVyCiBpZiBrZXlwKCJxIikg
b3Iga2V5cCgiZW50ZXIiKSB0aGVuCiAgaW5fY29tYmF0PWZhbHNlCiAgY3VycmVudF90YXJnZXQ9
bmlsCiAgcHJpbnRoKCJleGl0ZWQgY29tYmF0IikKIGVuZAplbmQKCi0tIHVwZGF0ZSBucGMgYWkg
KGJhc2ljIHBhdHJvbCBhbmQgZm9sbG93KQpmdW5jdGlvbiB1cGRhdGVfbnBjX2FpKCkKIGZvciBv
YiBpbiBhbGwob2JqZWN0cykgZG8KICBpZiBvYi50eXAgYW5kIG9iLnR5cC5raW5kPT0iaG9zdGls
ZV9ucGMiIGFuZCBvYi5haV90eXBlIHRoZW4KICAgbG9jYWwgb2xkX3gsb2xkX3k9b2IucG9zWzFd
LG9iLnBvc1syXQogICAKICAgaWYgb2IuYWlfdHlwZT09InBhdHJvbCIgdGhlbgogICAgLS0gcGF0
cm9sOiBjeWNsZSB0aHJvdWdoIHBhdHJvbF9wb2ludHMKICAgIGlmIG9iLnBhdHJvbF9wb2ludHMg
YW5kICNvYi5wYXRyb2xfcG9pbnRzPjAgdGhlbgogICAgIC0tIGluaXRpYWxpemUgcGF0cm9sX2lu
ZGV4IGlmIG5pbCBvciAwCiAgICAgaWYgbm90IG9iLnBhdHJvbF9pbmRleCBvciBvYi5wYXRyb2xf
aW5kZXg9PTAgdGhlbgogICAgICBvYi5wYXRyb2xfaW5kZXg9MQogICAgIGVuZAogICAgIAogICAg
IGxvY2FsIHRhcmdldD1vYi5wYXRyb2xfcG9pbnRzW29iLnBhdHJvbF9pbmRleF0KICAgICBpZiB0
YXJnZXQgdGhlbgogICAgICBsb2NhbCBkeD10YXJnZXQueC1vYi5wb3NbMV0KICAgICAgbG9jYWwg
ZHk9dGFyZ2V0Lnktb2IucG9zWzJdCiAgICAgIGxvY2FsIGRpc3Q9c3FydChkeCpkeCtkeSpkeSkK
ICAgICAgCiAgICAgIC0tIHJlYWNoZWQgd2F5cG9pbnQ6IGFkdmFuY2UgdG8gbmV4dAogICAgICBp
ZiBkaXN0PDAuMSB0aGVuCiAgICAgICBvYi5wYXRyb2xfaW5kZXg9KG9iLnBhdHJvbF9pbmRleCUj
b2IucGF0cm9sX3BvaW50cykrMQogICAgICBlbHNlCiAgICAgICAtLSBtb3ZlIHRvd2FyZCBjdXJy
ZW50IHdheXBvaW50CiAgICAgICBpZiBkaXN0PjAgdGhlbgogICAgICAgIGxvY2FsIHNwZD1vYi50
eXAucGF0cm9sX3NwZWVkIG9yIDAuMDMKICAgICAgICBsb2NhbCBueD1vYi5wb3NbMV0rZHgvZGlz
dCpzcGQKICAgICAgICBsb2NhbCBueT1vYi5wb3NbMl0rZHkvZGlzdCpzcGQKICAgICAgICB0cnlt
b3ZldG9fcG9zKG9iLnBvcyxueCxueSxvYi50eXAudyBvciAwLjQsZmFsc2UsZmFsc2UpCiAgICAg
ICBlbmQKICAgICAgZW5kCiAgICAgZW5kCiAgICBlbmQKICAgIAogICBlbHNlaWYgb2IuYWlfdHlw
ZT09ImZvbGxvdyIgdGhlbgogICAgLS0gZm9sbG93OiBtb3ZlIHRvd2FyZCBwbGF5ZXIgaWYgaW4g
cmFuZ2UKICAgIGxvY2FsIGR4PXBsYXllci54LW9iLnBvc1sxXQogICAgbG9jYWwgZHk9cGxheWVy
Lnktb2IucG9zWzJdCiAgICBsb2NhbCBkaXN0PXNxcnQoZHgqZHgrZHkqZHkpCiAgICBsb2NhbCBm
b2xsb3dfcmFuZ2U9b2IudHlwLmZvbGxvd19yYW5nZSBvciAyMAogICAgaWYgZGlzdDxmb2xsb3df
cmFuZ2UgYW5kIGRpc3Q_MC4xIHRoZW4KICAgICBsb2NhbCBzcGQ9b2IudHlwLmZvbGxvd19zcGVl
ZCBvciAwLjA1CiAgICAgbG9jYWwgbng9b2IucG9zWzFdK2R4L2Rpc3Qqc3BkCiAgICAgbG9jYWwg
bnk9b2IucG9zWzJdK2R5L2Rpc3Qqc3BkCiAgICAgdHJ5bW92ZXRvX3BvcyhvYi5wb3Msbngsbnks
b2IudHlwLncgb3IgMC40LGZhbHNlLGZhbHNlKQogICAgZW5kCiAgIGVuZAogIGVuZAogZW5kCmVu
ZA==
:: src/.info.pod
--[[pod,created="2025-11-07 22:14:13",modified="2025-11-12 02:28:40"]]
:: tests/.info.pod
--[[pod,created="2025-11-12 02:28:40",modified="2025-11-12 02:28:40"]]
:: [eoc]
