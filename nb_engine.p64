picotron cartridge // www.picotron.net
version 2

:: lib/
:: src/
:: src/docs/
:: src/procgen/
:: src/render/
:: test/
:: test/render/
:: lib/assert.lua
--[[pod_format="raw",created="2024-09-08 16:18:35",modified="2025-03-07 13:17:35",revision=2]]
--[[
	assert.lua - Custom assertion library for Lua
	(c) 2025 Andrew Vasilyev. All rights reserved.

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program. If not, see <https://www.gnu.org/licenses/>.
]]

local assert = {}

-- Helper function to compare two tables
local function deep_compare(table1, table2)
	if table1 == table2 then
		return true
	end

	if type(table1) ~= "table" or type(table2) ~= "table" then
		return false
	end

	for key, value1 in pairs(table1) do
		local value2 = table2[key]
		if not deep_compare(value1, value2) then
			return false
		end
	end

	for key in pairs(table2) do
		if table1[key] == nil then
			return false
		end
	end

	return true
end

-- Helper function to compare two tables while ignoring nil values
local function deep_compare_ignore_nil(table1, table2)
	if table1 == table2 then
		return true
	end

	if type(table1) ~= "table" or type(table2) ~= "table" then
		return false
	end

	for key, value1 in pairs(table1) do
		local value2 = table2[key]
		if value1 ~= nil and value2 ~= nil then
			if not deep_compare_ignore_nil(value1, value2) then
				return false
			end
		end
	end

	for key, value2 in pairs(table2) do
		local value1 = table1[key]
		if value1 ~= nil and value2 ~= nil then
			if not deep_compare_ignore_nil(value1, value2) then
				return false
			end
		end
	end

	return true
end

-- Asserts that two values are equal
function assert.are_equal(actual, expected, message)
	if actual ~= expected then
		error(message or string.format("Assertion failed: expected '%s', got '%s'", tostring(expected), tostring(actual)), 2)
	end
end

-- Asserts that two tables are deeply equal, ignoring nil values
function assert.are_equal_tables_ignore_nil(actual, expected, message)
	if not deep_compare_ignore_nil(actual, expected) then
		error(message or "Assertion failed: Tables are not equal (ignoring nil values)", 2)
	end
end

-- Asserts that two values are not equal
function assert.are_not_equal(actual, expected, message)
	if actual == expected then
		error(message or string.format("Assertion failed: expected values to be different, but both are '%s'", tostring(actual)), 2)
	end
end

-- Asserts that two tables are deeply equal
function assert.are_equal_tables(actual, expected, message)
	if not deep_compare(actual, expected) then
		error(message or "Assertion failed: Tables are not equal", 2)
	end
end

-- Asserts that a value is nil
function assert.is_nil(value, message)
	if value ~= nil then
		error(message or string.format("Assertion failed: expected nil, got '%s'", tostring(value)), 2)
	end
end

-- Asserts that a value is not nil
function assert.is_not_nil(value, message)
	if value == nil then
		error(message or "Assertion failed: expected value to not be nil", 2)
	end
end

-- Asserts that a value is of a specific type
function assert.is_type(value, expected_type, message)
	if type(value) ~= expected_type then
		error(message or string.format("Assertion failed: expected type '%s', got '%s'", expected_type, type(value)), 2)
	end
end

-- Asserts that a value is true
function assert.is_true(value, message)
	if not value then
		error(message or string.format("Assertion failed: expected true, got '%s'", tostring(value)), 2)
	end
end

-- Asserts that a value is false
function assert.is_false(value, message)
	if value then
		error(message or string.format("Assertion failed: expected false, got '%s'", tostring(value)), 2)
	end
end

-- Asserts that a number is greater than a threshold
function assert.is_greater_than(actual, threshold, message)
	if actual <= threshold then
		error(
		message or
		string.format("Assertion failed: expected '%s' to be greater than '%s'", tostring(actual), tostring(threshold)),
			2)
	end
end

-- Asserts that a number is less than a threshold
function assert.is_less_than(actual, threshold, message)
	if actual >= threshold then
		error(
		message or
		string.format("Assertion failed: expected '%s' to be less than '%s'", tostring(actual), tostring(threshold)), 2)
	end
end

-- Asserts that a table contains a specific value
function assert.contains(table, value, message)
	for _, v in pairs(table) do
		if v == value then
			return true -- Value found
		end
	end
	error(message or string.format("Assertion failed: expected table to contain '%s'", tostring(value)), 2)
end

-- Asserts that a table contains a specific key
function assert.has_key(table, key, message)
	if table[key] == nil then
		error(message or string.format("Assertion failed: expected table to have key '%s'", tostring(key)), 2)
	end
end

-- Asserts that a table or string has a specific length
function assert.has_length(value, expected_length, message)
	local len = #value
	if len ~= expected_length then
		error(message or string.format("Assertion failed: expected length '%d', got '%d'", expected_length, len), 2)
	end
end

-- Asserts that a string matches a given Lua pattern
function assert.matches_pattern(value, pattern, message)
	if not string.match(value, pattern) then
		error(message or string.format("Assertion failed: expected '%s' to match pattern '%s'", value, pattern), 2)
	end
end

return assert

:: lib/log.lua
--[[pod_format="raw",created="2024-09-08 16:18:39",modified="2024-09-08 22:44:14",revision=1]]
--[[
	log.lua - logging and tracing
	(c) 2024 Andrew Vasilyev. All rights reserved.

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program. If not, see <https://www.gnu.org/licenses/>.
]]

local log = {}

-- Log levels table
log.levels = {
	TRACE = 1,
	DEBUG = 2,
	INFO  = 3,
	WARN  = 4,
	ERROR = 5
}

-- Log level color codes for console output
local log_level_colors = {
	"\f6", -- TRACE
	"\f7", -- DEBUG
	"\fb", -- INFO
	"\fa", -- WARN
	"\f8"  -- ERROR
}

-- Log output targets
log.targets = {
	CONSOLE = 1,         -- Logs to console
	EXTERNAL_PROCESS = 2 -- Logs to an external process
}

-- Current log level (default to INFO)
log.current_level = log.levels.INFO

-- Default log target (set to external process)
log.target = log.targets.EXTERNAL_PROCESS
log.target_process_name = "logview" -- Name of external process
log.target_process_id = -1          -- Process ID of the log target

-- Formats a timestamp into MM:SS.mmm format
local function format_timestamp(timestamp)
	local minutes = math.floor(timestamp / 60)
	local seconds = math.floor(timestamp % 60)
	local milliseconds = math.floor((timestamp % 1) * 1000)
	return string.format("%02d:%02d.%03d", minutes, seconds, milliseconds)
end

-- Formats a log entry with level color, timestamp, and message
local function format_log_entry(level, timestamp, message)
	return log_level_colors[level] .. format_timestamp(timestamp) .. "\t" .. message
end

-- Logs a message if it meets the current log level
local function log_message(level, message, ...)
	if level < log.current_level then
		return
	end

	if log.target == log.targets.EXTERNAL_PROCESS and log.target_process_id == -1 then
		-- Logging target process ID not resolved. Unable to log message.
		return
	end

	local formatted_message = string.format(message, ...)
	local timestamp = time()

	local presentation = format_log_entry(level, timestamp, formatted_message)

	if log.target == log.targets.EXTERNAL_PROCESS then
		send_message(log.target_process_id, {
			event = "entry",
			entry = {
				timestamp = timestamp,
				level = level,
				message = formatted_message
			},
			presentation = presentation
		})
	elseif log.target == log.targets.CONSOLE then
		print(presentation)
	end
end

-- Initializes the logging system and resolves the external process ID
function log.init()
	if log.target == log.targets.EXTERNAL_PROCESS then
		log.target_process_id = get_pid_by_name(log.target_process_name)
		if log.target_process_id == -1 then
			log.set_target(log.targets.CONSOLE)
			log.warn("External logging process '" .. log.target_process_name .. "' not found. Defaulting to console output...")
		end
	end
end

-- Logs function entry and exit points for tracing
function log.trace_function(fn_name, fn, ...)
	log.trace("Entering %s()", fn_name)
	local result = { fn(...) }
	log.trace("Exiting %s()", fn_name)
	return table.unpack(result)
end

-- Log message functions for different levels
function log.trace(message, ...) log_message(log.levels.TRACE, message, ...) end

function log.debug(message, ...) log_message(log.levels.DEBUG, message, ...) end

function log.info(message, ...) log_message(log.levels.INFO, message, ...) end

function log.warn(message, ...) log_message(log.levels.WARN, message, ...) end

function log.error(message, ...) log_message(log.levels.ERROR, message, ...) end

-- Sets the current logging level
function log.set_level(level)
	log.current_level = level
end

-- Sets the logging target and optionally updates the external process name
function log.set_target(target_type, process_name)
	log.target = target_type

	if process_name then
		log.target_process_name = process_name
		log.target_process_id = -1
	end
end

return log

:: lib/require.lua
--[[pod_format="raw",created="2024-09-08 09:50:21",modified="2025-03-07 13:16:28",revision=8]]
--[[
	require.lua - Lua 5.4-compatible "require"
	(c) 2025 Andrew Vasilyev. All rights reserved.

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program. If not, see <https://www.gnu.org/licenses/>.
]]

-- Retrieves the current folder of the calling script
local function get_current_folder()
	local str = debug.getinfo(2, "S").source:sub(2)
	return str:match("(.*/)")
end

-- Attempts to resolve the full path of a module.
-- Adds ".lua" extension if necessary.
-- @param path: The path to the module
-- @return: The full path of the module
local function resolve_module_path(path)
	if not path:match("%.lua$") then
		return fullpath(path .. ".lua")
	end
	return fullpath(path)
end

-- Table to cache loaded modules to avoid reloading
local _LOADED = {}

-- Holds all the paths to search for modules
local _PATH = { get_current_folder() }

-- Adds a new path to the module search path
-- @param path: The new path to be added
function add_module_path(path)
	table.insert(_PATH, path)
end

-- Clears all loaded modules from the cache, with an option to preserve specific modules.
-- This allows modules to be reloaded upon the next `require()` call, except for those marked as preserved.
-- Useful for reloading modules during testing or debugging, while retaining essential ones like log utilities.
-- @param preserved: (Optional) A list of module names to preserve in the cache (e.g., {"log", "config"}).
function clear_module_cache(preserved)
	-- Iterate through the loaded modules cache (_LOADED)
	for module_name, _ in pairs(_LOADED) do
		local preserve = false  -- Flag to determine if the module should be preserved

		-- Check if the module is in the list of preserved modules
		if preserved then
			for _, preserve_name in pairs(preserved) do
				if module_name == preserve_name then
					preserve = true
					break  -- No need to check further if the module is already marked to preserve
				end
			end
		end

		-- If the module is not in the preserved list, remove it from the cache
		if not preserve then
			_LOADED[module_name] = nil
		end
	end
end

-- Loads and caches a Lua module, similar to the `require()` function.
-- If the module is already cached, it returns the cached version.
-- Otherwise, it resolves the module's path, fetches, compiles, and executes it.
-- The `alias` parameter allows you to load an alternative (mock) implementation
-- instead of the real module.
-- @param filename: The name of the Lua module to load.
-- @param alias: (Optional) An alternative name to use for caching or loading a mock module.
-- @return: The result of the module's execution, typically a table containing functions or data.
function require(filename, alias)
	local full_filename, src
	local key = filename

	if alias then
		key = alias
	end

	if _LOADED[key] then
		return _LOADED[key]
	end

	for _, path in ipairs(_PATH) do
		full_filename = resolve_module_path(path .. filename)

		src = fetch(full_filename)

		if type(src) == "string" then
			local func, err = load(src, "@" .. full_filename, "t", _ENV)

			if not func then
				wtf("Error loading module '" .. filename .. "': " .. err)
				return
			end

			_LOADED[key] = func() or true
			return _LOADED[key]
		end
	end

	wtf("Module '" .. filename .. "' not found in search paths.")
end

:: src/config.lua
--[[pod_format="raw",created="2025-11-07 21:17:14",modified="2025-11-07 21:48:05",revision=1]]
-- engine configuration

-- screen constants
screen_width=480
screen_height=270
screen_center_x=screen_width/2
screen_center_y=screen_height/2
-- default ray budget: tuned for 480px wide viewport; adaptive governor in main.lua can lower this
ray_count=128
-- CRITICAL: screen_center_x must equal screen_width/2, screen_center_y must equal screen_height/2
-- ray_count is decoupled from screen_width and can be configured independently for performance tuning
sdist=200 -- default; computed dynamically in raycast_scene() based on fov
map_size=128
objgrid_size=5
objgrid_array_size=26
fov=0.5

-- sprite configuration
sprite_size=32

-- fog configuration (unified linear fog system)
fog_near=5.0 -- near fog distance where fog begins
fog_far=20.0 -- far fog distance where fog is maximum
fog_hysteresis=0.5 -- minimum z change required to update fog level (reduces palette thrashing)
screenbright=1.0 -- screen brightness multiplier (1.0=normal, <1.0=darker for atmosphere)

-- lod configuration (ratios of fog_far)
wall_lod_ratio=0.4 -- ratio of fog_far for wall LOD transition
sprite_lod_ratio=0.5 -- ratio of fog_far for sprite LOD transition
wall_lod_distance=fog_far*wall_lod_ratio -- computed: walls beyond this z use simplified rendering
wall_tiny_screen_px=6 -- walls shorter than this many pixels use LOD solid fill

-- rendering configuration
row_stride=1 -- floor/ceiling stride; keep at 1 for correct perspective (governor can relax if needed)
per_cell_floors_enabled=false -- enable per-cell floor type detection (false=render entire scanline with single texture)
-- tline quality flag (0x400) is expensive; keep off unless visual artifacts demand it
tline_high_quality_near=false

-- raycast configuration
far_plane=25.0 -- maximum raycast distance; must be >= fog_far + 2.0 to prevent geometry popping

-- ai and interaction constants
ai_update_rate=2 -- frames between AI updates
interaction_range=0.5 -- proximity for triggers
combat_trigger_range=0.3 -- distance to trigger combat

-- player movement constants
player_rotation_speed=0.008 -- radians per frame when turning (slower, smoother)
player_move_speed=0.04 -- units per frame when moving (reduced)

-- door animation constants
door_anim_speed=0.06 -- door open/close speed per frame
door_close_delay=90 -- frames before door auto-closes

-- floor/ceiling types (tex indexes from gfx/1_surfaces.gfx, offset 32)
planetyps={
 -- stone_tile
 {tex=32,scale=1,height=0.5,lit=true,xvel=0,yvel=0},
 -- dirt
 {tex=33,scale=1,height=0.5,lit=true,xvel=0,yvel=0},
 -- stone_ceiling
 {tex=34,scale=1,height=0.5,lit=false,xvel=0,yvel=0},
 -- sky
 {tex=35,scale=2,height=1,lit=false,xvel=0.01,yvel=0},
 -- night_sky
 {tex=36,scale=2,height=1,lit=false,xvel=0.005,yvel=0}
}

-- wall texture sets (sprite indexes from gfx/0_walls.gfx)
texsets={
 -- none (removed to avoid collision with brick variant 0)
 -- brick
 {base=0,variants={0,1,2,3}},
 -- cobblestone
 {base=4,variants={4,5,6,7}},
 -- wood_plank
 {base=8,variants={8,9,10,11}},
 -- stone
 {base=12,variants={12,13,14,15}},
 -- grass (outdoor)
 {base=16,variants={16,17,18,19}},
 -- earth (outdoor)
 {base=20,variants={20,21,22,23}}
}

-- door types (sprite indexes from gfx/0_walls.gfx)
door_normal=24
door_locked=25
door_stay_open=26

-- helper: check if tile is a door
function is_door(val)
 return val>=door_normal and val<=door_stay_open
end

-- exit types (tile IDs)
exit_start=67
exit_end=68

-- wall fill constant
wall_fill_tile=1

-- generation parameters
gen_params={
 min_rooms=5,
 max_rooms=15,
 min_size=4,
 max_size=12,
 spacing=2,
 corridor_texture=0,
 room_door_prob=0.3,
 erode_amount=50,
 difficulty=1,
 max_difficulty=9,
 max_enemies_per_room=8,
 max_decorations_per_room=12,
 npc_hostile_ratio=0.7,
 items_per_room=2,
 pickup_density=0.1
}

gen_observability={
 enable_console=false,
 capture_history=true,
 history_limit=400,
 log_seed=true,
 log_room_attempts=true,
 log_corridors=true,
 log_progression=true,
 log_repairs=true
}

gen_adaptive_settings={
 spacing_relax_threshold=4,
 spacing_relax_step=1,
 spacing_max_relax=4,
 spacing_restore_delay=2,
 spacing_restore_step=1,
 max_room_failures=24,
 offcenter_bias=0.65,
 bias_radius=12,
 junction_retry_limit=6,
 corridor_jog_chance=0.25
}

-- helper constants
max_spawn_attempts=50
max_room_attempts=100

-- door testing parameters
test_door_open=nil -- if set to a value 0.0-1.0, forces all doors to this open state for testing
test_door_x=nil -- if set, only affects door at this position
test_door_y=nil -- if set, only affects door at this position

-- object type definitions (mx=sprite index from gfx files, my deprecated, mw/mh use sprite_size)
-- NOTE: my=0 is deprecated and maintained for backward compatibility only; will be removed once rendering code migrates
obj_types={
 player={solid=true,w=0.4,mx=0,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.8,flat=false,lit=nil,framect=nil,animspd=nil,yoffs=nil,kind="player"},
 enemy={solid=true,w=0.4,mx=64,my=0,mw=sprite_size,mh=sprite_size,y=0.1,h=0.8,flat=false,lit=nil,framect=4,animspd=0.25,yoffs={0,-0.01,0,-0.01},kind="hostile_npc",ai_type="follow",follow_speed=0.05,follow_range=20,patrol_speed=0.03},
 item={solid=false,w=0.3,mx=128,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.2,flat=false,lit=nil,framect=nil,animspd=nil,yoffs=nil,kind="direct_pickup",subtype="generic"},
 key={solid=false,w=0.3,mx=129,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.2,flat=false,lit=nil,framect=nil,animspd=nil,yoffs=nil,kind="direct_pickup",subtype="key"},
 heart={solid=false,w=0.3,mx=130,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.2,flat=false,lit=nil,framect=2,animspd=0.1,yoffs={0,0.05},kind="direct_pickup",subtype="heart"},
 decoration={solid=false,w=0.3,mx=148,my=0,mw=sprite_size,mh=sprite_size,y=0.3,h=0.4,flat=false,lit=0,framect=4,animspd=0.25,yoffs=nil,kind="decorative"},
 hostile_npc={solid=true,w=0.4,mx=64,my=0,mw=sprite_size,mh=sprite_size,y=0.1,h=0.8,flat=false,lit=nil,framect=4,animspd=0.25,yoffs={0,-0.01,0,-0.01},kind="hostile_npc",ai_type="follow",follow_speed=0.05,follow_range=20,patrol_speed=0.03},
 non_hostile_npc={solid=false,w=0.4,mx=73,my=0,mw=sprite_size,mh=sprite_size,y=0.1,h=0.8,flat=false,lit=nil,framect=1,animspd=0,yoffs=nil,kind="non_hostile_npc"},
 direct_pickup={solid=false,w=0.2,mx=128,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.2,flat=false,lit=nil,framect=2,animspd=0.1,yoffs={0,0.05},kind="direct_pickup"},
 interactable_chest={solid=false,w=0.3,mx=131,my=0,mw=sprite_size,mh=sprite_size,y=0.3,h=0.3,flat=false,lit=nil,framect=1,animspd=0,yoffs=nil,kind="interactable",subtype="chest"},
 interactable_shrine={solid=false,w=0.4,mx=132,my=0,mw=sprite_size,mh=sprite_size,y=0.3,h=0.5,flat=false,lit=nil,framect=1,animspd=0,yoffs=nil,kind="interactable",subtype="shrine"},
 interactable_trap={solid=false,w=0.2,mx=133,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.1,flat=true,lit=nil,framect=1,animspd=0,yoffs=nil,kind="interactable",subtype="trap"},
 interactable_note={solid=false,w=0.3,mx=134,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.2,flat=true,lit=nil,framect=1,animspd=0,yoffs=nil,kind="interactable",subtype="note"},
 interactable_exit={solid=false,w=0.3,mx=135,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.2,flat=false,lit=nil,framect=1,animspd=0,yoffs=nil,kind="interactable",subtype="exit"}
}

-- enemy type definitions (sprite indexes from gfx/2_characters.gfx, offset 64)
enemy_types={
 {name="rat",difficulty=1,min_count=1,max_count=3,obj_type=obj_types.hostile_npc,sprite=64,hp=1},
 {name="bat",difficulty=2,min_count=1,max_count=4,obj_type=obj_types.hostile_npc,sprite=65,hp=1},
 {name="slime",difficulty=3,min_count=2,max_count=5,obj_type=obj_types.hostile_npc,sprite=66,hp=2},
 {name="skeleton",difficulty=4,min_count=1,max_count=3,obj_type=obj_types.hostile_npc,sprite=67,hp=3},
 {name="goblin",difficulty=5,min_count=2,max_count=4,obj_type=obj_types.hostile_npc,sprite=68,hp=3},
 {name="orc",difficulty=6,min_count=1,max_count=3,obj_type=obj_types.hostile_npc,sprite=69,hp=4},
 {name="troll",difficulty=7,min_count=1,max_count=2,obj_type=obj_types.hostile_npc,sprite=70,hp=5},
 {name="demon",difficulty=8,min_count=1,max_count=2,obj_type=obj_types.hostile_npc,sprite=71,hp=6},
 {name="dragon",difficulty=9,min_count=1,max_count=1,obj_type=obj_types.hostile_npc,sprite=72,hp=10}
}

-- decoration type definitions (sprite indexes from gfx/3_props.gfx, offset 148)
decoration_types={
 {name="torch",difficulty=1,obj_type=obj_types.decoration,gen_tags={"lit","uni"},theme_tags={"dng","lit"},sprite=148},
 {name="barrel",difficulty=1,obj_type=obj_types.decoration,gen_tags={"uni"},theme_tags={"dng","house"},sprite=149},
 {name="crate",difficulty=1,obj_type=obj_types.decoration,gen_tags={"uni2"},theme_tags={"dng","house"},sprite=150},
 {name="pillar",difficulty=2,obj_type=obj_types.decoration,gen_tags={"big"},theme_tags={"dng","dem"},sprite=151},
 {name="statue",difficulty=3,obj_type=obj_types.decoration,gen_tags={"rare"},theme_tags={"dng","dem"},sprite=152},
 {name="chest",difficulty=2,obj_type=obj_types.decoration,gen_tags={"scatter"},theme_tags={"dng","house"},sprite=153},
 {name="tree",difficulty=1,obj_type=obj_types.decoration,gen_tags={"scatter"},theme_tags={"out"},sprite=154},
 {name="rock",difficulty=1,obj_type=obj_types.decoration,gen_tags={"uni"},theme_tags={"out"},sprite=155}
}

-- theme definitions
themes={
 dng={
  floor="stone_tile",
  roof="stone_ceiling",
  decor_prob=0.8,
  rules={
   room_shape_weights={square=0.5,hall_horizontal=0.25,hall_vertical=0.2,grand=0.1},
   room_extra_size=1,
   bias_radius=10,
   center_bias=0.55,
   corridor_jog_chance=0.2,
   erosion_intensity=1.0
  }
 },
 out={
  floor="dirt",
  roof="sky",
  decor_prob=0.5,
  rules={
   room_shape_weights={hall_horizontal=0.45,square=0.35,grand=0.05,hall_vertical=0.15},
   room_extra_size=0,
   bias_radius=14,
   center_bias=0.7,
   corridor_jog_chance=0.35,
   erosion_intensity=1.2
  }
 },
 dem={
  floor="stone_tile",
  roof="night_sky",
  decor_prob=0.9,
  rules={
   room_shape_weights={square=0.4,hall_vertical=0.3,hall_horizontal=0.2,grand=0.15},
   room_extra_size=2,
   bias_radius=8,
   center_bias=0.5,
   corridor_jog_chance=0.15,
   erosion_intensity=0.8
  }
 },
 house={
  floor="stone_tile",
  roof="stone_ceiling",
  decor_prob=0.7,
  rules={
   room_shape_weights={square=0.6,hall_horizontal=0.2,hall_vertical=0.2},
   room_extra_size=0,
   bias_radius=9,
   center_bias=0.6,
   corridor_jog_chance=0.1,
   erosion_intensity=0.5
  }
 },
 dark={
  floor="stone_tile",
  roof="night_sky",
  decor_prob=0.6,
  rules={
   room_shape_weights={square=0.35,hall_vertical=0.35,hall_horizontal=0.2,grand=0.1},
   room_extra_size=1,
   bias_radius=8,
   center_bias=0.5,
   corridor_jog_chance=0.25,
   erosion_intensity=0.9
  }
 }
}

-- fog palettes (distance-based)
-- extended to support all 64 colors in Picotron
-- base colors 0-15 are remapped per fog level; colors 16-63 map to their fogged equivalents
pals={
 -- level 0: no fog
 {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63},
 -- level 1
 {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,5,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,5,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,5,48,49,50,51,52,53,54,5,56,57,58,59,60,61,62,5},
 -- level 2
 {0,1,2,3,4,5,6,7,8,9,10,11,12,13,5,5,16,17,18,19,20,21,22,23,24,25,26,27,28,29,5,5,32,33,34,35,36,37,38,39,40,41,42,43,44,45,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,61,5,5},
 -- level 3
 {0,1,2,3,4,5,6,7,8,9,10,11,12,5,5,5,16,17,18,19,20,21,22,23,24,25,26,27,28,5,5,5,32,33,34,35,36,37,38,39,40,41,42,43,44,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 4
 {0,1,2,3,4,5,6,7,8,9,10,11,5,5,5,5,16,17,18,19,20,21,22,23,24,25,26,27,5,5,5,5,32,33,34,35,36,37,38,39,40,41,42,43,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 5
 {0,1,2,3,4,5,6,7,8,9,10,5,5,5,5,5,16,17,18,19,20,21,22,23,24,25,26,5,5,5,5,5,32,33,34,35,36,37,38,39,40,41,42,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 6
 {0,1,2,3,4,5,6,7,8,9,5,5,5,5,5,5,16,17,18,19,20,21,22,23,24,25,5,5,5,5,5,5,32,33,34,35,36,37,38,39,40,41,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 7
 {0,1,2,3,4,5,6,7,8,5,5,5,5,5,5,5,16,17,18,19,20,21,22,23,24,5,5,5,5,5,5,5,32,33,34,35,36,37,38,39,40,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 8
 {0,1,2,3,4,5,6,7,5,5,5,5,5,5,5,5,16,17,18,19,20,21,22,23,5,5,5,5,5,5,5,5,32,33,34,35,36,37,38,39,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 9
 {0,1,2,3,4,5,6,5,5,5,5,5,5,5,5,5,16,17,18,19,20,21,5,5,5,5,5,5,5,5,5,5,32,33,34,35,36,37,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 10
 {0,1,2,3,4,5,5,5,5,5,5,5,5,5,5,5,16,17,18,19,20,21,5,5,5,5,5,5,5,5,5,5,32,33,34,35,36,37,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 11
 {0,1,2,3,4,5,5,5,5,5,5,5,5,5,5,5,16,17,18,19,20,21,5,5,5,5,5,5,5,5,5,5,32,33,34,35,36,37,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 12
 {0,1,2,3,5,5,5,5,5,5,5,5,5,5,5,5,16,17,18,19,5,5,5,5,5,5,5,5,5,5,5,5,32,33,34,35,5,5,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 13
 {0,1,2,5,5,5,5,5,5,5,5,5,5,5,5,5,16,17,18,5,5,5,5,5,5,5,5,5,5,5,5,5,32,33,34,5,5,5,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 14
 {0,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,16,17,5,5,5,5,5,5,5,5,5,5,5,5,5,5,32,33,5,5,5,5,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 15: maximum fog
 {0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,16,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,32,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5}
}

:: src/configuration.lua
--[[pod_format="raw",created="2024-09-08 09:49:19",modified="2025-03-07 13:16:06",revision=6]]
--[[
	configuration.lua - configuration settings for the program
	(c) 2025 Andrew Vasilyev. All rights reserved.

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program. If not, see <https://www.gnu.org/licenses/>.
]]

local log = require("log", "log")

configuration = {
	-- If true, logging will be initialized and messages will be sent to the "logview" process
	log = {
		-- If true, logging will be enabled
		enabled = true,
		-- The logging level to use
		level = log.levels.DEBUG
	}
}

:: src/globals.lua
--[[pod_format="raw",created="2024-09-08 09:49:37",modified="2025-03-07 13:16:47",revision=5]]
--[[
	globals.lua - global utility functions
	(c) 2025 Andrew Vasilyev. All rights reserved.

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program. If not, see <https://www.gnu.org/licenses/>.
]]

local wm_pid = 3 -- Process ID of Picotron's window manager and info bar

-- Reports a fatal error, logs the message and traceback, and exits the program.
-- @param message: The format string for the error message
-- @param exit_code: Optional custom exit code (default is 1)
-- @param ...: Additional arguments to format the message
function wtf(message, exit_code, ...)
	local error_report = debug.traceback(string.format(message, ...), 2)

	send_message(wm_pid, { event = "report_error", content = "*wtf?!" })
	send_message(wm_pid, { event = "report_error", content = error_report })

	exit(exit_code or 1)
end

-- Retrieves the process ID (PID) by process name.
-- @param name: The name of the process to search for.
-- @return: The process ID if found, or -1 if not found.
function get_pid_by_name(name)
	local processes = fetch("/ram/system/processes.pod")

	for i = 1, #processes do
		local process = processes[i]
		if (process.name == name) then
			-- Return the process ID if found
			return process.id
		end
	end

	return -1
end

:: src/logview.lua
--[[pod_format="raw",created="2024-09-08 09:51:03",modified="2025-03-07 13:16:38",revision=5]]
--[[
	logview.lua - log viewer utility
	(c) 2025 Andrew Vasilyev. All rights reserved.

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program. If not, see <https://www.gnu.org/licenses/>.
]]

local gui = create_gui()

-- Initializes the log viewer window and sets up the log display.
function _init()
	window({
		width      = 320,
		height     = 200,
		resizeable = true,
		title      = "Log Viewer"
	})

	local lines = {}

	-- Attach a log display panel to the GUI
	gui:attach({
		x = 1,
		y = 1,
		width = 480,
		height = 0,
		update = function(self, ev)
			self.height = #lines * 9  -- Adjust the height dynamically based on the number of lines
		end,
		draw = function(self, ev)
			for i = 1, #lines do
				print(lines[i], 0, (i - 1) * 9)
			end
		end
	})

	-- Attach scrollbars to the GUI, with autohide enabled
	gui:attach_scrollbars({
		autohide = true
	})

	-- Event listener to handle incoming log entries
	on_event("entry", function(entry)
		table.insert(lines, entry.presentation)

		-- Ensure the log display doesn't exceed 500 lines
		while (#lines > 500) do
			table.remove(lines, 1)
		end
	end)
end

-- Clears the screen and draws the GUI.
-- This function is called every frame to refresh the display.
function _draw()
	cls(1)
	gui:draw_all()
end

-- Updates the GUI state based on input or events.
-- Called every frame to handle updates to the GUI.
function _update()
	gui:update_all()
end

:: src/procgen/door_system.lua
--[[pod_format="raw",created="2025-11-07 21:17:14",modified="2025-11-07 21:48:06",revision=1]]
-- door animation system
-- test mode state (to avoid permanent mutation)
test_mode_prev=false
test_mode_saved_state={}

-- create a door
function create_door(x,y,dtype,key_id)
 local door={
  x=x,
  y=y,
  open=0, -- 0=closed, 1=fully open
  opening=false, -- animation state
  timer=0,
  dtype=dtype or door_normal,
  keynum=key_id, -- nil if unlocked, key id if locked
  stayopen=(dtype==door_stay_open) -- doors with door_stay_open dtype stay open
 }
 
 -- prevent duplicates at same grid cell
 local existing = doorgrid[x] and doorgrid[x][y] or nil
 if existing then
  printh("warning: duplicate door at ("..x..","..y..") - replacing")
  del(doors, existing)
 end
 add(doors,door)
 doorgrid[x][y]=door
	-- walls layer already set by generation to door tile ID (authoritative)
 
 return door
end

-- update all doors
function update_doors()
 -- handle test mode transitions to avoid permanent state mutation
 if test_door_mode and not test_mode_prev then
  -- entering test mode: save states
  test_mode_saved_state={}
  for door in all(doors) do
   test_mode_saved_state[door]={open=door.open,opening=door.opening,timer=door.timer}
  end
 elseif (not test_door_mode) and test_mode_prev then
  -- exiting test mode: restore states
  for door in all(doors) do
   local st=test_mode_saved_state[door]
   if st~=nil then
    door.open=st.open
    door.opening=st.opening
    door.timer=st.timer
   end
  end
  test_mode_saved_state={}
 end
 
 -- in test mode, temporarily override open values (restored on exit)
 if test_door_mode then
  for door in all(doors) do
   door.open=test_door_open or 0
  end
  -- keep early return to skip normal animation while testing
  test_mode_prev=true
  return
 end
 
 test_mode_prev=false
 
 for door in all(doors) do
  if door.opening then
   -- play sound on start
   if door.open==0 then
    -- sfx(10) -- door open sound
   end
   -- animate opening
   door.open+=door_anim_speed
   if door.open>1 then
    door.open=1
    door.opening=false
    door.timer=door_close_delay
   end
  else
   -- not opening
   if door.timer>0 then
    door.timer-=1
   elseif not door.stayopen then
    -- close door
    door.open=max(door.open-door_anim_speed,0)
   end
  end
 end
end



-- remove a door
function remove_door(x,y)
 local door=doorgrid[x][y]
 if door then
  del(doors,door)
  doorgrid[x][y]=nil
		set_wall(x,y,0)
 end
end

:: src/procgen/dungeon_gen.lua
--[[pod_format="raw",created="2025-11-07 21:17:13",modified="2025-11-07 21:48:06",revision=1]]
-- procedural dungeon generation

-- generation state
gen_rects={}
gen_nodes={}
gen_edges={}
gen_inventory={}
gen_objects={}
gen_locked_edges={}

-- theme-specific floor id used during carving/eroding; initialized to stone_tile (1)
local gen_floor_id=1

-- observability + diagnostics configuration (defaults if config.lua did not define them)
local observability = rawget(_G,"gen_observability") or {
 enable_console=false,
 capture_history=true,
 history_limit=400,
 log_seed=true,
 log_room_attempts=true,
 log_corridors=true,
 log_progression=true,
 log_repairs=true
}

local gen_history={}
local protected_tiles={}
local dynamic_spacing=0
local base_spacing=0
local spacing_restore_timer=0
local spacing_relaxations=0
local active_theme_rules=nil
local adaptive_settings=rawget(_G,"gen_adaptive_settings") or {
 spacing_relax_threshold=4,
 spacing_relax_step=1,
 spacing_max_relax=4,
 spacing_restore_delay=2,
 spacing_restore_step=1,
 max_room_failures=20,
 offcenter_bias=0.65,
 bias_radius=12,
 junction_retry_limit=4,
 corridor_jog_chance=0.25
}

local room_failure_streak=0
local total_room_failures=0

local tick_spacing -- forward declaration
local gen_log -- forward declaration
local relax_spacing -- forward declaration

local function hist_push(entry)
 if not observability.capture_history then return end
 add(gen_history,entry)
 if #gen_history>(observability.history_limit or 400) then
  deli(gen_history,1)
 end
end

local function register_room_failure(reason)
 room_failure_streak+=1
 total_room_failures+=1
 tick_spacing(false)
 if observability.log_room_attempts then
  gen_log("room_fail",reason.." (streak="..room_failure_streak..")")
 end
 if room_failure_streak>=(adaptive_settings.spacing_relax_threshold or 4) then
  relax_spacing()
  room_failure_streak=0
 end
end

local function register_room_success()
 room_failure_streak=0
 tick_spacing(true)
end

gen_log=function(tag,msg)
 local line="["..tag.."] "..msg
 hist_push(line)
 if observability.enable_console then printh(line) end
end

local function clear_protected()
 protected_tiles={}
end

local function protect_tile(x,y)
 if not x or not y then return end
 protected_tiles[x]=protected_tiles[x] or {}
 protected_tiles[x][y]=true
end

local function is_tile_protected(x,y)
 return protected_tiles[x] and protected_tiles[x][y] or false
end

local function reset_adaptive_spacing()
 base_spacing=gen_params.spacing or 0
 dynamic_spacing=base_spacing
 spacing_restore_timer=0
 spacing_relaxations=0
 room_failure_streak=0
 total_room_failures=0
end

relax_spacing=function()
 if spacing_relaxations>=(adaptive_settings.spacing_max_relax or 4) then return end
 dynamic_spacing=max(0,dynamic_spacing-(adaptive_settings.spacing_relax_step or 1))
 spacing_relaxations+=1
 spacing_restore_timer=adaptive_settings.spacing_restore_delay or 2
 gen_log("spacing","relaxed spacing to "..dynamic_spacing)
end

tick_spacing=function(success)
 if success then
  if spacing_restore_timer>0 then
   spacing_restore_timer-=1
  elseif dynamic_spacing<base_spacing then
   dynamic_spacing=min(base_spacing,dynamic_spacing+(adaptive_settings.spacing_restore_step or 1))
   if dynamic_spacing==base_spacing then
    spacing_relaxations=0
   end
   gen_log("spacing","restored spacing to "..dynamic_spacing)
  end
 else
  if spacing_restore_timer>0 then
   spacing_restore_timer-=1
  end
 end
end

local function rect_area(rect)
 return (rect[3]-rect[1]+1)*(rect[4]-rect[2]+1)
end

local function classify_room_style(rect)
 local w=rect[3]-rect[1]+1
 local h=rect[4]-rect[2]+1
 local ratio=w/h
 if ratio>=1.8 then
  return "hall_horizontal"
 elseif ratio<=0.55 then
  return "hall_vertical"
 elseif w*h>=120 then
  return "grand"
 elseif w<=6 and h<=6 then
  return "compact"
 else
  return "square"
 end
end

local function choose_weighted(weights,default_key)
 if not weights then return default_key end
 local total=0
 for _,v in pairs(weights) do
  total+=v
 end
 if total<=0 then return default_key end
 local roll=rnd(total)
 local acc=0
 for key,v in pairs(weights) do
  acc+=v
  if roll<=acc then return key end
 end
 return default_key
end

local function get_edge_between(a,b)
 for e in all(gen_edges) do
  if (e.n1==a and e.n2==b) or (e.n1==b and e.n2==a) then
   return e
  end
 end
 return nil
end

local function locate_room_for_position(x,y)
 for node in all(gen_nodes) do
  local r=node.rect
  if x>=r[1] and x<=r[3] and y>=r[2] and y<=r[4] then
   return node
  end
 end
 return nil
end

local function relocate_key_to_room(keynum,target_node)
 if not target_node then return false end
 local sx,sy=find_spawn_point(target_node.rect)
 if not sx then
  sx=target_node.midx+0.5
  sy=target_node.midy+0.5
 end
 for ob in all(gen_objects) do
  if ob.typ==obj_types.key and ob.keynum==keynum then
   ob.pos={sx,sy}
   ob.room_index=target_node.index
   if observability.log_progression then
    gen_log("progression","relocated key#"..keynum.." to room "..target_node.index)
   end
   return true
  end
 end
 return false
end

local function validate_and_repair_progression(start_node,locked_edges)
 if not locked_edges or #locked_edges==0 then return end
 local key_rooms={}
 for ob in all(gen_objects) do
  if ob.typ==obj_types.key and ob.keynum then
   if not ob.room_index then
    local node=locate_room_for_position(ob.pos[1],ob.pos[2])
    ob.room_index=node and node.index or nil
   end
   key_rooms[ob.keynum]=ob.room_index
  end
 end

 local acquired={}
 local visited={}
 local queue={start_node}
 visited[start_node]=true
 local function collect_keys(node)
  for ob in all(gen_objects) do
   if ob.typ==obj_types.key and ob.keynum and ob.room_index==node.index then
    acquired[ob.keynum]=true
   end
  end
 end
 collect_keys(start_node)
 local progressed=true
 while progressed do
  progressed=false
  for edge in all(gen_edges) do
   local a,b=edge.n1,edge.n2
   local a_vis=visited[a]
   local b_vis=visited[b]
   if a_vis and not b_vis then
    local can_traverse=true
    if edge.locked and edge.keynum and not acquired[edge.keynum] then
     can_traverse=false
    end
    if can_traverse then
     visited[b]=true
     collect_keys(b)
     progressed=true
    end
   elseif b_vis and not a_vis then
    local can_traverse=true
    if edge.locked and edge.keynum and not acquired[edge.keynum] then
     can_traverse=false
    end
    if can_traverse then
     visited[a]=true
     collect_keys(a)
     progressed=true
    end
   end
  end
 end

 local relocated=false
 for edge in all(locked_edges) do
  if edge.locked and edge.keynum then
   local n1_vis=visited[edge.n1]
   local n2_vis=visited[edge.n2]
   if not (n1_vis and n2_vis) then
    if relocate_key_to_room(edge.keynum,start_node) then
     relocated=true
     acquired[edge.keynum]=true
     visited[edge.n1]=true
     visited[edge.n2]=true
    end
   end
  end
 end
 if relocated then
  validate_and_repair_progression(start_node,locked_edges)
 end
end

local function ensure_theme_rules(theme)
 local rules=(themes[theme] and themes[theme].rules) or nil
 active_theme_rules=rules or {
  room_aspect_bias=0.35,
  room_extra_size=0,
  spacing_floor=0,
  corridor_width=1,
  corridor_jog_chance=adaptive_settings.corridor_jog_chance or 0.25
 }
end

-- helper: check if tile is a wall
function is_wall(val)
 return val>0 and val<door_normal
end

-- helper: check if tile is a door
function is_door(val)
 return val>=door_normal and val<=door_stay_open
end

-- helper: check if tile is an exit
function is_exit(val)
 return val>=exit_start and val<=exit_end
end

-- helper: boundary cell is reserved if it has a door/exit in either layer
function is_reserved_boundary(x,y)
 local w=get_wall(x,y)
 if is_door(w) or is_exit(w) then return true end
 -- defensive: should always be 0 if walls layer is authoritative
 if get_door(x,y)>0 then return true end
 if doorgrid[x] and doorgrid[x][y] then return true end
 return false
end

-- helper: check if rectangles overlap
function rect_overlaps(rect)
 -- reject out-of-bounds rectangles upfront (map is 0..127)
 if rect[1]<0 or rect[3]>=128 or rect[2]<0 or rect[4]>=128 then
  return true
 end
 for r in all(gen_rects) do
  local spacing=dynamic_spacing or 0
  if not (rect[3]+spacing<r[1] or rect[1]>r[3]+spacing or
          rect[4]+spacing<r[2] or rect[2]>r[4]+spacing) then
   return true
  end
 end
 return false
end

local function rect_conflicts(rect,ignore_nodes,spacing_override)
 if rect[1]<0 or rect[3]>=map_size or rect[2]<0 or rect[4]>=map_size then
  return true
 end
 local ignore={}
 if ignore_nodes then
  for n in all(ignore_nodes) do
   if n and n.index then
    ignore[n.index]=true
   end
  end
 end
 local spacing=(spacing_override~=nil) and spacing_override or (dynamic_spacing or 0)
 for idx=1,#gen_rects do
  if not ignore[idx] then
   local r=gen_rects[idx]
   if r and not (rect[3]+spacing<r[1] or rect[1]>r[3]+spacing or rect[4]+spacing<r[2] or rect[2]>r[4]+spacing) then
    return true
   end
  end
 end
 return false
end

-- helper: fill rectangle using set_wall
-- Note: Uses Lua loops with userdata:set() calls; potential optimization:
-- batch userdata operations or memset() if available per Picotron guidelines
function fill_rect(rect,val)
 local x0=max(0,rect[1])
 local x1=min(127,rect[3])
 local y0=max(0,rect[2])
 local y1=min(127,rect[4])
 local fill_val=(val or 0)
 for x=x0,x1 do
  for y=y0,y1 do
   set_wall(x,y,fill_val)
  end
 end
end

-- helper: try place door with fallback positions
function try_place_door_with_fallback(x,y,dtype)
 dtype=dtype or door_normal
 local attempts={{0,0},{-1,0},{1,0},{0,-1},{0,1},{-2,0},{2,0},{0,-2},{0,2}}
 local should_place=rnd(1)<gen_params.room_door_prob
 if not should_place then
  gen_log("door","skipped optional door at "..x..","..y)
  return false
 end
 for i=1,#attempts do
  local off=attempts[i]
  local ax,ay=x+off[1],y+off[2]
  if ax>=0 and ax<map_size and ay>=0 and ay<map_size then
   local existing=get_wall(ax,ay)
   if is_wall(existing) then
    set_wall(ax,ay,dtype)
    create_door(ax,ay,dtype)
    protect_tile(ax,ay)
    if observability.log_corridors then
     gen_log("door","placed door at "..ax..","..ay.." after "..i.." attempts")
    end
    return true
   end
  end
 end
 if observability.log_repairs then
  gen_log("door","failed to place door near "..x..","..y)
 end
 return false
end

-- helper: generate random room
function random_room(base_node,is_special)
 local min_size=gen_params.min_size or 4
 local max_size=gen_params.max_size or 12
 if active_theme_rules and active_theme_rules.room_extra_size then
  max_size+=active_theme_rules.room_extra_size
 end
 if max_size<min_size then max_size=min_size end
 local shape_weights=active_theme_rules and active_theme_rules.room_shape_weights
 local shape=choose_weighted(shape_weights,"square")
 local w,h
 if is_special then
  w,h=12,12
 else
  if shape=="hall_horizontal" then
   w=flr(rnd(max_size-min_size+1))+min_size
   h=max(min_size,flr(w*0.5))
  elseif shape=="hall_vertical" then
   h=flr(rnd(max_size-min_size+1))+min_size
   w=max(min_size,flr(h*0.5))
  elseif shape=="grand" then
   w=max_size
   h=max(min_size,max_size-2)
  else
   w=flr(rnd(max_size-min_size+1))+min_size
   h=flr(rnd(max_size-min_size+1))+min_size
  end
 end
 w=min(w, max_size)
 h=min(h, max_size)
 w=max(w,min_size)
 h=max(h,min_size)

 local function sample_offset(range)
  local bias=(active_theme_rules and active_theme_rules.center_bias) or adaptive_settings.offcenter_bias or 0.65
  local magnitude=flr(range*(rnd()^bias))
  if rnd(1)<0.5 then magnitude=-magnitude end
  return magnitude
 end

 local x,y
 if base_node then
  local radius=(active_theme_rules and active_theme_rules.bias_radius) or adaptive_settings.bias_radius or 12
  local dx=sample_offset(radius)
  local dy=sample_offset(radius)
  x=base_node.midx+dx-flr(w/2)
  y=base_node.midy+dy-flr(h/2)
 else
  local margin=4
  x=flr(rnd(map_size-w-margin*2))+margin
  y=flr(rnd(map_size-h-margin*2))+margin
 end

 x=max(1,min(map_size-w-2,x))
 y=max(1,min(map_size-h-2,y))

 return {x,y,x+w-1,y+h-1}
end

-- helper: add room to generation state
function add_room(rect,is_junction)
 local index=#gen_nodes+1
 gen_rects[index]=rect
 local style=classify_room_style(rect)
 local node={
  rect=rect,
  midx=flr((rect[1]+rect[3])/2),
  midy=flr((rect[2]+rect[4])/2),
  edges={},
  is_junction=is_junction or false,
  style=style,
  area=rect_area(rect),
  theme=gen_params.theme,
  metadata={},
  index=index
 }
 if observability.log_room_attempts then
  gen_log("room","added room "..(#gen_nodes+1).." style="..style.." rect=("..rect[1]..","..rect[2]..")-("..rect[3]..","..rect[4]..")")
 end
 add(gen_nodes,node)
 return node
end

-- helper: determine corridor type between two rooms
function get_corridor_type(r1,r2)
 local ox=not (r1[3]<r2[1] or r1[1]>r2[3])
 local oy=not (r1[4]<r2[2] or r1[2]>r2[4])
 if ox and not oy then return "vert" end
 if oy and not ox then return "horiz" end
 return "l_shape"
end

-- helper: place door at exact boundary wall tile with retry
function place_boundary_door_with_retry(bx,by,dtype,max_attempts)
 dtype=dtype or door_normal
 local offsets={{0,0},{-1,0},{1,0},{0,-1},{0,1},{-2,0},{2,0},{0,-2},{0,2}}
 local attempts=max_attempts or #offsets
 for i=1,attempts do
  local off=offsets[i] or offsets[#offsets]
  local ax,ay=bx+off[1],by+off[2]
  if ax>=0 and ax<map_size and ay>=0 and ay<map_size then
   local tile=get_wall(ax,ay)
   if is_wall(tile) then
    set_wall(ax,ay,dtype)
    create_door(ax,ay,dtype)
    protect_tile(ax,ay)
    if observability.log_corridors then
     gen_log("door","boundary door placed at "..ax..","..ay.." (from "..bx..","..by..")")
    end
    return true
   end
  end
 end
 return false
end

-- helper: place door at exact boundary wall tile
function place_boundary_door(bx,by,dtype)
 -- bx,by = boundary wall tile (between corridor and room)
 if bx>=0 and bx<128 and by>=0 and by<128 then
  if is_wall(get_wall(bx,by)) then
   set_wall(bx,by,dtype or door_normal)
   create_door(bx,by,dtype)
   protect_tile(bx,by)
   return true
  end
 end
 return false
end

-- helper: ensure boundary passage (fallback for failed door placement)
function ensure_boundary_passage(bx,by)
 if bx>=0 and bx<128 and by>=0 and by<128 then
  local tile=get_wall(bx,by)
  -- if wall is still blocking and not a door, clear it
  if tile>0 and not is_door(tile) and not is_exit(tile) then
   set_wall(bx,by,0)
   set_floor(bx,by,gen_floor_id)
   protect_tile(bx,by)
   if observability.log_repairs then
    gen_log("door","fallback cleared wall at ("..bx..","..by..")")
   end
   return true
  end
 end
 return false
end

local function verify_boundary_door(bx,by,dtype)
 if not bx or not by then return end
 dtype=dtype or door_normal
 if bx<0 or bx>=map_size or by<0 or by>=map_size then return end
 local tile=get_wall(bx,by)
 if is_door(tile) then
  protect_tile(bx,by)
  return
 end
 if tile==0 then
  set_wall(bx,by,dtype)
  create_door(bx,by,dtype)
  protect_tile(bx,by)
  if observability.log_repairs then
   gen_log("door","repaired missing door at "..bx..","..by)
  end
 else
  local ok=place_boundary_door_with_retry(bx,by,dtype,6)
  if not ok then
   ensure_boundary_passage(bx,by)
  end
 end
end

local function carve_horizontal_span(y,x_start,x_end,floor_id)
 if not floor_id then floor_id=gen_floor_id end
 if y<0 or y>=map_size then return end
 local a=min(x_start,x_end)
 local b=max(x_start,x_end)
 a=max(0,a)
 b=min(map_size-1,b)
 for x=a,b do
  set_wall(x,y,0)
  set_floor(x,y,floor_id)
 end
end

local function carve_vertical_span(x,y_start,y_end,floor_id)
 if not floor_id then floor_id=gen_floor_id end
 if x<0 or x>=map_size then return end
 local a=min(y_start,y_end)
 local b=max(y_start,y_end)
 a=max(0,a)
 b=min(map_size-1,b)
 for y=a,b do
  set_wall(x,y,0)
  set_floor(x,y,floor_id)
 end
end

local function create_horizontal_corridor(n1,n2,edge)
 local left,right=n1,n2
 if n1.midx>n2.midx then left,right=n2,n1 end
 local r_left,r_right=left.rect,right.rect
 local y_start=max(r_left[2],r_right[2])
 local y_end=min(r_left[4],r_right[4])
 local y
 if y_start<=y_end then
  y=flr((y_start+y_end)/2)
 else
  y=flr((n1.midy+n2.midy)/2)
 end
 local jog_offset=0
 local jog_chance=(active_theme_rules and active_theme_rules.corridor_jog_chance) or adaptive_settings.corridor_jog_chance or 0.25
 if rnd(1)<jog_chance then
  local offset=(rnd(1)<0.5) and -1 or 1
  local candidate=y+offset
  if candidate>1 and candidate<map_size-2 then
   y=candidate
   jog_offset=offset
  end
 end
 local bx_left=r_left[3]+1
 local bx_right=r_right[1]-1
 local success=true
 if not place_boundary_door_with_retry(bx_left,y,door_normal,5) then
  success=false
  ensure_boundary_passage(bx_left,y)
 end
 if not place_boundary_door_with_retry(bx_right,y,door_normal,5) then
  success=false
  ensure_boundary_passage(bx_right,y)
 end
 carve_horizontal_span(y,bx_left+1,bx_right-1,gen_floor_id)
 verify_boundary_door(bx_left,y,door_normal)
 verify_boundary_door(bx_right,y,door_normal)
 edge.b1={x=bx_left,y=y}
 edge.b2={x=bx_right,y=y}
 edge.shape=jog_offset~=0 and "jog" or "straight"
 edge.metadata.corridor_y=y
 edge.metadata.jog_offset=jog_offset
 return success
end

local function create_vertical_corridor(n1,n2,edge)
 local top,bottom=n1,n2
 if n1.midy>n2.midy then top,bottom=n2,n1 end
 local r_top,r_bottom=top.rect,bottom.rect
 local x_start=max(r_top[1],r_bottom[1])
 local x_end=min(r_top[3],r_bottom[3])
 local x
 if x_start<=x_end then
  x=flr((x_start+x_end)/2)
 else
  x=flr((n1.midx+n2.midx)/2)
 end
 local jog_offset=0
 local jog_chance=(active_theme_rules and active_theme_rules.corridor_jog_chance) or adaptive_settings.corridor_jog_chance or 0.25
 if rnd(1)<jog_chance then
  local offset=(rnd(1)<0.5) and -1 or 1
  local candidate=x+offset
  if candidate>1 and candidate<map_size-2 then
   x=candidate
   jog_offset=offset
  end
 end
 local by_top=r_top[4]+1
 local by_bottom=r_bottom[2]-1
 local success=true
 if not place_boundary_door_with_retry(x,by_top,door_normal,5) then
  success=false
  ensure_boundary_passage(x,by_top)
 end
 if not place_boundary_door_with_retry(x,by_bottom,door_normal,5) then
  success=false
  ensure_boundary_passage(x,by_bottom)
 end
 carve_vertical_span(x,by_top+1,by_bottom-1,gen_floor_id)
 verify_boundary_door(x,by_top,door_normal)
 verify_boundary_door(x,by_bottom,door_normal)
 edge.b1={x=x,y=by_top}
 edge.b2={x=x,y=by_bottom}
 edge.shape=jog_offset~=0 and "jog" or "straight"
 edge.metadata.corridor_x=x
 edge.metadata.jog_offset=jog_offset
 return success
end

local function create_l_shaped_corridor(n1,n2,edge)
local orient_horizontal_first=rnd(1)<0.5
local anchor_x=orient_horizontal_first and n2.midx or n1.midx
local anchor_y=orient_horizontal_first and n1.midy or n2.midy
local jrect
local offsets={{0,0},{1,0},{-1,0},{0,1},{0,-1},{2,0},{-2,0},{0,2},{0,-2}}
local attempt_limit=adaptive_settings.junction_retry_limit or 4
for i=1,#offsets do
 local off=offsets[i]
 local cx=max(1,min(map_size-2,anchor_x+off[1]))
 local cy=max(1,min(map_size-2,anchor_y+off[2]))
 local candidate={cx-1,cy-1,cx+1,cy+1}
 if not rect_conflicts(candidate,{n1,n2},0) then
  jrect=candidate
  anchor_x=cx
  anchor_y=cy
  break
 end
 if i>=attempt_limit then break end
end
 local success=true
 if not jrect then
  -- fallback: carve direct manhattan path without junction
  orient_horizontal_first=true
  anchor_x=n2.midx
  anchor_y=n1.midy
  jrect=nil
  success=false
  if observability.log_corridors then
   gen_log("corridor","fallback L-shape without junction between rooms")
  end
 else
  fill_rect(jrect,0)
  for x=jrect[1],jrect[3] do
   for y=jrect[2],jrect[4] do
    set_floor(x,y,gen_floor_id)
   end
  end
  local jnode=add_room(jrect,true)
  edge.metadata.junction_node=jnode
 end

 local function connect_horizontal(from_node, target_x, y)
  local rect=from_node.rect
  local side=target_x>from_node.midx and 1 or -1
  local boundary_from=(side==1) and rect[3]+1 or rect[1]-1
  local boundary_to=side==1 and target_x-1 or target_x+1
  local door_pos=boundary_from
  if not place_boundary_door_with_retry(door_pos, y, door_normal,5) then
   success=false
   ensure_boundary_passage(door_pos,y)
  end
  carve_horizontal_span(y, boundary_from+side, boundary_to, gen_floor_id)
  verify_boundary_door(door_pos,y,door_normal)
  return {x=door_pos,y=y}
 end

 local function connect_vertical(from_node, x, target_y)
  local rect=from_node.rect
  local side=target_y>from_node.midy and 1 or -1
  local boundary_from=(side==1) and rect[4]+1 or rect[2]-1
  local boundary_to=side==1 and target_y-1 or target_y+1
  local door_pos=boundary_from
  if not place_boundary_door_with_retry(x,door_pos,door_normal,5) then
   success=false
   ensure_boundary_passage(x,door_pos)
  end
  carve_vertical_span(x, boundary_from+side, boundary_to, gen_floor_id)
  verify_boundary_door(x,door_pos,door_normal)
  return {x=x,y=door_pos}
 end

 local b1,b2
 if orient_horizontal_first then
  local horizontal_y=n1.midy
  b1=connect_horizontal(n1, anchor_x, horizontal_y)
  local vertical_x=jrect and anchor_x or b1.x+(anchor_x>b1.x and 1 or -1)
  b2=connect_vertical(n2, vertical_x, anchor_y)
 else
  local vertical_x=n1.midx
  b1=connect_vertical(n1, vertical_x, anchor_y)
  local horizontal_y=jrect and anchor_y or b1.y+(anchor_y>b1.y and 1 or -1)
  b2=connect_horizontal(n2, anchor_x, horizontal_y)
 end

 edge.b1=b1
 edge.b2=b2
 edge.shape="l_shape"
 edge.metadata.anchor={x=anchor_x,y=anchor_y}
 edge.metadata.orientation=orient_horizontal_first and "hv" or "vh"
 return success
end

function create_corridor(n1,n2)
 local edge={n1=n1,n2=n2,metadata={}}
 local ctype=get_corridor_type(n1.rect,n2.rect)
 local success=true
 if ctype=="horiz" then
  success=create_horizontal_corridor(n1,n2,edge)
 elseif ctype=="vert" then
  success=create_vertical_corridor(n1,n2,edge)
 else
  success=create_l_shaped_corridor(n1,n2,edge)
 end
 edge.success=success
 add(gen_edges,edge)
 add(n1.edges,n2)
 add(n2.edges,n1)
 if observability.log_corridors then
  local status=success and "ok" or "fallback"
  gen_log("corridor","linked nodes "..n1.index.." <-> "..n2.index.." ("..ctype..","..status..")")
 end
 return success
end

-- helper: try to generate and connect a room
function try_generate_room()
 if #gen_nodes==0 then return false end
 local base=gen_nodes[flr(rnd(#gen_nodes))+1]
 if not base then return false end
 local rect=random_room(base,false)
 
 if rect[1]<2 or rect[3]>map_size-3 or rect[2]<2 or rect[4]>map_size-3 then
  register_room_failure("bounds")
  return false
 end
 
 if rect_overlaps(rect) then
  register_room_failure("overlap")
  return false
 end
 
 local node=add_room(rect)
 fill_rect(rect,0)
 for x=max(0,rect[1]),min(map_size-1,rect[3]) do
  for y=max(0,rect[2]),min(map_size-1,rect[4]) do
   set_floor(x, y, gen_floor_id)
  end
 end
 local corridor_ok=create_corridor(base,node)
 if not corridor_ok and observability.log_corridors then
  gen_log("corridor","degenerate corridor between nodes "..base.index.." and "..node.index)
 end
 register_room_success()
 return true
end

-- helper: apply wall textures to room perimeter
function apply_room_walls(rect,tex)
 -- ensure tex is never 0
 if tex==0 then tex=1 end
 
 for x=rect[1],rect[3] do
  if rect[2]-1>=0 and rect[2]-1<128 and x>=0 and x<128 then
   -- skip reserved cells (doors/exits in any layer)
		if not is_reserved_boundary(x,rect[2]-1) then
     set_wall(x,rect[2]-1,tex)
   end
  end
  if rect[4]+1>=0 and rect[4]+1<128 and x>=0 and x<128 then
   -- skip reserved cells (doors/exits in any layer)
		if not is_reserved_boundary(x,rect[4]+1) then
     set_wall(x,rect[4]+1,tex)
   end
  end
 end
 for y=rect[2],rect[4] do
  if rect[1]-1>=0 and rect[1]-1<128 and y>=0 and y<128 then
   -- skip reserved cells (doors/exits in any layer)
		if not is_reserved_boundary(rect[1]-1,y) then
     set_wall(rect[1]-1,y,tex)
   end
  end
  if rect[3]+1>=0 and rect[3]+1<128 and y>=0 and y<128 then
   -- skip reserved cells (doors/exits in any layer)
		if not is_reserved_boundary(rect[3]+1,y) then
     set_wall(rect[3]+1,y,tex)
   end
  end
 end
end

-- repair step: ensure door tiles exist on walls layer for all logical doors
function enforce_door_tiles()
 for door in all(doors) do
  if not is_door(get_wall(door.x,door.y)) then
   set_wall(door.x,door.y,door.dtype or door_normal)
  end
 end
 
 -- also check doorgrid consistency
 for x=0,map_size-1 do
  if doorgrid[x] then
   for y=0,map_size-1 do
    if doorgrid[x][y] then
     local tile=get_wall(x,y)
     if not is_door(tile) then
      -- restore door tile from doorgrid or use default
      local correct_tile=doorgrid[x][y].tile or door_normal
      set_wall(x,y,correct_tile)
      if observability.log_repairs then
       gen_log("door","restored door tile at ("..x..","..y..")")
      end
     end
    end
   end
  end
 end
end

-- border ring enforcement: set outermost ring to walls while preserving doors/exits
function enforce_border_ring()
 -- top and bottom edges (y=0 and y=map_size-1)
 for x=0,map_size-1 do
  -- top edge
  local top_tile=get_wall(x,0)
  if not is_door(top_tile) and not is_exit(top_tile) then
  set_wall(x,0,wall_fill_tile)
  end
  
  -- bottom edge
  local bottom_tile=get_wall(x,map_size-1)
  if not is_door(bottom_tile) and not is_exit(bottom_tile) then
  set_wall(x,map_size-1,wall_fill_tile)
  end
 end
 
 -- left and right edges (x=0 and x=map_size-1)
 for y=0,map_size-1 do
  -- left edge
  local left_tile=get_wall(0,y)
  if not is_door(left_tile) and not is_exit(left_tile) then
  set_wall(0,y,wall_fill_tile)
  end
  
  -- right edge
  local right_tile=get_wall(map_size-1,y)
  if not is_door(right_tile) and not is_exit(right_tile) then
  set_wall(map_size-1,y,wall_fill_tile)
  end
 end
end

-- helper: random wall texture (never returns 0)
function random_wall_texture()
 local set=texsets[flr(rnd(#texsets-1))+2] -- skip texsets[1] which is floor
 return set.variants[flr(rnd(#set.variants))+1]
end

-- helper: get theme-appropriate wall texture set
function theme_wall_texture(theme)
 if theme=="out" then
  -- outdoor: grass or earth variants
  -- indices in texsets: 5=grass, 6=earth
  local idx=rnd(1)<0.5 and 5 or 6
  return texsets[idx] or texsets[1]
 elseif theme=="dem" then
  -- demon: stone or cobblestone
  -- indices: 4=stone, 2=cobblestone
  local idx=rnd(1)<0.5 and 4 or 2
  return texsets[idx] or texsets[1]
 elseif theme=="house" then
  -- house: wood plank
  -- index: 3=wood_plank
  return texsets[3] or texsets[1]
 else
  -- default dungeon: brick or cobblestone
  -- indices: 1=brick, 2=cobblestone
  local idx=rnd(1)<0.5 and 1 or 2
  return texsets[idx] or texsets[1]
 end
end

-- helper: find accessible rooms from start via edges
function find_accessible_rooms(start_node,locked_edges)
 local accessible={}
 local queue={start_node}
 local visited={}
 visited[start_node]=true
 
 while #queue>0 do
  local node=queue[1]
  deli(queue,1)
  add(accessible,node)
  
  for edge_node in all(node.edges) do
   if not visited[edge_node] then
    local is_locked=false
    if locked_edges then
     for le in all(locked_edges) do
					if (le.n1==node and le.n2==edge_node) or (le.n1==edge_node and le.n2==node) then
       is_locked=true
       break
      end
     end
    end
    
    if not is_locked then
     visited[edge_node]=true
     add(queue,edge_node)
    end
   end
  end
 end
 
 return accessible
end

-- helper: find spawn point in room
function find_spawn_point(rect)
 for attempt=1,max_spawn_attempts do
  local x=rect[1]+1+flr(rnd(rect[3]-rect[1]-1))
  local y=rect[2]+1+flr(rnd(rect[4]-rect[2]-1))
  
  if x>=0 and x<128 and y>=0 and y<128 and get_wall(x,y)==0 then
   local valid=true
   for obj in all(gen_objects) do
    local ox=obj.pos and obj.pos[1] or obj.x
    local oy=obj.pos and obj.pos[2] or obj.y
    if ox and oy then
     local dx,dy=abs(ox-x),abs(oy-y)
     if dx<1 and dy<1 then
      valid=false
      break
     end
    end
   end
   
   if valid then
    return x+0.5,y+0.5
   end
  end
 end
 return nil,nil
end

-- helper: erode map for organic feel (generalized for all wall types)
function erode_map(amount)
 local intensity=(active_theme_rules and active_theme_rules.erosion_intensity) or 1
 local target=flr(amount*intensity)
 local removed=0
 for i=1,target do
  local x,y=flr(rnd(map_size)),flr(rnd(map_size))
  if is_tile_protected(x,y) then goto continue end
  if is_wall(get_wall(x,y)) then
   local neighbors=0
   local near_protected=false
   for dx=-1,1 do
    for dy=-1,1 do
     local nx,ny=x+dx,y+dy
     if nx>=0 and nx<map_size and ny>=0 and ny<map_size then
      if is_tile_protected(nx,ny) then
       near_protected=true
      end
      if get_wall(nx,ny)==0 then
       neighbors+=1
      end
     end
    end
   end
   if not near_protected and neighbors>=3 then
    set_wall(x,y,0)
    set_floor(x,y,gen_floor_id)
    removed+=1
   end
  end
 ::continue::
 end
 if observability.log_corridors and removed>target*0.7 then
  gen_log("erosion","high erosion count "..removed.."/"..target)
 end
end

-- helper: generate exit portal on wall
function generate_exit(rect,exit_type)
 local walls={}
 for x=rect[1],rect[3] do
		if rect[2]-1>=0 and is_wall(get_wall(x,rect[2]-1)) then
   add(walls,{x,rect[2]})
  end
		if rect[4]+1<128 and is_wall(get_wall(x,rect[4]+1)) then
   add(walls,{x,rect[4]})
  end
 end
 for y=rect[2],rect[4] do
		if rect[1]-1>=0 and is_wall(get_wall(rect[1]-1,y)) then
   add(walls,{rect[1],y})
  end
		if rect[3]+1<128 and is_wall(get_wall(rect[3]+1,y)) then
   add(walls,{rect[3],y})
  end
 end
 
 if #walls>0 then
  local pos=walls[flr(rnd(#walls))+1]
  -- write exit tile to map
  local exit_tile=exit_type==3 and exit_start or exit_end
  set_wall(pos[1],pos[2],exit_tile or 0)
  -- also add interactable exit object
  local ob={
   pos={pos[1]+0.5,pos[2]+0.5},
   typ=obj_types.interactable_exit,
   rel={0,0},
   frame=0,
   animloop=true,
   autoanim=false,
   exit_type=exit_type
  }
  add(gen_objects,ob)
 end
end

-- gameplay generation: enemies, items, decorations, npcs
function generate_gameplay()
 -- guard against empty gen_nodes to avoid nil dereference
 if not gen_nodes or #gen_nodes==0 then
  gen_log("error","generate_gameplay() called with no rooms")
  printh("error: generate_gameplay() called with no rooms")
  return
 end
 local start_node=gen_nodes[1]
 local exit_node=gen_nodes[#gen_nodes]
 
 -- place start/exit portals
 generate_exit(start_node.rect,3)
 generate_exit(exit_node.rect,4)
 
 -- erode map
 erode_map(gen_params.erode_amount)
 
 -- populate inventory with health items
 for i=1,3 do
  add(gen_inventory,{type="heart"})
 end
 
 -- generate progression loop (simplified - no locking yet)
 generate_progression_loop(start_node)
 
 -- generate npcs (includes hostile and non-hostile)
 generate_npcs()
 
 -- generate items
 generate_items()
 
 -- generate decorations
 generate_decorations()
end

-- generate progression: items and locked doors
function generate_progression_loop(start_node)
 local locked_edges={}
 local key_counter=1
 
 -- cache accessible rooms for current locked_edges; recompute only after a successful lock
 local full_accessible=find_accessible_rooms(start_node,locked_edges)
 
 -- prepare shuffled edge order to avoid duplicate selection and ensure coverage
 local edges_shuffled={}
 for e in all(gen_edges) do add(edges_shuffled,e) end
 -- fisher-yates shuffle
 for i=#edges_shuffled,2,-1 do
  local j=flr(rnd(i))+1
  edges_shuffled[i],edges_shuffled[j]=edges_shuffled[j],edges_shuffled[i]
 end
 
 -- attempt to create progression gates
 for gate_idx=1,#edges_shuffled do
  if key_counter>3 then break end
  
  -- try to lock an edge
  local edge=edges_shuffled[gate_idx]
  local n1,n2=edge.n1,edge.n2
  
  -- check if this edge would gate content
  local combined_locked={}
  for le in all(locked_edges) do add(combined_locked,le) end
  add(combined_locked,edge)
  local test_accessible=find_accessible_rooms(start_node,combined_locked)
  
  -- if locking this edge hides new rooms, add it as a gate
  if #test_accessible<#full_accessible then
   local candidates={edge.b1,edge.b2}
   local chosen=nil
   for c in all(candidates) do
    if c and c.x and c.y then
     local wt=get_wall(c.x,c.y)
     if is_door(wt) then
      chosen=c
      break
     end
    end
   end
   if chosen then
    local x,y=chosen.x,chosen.y
    local door=doorgrid[x] and doorgrid[x][y] or nil
    if door then
     set_wall(x,y,door_locked)
     door.dtype=door_locked
     door.keynum=key_counter
     door.locked=true
    else
     set_wall(x,y,door_locked)
     create_door(x,y,door_locked,key_counter)
    end
    protect_tile(x,y)
    edge.locked=true
    edge.keynum=key_counter
    edge.lock_tile={x=x,y=y}
    add(locked_edges,edge)
    full_accessible=find_accessible_rooms(start_node,locked_edges)
    add(gen_inventory,{type="key",keynum=key_counter})
    if observability.log_progression then
     gen_log("progression","locked edge "..n1.index.." <-> "..n2.index.." key#"..key_counter)
    end
    key_counter+=1
   else
    if observability.log_progression then
     gen_log("progression","edge "..n1.index.." <-> "..n2.index.." missing door; skipped")
    end
   end
  end
 end
 
 -- place inventory items in accessible rooms
 local failed_placements=0
 -- compute accessible rooms once (does not change during item placement)
 local accessible=find_accessible_rooms(start_node,locked_edges)
 while #gen_inventory>0 do
  
  if #accessible>0 then
   local room=accessible[flr(rnd(#accessible))+1]
   local item=gen_inventory[1]
   deli(gen_inventory,1)
   
   local x,y=find_spawn_point(room.rect)
   if x then
    failed_placements=0
    if item.type=="key" then
     local ob={pos={x,y},typ=obj_types.key,rel={0,0},frame=0,animloop=true,autoanim=true,keynum=item.keynum,room_index=room.index}
     add(gen_objects,ob)
    else
     local ob={pos={x,y},typ=obj_types[item.type],rel={0,0},frame=0,animloop=true,autoanim=true}
     add(gen_objects,ob)
    end
   else
    -- handle failed placement
    if item.type=="key" then
     -- retry a limited number of times across different rooms
     local attempts=0
     local placed=false
     while attempts<15 and not placed do
      local rr=accessible[flr(rnd(#accessible))+1]
      local kx,ky=find_spawn_point(rr.rect)
      if kx then
       local ob={pos={kx,ky},typ=obj_types.key,rel={0,0},frame=0,animloop=true,autoanim=true,keynum=item.keynum,room_index=rr.index}
       add(gen_objects,ob)
       placed=true
       break
      end
      attempts+=1
     end
     if not placed then
      -- fallback: force place in start room (center if needed)
      local sx,sy=find_spawn_point(start_node.rect)
      if not sx then
       sx=start_node.midx+0.5
       sy=start_node.midy+0.5
      end
      local ob={pos={sx,sy},typ=obj_types.key,rel={0,0},frame=0,animloop=true,autoanim=true,keynum=item.keynum,room_index=start_node.index}
      add(gen_objects,ob)
     end
    else
     failed_placements+=1
     if failed_placements>10 then
      gen_log("items","failed to place items after multiple attempts; stopping")
      break
     end
    end
   end
  else
   break
  end
 end

validate_and_repair_progression(start_node,locked_edges)
gen_locked_edges=locked_edges
end

-- generate npcs (hostile and non-hostile) in rooms
function generate_npcs()
 for node in all(gen_nodes) do
  local rect=node.rect
  local num_npcs=flr(rnd(3))+1
  
  for i=1,num_npcs do
   local x,y=find_spawn_point(rect)
   if x then
    -- 70% hostile, 30% non-hostile
    if rnd(1)<gen_params.npc_hostile_ratio then
     -- select enemy type based on current difficulty level
     local available_enemies = {}
     for enemy in all(enemy_types) do
      if enemy.difficulty <= gen_params.difficulty then
       add(available_enemies, enemy)
      end
     end
     -- fallback to rat if no enemies available
     if #available_enemies == 0 then
      available_enemies = {enemy_types[1]}
     end
     local enemy_type = available_enemies[flr(rnd(#available_enemies))+1]
     
     -- hostile npc with patrol or follow behavior
     local ai_type=rnd(1)<0.5 and "patrol" or "follow"
     -- sprite_index from enemy_types configuration (64-72 range)
     local ob={
      pos={x,y},
      typ=obj_types.hostile_npc,
      rel={0,0},
      frame=0,
      animloop=true,
      autoanim=true,
      ai_type=ai_type,
      patrol_index=0,
      patrol_points={},
      sprite_index=enemy_type.sprite
     }
     -- generate patrol points if patrol mode
     if ai_type=="patrol" then
      for j=1,4 do
       local px,py=find_spawn_point(rect)
       if px then
        add(ob.patrol_points,{x=px,y=py})
       end
      end
      if #ob.patrol_points==0 then
       add(ob.patrol_points,{x=x,y=y})
      end
     end
     add(gen_objects,ob)
    else
     -- non-hostile NPCs use sprite 73
     local ob={
      pos={x,y},
      typ=obj_types.non_hostile_npc,
      rel={0,0},
      frame=0,
      animloop=true,
      autoanim=false,
      sprite_index=obj_types.non_hostile_npc.mx
     }
     add(gen_objects,ob)
    end
   end
  end
 end
end

-- generate items (pickups and interactables) in rooms
function generate_items()
 for node in all(gen_nodes) do
  local rect=node.rect
  local num_items=flr(rnd(gen_params.items_per_room))+1
  
  for i=1,num_items do
   local x,y=find_spawn_point(rect)
   if x then
    -- choose item type: 60% pickup, 40% interactable
    if rnd(1)<0.6 then
     -- direct pickup (heart or generic item)
     local pickup_type=rnd(1)<0.5 and "heart" or "direct_pickup"
     local obj_type=pickup_type=="heart" and obj_types.heart or obj_types.direct_pickup
     local ob={
      pos={x,y},
      typ=obj_type,
      rel={0,0},
      frame=0,
      animloop=true,
      autoanim=true
     }
     add(gen_objects,ob)
    else
     -- interactable (chest, shrine, trap, note)
     local subtypes={"chest","shrine","trap","note"}
     local subtype=subtypes[flr(rnd(#subtypes))+1]
     local obj_type
     if subtype=="chest" then
      obj_type=obj_types.interactable_chest
     elseif subtype=="shrine" then
      obj_type=obj_types.interactable_shrine
     elseif subtype=="trap" then
      obj_type=obj_types.interactable_trap
     else
      obj_type=obj_types.interactable_note
     end
     local ob={
      pos={x,y},
      typ=obj_type,
      rel={0,0},
      frame=0,
      animloop=true,
      autoanim=false,
      subtype=subtype
     }
     add(gen_objects,ob)
    end
   end
  end
 end
end

-- generate decorations in rooms
function generate_decorations()
 local current_theme=gen_params.theme or "dng"
 local theme_config=themes[current_theme] or themes.dng
 local decor_prob=theme_config.decor_prob or 0.8
 
 for node in all(gen_nodes) do
  local rect=node.rect
  local w,h=rect[3]-rect[1]+1,rect[4]-rect[2]+1
  local room_decor_count=0
  local max_decor=gen_params.max_decorations_per_room or 12
  
  -- uniform grid pattern
  for dec in all(decoration_types) do
   if room_decor_count>=max_decor then break end
   
   -- filter by theme: check if any theme_tags match current_theme
   local theme_match=false
   if dec.theme_tags then
    for tag in all(dec.theme_tags) do
     if tag==current_theme then
      theme_match=true
      break
     end
    end
   else
    theme_match=true -- no theme_tags means always match
   end
   
   if theme_match and dec.gen_tags then
    for tag in all(dec.gen_tags) do
     if room_decor_count>=max_decor then break end
     
     if tag=="uni" and rnd(1)<0.3*decor_prob then
      for dx=2,w-2,3 do
       for dy=2,h-2,3 do
        if room_decor_count>=max_decor then break end
        if rnd(1)<0.5 then
         local x,y=rect[1]+dx+0.5,rect[2]+dy+0.5
         -- sprite_index from decoration_types configuration (148-155 range)
         local ob={pos={x,y},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,sprite_index=dec.sprite}
         add(gen_objects,ob)
         room_decor_count+=1
        end
       end
       if room_decor_count>=max_decor then break end
      end
      
     elseif tag=="uni2" and rnd(1)<0.4*decor_prob then
      -- denser uniform grid
      for dx=1,w-1,2 do
       for dy=1,h-1,2 do
        if room_decor_count>=max_decor then break end
        if rnd(1)<0.6 then
         local x,y=rect[1]+dx+0.5,rect[2]+dy+0.5
         local ob={pos={x,y},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,sprite_index=dec.sprite}
         add(gen_objects,ob)
         room_decor_count+=1
        end
       end
       if room_decor_count>=max_decor then break end
      end
      
     elseif tag=="scatter" and rnd(1)<0.2*decor_prob then
      local count=flr(rnd(3))+1
      for i=1,count do
       if room_decor_count>=max_decor then break end
       local x,y=find_spawn_point(rect)
       if x then
        local ob={pos={x,y},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,sprite_index=dec.sprite}
        add(gen_objects,ob)
        room_decor_count+=1
       end
      end
      
     elseif tag=="big" and rnd(1)<0.15*decor_prob then
      if room_decor_count>=max_decor then break end
      -- large object: place at room center or corner
      local cx,cy=flr((rect[1]+rect[3])/2)+0.5,flr((rect[2]+rect[4])/2)+0.5
      if rnd(1)<0.5 then
       -- center
       local ob={pos={cx,cy},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,sprite_index=dec.sprite}
       add(gen_objects,ob)
       room_decor_count+=1
      else
       -- random corner
       local corners={{rect[1]+1.5,rect[2]+1.5},{rect[3]-0.5,rect[2]+1.5},{rect[1]+1.5,rect[4]-0.5},{rect[3]-0.5,rect[4]-0.5}}
       local corner=corners[flr(rnd(#corners))+1]
       local ob={pos={corner[1],corner[2]},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,sprite_index=dec.sprite}
       add(gen_objects,ob)
       room_decor_count+=1
      end
      
     elseif tag=="rare" and rnd(1)<0.05*decor_prob then
      if room_decor_count>=max_decor then break end
      -- rare: single spawn
      local x,y=find_spawn_point(rect)
      if x then
       local ob={pos={x,y},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,sprite_index=dec.sprite}
       add(gen_objects,ob)
       room_decor_count+=1
      end
      
     elseif tag=="lit" and rnd(1)<0.25*decor_prob then
      if room_decor_count>=max_decor then break end
      -- lit: bias toward walls or doorways
      local walls={}
      -- collect wall-adjacent floor tiles
      for x=rect[1]+1,rect[3]-1 do
       if get_wall(x,rect[2])>0 then add(walls,{x+0.5,rect[2]+1.5}) end
       if get_wall(x,rect[4])>0 then add(walls,{x+0.5,rect[4]-0.5}) end
      end
      for y=rect[2]+1,rect[4]-1 do
       if get_wall(rect[1],y)>0 then add(walls,{rect[1]+1.5,y+0.5}) end
       if get_wall(rect[3],y)>0 then add(walls,{rect[3]-0.5,y+0.5}) end
      end
      if #walls>0 then
       local pos=walls[flr(rnd(#walls))+1]
       local ob={pos={pos[1],pos[2]},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,sprite_index=dec.sprite}
       add(gen_objects,ob)
       room_decor_count+=1
      end
     end
    end
   end
  end
 end
end

-- generate a complete dungeon
function generate_dungeon(opts)
 opts=opts or {}
 local seed=opts.seed or flr(rnd(1000000))
 srand(seed)
 gen_history={}
 clear_protected()
 reset_adaptive_spacing()
 if gen_params.spacing==nil then gen_params.spacing=0 end
 if observability.log_seed then
  gen_log("seed","generation seed "..seed)
 end
 
 -- initialize state
 gen_rects={}
 gen_nodes={}
 gen_edges={}
 gen_inventory={}
 gen_objects={}
 doors={}
 animated_objects={}
 -- clear doorgrid
 for x=0,map_size-1 do
  if doorgrid[x] then
   for y=0,map_size-1 do
    doorgrid[x][y]=nil
   end
  end
 end
 
 -- fill with walls (non-zero tile)
 fill_rect({0,0,map_size-1,map_size-1},wall_fill_tile)
 
 -- assign global theme before carving (ensures theme floor id is available)
 local selected_theme=opts.theme or "dng"
 if not opts.theme then
  local theme_roll=rnd(1)
  if theme_roll<0.7 then
   selected_theme="dng"
  elseif theme_roll<0.9 then
   selected_theme="out"
  else
   selected_theme="dem"
  end
 end
 gen_params.theme=selected_theme
 ensure_theme_rules(selected_theme)
 local theme_config=themes[selected_theme] or themes.dng
 
 -- set floor and ceiling types based on theme
 local floor_idx=1
 local roof_idx=3
 if theme_config.floor=="stone_tile" then floor_idx=1
 elseif theme_config.floor=="dirt" then floor_idx=2
 end
 if theme_config.roof=="stone_ceiling" then roof_idx=3
 elseif theme_config.roof=="sky" then roof_idx=4
 elseif theme_config.roof=="night_sky" then roof_idx=5
 end
 floor.typ=planetyps[floor_idx]
 roof.typ=planetyps[roof_idx]
 floor.x,floor.y=0,0
 roof.x,roof.y=0,0
 -- theme-specific floor id used by generator when carving/eroding
 gen_floor_id=floor_idx
 
 -- generate first room
 local first_rect=random_room(nil,false)
 local first_node=add_room(first_rect)
 fill_rect(first_rect,0)
 for x=max(0,first_rect[1]),min(map_size-1,first_rect[3]) do
  for y=max(0,first_rect[2]),min(map_size-1,first_rect[4]) do
   set_floor(x, y, gen_floor_id)
  end
 end
 register_room_success()
 
 -- generate additional rooms
 local target_rooms=flr(rnd(gen_params.max_rooms-gen_params.min_rooms+1))+gen_params.min_rooms
 for i=2,target_rooms do
  local placed=false
  for attempt=1,max_room_attempts do
   if try_generate_room() then
    placed=true
    break
   end
  end
  if not placed and observability.log_room_attempts then
   gen_log("room","failed to place room "..i.." after "..max_room_attempts.." attempts")
  end
 end
 
 -- apply wall textures based on theme
 for node in all(gen_nodes) do
  if not node.is_junction then
   local texset=theme_wall_texture(selected_theme)
   local tex=texset.variants[flr(rnd(#texset.variants))+1]
   apply_room_walls(node.rect,tex)
  end
 end
 
 -- ensure any doors placed earlier remain doors on the walls layer
 enforce_door_tiles()
 
 -- generate gameplay content (now aware of theme)
 generate_gameplay()
 -- gameplay may lock doors; re-assert tiles
 enforce_door_tiles()
 
 -- enforce border ring while preserving doors/exits
 enforce_border_ring()
 -- re-assert door tiles after border enforcement
 enforce_door_tiles()
 if observability.enable_console then
  gen_log("summary","border ring enforced")
 end
 
 -- export objects to global arrays (flat iteration, no spatial grid)
 objects=gen_objects
 
 -- populate animated_objects list for frame updates
 animated_objects={}
 for ob in all(objects) do
  if ob.autoanim then
   add(animated_objects, ob)
  end
 end
 
 -- set player start
 player.x=first_node.midx+0.5
 player.y=first_node.midy+0.5
 
 if observability.enable_console then
  gen_log("summary","rooms="..#gen_nodes.." objects="..#gen_objects)
 end
 
 return {x=player.x,y=player.y},{rooms=#gen_nodes,objects=#gen_objects,seed=seed,history=gen_history}
end


:: src/procgen/dungeon_harness.lua
-- deterministic dungeon generation harness
local harness={}

harness.default_seeds={1111,2222,3333,4444,5555}

local function validate_locked_edges(issues)
 if not gen_locked_edges then return end
 for edge in all(gen_locked_edges) do
  if edge.locked and edge.keynum then
   local lt=edge.lock_tile
   if not lt then
    add(issues,"edge "..edge.n1.index.."->"..edge.n2.index.." missing lock tile")
   else
    local tile=get_wall(lt.x,lt.y)
    if tile~=door_locked then
     add(issues,"door at "..lt.x..","..lt.y.." not locked")
    end
   end
   local key_found=false
   for ob in all(gen_objects) do
    if ob.typ==obj_types.key and ob.keynum==edge.keynum then
     key_found=true
     break
    end
   end
   if not key_found then
    add(issues,"missing key#"..edge.keynum.." for edge "..edge.n1.index.."->"..edge.n2.index)
   end
  end
 end
end

function harness.run(seeds)
 seeds=seeds or harness.default_seeds
 local summary={
  total=#seeds,
  failures=0,
  results={}
 }
 local original_seed=nil
 for _,seed in ipairs(seeds) do
  local ok,meta=pcall(function()
   local _,stats=generate_dungeon({seed=seed})
   return stats
  end)
  local record={seed=seed,issues={},rooms=0,objects=0}
  if not ok then
   record.error=meta
   summary.failures+=1
  else
   record.rooms=meta.rooms or 0
   record.objects=meta.objects or 0
   if record.rooms<(gen_params.min_rooms or 0) then
    add(record.issues,"room count "..record.rooms.." below min "..gen_params.min_rooms)
   end
   validate_locked_edges(record.issues)
   if #record.issues>0 then
    summary.failures+=1
   end
  end
  add(summary.results,record)
 end
 return summary
end

dungeon_harness=harness
return harness


:: src/render/r_batch.lua
--[[pod_format="raw",created="2025-11-12 00:00:00",modified="2025-11-12 00:00:00",revision=1]]
-- r_batch.lua
-- Central batching for tline3d and rectfill operations

local r_batch = {}

-- Batch configuration
local TLINE_COLS = 13  -- sprite_index, x0,y0,x1,y1, u0,v0,u1,v1, w0,w1, flags
local RECT_COLS = 5    -- x0,y0,x1,y1, color

-- Buffer capacities
local tline_capacity = 480 * 2  -- 2x screen width
local rect_capacity = 480 * 4   -- 4x screen width

-- Batch buffers
local tline_args = nil
local rect_args = nil
local tline_count = 0
local rect_count = 0

-- Current clip/palette state (for pass isolation)
local current_clip = nil
local current_palette = nil

-- Initialize batch buffers
function r_batch.init()
  tline_args = userdata("f64", TLINE_COLS, tline_capacity)
  rect_args = userdata("f64", RECT_COLS, rect_capacity)
  tline_count = 0
  rect_count = 0
  printh("[r_batch] initialized: tline=" .. tline_capacity .. ", rect=" .. rect_capacity)
end

-- Reset tline batch
function r_batch.tline_reset()
  tline_count = 0
end

-- Push a tline3d call to batch
function r_batch.tline_push(idx, x0, y0, x1, y1, u0, v0, u1, v1, w0, w1, flags)
  if tline_count >= tline_capacity then
    r_batch.tline_submit()
  end
  
  tline_args:set(0, tline_count, 
    idx, x0, y0, x1, y1, 
    u0, v0, u1, v1, 
    w0 or 1, w1 or 1, 
    flags or 0)
  tline_count = tline_count + 1
end

-- Submit tline batch
function r_batch.tline_submit()
  if tline_count > 0 then
    tline3d(tline_args, 0, tline_count, TLINE_COLS)
    tline_count = 0
  end
end

-- Reset rect batch
function r_batch.rect_reset()
  rect_count = 0
end

-- Push a rectfill call to batch
function r_batch.rect_push(x0, y0, x1, y1, c)
  if rect_count >= rect_capacity then
    r_batch.rect_submit()
  end
  
  rect_args:set(0, rect_count, x0, y0, x1, y1, c)
  rect_count = rect_count + 1
end

-- Submit rect batch
function r_batch.rect_submit()
  if rect_count > 0 then
    rectfill(rect_args, 0, rect_count, RECT_COLS)
    rect_count = 0
  end
end

-- Set clip region for current pass
function r_batch.set_clip(x, y, w, h)
  -- Flush any pending batches before changing state
  r_batch.tline_submit()
  r_batch.rect_submit()
  
  if x == nil then
    clip()
    current_clip = nil
  else
    clip(x, y, w, h)
    current_clip = {x, y, w, h}
  end
end

-- Set palette for current pass
function r_batch.set_palette(pal_table)
  -- Flush any pending batches before changing state
  r_batch.tline_submit()
  r_batch.rect_submit()
  
  if pal_table == nil then
    pal()
    current_palette = nil
  else
    pal(pal_table)
    current_palette = pal_table
  end
end

-- Restore default state (called at pass boundaries)
function r_batch.restore_defaults()
  r_batch.tline_submit()
  r_batch.rect_submit()
  clip()
  pal()
  palt()
  current_clip = nil
  current_palette = nil
end

return r_batch


:: src/render/r_cast.lua
--[[pod_format="raw",created="2025-11-12 00:00:00",modified="2025-11-12 00:00:00",revision=1]]
-- r_cast.lua
-- DDA raycaster writing hit data to userdata buffers

local r_cast = {}
local assert_lib = include"src/lib/assert.lua"

-- Sign helper
local function sgn(n)
  if n < 0 then return -1 end
  if n > 0 then return 1 end
  return 0
end

-- DDA raycast with depth tracking
-- Returns: z, hit_x, hit_y, tile, tx
local function raycast_dda(x, y, dx, dy, fx, fy, far_plane, map_size, get_wall_fn, is_door_fn, doorgrid, test_door_mode, test_door_open)
  -- Preserve original signs for step directions
  local sdx = dx
  local sdy = dy

  -- Clamp near-zero components but keep sign
  if abs(dx) < 0.01 then dx = (sdx < 0) and -0.01 or 0.01 end
  if abs(dy) < 0.01 then dy = (sdy < 0) and -0.01 or 0.01 end
  
  -- Horizontal ray initialization (vertical gridlines)
  local hx, hy = x, y
  local hdx = (sdx < 0) and -1 or 1
  local hdy = dy / abs(dx)
  local hdz = hdx * fx + hdy * fy
  local hz = 0
  
  -- Step to grid boundary
  local fracx = hx % 1
  local hstep = (hdx > 0) and (1 - fracx) or fracx
  hx = hx + hdx * hstep
  hy = hy + hdy * hstep
  hz = hz + hdz * hstep
  
  -- Vertical ray initialization (horizontal gridlines)
  local vx, vy = x, y
  local vdx = dx / abs(dy)
  local vdy = (sdy < 0) and -1 or 1
  local vdz = vdx * fx + vdy * fy
  local vz = 0
  
  -- Step to grid boundary
  local fracy = vy % 1
  local vstep = (vdy > 0) and (1 - fracy) or fracy
  vx = vx + vdx * vstep
  vy = vy + vdy * vstep
  vz = vz + vdz * vstep
  
  -- Compute iteration limit
  local horizontal_crossings = (hdx > 0) and (map_size - math.floor(hx)) or (math.floor(hx) + 1)
  local vertical_crossings = (vdy > 0) and (map_size - math.floor(vy)) or (math.floor(vy) + 1)
  local iteration_limit = min(256, horizontal_crossings + vertical_crossings + 10)
  
  -- Ray marching
  for iter = 1, iteration_limit do
    -- Far-plane check
    if min(hz, vz) > far_plane then
      return 999, hx, hy, 0, 0
    end
    
    if hz < vz then
      -- Horizontal crossing (vertical gridline)
      local gx = math.floor(hx) + ((hdx < 0) and -1 or 0)
      local gy = math.floor(hy)
      
      -- OOB check
      if (gx < 0 and hdx < 0) or (gx >= map_size and hdx > 0) or 
         (gy < 0 and hdy < 0) or (gy >= map_size and hdy > 0) then
        return 999, hx, hy, 0, 0
      end
      
      if gx >= 0 and gx < map_size and gy >= 0 and gy < map_size then
        local m = get_wall_fn(gx, gy)
        if m > 0 then
          -- Check if door
          if is_door_fn(m) and doorgrid[gx] and doorgrid[gx][gy] then
            local dz = ((hx + hdx / 2 - x) * fx + (hy + hdy / 2 - y) * fy)
            if dz <= vz then
              local open = test_door_mode and (test_door_open or 0) or doorgrid[gx][gy].open
              local dy_off = (hy + hdy / 2) % 1 - open
              if dy_off >= 0 then
                return dz, hx, hy, m, dy_off
              end
            end
          else
            -- Wall hit
            local z = ((hx - x) * fx + (hy - y) * fy)
            local frac = hy - math.floor(hy)
            local tx = (hdx > 0) and (1 - frac) or frac
            return z, hx, hy, m, tx
          end
        end
      end
      
      hx = hx + hdx
      hy = hy + hdy
      hz = hz + hdz
    else
      -- Vertical crossing (horizontal gridline)
      local gx = math.floor(vx)
      local gy = math.floor(vy) + ((vdy < 0) and -1 or 0)
      
      -- OOB check
      if (gx < 0 and vdx < 0) or (gx >= map_size and vdx > 0) or 
         (gy < 0 and vdy < 0) or (gy >= map_size and vdy > 0) then
        return 999, vx, vy, 0, 0
      end
      
      if gx >= 0 and gx < map_size and gy >= 0 and gy < map_size then
        local m = get_wall_fn(gx, gy)
        if m > 0 then
          -- Check if door
          if is_door_fn(m) and doorgrid[gx] and doorgrid[gx][gy] then
            local dz = ((vx + vdx / 2 - x) * fx + (vy + vdy / 2 - y) * fy)
            if dz <= hz then
              local open = test_door_mode and (test_door_open or 0) or doorgrid[gx][gy].open
              local dx_off = (vx + vdx / 2) % 1 - open
              if dx_off >= 0 then
                return dz, vx, vy, m, dx_off
              end
            end
          else
            -- Wall hit
            local z = ((vx - x) * fx + (vy - y) * fy)
            local frac = vx - math.floor(vx)
            local tx = (vdy < 0) and (1 - frac) or frac
            return z, vx, vy, m, tx
          end
        end
      end
      
      vx = vx + vdx
      vy = vy + vdy
      vz = vz + vdz
    end
  end
  
  -- Fallback
  return 999, hx, hy, 0, 0
end

-- Cast scene: populate ray hit buffers
-- camera: {x, y} position table
-- r_view: view module with forward/right vectors
-- r_state: renderer state with buffers
-- game_state: {get_wall, is_door, doorgrid, test_door_mode, test_door_open, far_plane, map_size}
function r_cast.cast_scene(camera, r_view, r_state, game_state)
  -- Defensive guards: avoid indexing nil when wiring is incomplete
  if not r_state or not r_state.occupancy or (r_state.occupancy.rays_active or 0) <= 0 then
    printh("[r_cast] WARN: no active rays; skipping cast")
    return
  end
  if not game_state or
     type(game_state.get_wall) ~= "function" or
     type(game_state.is_door) ~= "function" or
     type(game_state.doorgrid) ~= "table" or
     game_state.far_plane == nil or
     game_state.map_size == nil then
    printh("[r_cast] WARN: invalid game_state; skipping cast")
    return
  end

  local bufs = r_state.buffers
  local ray_cnt = r_state.occupancy.rays_active
  local fx, fy = r_view.forward_x, r_view.forward_y
  
  for i = 0, ray_cnt - 1 do
    local dx = bufs.ray_dir_x:get(i)
    local dy = bufs.ray_dir_y:get(i)
    
    local z, hx, hy, tile, tx = raycast_dda(
      camera.x, camera.y, dx, dy, fx, fy,
      game_state.far_plane, game_state.map_size,
      game_state.get_wall, game_state.is_door,
      game_state.doorgrid, game_state.test_door_mode, game_state.test_door_open
    )
    
    bufs.ray_z:set(i, z)
    bufs.ray_hitx:set(i, hx)
    bufs.ray_hity:set(i, hy)
    bufs.ray_tile:set(i, tile)
    bufs.ray_tx:set(i, tx)
  end
end

-- Contract verification harness
-- Call after cast_scene() to verify hit detection
function r_cast.verify_contract(r_state, game_state)
  local bufs = r_state.buffers
  local ray_cnt = r_state.occupancy.rays_active

  printh("[r_cast] verifying contract for " .. ray_cnt .. " rays...")

  local hits_found = 0
  local valid_depths = 0

  for i = 0, math.min(ray_cnt - 1, 9) do  -- Check first 10 rays
    local z = bufs.ray_z:get(i)
    local tile = bufs.ray_tile:get(i)

    if tile > 0 then
      hits_found = hits_found + 1
    end

    if z > 0 and z < game_state.far_plane then
      valid_depths = valid_depths + 1
    end
  end

  local success = hits_found > 0 and valid_depths > 0
  printh(string.format("[r_cast] hits: %d, valid depths: %d, contract: %s",
    hits_found, valid_depths, success and "PASSED" or "FAILED"))

  return success
end

return r_cast


:: src/render/r_diag.lua
--[[pod_format="raw",created="2025-11-12 00:00:00",modified="2025-11-12 00:00:00",revision=1]]
-- r_diag.lua
-- Diagnostics overlay gated by debug_mode

local r_diag = {}

-- Draw diagnostics panel
-- r_state: renderer state with occupancy counters
-- frame_ms: frame time in milliseconds
-- cpu_sample: CPU usage from stat(1)
function r_diag.draw(r_state, frame_ms, cpu_sample)
  if not r_state.config.debug_mode then
    return
  end
  
  local cfg = r_state.config
  local occ = r_state.occupancy
  
  -- Format metrics
  frame_ms = frame_ms or 0
  cpu_sample = cpu_sample or 0
  local cpu_pct = math.floor(cpu_sample * 1000 + 0.5) / 10
  local frame_ms_fmt = math.floor(frame_ms * 10 + 0.5) / 10
  local rays_text = occ.rays_active .. "/" .. cfg.ray_count
  
  local lines = {
    {text = "r_diag: metrics", color = 11},
    {text = "frame_ms: " .. frame_ms_fmt, color = 11},
    {text = "cpu%: " .. cpu_pct, color = (cpu_pct > 90) and 8 or ((cpu_pct > 70) and 10 or 11)},
    {text = "rays: " .. rays_text, color = 7},
    {text = "floor rows: " .. occ.floor_rows, color = 7},
    {text = "wall spans: " .. occ.wall_spans, color = 7},
    {text = "sprite count: " .. occ.sprite_count, color = 7}
  }
  
  -- Compute panel dimensions
  local max_len = 0
  for entry in all(lines) do
    if #entry.text > max_len then
      max_len = #entry.text
    end
  end
  
  local panel_x = 4
  local panel_y = 80
  local panel_w = max_len * 4 + 6
  local panel_h = #lines * 8 + 6
  
  -- Save clip/palette state
  local prev_clip = peek(0x5f20, 4)
  
  -- Draw panel background and border
  clip()
  rectfill(panel_x - 2, panel_y - 2, panel_x + panel_w, panel_y + panel_h, 1)
  rect(panel_x - 3, panel_y - 3, panel_x + panel_w + 1, panel_y + panel_h + 1, 7)
  
  -- Draw text
  for i = 1, #lines do
    local entry = lines[i]
    print(entry.text, panel_x, panel_y + (i - 1) * 8, entry.color)
  end
  
  -- Restore clip state
  clip()
end

return r_diag


:: src/render/r_floor.lua
--[[pod_format="raw",created="2025-11-12 00:00:00",modified="2025-11-12 00:00:00",revision=1]]
-- r_floor.lua
-- Hybrid floor/ceiling renderer with near/mid/far row scheduling

local r_floor = {}
local assert_lib = include"lib/assert.lua"

-- Preallocated buffers for per-cell floor runs (avoid per-frame allocations)
local RUN_CAP = 1024
local runs_x0 = userdata("i16", RUN_CAP)
local runs_x1 = userdata("i16", RUN_CAP)
local runs_id = userdata("i16", RUN_CAP)
local merged_x0 = userdata("i16", RUN_CAP)
local merged_x1 = userdata("i16", RUN_CAP)
local merged_id = userdata("i16", RUN_CAP)

-- Clamped blit helper
local function clamped_blit(src_row, dst_row, screen_center_y, screen_height, y1_limit, r_state)
  if dst_row > y1_limit then return end
  local dst_y = screen_center_y + dst_row
  if dst_y < 0 or dst_y >= screen_height then return end
  local src_y = screen_center_y + src_row
  if src_y < 0 or src_y >= screen_height then return end
  blit(get_draw_target(), get_draw_target(), 0, src_y, 0, dst_y, screen_width, 1)
  r_state.occupancy.floor_rows = r_state.occupancy.floor_rows + 1
end

-- Resolve sprite index with fallback
local function resolve_sprite_index(idx, kind, error_idx_table, get_spr_fn)
  if idx and get_spr_fn(idx) then
    return idx
  end
  if error_idx_table then
    if kind == "floor" then return error_idx_table.floor
    elseif kind == "ceiling" then return error_idx_table.ceiling
    else return error_idx_table.default end
  end
  return 0
end

-- Draw single row with optional per-cell floor sampling
local function draw_single_row(row, src, tex, tilesize, height, cx, cy, sa, ca, sdist, screen_center_y, screen_width, sprite_size, r_batch, r_state, per_cell_floors, get_floor_fn, planetyps, error_idx_table, get_spr_fn)
  local y = row
  local y_offset = (y >= 0) and (y + 0.5) or abs(y - 0.5)
  local g = y_offset / sdist
  if g < 0.0001 then g = 0.0001 end
  local z = (height or 0.5) / g
  local mx = (cx + z * sa) / tilesize
  local my = (cy + z * ca) / tilesize
  local s = sdist / z * tilesize
  local mdx = -ca / s
  local mdy = sa / s
  mx = mx - screen_center_x * mdx
  my = my - screen_center_x * mdy
  
  if per_cell_floors then
    -- Per-cell floor sampling
    local sample_interval = 12
    local rcount = 0
    local cur_id = -1
    local cur_x0 = 0
    
    for x = 0, screen_width - 1, sample_interval do
      local wx = mx + x * mdx
      local wy = my + x * mdy
      local gx = math.floor(wx)
      local gy = math.floor(wy)
      local fid = get_floor_fn(gx, gy)
      
      if cur_id < 0 then
        cur_id = fid
        cur_x0 = x
      elseif fid ~= cur_id then
        if rcount < RUN_CAP then
          runs_x0:set(rcount, cur_x0)
          runs_x1:set(rcount, x - 1)
          runs_id:set(rcount, cur_id)
          rcount = rcount + 1
        end
        cur_id = fid
        cur_x0 = x
      end
    end
    
    if rcount < RUN_CAP then
      runs_x0:set(rcount, cur_x0)
      runs_x1:set(rcount, screen_width - 1)
      runs_id:set(rcount, cur_id)
      rcount = rcount + 1
    end
    
    -- Merge tiny runs
    local mcount = 0
    for i = 0, rcount - 1 do
      local x0i = runs_x0:get(i)
      local x1i = runs_x1:get(i)
      local fidi = runs_id:get(i)
      local width = x1i - x0i + 1
      if width < 4 and mcount > 0 then
        local prev_x1 = merged_x1:get(mcount - 1)
        if x1i > prev_x1 then merged_x1:set(mcount - 1, x1i) end
      else
        if mcount < RUN_CAP then
          merged_x0:set(mcount, x0i)
          merged_x1:set(mcount, x1i)
          merged_id:set(mcount, fidi)
          mcount = mcount + 1
        end
      end
    end
    
    -- Draw merged runs
    for i = 0, mcount - 1 do
      local rx0 = merged_x0:get(i)
      local rx1 = merged_x1:get(i)
      local fid = merged_id:get(i)
      local run_tex = tex
      if fid > 0 and fid <= #planetyps then
        run_tex = planetyps[fid].tex
      end
      local idx = resolve_sprite_index(run_tex, "floor", error_idx_table, get_spr_fn)
      local u0 = ((mx + rx0 * mdx) % 1) * sprite_size
      local v0 = ((my + rx0 * mdy) % 1) * sprite_size
      u0 = math.max(0, math.min(sprite_size - 0.001, u0))
      v0 = math.max(0, math.min(sprite_size - 0.001, v0))
      local u1 = u0 + (rx1 - rx0) * mdx * sprite_size
      local v1 = v0 + (rx1 - rx0) * mdy * sprite_size
      r_batch.tline_push(idx, rx0, screen_center_y + y, rx1, screen_center_y + y, u0, v0, u1, v1, 1, 1)
    end
  else
    -- Single texture for entire row
    local idx = resolve_sprite_index(tex, "floor", error_idx_table, get_spr_fn)
    local u0 = (mx % 1) * sprite_size
    local v0 = (my % 1) * sprite_size
    u0 = math.max(0, math.min(sprite_size - 0.001, u0))
    v0 = math.max(0, math.min(sprite_size - 0.001, v0))
    local u1 = u0 + (screen_width - 1) * mdx * sprite_size
    local v1 = v0 + (screen_width - 1) * mdy * sprite_size
    r_batch.tline_push(idx, 0, screen_center_y + y, screen_width - 1, screen_center_y + y, u0, v0, u1, v1, 1, 1)
  end
  
  r_state.occupancy.floor_rows = r_state.occupancy.floor_rows + 1
end

-- Draw floor and ceiling with hybrid duplication schedule
-- camera: {x, y} position
-- r_view: view module with forward/right vectors and sdist
-- r_state: renderer state
-- r_batch: batch module
-- game_state: {floor, roof, sprite_size, per_cell_floors_enabled, get_floor, planetyps, error_textures, ERROR_IDX, get_spr}
function r_floor.draw_floor_ceiling(camera, r_view, r_state, r_batch, game_state)
  -- Contract guards
  assert_lib.is_not_nil(game_state.floor, "r_floor: game_state.floor required")
  assert_lib.is_not_nil(game_state.roof, "r_floor: game_state.roof required")
  assert_lib.is_not_nil(game_state.get_spr, "r_floor: game_state.get_spr required")
  assert_lib.is_type(game_state.get_spr, "function", "r_floor: game_state.get_spr must be callable")
  assert_lib.is_not_nil(game_state.planetyps, "r_floor: game_state.planetyps required")
  assert_lib.is_type(game_state.planetyps, "table", "r_floor: game_state.planetyps must be table")
  assert_lib.is_not_nil(game_state.ERROR_IDX, "r_floor: game_state.ERROR_IDX required")
  if game_state.per_cell_floors_enabled then
    assert_lib.is_not_nil(game_state.get_floor, "r_floor: game_state.get_floor required when per_cell_floors_enabled")
    assert_lib.is_type(game_state.get_floor, "function", "r_floor: game_state.get_floor must be callable")
  end

  local cfg = r_state.config
  local screen_center_y = cfg.screen_height / 2
  local screen_width = cfg.screen_width
  local screen_height = cfg.screen_height
  local fwdy = r_view.forward_y
  local fwdx = r_view.forward_x
  local sdist = r_view.sdist
  local sprite_size = game_state.sprite_size or 32
  
  palt(0, false)
  
  r_batch.tline_reset()
  
  -- Draw ceiling
  local roof_typ = game_state.roof.typ
  local roof_src = game_state.get_spr(roof_typ.tex)
  local y0_ceil = -screen_center_y
  local y1_ceil = -1
  
  -- Near ceiling rows (every row)
  local near_end = math.min(y1_ceil, -16)
  for y = y0_ceil, near_end do
    draw_single_row(y, roof_src, roof_typ.tex, roof_typ.scale, roof_typ.height, 
      camera.x - game_state.roof.x, camera.y - game_state.roof.y, 
      fwdy, fwdx, sdist, screen_center_y, screen_width, sprite_size, 
      r_batch, r_state, false, nil, nil, game_state.ERROR_IDX, game_state.get_spr)
  end
  
  -- Mid ceiling rows (2x duplication)
  local mid_end = math.min(y1_ceil, 32)
  local y = near_end + 1
  while y <= mid_end do
    draw_single_row(y, roof_src, roof_typ.tex, roof_typ.scale, roof_typ.height,
      camera.x - game_state.roof.x, camera.y - game_state.roof.y,
      fwdy, fwdx, sdist, screen_center_y, screen_width, sprite_size,
      r_batch, r_state, false, nil, nil, game_state.ERROR_IDX, game_state.get_spr)
    clamped_blit(y, y + 1, screen_center_y, screen_height, y1_ceil, r_state)
    y = y + 2
  end
  
  -- Far ceiling rows (4x duplication)
  while y <= y1_ceil do
    draw_single_row(y, roof_src, roof_typ.tex, roof_typ.scale, roof_typ.height,
      camera.x - game_state.roof.x, camera.y - game_state.roof.y,
      fwdy, fwdx, sdist, screen_center_y, screen_width, sprite_size,
      r_batch, r_state, false, nil, nil, game_state.ERROR_IDX, game_state.get_spr)
    clamped_blit(y, y + 1, screen_center_y, screen_height, y1_ceil, r_state)
    clamped_blit(y, y + 2, screen_center_y, screen_height, y1_ceil, r_state)
    clamped_blit(y, y + 3, screen_center_y, screen_height, y1_ceil, r_state)
    y = y + 4
  end
  
  -- Draw floor
  local floor_typ = game_state.floor.typ
  local floor_src = game_state.get_spr(floor_typ.tex)
  local y0_floor = 0
  local y1_floor = screen_center_y - 1
  
  -- Near floor rows (every row) - POSITIVE threshold for floor space
  near_end = math.min(y1_floor, 16)
  for y = y0_floor, near_end do
    draw_single_row(y, floor_src, floor_typ.tex, floor_typ.scale, floor_typ.height,
      camera.x - game_state.floor.x, camera.y - game_state.floor.y,
      fwdy, fwdx, sdist, screen_center_y, screen_width, sprite_size,
      r_batch, r_state, game_state.per_cell_floors_enabled, game_state.get_floor, game_state.planetyps, game_state.ERROR_IDX, game_state.get_spr)
  end
  
  -- Mid floor rows (2x duplication) - POSITIVE threshold
  mid_end = math.min(y1_floor, 48)
  y = near_end + 1
  while y <= mid_end do
    draw_single_row(y, floor_src, floor_typ.tex, floor_typ.scale, floor_typ.height,
      camera.x - game_state.floor.x, camera.y - game_state.floor.y,
      fwdy, fwdx, sdist, screen_center_y, screen_width, sprite_size,
      r_batch, r_state, game_state.per_cell_floors_enabled, game_state.get_floor, game_state.planetyps, game_state.ERROR_IDX, game_state.get_spr)
    clamped_blit(y, y + 1, screen_center_y, screen_height, y1_floor, r_state)
    y = y + 2
  end
  
  -- Far floor rows (4x duplication)
  while y <= y1_floor do
    draw_single_row(y, floor_src, floor_typ.tex, floor_typ.scale, floor_typ.height,
      camera.x - game_state.floor.x, camera.y - game_state.floor.y,
      fwdy, fwdx, sdist, screen_center_y, screen_width, sprite_size,
      r_batch, r_state, game_state.per_cell_floors_enabled, game_state.get_floor, game_state.planetyps, game_state.ERROR_IDX, game_state.get_spr)
    clamped_blit(y, y + 1, screen_center_y, screen_height, y1_floor, r_state)
    clamped_blit(y, y + 2, screen_center_y, screen_height, y1_floor, r_state)
    clamped_blit(y, y + 3, screen_center_y, screen_height, y1_floor, r_state)
    y = y + 4
  end
  
  r_batch.tline_submit()
  palt()
end

-- Contract verification harness
-- Call after draw_floor_ceiling() to verify occupancy counters
function r_floor.verify_contract(r_state)
  local floor_rows = r_state.occupancy.floor_rows

  printh("[r_floor] verifying contract...")
  printh(string.format("  floor_rows: %d", floor_rows))

  local success = floor_rows > 0
  printh("[r_floor] contract: " .. (success and "PASSED" or "FAILED"))

  return success
end

return r_floor


:: src/render/r_sprites.lua
--[[pod_format="raw",created="2025-11-12 00:00:00",modified="2025-11-12 00:00:00",revision=1]]
-- r_sprites.lua
-- Depth-bucketed sprite renderer with impostor fallback

local r_sprites = {}
local assert_lib = include"lib/assert.lua"

-- Note: Sprite buckets now use userdata buffers from r_state
-- Each bucket stores object indices (not object references) to avoid GC pressure
-- Buckets are stored as flat arrays: [bucket0_obj1, bucket0_obj2, ..., bucket1_obj1, ...]
-- bucket_counts tracks how many objects in each bucket

local function clear_buckets(r_state)
  -- Zero out bucket counts (userdata stays allocated)
  for i = 0, r_state.config.sprite_bucket_count - 1 do
    r_state.buffers.sprite_bucket_counts:set(i, 0)
  end
end

-- Draw single sprite with z-buffer occlusion
local function draw_sprite(ob, camera, r_view, r_state, r_batch, game_state)
  if not ob or not ob.typ or not ob.rel then
    return
  end
  
  local t = ob.typ
  local x = ob.rel[1]  -- camera-space x
  local z = ob.rel[2]  -- camera-space z (depth)
  local sdist = r_view.sdist
  local cfg = r_state.config
  local screen_center_x = cfg.screen_width / 2
  local screen_center_y = cfg.screen_height / 2
  local sprite_size = game_state.sprite_size or 32
  
  -- Fetch sprite index
  local base_sprite_index = ob.sprite_index or t.mx
  local sprite_index = base_sprite_index
  
  -- Handle animation
  if t.framect then
    local fr = math.floor(ob.frame or 0)
    if ob.animloop then
      fr = fr % t.framect
    else
      fr = math.min(fr, t.framect - 1)
    end
    sprite_index = base_sprite_index + fr
  end
  
  -- Validate sprite exists
  local src = game_state.get_spr(sprite_index)
  if not src then
    if sprite_index ~= base_sprite_index then
      sprite_index = base_sprite_index
    end
    src = game_state.get_spr(sprite_index)
  end
  
  if not src then
    src = game_state.error_textures.sprite or game_state.error_textures.default
  end
  
  -- Get vertical offset
  local y = ob.y or t.y
  if t.yoffs then
    local frame = ob.frame or 0
    local frame_idx = math.floor(frame % #t.yoffs) + 1
    if frame_idx > 0 and frame_idx <= #t.yoffs then
      y = y + t.yoffs[frame_idx]
    end
  end
  
  -- LOD: impostor rendering for distant sprites
  local sprite_lod_distance = game_state.fog_far * game_state.sprite_lod_ratio
  if z > sprite_lod_distance then
    -- Sample average color from sprite center
    local avg_color = 5
    if src and src.get then
      avg_color = src:get(16, 16) or 5
    end
    
    -- Project to screen space
    local f_lod = sdist / z
    local sx_lod = x * f_lod + screen_center_x
    local w_lod = t.w * f_lod
    
    -- Compute vertical span
    local y0_lod, y1_lod
    if t.flat then
      local z0 = z + t.w / 2
      local z1 = z - t.w / 2
      y0_lod = y * sdist / z0 + screen_center_y
      y1_lod = y * sdist / z1 + screen_center_y
    else
      local sy_lod = y * f_lod + screen_center_y
      local h_lod = t.h * f_lod
      y0_lod = sy_lod - h_lod / 2
      y1_lod = sy_lod + h_lod / 2
    end
    
    -- Clamp to screen bounds
    local x0 = math.max(0, math.ceil(sx_lod - w_lod / 2))
    local x1 = math.min(cfg.screen_width - 1, math.floor(sx_lod + w_lod / 2))
    y0_lod = math.max(0, math.ceil(y0_lod))
    y1_lod = math.min(cfg.screen_height - 1, math.floor(y1_lod))
    
    -- Draw impostor columns with z-test
    if y1_lod > y0_lod and x1 >= x0 then
      r_batch.rect_reset()
      for px = x0, x1 do
        local zb = r_state.zread(px)
        if z < zb then
          r_batch.rect_push(px, y0_lod, px, y1_lod, avg_color)
          r_state.zwrite(px, z)
        end
      end
      r_batch.rect_submit()
    end
    
    return
  end
  
  -- Full texture rendering
  local f = sdist / z
  local sx = x * f + screen_center_x
  local w = t.w * f
  
  -- Calculate y coordinates
  local y0, y1
  if t.flat then
    local z0 = z + t.w / 2
    local z1 = z - t.w / 2
    y0 = y * sdist / z0 + screen_center_y
    y1 = y * sdist / z1 + screen_center_y
  else
    local sy = y * f + screen_center_y
    local h = t.h * f
    y0 = sy - h / 2
    y1 = sy + h / 2
  end
  
  -- Map to UV space
  local sxd = sprite_size / w
  local syd = sprite_size / (y1 - y0 + 0.01)
  local u0 = 0
  local v0 = 0
  
  -- Clamp to screen bounds
  local lx = sx - w / 2
  local fy0 = y0
  local x0 = math.max(0, math.ceil(lx))
  local x1 = math.min(cfg.screen_width - 1, math.floor(sx + w / 2))
  
  if x0 > lx then
    u0 = u0 + (x0 - lx) * sxd
  end
  
  y0 = math.max(0, math.ceil(fy0))
  y1 = math.min(cfg.screen_height - 1, math.floor(y1))
  
  if y0 > fy0 then
    v0 = v0 + (y0 - fy0) * syd
  end
  
  -- Guard against degenerate span
  if y1 <= y0 or x1 < x0 then
    return
  end
  
  -- Draw sprite column-by-column with z-buffer
  local spr_idx = sprite_index
  r_batch.tline_reset()
  for px = x0, x1 do
    local zb = r_state.zread(px)
    if z < zb then
      local u = u0 + (px - x0) * sxd
      r_batch.tline_push(spr_idx, px, y0, px, y1, u, v0, u, v0 + sprite_size, 1, 1)
      r_state.zwrite(px, z)
    end
  end
  r_batch.tline_submit()
end

-- Render all sprites with depth bucketing
-- camera: {x, y} position
-- r_view: view module with forward/right vectors
-- r_state: renderer state
-- r_batch: batch module
-- game_state: {objects, far_plane, sprite_lod_ratio, fog_far, sprite_size, get_spr, error_textures}
function r_sprites.draw(camera, r_view, r_state, r_batch, game_state)
  -- Contract guards
  assert_lib.is_not_nil(game_state.objects, "r_sprites: game_state.objects required")
  assert_lib.is_type(game_state.objects, "table", "r_sprites: game_state.objects must be table")
  assert_lib.is_not_nil(game_state.far_plane, "r_sprites: game_state.far_plane required")
  assert_lib.is_not_nil(game_state.sprite_lod_ratio, "r_sprites: game_state.sprite_lod_ratio required")
  assert_lib.is_not_nil(game_state.fog_far, "r_sprites: game_state.fog_far required")
  assert_lib.is_not_nil(game_state.get_spr, "r_sprites: game_state.get_spr required")
  assert_lib.is_type(game_state.get_spr, "function", "r_sprites: game_state.get_spr must be callable")
  assert_lib.is_not_nil(game_state.error_textures, "r_sprites: game_state.error_textures required")
  assert_lib.is_type(game_state.error_textures, "table", "r_sprites: game_state.error_textures must be table")

  local cfg = r_state.config
  local sa, ca = sin(camera.a), cos(camera.a)
  local bucket_size = game_state.far_plane / 8
  local bufs = r_state.buffers
  local bucket_count = cfg.sprite_bucket_count
  local bucket_capacity = cfg.sprite_bucket_capacity
  
  clear_buckets(r_state)
  
  -- Build object index list (for stable bucket storage)
  local obj_list = game_state.objects
  local obj_count = #obj_list
  
  -- Transform sprites to camera space and bucket by depth
  for obj_idx = 1, obj_count do
    local ob = obj_list[obj_idx]
    if ob and ob.pos and ob.typ then
      -- Transform to view space
      local rx = ob.pos[1] - camera.x
      local ry = ob.pos[2] - camera.y
      
      -- Simple distance culling
      if abs(rx) >= game_state.far_plane or abs(ry) >= game_state.far_plane then
        goto skip_sprite
      end
      
      -- Rotate to camera space
      local x_cam = -sa * rx + ca * ry
      local z_cam = ca * rx + sa * ry
      ob.rel = ob.rel or {}
      ob.rel[1] = x_cam
      ob.rel[2] = z_cam
      
      -- Far-plane culling
      if ob.rel[2] > game_state.far_plane then
        goto skip_sprite
      end
      
      -- Frustum culling
      local t = ob.typ
      local pass_frustum = false
      if ob.rel[2] > 0.1 then
        if t.flat then
          if ob.rel[2] >= t.w / 2 then
            pass_frustum = true
          end
        else
          if abs(ob.rel[1]) - (t.w / 2) < ob.rel[2] * (cfg.screen_width / 2 / r_view.sdist) then
            pass_frustum = true
          end
        end
      end
      
      if pass_frustum then
        local bucket_idx = math.min(bucket_count - 1, math.floor(ob.rel[2] / bucket_size))
        local count = bufs.sprite_bucket_counts:get(bucket_idx)
        
        -- Check capacity
        if count < bucket_capacity then
          local base = bucket_idx * bucket_capacity
          bufs.sprite_bucket_indices:set(base + count, obj_idx)
          bufs.sprite_bucket_depths:set(base + count, ob.rel[2])
          bufs.sprite_bucket_counts:set(bucket_idx, count + 1)
        end
      end
      
      ::skip_sprite::
    end
  end
  
  -- Draw sprites back-to-front
  palt(0, false)
  palt(14, true)
  
  for bucket_idx = bucket_count - 1, 0, -1 do
    local count = bufs.sprite_bucket_counts:get(bucket_idx)
    
    -- Sort bucket by z descending (far to near) using insertion sort
    if count > 4 then
      local base = bucket_idx * bucket_capacity
      for i = 1, count - 1 do
        local idx_i = bufs.sprite_bucket_indices:get(base + i)
        local z_i = bufs.sprite_bucket_depths:get(base + i)
        local j = i - 1
        while j >= 0 and bufs.sprite_bucket_depths:get(base + j) < z_i do
          bufs.sprite_bucket_indices:set(base + j + 1, bufs.sprite_bucket_indices:get(base + j))
          bufs.sprite_bucket_depths:set(base + j + 1, bufs.sprite_bucket_depths:get(base + j))
          j = j - 1
        end
        bufs.sprite_bucket_indices:set(base + j + 1, idx_i)
        bufs.sprite_bucket_depths:set(base + j + 1, z_i)
      end
    end
    
    -- Draw all sprites in bucket
    local base = bucket_idx * bucket_capacity
    for i = 0, count - 1 do
      local obj_idx = bufs.sprite_bucket_indices:get(base + i)
      local ob = obj_list[obj_idx]
      draw_sprite(ob, camera, r_view, r_state, r_batch, game_state)
    end
  end
  
  palt()
  r_state.occupancy.sprite_count = r_state.occupancy.sprite_count + #game_state.objects
end

-- Contract verification harness
-- Call after draw() to verify occupancy counters and bucket usage
function r_sprites.verify_contract(r_state, game_state)
  local sprite_count = r_state.occupancy.sprite_count
  local expected_count = #game_state.objects

  printh("[r_sprites] verifying contract...")
  printh(string.format("  sprite_count: %d (expected: %d)", sprite_count, expected_count))

  -- Check bucket usage
  local total_bucketed = 0
  local cfg = r_state.config
  for i = 0, cfg.sprite_bucket_count - 1 do
    local count = r_state.buffers.sprite_bucket_counts:get(i)
    total_bucketed = total_bucketed + count
    if count > cfg.sprite_bucket_capacity then
      printh(string.format("  WARNING: bucket %d overflow (%d > %d)", i, count, cfg.sprite_bucket_capacity))
    end
  end
  printh(string.format("  total bucketed: %d", total_bucketed))

  local success = sprite_count == expected_count
  printh("[r_sprites] contract: " .. (success and "PASSED" or "FAILED"))

  return success
end

return r_sprites


:: src/render/r_state.lua
--[[pod_format="raw",created="2025-11-12 00:00:00",modified="2025-11-12 00:00:00",revision=1]]
-- r_state.lua
-- Renderer state: owns all userdata buffers, config, and occupancy counters

local r_state = {}

-- Memory base address for renderer buffers (safe range per optimization guidelines)
local MEM_BASE = 0x080000

-- Configuration
r_state.config = {
  screen_width = 480,
  screen_height = 270,
  ray_count = 128,
  sprite_bucket_count = 8,
  sprite_bucket_capacity = 64,
  debug_mode = false
}

-- Buffer handles (will be populated by init)
r_state.buffers = {}

-- Occupancy counters (reset per frame)
r_state.occupancy = {
  rays_active = 0,
  wall_spans = 0,
  floor_rows = 0,
  sprite_count = 0
}

-- Frame counter for z-buffer stamping
r_state.frame_id = 0

-- Initialize all renderer buffers using memmap
function r_state.init(config)
  -- Merge user config
  if config then
    for k, v in pairs(config) do
      r_state.config[k] = v
    end
  end
  
  local cfg = r_state.config
  local ray_cnt = cfg.ray_count
  local sw = cfg.screen_width
  local sh = cfg.screen_height
  
  -- Ray direction and hit data buffers
  r_state.buffers.ray_dir_x = userdata("f64", ray_cnt)
  r_state.buffers.ray_dir_y = userdata("f64", ray_cnt)
  r_state.buffers.ray_z = userdata("f64", ray_cnt)
  r_state.buffers.ray_tx = userdata("f64", ray_cnt)
  r_state.buffers.ray_hitx = userdata("f64", ray_cnt)
  r_state.buffers.ray_hity = userdata("f64", ray_cnt)
  r_state.buffers.ray_tile = userdata("i16", ray_cnt)
  
  -- Screen span mapping (which pixels each ray covers)
  r_state.buffers.ray_x0 = userdata("i16", ray_cnt)
  r_state.buffers.ray_x1 = userdata("i16", ray_cnt)
  r_state.buffers.ray_px_center = userdata("f64", ray_cnt)
  
  -- Wall span buffers (worst case: one span per ray)
  r_state.buffers.wall_span_start = userdata("i16", ray_cnt)
  r_state.buffers.wall_span_end = userdata("i16", ray_cnt)
  r_state.buffers.wall_span_tile = userdata("i16", ray_cnt)
  r_state.buffers.wall_span_uv0 = userdata("f32", ray_cnt)
  r_state.buffers.wall_span_uv1 = userdata("f32", ray_cnt)
  r_state.buffers.wall_span_depth = userdata("f32", ray_cnt)
  
  -- Sprite buckets (depth-sorted bins)
  local bucket_size = cfg.sprite_bucket_count * cfg.sprite_bucket_capacity
  r_state.buffers.sprite_bucket_indices = userdata("i16", bucket_size)
  r_state.buffers.sprite_bucket_depths = userdata("f32", bucket_size)
  r_state.buffers.sprite_bucket_counts = userdata("i16", cfg.sprite_bucket_count)
  
  -- Z-buffer and frame stamp
  r_state.buffers.zbuf = userdata("f32", sw)
  r_state.buffers.zstamp = userdata("i32", sw)
  
  -- Initialize zstamp to 0
  for i = 0, sw - 1 do
    r_state.buffers.zstamp:set(i, 0)
  end
  
  -- Diagnostics snapshot buffer (only used when debug_mode enabled)
  r_state.buffers.stats_ud = userdata("f32", 32)
  
  printh("[r_state] initialized: " .. ray_cnt .. " rays, " .. sw .. "x" .. sh .. " screen")
end

-- Prepare frame: clear occupancy counters and stamp z-buffer
function r_state.prepare_frame()
  r_state.frame_id = r_state.frame_id + 1
  r_state.occupancy.rays_active = 0
  r_state.occupancy.wall_spans = 0
  r_state.occupancy.floor_rows = 0
  r_state.occupancy.sprite_count = 0
  
  -- Z-buffer is invalidated by frame stamp, no need to clear values
end

-- Z-buffer helpers using frame stamping
function r_state.zread(x)
  if x < 0 or x >= r_state.config.screen_width then return 999 end
  local stamp = r_state.buffers.zstamp:get(x) or 0
  if stamp == r_state.frame_id then
    return r_state.buffers.zbuf:get(x) or 999
  end
  return 999
end

function r_state.zwrite(x, z)
  if x < 0 or x >= r_state.config.screen_width then return end
  r_state.buffers.zbuf:set(x, z)
  r_state.buffers.zstamp:set(x, r_state.frame_id)
end

-- Dump buffer usage (debug mode only)
function r_state.dump_usage()
  if not r_state.config.debug_mode then return end
  
  printh("[r_state] buffer usage:")
  printh("  rays_active: " .. r_state.occupancy.rays_active .. " / " .. r_state.config.ray_count)
  printh("  wall_spans: " .. r_state.occupancy.wall_spans .. " / " .. r_state.config.ray_count)
  printh("  floor_rows: " .. r_state.occupancy.floor_rows)
  printh("  sprite_count: " .. r_state.occupancy.sprite_count)
end

-- Teardown: unmap all userdata (allows GC)
function r_state.teardown()
  -- Picotron doesn't require explicit unmap, but we clear references
  for k, v in pairs(r_state.buffers) do
    r_state.buffers[k] = nil
  end
  printh("[r_state] teardown complete")
end

return r_state


:: src/render/r_view.lua
--[[pod_format="raw",created="2025-11-12 00:00:00",modified="2025-11-12 00:00:00",revision=1]]
-- r_view.lua
-- Camera basis and ray direction LUT computation

local r_view = {}
local assert_lib = include"lib/assert.lua"

local NORMALIZED_EPSILON = 0.000001

-- Cached state to detect changes
local last_ray_count = 0
local last_fov = 0

-- Camera basis vectors (cached per frame)
r_view.forward_x = 0
r_view.forward_y = 0
r_view.right_x = 0
r_view.right_y = 0

-- Projection distance (cached, recomputed when FOV changes)
r_view.sdist = 200

-- Update camera basis and ray direction LUTs
-- camera: {x, y, a} table with position and angle
-- r_state: renderer state with buffers
-- fov: field of view (half-angle in radians)
-- active_ray_count: current ray budget (can be < r_state.config.ray_count)
function r_view.update(camera, r_state, fov, active_ray_count)
  local cfg = r_state.config
  local ray_cnt = active_ray_count or cfg.ray_count
  local screen_center_x = cfg.screen_width / 2
  
  -- Recompute projection distance if FOV changed
  if fov ~= last_fov then
    r_view.sdist = screen_center_x / math.tan(fov)
    last_fov = fov
  end
  
  -- Update camera basis (cached sin/cos)
  local sa = sin(camera.a)
  local ca = cos(camera.a)
  
  r_view.forward_x = ca
  r_view.forward_y = sa
  r_view.right_x = -sa
  r_view.right_y = ca
  
  -- Rebuild ray direction LUTs only if ray count changed
  if ray_cnt ~= last_ray_count then
    local bufs = r_state.buffers
    
    for i = 0, ray_cnt - 1 do
      -- Compute screen span for this ray
      local x0 = math.floor(i * cfg.screen_width / ray_cnt)
      local x1 = math.max(x0, math.floor((i + 1) * cfg.screen_width / ray_cnt) - 1)
      local pixel_x = (x0 + x1) / 2 + 0.5
      
      bufs.ray_x0:set(i, x0)
      bufs.ray_x1:set(i, x1)
      bufs.ray_px_center:set(i, pixel_x)
    end
    
    last_ray_count = ray_cnt
    printh("[r_view] rebuilt LUTs for " .. ray_cnt .. " rays")
  end
  
  -- Compute ray directions in world space
  local bufs = r_state.buffers
  for i = 0, ray_cnt - 1 do
    local pixel_x = bufs.ray_px_center:get(i)
    local dx = pixel_x - screen_center_x
    local dy = r_view.sdist

    -- Transform camera-space direction to world-space
    -- ray_dir = right * dx + forward * dy
    local world_dx = r_view.right_x * dx + r_view.forward_x * dy
    local world_dy = r_view.right_y * dx + r_view.forward_y * dy

    -- Normalize ray direction to unit vector (critical for DDA math)
    local mag_sq = world_dx * world_dx + world_dy * world_dy
    if mag_sq > 0 then
      local inv_mag = 1 / math.sqrt(mag_sq)
      world_dx = world_dx * inv_mag
      world_dy = world_dy * inv_mag
    end

    -- Contract assertion: rays must be normalized unit vectors
    local final_mag_sq = world_dx * world_dx + world_dy * world_dy
    assert_lib.is_true(math.abs(final_mag_sq - 1) < NORMALIZED_EPSILON,
      string.format("r_view: ray %d not normalized (magnitude squared: %.6f)", i, final_mag_sq))

    bufs.ray_dir_x:set(i, world_dx)
    bufs.ray_dir_y:set(i, world_dy)
  end
  
  r_state.occupancy.rays_active = ray_cnt
end

-- Contract verification harness
-- Call after update() to verify ray normalization
function r_view.verify_contract(r_state)
  local bufs = r_state.buffers
  local ray_cnt = r_state.occupancy.rays_active

  printh("[r_view] verifying contract for " .. ray_cnt .. " rays...")

  -- Verify ray normalization
  local violations = 0
  for i = 0, math.min(ray_cnt - 1, 4) do  -- Check first 5 rays
    local dx = bufs.ray_dir_x:get(i)
    local dy = bufs.ray_dir_y:get(i)
    local mag_sq = dx * dx + dy * dy
    local mag_error = math.abs(mag_sq - 1)

    if mag_error >= NORMALIZED_EPSILON then
      printh(string.format("  ray %d: magnitude error %.6f (dx=%.3f, dy=%.3f)", i, mag_error, dx, dy))
      violations = violations + 1
    end
  end

  if violations == 0 then
    printh("[r_view] contract verification PASSED")
    return true
  else
    printh("[r_view] contract verification FAILED (" .. violations .. " violations)")
    return false
  end
end

return r_view


:: src/render/r_walls.lua
--[[pod_format="raw",created="2025-11-12 00:00:00",modified="2025-11-12 00:00:00",revision=1]]
-- r_walls.lua
-- Span batcher for wall rendering with LOD

local r_walls = {}
local assert_lib = include"lib/assert.lua"

-- Texture cache (sprite index -> {src, is_fallback})
local tex_cache = {}
local avg_color_cache = {}

-- Resolve sprite index with fallback to error textures
local function resolve_sprite_index(idx, kind, error_idx_table, get_spr_fn)
  if idx and get_spr_fn(idx) then
    return idx
  end
  if error_idx_table then
    if kind == "door" then return error_idx_table.door
    else return error_idx_table.wall end
  end
  return 0
end

-- Get texture source with caching
local function get_texture_source(sprite_index, obj_type, get_spr_fn, error_textures)
  sprite_index = sprite_index or 0
  obj_type = obj_type or "default"
  
  -- Check cache
  local cached = tex_cache[sprite_index]
  if cached then
    return cached.src, cached.is_fallback
  end
  
  -- Try to fetch sprite
  local src = get_spr_fn(sprite_index)
  if not src then
    -- Use error texture
    local err_tex = error_textures[obj_type] or error_textures.default
    tex_cache[sprite_index] = {src = err_tex, is_fallback = true}
    return err_tex, true
  end
  
  tex_cache[sprite_index] = {src = src, is_fallback = false}
  return src, false
end

-- Get average color with caching
local function get_avg_color(tile, get_spr_fn, error_textures, is_door_fn)
  local avg = avg_color_cache[tile]
  if avg then return avg end
  
  local obj_type = is_door_fn and is_door_fn(tile) and "door" or "wall"
  local src, is_fallback = get_texture_source(tile, obj_type, get_spr_fn, error_textures)
  
  avg = 5  -- default fog color
  if src and src.get then
    avg = src:get(16, 16) or 5
  end
  
  avg_color_cache[tile] = avg
  return avg
end

-- Draw wall spans with LOD and batching
-- camera: {x, y} position
-- r_view: view module with forward vectors and sdist
-- r_state: renderer state with buffers
-- r_batch: batch module
-- game_state: {wall_lod_distance, wall_tiny_screen_px, sprite_size, is_door, get_spr, error_textures, ERROR_IDX}
function r_walls.draw_spans(camera, r_view, r_state, r_batch, game_state)
  -- Contract guards
  assert_lib.is_not_nil(r_state.occupancy.rays_active, "r_walls: rays_active not set")
  assert_lib.is_true(r_state.occupancy.rays_active > 0, "r_walls: no active rays")
  assert_lib.is_not_nil(game_state.get_spr, "r_walls: game_state.get_spr required")
  assert_lib.is_type(game_state.get_spr, "function", "r_walls: game_state.get_spr must be callable")
  assert_lib.is_not_nil(game_state.error_textures, "r_walls: game_state.error_textures required")
  assert_lib.is_type(game_state.error_textures, "table", "r_walls: game_state.error_textures must be table")
  assert_lib.is_not_nil(game_state.ERROR_IDX, "r_walls: game_state.ERROR_IDX required")

  local bufs = r_state.buffers
  local ray_cnt = r_state.occupancy.rays_active
  local cfg = r_state.config
  local screen_center_y = cfg.screen_height / 2
  local fwdx, fwdy = r_view.forward_x, r_view.forward_y
  local sdist = r_view.sdist
  local tex_size = game_state.sprite_size or 32
  
  r_batch.rect_reset()
  r_batch.tline_reset()
  
  -- Span merging state
  local span_start = nil
  local span_tile = nil
  local span_spr = nil
  local span_avg = nil
  local span_tx0, span_tx1 = nil, nil
  local span_hitx0, span_hity0 = nil, nil
  local span_hitx1, span_hity1 = nil, nil
  
  local function flush_span(span_end)
    if not span_start then return end
    
    local x0 = bufs.ray_x0:get(span_start)
    local x1 = bufs.ray_x1:get(span_end)
    if x0 > x1 then span_start = nil return end
    
    local span_width = x1 - x0
    
    -- Handle single-column span
    if span_width <= 0 then
      local rel_x = span_hitx0 - camera.x
      local rel_y = span_hity0 - camera.y
      local z = rel_x * fwdx + rel_y * fwdy
      if z <= 0.0001 then z = 0.0001 end
      
      local h = sdist / z
      local y0 = screen_center_y - h / 2
      local y1 = screen_center_y + h / 2
      local tdy0 = math.ceil(y0)
      local tdy1 = math.min(math.floor(y1), cfg.screen_height - 1)
      
      if tdy0 <= tdy1 then
        local wall_height = tdy1 - tdy0
        if z > game_state.wall_lod_distance or wall_height < game_state.wall_tiny_screen_px then
          r_batch.rect_push(x0, tdy0, x1, tdy1, span_avg)
        else
          local u0 = span_tx0 * tex_size
          local v0 = 0
          local full_h = y1 - y0
          if full_h > 0 and tdy0 < y1 then
            v0 = ((tdy0 - y0) / full_h) * tex_size
          end
          local w0 = 1 / z
          r_batch.tline_push(span_spr, x0, tdy0, x1, tdy1, u0, v0, u0, v0 + tex_size, w0, w0, 0)
        end
        r_state.zwrite(x0, z)
      end
      
      span_start = nil
      return
    end
    
    -- Multi-column span
    local rel_x0 = span_hitx0 - camera.x
    local rel_y0 = span_hity0 - camera.y
    local z0 = rel_x0 * fwdx + rel_y0 * fwdy
    if z0 <= 0.0001 then z0 = 0.0001 end
    
    local rel_x1 = span_hitx1 - camera.x
    local rel_y1 = span_hity1 - camera.y
    local z1 = rel_x1 * fwdx + rel_y1 * fwdy
    if z1 <= 0.0001 then z1 = 0.0001 end
    
    local h0 = sdist / z0
    local base_y0 = screen_center_y - h0 / 2
    local base_y1 = screen_center_y + h0 / 2
    local tdy0 = math.ceil(base_y0)
    local tdy1 = math.min(math.floor(base_y1), cfg.screen_height - 1)
    
    if tdy0 > tdy1 then
      span_start = nil
      return
    end
    
    local h1 = sdist / z1
    local y1_top = screen_center_y - h1 / 2
    local y1_bot = screen_center_y + h1 / 2
    tdy0 = math.min(tdy0, math.ceil(y1_top))
    tdy1 = math.max(tdy1, math.min(math.floor(y1_bot), cfg.screen_height - 1))
    tdy0 = math.max(tdy0, 0)
    tdy1 = math.min(tdy1, cfg.screen_height - 1)
    
    if tdy0 > tdy1 then
      span_start = nil
      return
    end
    
    local column_count = x1 - x0 + 1
    
    -- LOD check
    if z0 > game_state.wall_lod_distance and z1 > game_state.wall_lod_distance then
      r_batch.rect_push(x0, tdy0, x1, tdy1, span_avg)
    else
      local u0 = span_tx0 * tex_size
      local u1 = span_tx1 * tex_size
      local v0 = ((tdy0 - base_y0) / (base_y1 - base_y0)) * tex_size
      if base_y1 - base_y0 <= 0 then v0 = 0 end
      v0 = math.max(0, math.min(tex_size, v0))
      local v1 = v0 + tex_size
      r_batch.tline_push(span_spr, x0, tdy0, x1, tdy1, u0, v0, u1, v1, 1 / z0, 1 / z1, 0)
    end
    
    -- Update z-buffer for all columns in span
    for col = x0, x1 do
      local t = (span_width > 0) and ((col - x0) / span_width) or 0
      local world_x = span_hitx0 + (span_hitx1 - span_hitx0) * t
      local world_y = span_hity0 + (span_hity1 - span_hity0) * t
      local rel_x = world_x - camera.x
      local rel_y = world_y - camera.y
      local z = rel_x * fwdx + rel_y * fwdy
      if z <= 0.0001 then z = 0.0001 end
      r_state.zwrite(col, z)
    end
    
    r_state.occupancy.wall_spans = r_state.occupancy.wall_spans + 1
    span_start = nil
  end
  
  -- Iterate rays and merge into spans
  for ray_idx = 0, ray_cnt - 1 do
    local tile = bufs.ray_tile:get(ray_idx)
    
    if tile and tile > 0 then
      if span_start and tile == span_tile then
        -- Continue span
        span_tx1 = bufs.ray_tx:get(ray_idx)
        span_hitx1 = bufs.ray_hitx:get(ray_idx)
        span_hity1 = bufs.ray_hity:get(ray_idx)
      else
        -- Flush previous span
        if span_start then flush_span(ray_idx - 1) end
        
        -- Start new span
        span_start = ray_idx
        span_tile = tile
        span_spr = resolve_sprite_index(tile, (game_state.is_door and game_state.is_door(tile)) and "door" or "wall", game_state.ERROR_IDX, game_state.get_spr)
        span_avg = get_avg_color(tile, game_state.get_spr, game_state.error_textures, game_state.is_door)
        span_tx0 = bufs.ray_tx:get(ray_idx)
        span_tx1 = span_tx0
        span_hitx0 = bufs.ray_hitx:get(ray_idx)
        span_hity0 = bufs.ray_hity:get(ray_idx)
        span_hitx1 = span_hitx0
        span_hity1 = span_hity0
      end
    else
      -- Empty tile: flush span
      if span_start then flush_span(ray_idx - 1) end
    end
  end
  
  -- Flush final span
  if span_start then flush_span(ray_cnt - 1) end
  
  r_batch.tline_submit()
  r_batch.rect_submit()
end

-- Clear texture caches (call on level load)
function r_walls.clear_caches()
  tex_cache = {}
  avg_color_cache = {}
end

-- Contract verification harness
-- Call after draw_spans() to verify occupancy counters
function r_walls.verify_contract(r_state)
  local wall_spans = r_state.occupancy.wall_spans

  printh("[r_walls] verifying contract...")
  printh(string.format("  wall_spans: %d", wall_spans))

  local success = wall_spans >= 0  -- Allow 0 for empty scenes
  printh("[r_walls] contract: " .. (success and "PASSED" or "FAILED"))

  return success
end

return r_walls


:: test/render/test_pipeline_contracts.lua
--[[pod_format="raw",created="2025-11-12 00:00:00",modified="2025-11-12 00:00:00",revision=1]]
-- Renderer pipeline contract tests (unit-style, not tied to frame loop)
--
-- This fixture validates that:
-- - r_view produces normalized rays and sets rays_active
-- - r_cast can cast against a trivial map without crashing
-- - r_floor/r_walls/r_sprites can run once and update occupancy counters
-- 
-- The tests rely on small, deterministic game_state tables and do not
-- require the main game loop.

local assert = require("assert")
local log = require("log")

local fixture = {}

local r_state, r_batch, r_view, r_cast, r_floor, r_walls, r_sprites
local config

-- Minimal helpers and state shared by tests
local camera
local game_state_cast
local game_state_floor
local game_state_walls
local game_state_sprites

-- Minimal error textures for fallback paths
local function make_error_textures()
	local t = {
		wall = userdata("u8", 32, 32),
		door = userdata("u8", 32, 32),
		floor = userdata("u8", 32, 32),
		ceiling = userdata("u8", 32, 32),
		sprite = userdata("u8", 32, 32),
		default = userdata("u8", 32, 32)
	}
	-- Colorize a checkerboard so getters won't fail
	for _, ud in pairs(t) do
		for y = 0, 31 do
			for x = 0, 31 do
				local c = ((flr(x/4) + flr(y/4)) % 2 == 0) and 8 or 14
				ud:set(x, y, c)
			end
		end
	end
	return t
end

local ERROR_IDX = { wall=8000, door=8001, floor=8002, ceiling=8003, sprite=8004, default=8005 }

function fixture.before_all()
	-- Load modules
	config = include"src/config.lua"
	r_state = include"src/render/r_state.lua"
	r_batch = include"src/render/r_batch.lua"
	r_view  = include"src/render/r_view.lua"
	r_cast  = include"src/render/r_cast.lua"
	r_floor = include"src/render/r_floor.lua"
	r_walls = include"src/render/r_walls.lua"
	r_sprites = include"src/render/r_sprites.lua"

	-- Initialize renderer state
	r_state.init({
		screen_width = 160,   -- smaller for tests
		screen_height = 90,
		ray_count = 64,
		sprite_bucket_count = 4,
		sprite_bucket_capacity = 16,
		debug_mode = true
	})
	r_batch.init()
end

function fixture.before_each()
	-- Fresh frame
	r_state.prepare_frame()

	-- Build a trivial test camera
	camera = { x = 2.5, y = 2.5, a = 0 }

	-- Minimal "map": a vertical wall line at gx == 6
	local function get_wall_fn(gx, gy)
		if gx == 6 and gy >= 0 and gy < config.map_size then return 1 end
		return 0
	end

	-- Door grid: empty for tests
	local doorgrid = {}
	for i=0,config.map_size-1 do doorgrid[i] = {} end

	-- CAST game state
	game_state_cast = {
		get_wall = get_wall_fn,
		is_door = is_door,
		doorgrid = doorgrid,
		test_door_mode = false,
		test_door_open = 0,
		far_plane = config.far_plane,
		map_size = config.map_size
	}

	-- FLOOR/ROOF state
	local error_textures = make_error_textures()
	local get_spr = function(_) return nil end -- force error textures path
	game_state_floor = {
		floor = { typ = planetyps[1], x=0, y=0 },
		roof = { typ = planetyps[3], x=0, y=0 },
		sprite_size = config.sprite_size,
		per_cell_floors_enabled = false,
		get_floor = function() return 0 end,
		planetyps = planetyps,
		ERROR_IDX = ERROR_IDX,
		get_spr = get_spr,
		error_textures = error_textures
	}

	-- WALLS state
	game_state_walls = {
		wall_lod_distance = config.wall_lod_distance,
		wall_tiny_screen_px = config.wall_tiny_screen_px,
		sprite_size = config.sprite_size,
		is_door = is_door,
		get_spr = get_spr,
		error_textures = error_textures,
		ERROR_IDX = ERROR_IDX
	}

	-- SPRITES state (empty set for determinism)
	game_state_sprites = {
		objects = {},
		far_plane = config.far_plane,
		sprite_lod_ratio = config.sprite_lod_ratio,
		fog_far = config.fog_far,
		sprite_size = config.sprite_size,
		get_spr = get_spr,
		error_textures = error_textures
	}
end

function fixture.test_r_view_contract_normalizes_rays()
	-- Update view and build LUTs
	r_view.update(camera, r_state, fov, r_state.config.ray_count)
	-- Should set rays_active
	assert.is_true(r_state.occupancy.rays_active > 0, "rays_active should be set")
	-- Verify a few rays are unit-length
	local ok = r_view.verify_contract(r_state)
	assert.is_true(ok, "r_view.verify_contract should pass")
end

function fixture.test_r_cast_contract_hits_simple_wall()
	-- Prepare view first
	r_view.update(camera, r_state, fov, r_state.config.ray_count)
	-- Cast scene
	r_cast.cast_scene(camera, r_view, r_state, game_state_cast)
	-- Verify basic contract
	local ok = r_cast.verify_contract(r_state, game_state_cast)
	assert.is_true(ok, "r_cast.verify_contract should pass")
end

function fixture.test_floor_walls_sprites_draw_once_and_update_occupancy()
	-- View and cast to prepare buffers for walls
	r_view.update(camera, r_state, fov, r_state.config.ray_count)
	r_cast.cast_scene(camera, r_view, r_state, game_state_cast)
	-- Draw floor/ceiling
	r_floor.draw_floor_ceiling(camera, r_view, r_state, r_batch, game_state_floor)
	-- Draw walls
	r_walls.draw_spans(camera, r_view, r_state, r_batch, game_state_walls)
	-- Draw sprites (none)
	r_sprites.draw(camera, r_view, r_state, r_batch, game_state_sprites)
	-- Submit pending batches just in case
	r_batch.tline_submit()
	r_batch.rect_submit()

	assert.is_true(r_state.occupancy.floor_rows > 0, "floor_rows should be > 0 after draw")
	assert.is_true(r_state.occupancy.wall_spans >= 0, "wall_spans should be >= 0")
	assert.are_equal(r_state.occupancy.sprite_count, 0, "sprite_count should match objects length")
end

function fixture.after_each()
	-- no-op
end

function fixture.after_all()
	-- Teardown renderer
	r_state.teardown()
end

return fixture



:: test/run_tests.lua
--[[pod_format="raw",created="2024-09-08 16:10:59",modified="2025-03-07 13:16:21",revision=5]]
--[[
	run_tests.lua - Program entry point for test execution
	(c) 2025 Andrew Vasilyev. All rights reserved.

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program. If not, see <https://www.gnu.org/licenses/>.
]]

include("src/globals.lua")
include("lib/require.lua")

-- Add paths for module search
add_module_path("lib/")
add_module_path("src/")
add_module_path("test/")

local _TEST_PREFIX = "test_"

local log = require("log")

-- Initialize logging
log.set_level(log.levels.DEBUG)
log.set_target(log.targets.CONSOLE)
log.init()

local total_tests = 0
local total_passed = 0
local total_failed = 0
local failed_tests = {}

-- Utility function to extract line number and error message from Lua errors
local function extract_error_info(err)
	local line_number, message = err:match(":(%d+): (.+)$")
	return line_number or "unknown", message or err
end

-- Clears the environment and includes necessary configurations
local function initialize_environment()
	clear_module_cache({ "log" })
	include("test/test_configuration.lua")
end

-- Runs a single fixture and handles its lifecycle
local function run_fixture(filename)
	log.info("Executing fixture: '%s'", filename)
	initialize_environment()

	local fixture = require(filename)
	local fixture_tests, fixture_passed, fixture_failed = 0, 0, 0
	failed_tests[filename] = {} -- Initialize table for failed tests in this fixture

	if fixture.before_all then
		local success, err = pcall(fixture.before_all)
		if not success then
			for name, _ in pairs(fixture) do
				if string.sub(name, 1, string.len(_TEST_PREFIX)) == _TEST_PREFIX then
					fixture_tests, total_tests = fixture_tests + 1, total_tests + 1
				end
			end
			local line_number, message = extract_error_info(err)
			log.error("Error in 'before_all' hook on line %s, affecting %d test(s).", line_number, fixture_tests)
			log.error("Details: %s", message)
			table.insert(failed_tests[filename], string.format("'before_all' hook failure affecting %d test(s) on line %s.", fixture_tests, line_number))
			table.insert(failed_tests[filename], string.format("Error details: %s", message))
			total_failed = total_failed + fixture_tests

			log.error("Fixture '%s' summary: %d test(s), 0 passed, %d failed.", filename, fixture_tests, fixture_tests)
			return
		end
	end

	for name, test in pairs(fixture) do
		if string.sub(name, 1, string.len(_TEST_PREFIX)) == _TEST_PREFIX then
			fixture_tests, total_tests = fixture_tests + 1, total_tests + 1
			local test_passed = true
			local already_failed = false

			if fixture.before_each then
				local success, err = pcall(fixture.before_each)
				if not success then
					local line_number, message = extract_error_info(err)
					log.error("Error in 'before_each' hook for test '%s' on line %s.", name, line_number)
					log.error("Details: %s", message)
					table.insert(failed_tests[filename], string.format("Test '%s' -> 'before_each' hook failure on line %s.", name, line_number))
					table.insert(failed_tests[filename], string.format("Error details: %s", message))
					total_failed, fixture_failed = total_failed + 1, fixture_failed + 1
					test_passed = false
					already_failed = true
				end
			end

			if test_passed then
				local success, err = pcall(test)
				if not success then
					local line_number, message = extract_error_info(err)
					log.error("Test '%s' failed on line %s.", name, line_number)
					log.error("Details: %s", message)
					table.insert(failed_tests[filename], string.format("Test '%s' -> failure on line %s.", name, line_number))
					table.insert(failed_tests[filename], string.format("Error details: %s", message))
					total_failed, fixture_failed = total_failed + 1, fixture_failed + 1
					test_passed = false
					already_failed = true
				end
			end

			if fixture.after_each then
				local success, err = pcall(fixture.after_each)
				if not success then
					local line_number, message = extract_error_info(err)
					log.error("Error in 'after_each' hook for test '%s' on line %s.", name, line_number)
					log.error("Details: %s", message)
					test_passed = false
					if not already_failed then
						table.insert(failed_tests[filename], string.format("Test '%s' -> 'after_each' hook failure on line %s.", name, line_number))
						table.insert(failed_tests[filename], string.format("Error details: %s", message))
						total_failed, fixture_failed = total_failed + 1, fixture_failed + 1
					end
				end
			end

			if test_passed then
				log.info("Test '%s' passed.", name)
				total_passed, fixture_passed = total_passed + 1, fixture_passed + 1
			end
		end
	end

	if fixture.after_all then
		local success, err = pcall(fixture.after_all)
		if not success then
			local line_number, message = extract_error_info(err)
			log.warn("Error in 'after_all' hook on line %s, affecting %d test(s).", line_number, fixture_tests)
			log.warn("Details: %s", message)
			table.insert(failed_tests[filename], string.format("'after_all' hook failure affecting %d test(s) on line %s.", fixture_tests, line_number))
			table.insert(failed_tests[filename], string.format("Error details: %s", message))
		end
	end

	if fixture_failed > 0 then
		log.error("Fixture '%s' summary: %d test(s), %d passed, %d failed.", filename, fixture_tests, fixture_passed, fixture_failed)
	else
		log.info("Fixture '%s' summary: %d test(s), %d passed, %d failed.", filename, fixture_tests, fixture_passed, fixture_failed)
	end
end

-- Runs a list of test fixtures provided as input
local function run_fixtures_from_list(fixture_list)
	for _, fixture_module_name in ipairs(fixture_list) do
		run_fixture(fixture_module_name)
	end
end

-- Provides a summary of the test results
local function report_test_summary()
	if total_failed > 0 then
		log.error("Test run summary: %d test(s) executed, %d passed, %d failed.", total_tests, total_passed, total_failed)
		log.error("Detailed report of failed test(s):")
		for fixture, errors in pairs(failed_tests) do
			log.error("Fixture '%s' encountered the following failures:", fixture)
			for _, error in ipairs(errors) do
				log.error("\t%s", error)
			end
		end
	else
		log.info("Test run summary: %d test(s) executed, %d passed, %d failed.", total_tests, total_passed, total_failed)
		log.info("All tests passed successfully.")
	end
end

-- Main function to handle command-line arguments and run appropriate tests
local function main()
	local params = env().argv
	local fixture_names = {}

	if #params > 0 then
		for _, filename in ipairs(params) do
			local module_name = filename:gsub("%.lua$", "")
			table.insert(fixture_names, module_name)
		end

		log.info("Executing selected fixtures: %s", table.concat(fixture_names, ", "))
	else
		for _, filename in ipairs(ls("test/")) do
			if filename:match("%.lua$") then
				local module_name = filename:gsub("%.lua$", "")
				table.insert(fixture_names, module_name)
			end
		end

		log.info("Executing all fixtures: %s", table.concat(fixture_names, ", "))
	end

	run_fixtures_from_list(fixture_names)

	report_test_summary()
end

main()

:: test/test_configuration.lua
--[[pod_format="raw",created="2024-09-08 16:18:29",modified="2025-03-07 13:16:15",revision=3]]
--[[
    test_configuration.lua - configuration settings for tests
    (c) 2025 Andrew Vasilyev. All rights reserved.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program. If not, see <https://www.gnu.org/licenses/>.
]]

include("src/configuration.lua") -- Load default configuration settings

-- Add and update configuration settings specifically for the test environment
:: test/test_example.lua
--[[pod_format="raw",created="2025-03-07 13:17:59",modified="2025-03-07 13:18:32",revision=1]]
--[[
	logview.lua - log viewer utility
	(c) 2025 Andrew Vasilyev. All rights reserved.

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program. If not, see <https://www.gnu.org/licenses/>.
]]

local assert = require("assert")
local log = require("log")

local fixture = { }

function fixture.before_all()
end

function fixture.before_each()
end

function fixture.test_something()
end

function fixture.test_something2()
end

function fixture.after_each()
end

function fixture.after_all()
end

return fixture
:: .info.pod
--[[pod,created="2025-11-07 22:14:20",modified="2025-11-10 12:35:37",runtime=21,workspaces={{location="main.lua#828",workspace_index=1}}]]
:: lib/.info.pod
--[[pod,created="2025-11-12 15:40:09",modified="2025-11-12 15:40:09"]]
:: main.lua
b64$LS1bWwoKXV0KCmluY2x1ZGUoImxpYi9yZXF1aXJlLmx1YSIpCmFkZF9tb2R1bGVfcGF0aCgi
bGliLyIpCmFkZF9tb2R1bGVfcGF0aCgic3JjLyIpCgppbmNsdWRlKCJzcmMvZ2xvYmFscy5sdWEi
KQppbmNsdWRlKCJzcmMvY29uZmlndXJhdGlvbi5sdWEiKQoKbG9jYWwgbWF0aCA9IG1hdGgKCi0t
IEV4cG9zZSBsb2dnZXIgZ2xvYmFsbHkgc28gaW5jbHVkZWQgZmlsZXMgY2FuIHVzZSBpdApsb2cg
PSByZXF1aXJlKCJsb2ciKQoKaWYgY29uZmlndXJhdGlvbi5sb2cuZW5hYmxlZCB0aGVuCglsb2cu
c2V0X2xldmVsKGNvbmZpZ3VyYXRpb24ubG9nLmxldmVsKQoJbG9nLmluaXQoKQplbmQKCmluY2x1
ZGUgInNyYy9jb25maWcubHVhIgppbmNsdWRlICJzcmMvcHJvY2dlbi9kb29yX3N5c3RlbS5sdWEi
CmluY2x1ZGUgInNyYy9wcm9jZ2VuL2R1bmdlb25fZ2VuLmx1YSIKaW5jbHVkZSAic3JjL3Byb2Nn
ZW4vZHVuZ2Vvbl9oYXJuZXNzLmx1YSIKCmxvY2FsIHJfc3RhdGUgPSBpbmNsdWRlICJzcmMvcmVu
ZGVyL3Jfc3RhdGUubHVhIgpsb2NhbCByX2JhdGNoID0gaW5jbHVkZSAic3JjL3JlbmRlci9yX2Jh
dGNoLmx1YSIKbG9jYWwgcl92aWV3ID0gaW5jbHVkZSAic3JjL3JlbmRlci9yX3ZpZXcubHVhIgps
b2NhbCByX2Nhc3QgPSBpbmNsdWRlICJzcmMvcmVuZGVyL3JfY2FzdC5sdWEiCmxvY2FsIHJfZmxv
b3IgPSBpbmNsdWRlICJzcmMvcmVuZGVyL3JfZmxvb3IubHVhIgpsb2NhbCByX3dhbGxzID0gaW5j
bHVkZSAic3JjL3JlbmRlci9yX3dhbGxzLmx1YSIKbG9jYWwgcl9zcHJpdGVzID0gaW5jbHVkZSAi
c3JjL3JlbmRlci9yX3Nwcml0ZXMubHVhIgpsb2NhbCByX2RpYWcgPSBpbmNsdWRlICJzcmMvcmVu
ZGVyL3JfZGlhZy5sdWEiCgpsb2NhbCBzY2VuZXMgPSB7fQpsb2NhbCBzY2VuZV9zdGF0ZSA9IHt9
CmxvY2FsIGN1cnJlbnRfc2NlbmUgPSBuaWwKCmxvY2FsIGZ1bmN0aW9uIGdldF9zY2VuZV9zdGF0
ZShuYW1lKQoJc2NlbmVfc3RhdGVbbmFtZV0gPSBzY2VuZV9zdGF0ZVtuYW1lXSBvciB7fQoJcmV0
dXJuIHNjZW5lX3N0YXRlW25hbWVdCmVuZAoKbG9jYWwgZnVuY3Rpb24gc3dpdGNoX3NjZW5lKG5h
bWUsIHBhcmFtcykKCWxvY2FsIHNjZW5lID0gc2NlbmVzW25hbWVdCglpZiBub3Qgc2NlbmUgdGhl
bgoJCWxvZy53YXJuKCJ1bmtub3duIHNjZW5lICVzIiwgdG9zdHJpbmcobmFtZSkpCgkJcmV0dXJu
CgllbmQKCWlmIGN1cnJlbnRfc2NlbmUgYW5kIHNjZW5lc1tjdXJyZW50X3NjZW5lXSBhbmQgc2Nl
bmVzW2N1cnJlbnRfc2NlbmVdLmxlYXZlIHRoZW4KCQlzY2VuZXNbY3VycmVudF9zY2VuZV0ubGVh
dmUoZ2V0X3NjZW5lX3N0YXRlKGN1cnJlbnRfc2NlbmUpKQoJZW5kCgljdXJyZW50X3NjZW5lID0g
bmFtZQoJbG9jYWwgc3RhdGUgPSBnZXRfc2NlbmVfc3RhdGUobmFtZSkKCWlmIHNjZW5lLmVudGVy
IHRoZW4KCQlzY2VuZS5lbnRlcihzdGF0ZSwgcGFyYW1zIG9yIHt9KQoJZW5kCmVuZAoKbG9jYWwg
ZnVuY3Rpb24gc2NlbmVfdXBkYXRlKCkKCWlmIGN1cnJlbnRfc2NlbmUgYW5kIHNjZW5lc1tjdXJy
ZW50X3NjZW5lXSBhbmQgc2NlbmVzW2N1cnJlbnRfc2NlbmVdLnVwZGF0ZSB0aGVuCgkJc2NlbmVz
W2N1cnJlbnRfc2NlbmVdLnVwZGF0ZShnZXRfc2NlbmVfc3RhdGUoY3VycmVudF9zY2VuZSkpCgll
bmQKZW5kCgpsb2NhbCBmdW5jdGlvbiBzY2VuZV9kcmF3KCkKCWlmIGN1cnJlbnRfc2NlbmUgYW5k
IHNjZW5lc1tjdXJyZW50X3NjZW5lXSBhbmQgc2NlbmVzW2N1cnJlbnRfc2NlbmVdLmRyYXcgdGhl
bgoJCXNjZW5lc1tjdXJyZW50X3NjZW5lXS5kcmF3KGdldF9zY2VuZV9zdGF0ZShjdXJyZW50X3Nj
ZW5lKSkKCWVsc2UKCQljbHMoMCkKCWVuZAplbmQKCi0tIGNvbnN0YW50cwpwbGF5ZXJfY29sbGlz
aW9uX3JhZGl1cyA9IDAuMTUKCmZ1bmN0aW9uIF9pbml0KCkKCXdpbmRvdyhzY3JlZW5fd2lkdGgs
IHNjcmVlbl9oZWlnaHQpCgoJLS0gcGluIG1hc2tzIHRvIGRlZmF1bHRzIGZvciBzaW5nbGUgY29s
b3VyLXRhYmxlIGZhc3QgcGF0aAoJcG9rZSgweDU1MDgsIDB4M2YpCglwb2tlKDB4NTUwOSwgMHgz
ZikKCXBva2UoMHg1NTBhLCAweDNmKQoJcG9rZSgweDU1MGIsIDB4MDApCgoJLS0gdGlsZSAwIGRy
YXdpbmcgc3RhdGU6IHZlcmlmaWVkIG5vdCByZXF1aXJlZDsgbGVhdmUgMHg1ZjM2IGF0IGRlZmF1
bHQgKG5vIGV4cGxpY2l0IHBva2UpCgktLSBzc3ByKCkgdXNhZ2UgdmVyaWZpZWQ6IE5vbmUgaW4g
cHJvZHVjdGlvbiBjb2RlIChvbmx5IGluIHNhbXBsZSBmaWxlcykKCS0tIFBlciBQaWNvdHJvbiBn
dWlkZWxpbmVzOiBibGl0KCkgaXMgZmFzdGVyOyBIVUQvbWluaW1hcCB1c2UgZGlyZWN0IGRyYXdp
bmcKCS0tIGNvbmZpZ3VyYXRpb24gZ3VhcmQ6IHByZXZlbnQgZm9nIHBvcHBpbmcgYmV5b25kIGZh
ci1wbGFuZQoJYXNzZXJ0KGZhcl9wbGFuZSA_PSBmb2dfZmFyICsgMSwgImNvbmZpZyBlcnJvcjog
ZmFyX3BsYW5lIG11c3QgYmUgPj0gZm9nX2ZhciArIDEiKQoKCS0tIGRlZmVuc2l2ZSBkZWZhdWx0
cyBpZiBjb25maWcgaW5jbHVkZSBmYWlsZWQgdG8gc2V0IHRoZW0gZm9yIGFueSByZWFzb24KCWlm
IG5vdCBvYmpncmlkX3NpemUgdGhlbiBvYmpncmlkX3NpemUgPSA1IGVuZAoJaWYgbm90IG9iamdy
aWRfYXJyYXlfc2l6ZSB0aGVuIG9iamdyaWRfYXJyYXlfc2l6ZSA9IDI2IGVuZAoKCS0tIGZyYW1l
IGNvdW50ZXIgZm9yIGFpIHRpbWluZwoJZnJhbWVfY3QgPSAwCgoJLS0gSW5pdGlhbGl6ZSBuZXcg
cmVuZGVyZXIKCXJfc3RhdGUuaW5pdCh7CgkJc2NyZWVuX3dpZHRoID0gc2NyZWVuX3dpZHRoLAoJ
CXNjcmVlbl9oZWlnaHQgPSBzY3JlZW5faGVpZ2h0LAoJCXJheV9jb3VudCA9IHJheV9jb3VudCwK
CQlzcHJpdGVfYnVja2V0X2NvdW50ID0gOCwKCQlzcHJpdGVfYnVja2V0X2NhcGFjaXR5ID0gNjQs
CgkJZGVidWdfbW9kZSA9IGZhbHNlCgl9KQoJcl9iYXRjaC5pbml0KCkKCWxvZy5pbmZvKCJbbWFp
bl0gbmV3IHJlbmRlcmVyIGluaXRpYWxpemVkIikKCgktLSBDb21wYXRpYmlsaXR5IGhlbHBlcnMg
Zm9yIG1pbmltYXAgZHJhd2luZyAodXNlcyByX2JhdGNoKQoJZnVuY3Rpb24gcmJhdGNoX3Jlc2V0
KCkKCQlyX2JhdGNoLnJlY3RfcmVzZXQoKQoJZW5kCglmdW5jdGlvbiByYmF0Y2hfcHVzaCh4MCwg
eTAsIHgxLCB5MSwgYykKCQlyX2JhdGNoLnJlY3RfcHVzaCh4MCwgeTAsIHgxLCB5MSwgYykKCWVu
ZAoJZnVuY3Rpb24gcmJhdGNoX3N1Ym1pdCgpCgkJcl9iYXRjaC5yZWN0X3N1Ym1pdCgpCgllbmQK
CgktLSBwbGF5ZXIgc3RhdGUKCXBsYXllciA9IHsKCQl4ID0gNjQsIHkgPSA2NCwKCQlhID0gMCwK
CQlzcGQgPSBwbGF5ZXJfbW92ZV9zcGVlZCwKCQlrZXlzID0ge30sCgkJaHAgPSAxMDAKCX0KCgkt
LSBpbnRlcmFjdGlvbiBzdGF0ZQoJaW50ZXJhY3Rpb25fYWN0aXZlID0gZmFsc2UKCWN1cnJlbnRf
aW50ZXJhY3QgPSBuaWwKCgktLSBjb21iYXQgc3RhdGUKCWluX2NvbWJhdCA9IGZhbHNlCgljdXJy
ZW50X3RhcmdldCA9IG5pbAoKCS0tIHRyYXAgbWVzc2FnZSB0aW1lcgoJdHJhcF9tc2dfdGltZXIg
PSAwCgoJLS0gY2FtZXJhCgljYW0gPSB7IHBsYXllci54LCBwbGF5ZXIueSB9CgoJLS0gbWFwIGFi
c3RyYWN0aW9uIHdpdGggdXNlcmRhdGEgbGF5ZXJzCgltYXAgPSB7fQoJbWFwLndhbGxzID0gdXNl
cmRhdGEoImkxNiIsIDEyOCwgMTI4KQoJbWFwLmRvb3JzID0gdXNlcmRhdGEoImkxNiIsIDEyOCwg
MTI4KQoJbWFwLmZsb29ycyA9IHVzZXJkYXRhKCJpMTYiLCAxMjgsIDEyOCkKCgktLSBoZWxwZXI6
IGdldCB3YWxsIHRpbGUKCS0tIFB1cnBvc2U6IFJldHJpZXZlIHdhbGwgdGlsZSBJRCBhdCBncmlk
IHBvc2l0aW9uCgktLSBQYXJhbWV0ZXJzOiB4LCB5IChncmlkIGNvb3JkaW5hdGVzIDAtMTI3KQoJ
LS0gUmV0dXJuczogdGlsZSBJRCAoMD1lbXB0eSwgPjA9d2FsbC9kb29yL2V4aXQpCglmdW5jdGlv
biBnZXRfd2FsbCh4LCB5KQoJCWlmIHggPj0gMCBhbmQgeCA8IDEyOCBhbmQgeSA_PSAwIGFuZCB5
IDwgMTI4IHRoZW4KCQkJcmV0dXJuIG1hcC53YWxsczpnZXQoeCwgeSkgb3IgMAoJCWVuZAoJCXJl
dHVybiAwCgllbmQKCgktLSBoZWxwZXI6IHNldCB3YWxsIHRpbGUKCWZ1bmN0aW9uIHNldF93YWxs
KHgsIHksIHZhbCkKCQlpZiB4ID49IDAgYW5kIHggPCAxMjggYW5kIHkgPj0gMCBhbmQgeSA8IDEy
OCB0aGVuCgkJCW1hcC53YWxsczpzZXQoeCwgeSwgdmFsIG9yIDApCgkJZW5kCgllbmQKCgktLSBo
ZWxwZXI6IGdldCBkb29yIHRpbGUKCWZ1bmN0aW9uIGdldF9kb29yKHgsIHkpCgkJaWYgeCA_PSAw
IGFuZCB4IDwgMTI4IGFuZCB5ID49IDAgYW5kIHkgPCAxMjggdGhlbgoJCQlyZXR1cm4gbWFwLmRv
b3JzOmdldCh4LCB5KSBvciAwCgkJZW5kCgkJcmV0dXJuIDAKCWVuZAoKCS0tIGhlbHBlcjogc2V0
IGRvb3IgdGlsZQoJZnVuY3Rpb24gc2V0X2Rvb3IoeCwgeSwgdmFsKQoJCWlmIHggPj0gMCBhbmQg
eCA8IDEyOCBhbmQgeSA_PSAwIGFuZCB5IDwgMTI4IHRoZW4KCQkJbWFwLmRvb3JzOnNldCh4LCB5
LCB2YWwgb3IgMCkKCQllbmQKCWVuZAoKCS0tIGhlbHBlcjogZ2V0IGZsb29yIHRpbGUKCS0tIFB1
cnBvc2U6IFJldHJpZXZlIGZsb29yIHR5cGUgSUQgYXQgZ3JpZCBwb3NpdGlvbgoJLS0gUGFyYW1l
dGVyczogeCwgeSAoZ3JpZCBjb29yZGluYXRlcyAwLTEyNykKCS0tIFJldHVybnM6IGZsb29yIHR5
cGUgSUQgKDA9dXNlIGdsb2JhbCBkZWZhdWx0LCAxLTg9c3BlY2lmaWMgZmxvb3IgdHlwZSBmcm9t
IHBsYW5ldHlwcykKCS0tIE5vdGVzOiBGbG9vciB0eXBlIElEcyBtYXAgdG8gaW5kaWNlcyBpbiB0
aGUgcGxhbmV0eXBzIHRhYmxlIGRlZmluZWQgaW4gY29uZmlnLmx1YQoJZnVuY3Rpb24gZ2V0X2Zs
b29yKHgsIHkpCgkJaWYgeCA_PSAwIGFuZCB4IDwgMTI4IGFuZCB5ID49IDAgYW5kIHkgPCAxMjgg
dGhlbgoJCQlyZXR1cm4gbWFwLmZsb29yczpnZXQoeCwgeSkgb3IgMAoJCWVuZAoJCXJldHVybiAw
CgllbmQKCgktLSBoZWxwZXI6IHNldCBmbG9vciB0aWxlCgktLSBQdXJwb3NlOiBTdG9yZSBwZXIt
Y2VsbCBmbG9vciB0eXBlIElEcyBmb3IgdmFyaWVkIGZsb29yIHRleHR1cmVzCgktLSBQYXJhbWV0
ZXJzOiB4LCB5IChncmlkIGNvb3JkaW5hdGVzIDAtMTI3KSwgdmFsIChmbG9vciB0eXBlIElEIDAt
OCkKCS0tIE5vdGVzOiAwPXVzZSBnbG9iYWwgZGVmYXVsdCBmbG9vciB0eXBlLCAxLTg9c3BlY2lm
aWMgZmxvb3IgdHlwZSBmcm9tIHBsYW5ldHlwcwoJZnVuY3Rpb24gc2V0X2Zsb29yKHgsIHksIHZh
bCkKCQlpZiB4ID49IDAgYW5kIHggPCAxMjggYW5kIHkgPj0gMCBhbmQgeSA8IDEyOCB0aGVuCgkJ
CS0tIG5vcm1hbGl6ZSB2YWwgdG8gdmFsaWQgcmFuZ2UgMC04CgkJCWlmIHR5cGUodmFsKSB_PSAi
bnVtYmVyIiBvciB2YWwgPT0gbmlsIHRoZW4KCQkJCXZhbCA9IDAKCQkJZWxzZWlmIHZhbCA8IDAg
dGhlbgoJCQkJdmFsID0gMAoJCQllbHNlaWYgdmFsID4gOCB0aGVuCgkJCQl2YWwgPSA4CgkJCWVu
ZAoJCQltYXAuZmxvb3JzOnNldCh4LCB5LCB2YWwpCgkJZW5kCgllbmQKCglkb29yZ3JpZCA9IHt9
Cglmb3IgaSA9IDAsIDEyNyBkbwoJCWRvb3JncmlkW2ldID0ge30KCQlmb3IgaiA9IDAsIDEyNyBk
bwoJCQlkb29yZ3JpZFtpXVtqXSA9IG5pbAoJCWVuZAoJZW5kCgoJLS0gaW5pdGlhbGl6ZSBmbG9v
ciBkYXRhCglmb3IgaSA9IDAsIDEyNyBkbwoJCWZvciBqID0gMCwgMTI3IGRvCgkJCXNldF9mbG9v
cihpLCBqLCAwKQoJCWVuZAoJZW5kCgoJZG9vcnMgPSB7fQoJb2JqZWN0cyA9IHt9CglhbmltYXRl
ZF9vYmplY3RzID0ge30KCgktLSBMZWdhY3kgYnVmZmVycyByZW1vdmVkIChub3cgbWFuYWdlZCBi
eSByX3N0YXRlKQoJLS0gZHluYW1pYyBidWRnZXRzCglhY3RpdmVfcmF5X2NvdW50ID0gcmF5X2Nv
dW50Cglyb3dfc3RyaWRlX2R5bmFtaWMgPSByb3dfc3RyaWRlCgoJLS0gZm9nIHN0YXRlIGZvciBo
eXN0ZXJlc2lzCglsYXN0X2ZvZ196ID0gMAoKCS0tIHByb2plY3Rpb24gY29uc3RhbnQgZGVmaW5l
ZCBpbiBjb25maWcubHVhCgoJLS0gZmxvb3IgYW5kIHJvb2Ygc3RhdGUKCWZsb29yID0geyB0eXAg
PSBwbGFuZXR5cHNbMV0sIHggPSAwLCB5ID0gMCB9Cglyb29mID0geyB0eXAgPSBwbGFuZXR5cHNb
M10sIHggPSAwLCB5ID0gMCB9CgoJZ2VuX3N0YXRzID0geyByb29tcyA9IDAsIG9iamVjdHMgPSAw
LCBzZWVkID0gMCwgaGlzdG9yeSA9IHt9IH0KCXN0YXJ0X3BvcyA9IHsgeCA9IHBsYXllci54LCB5
ID0gcGxheWVyLnkgfQoJLS0gbW9kZTogM2Qgb3IgMmQgbWFwCgl2aWV3X21vZGUgPSAiM2QiCgoJ
LS0gZGVidWcgbW9kZSBmb3IgcmF5IGNhc3RpbmcKCWRlYnVnX21vZGUgPSBmYWxzZQoJc2hvd19k
aWFnbm9zdGljcyA9IGZhbHNlCgllbmFibGVfZGlhZ25vc3RpY3NfbG9nZ2luZyA9IGZhbHNlCgkt
LSBQZXJtYW5lbnRseSBkaXNhYmxlZCBmb3IgcHJvZHVjdGlvbiBwZXJmb3JtYW5jZQoJLS0gT3B0
aW9uYWw6IHJlLWVuYWJsZSBhIG5vbi1yZW5kZXIgQ1BVIGdvdmVybm9yIChzYW1wbGVzIENQVSBv
dXRzaWRlIF9kcmF3KCkpCgllbmFibGVfbm9ucmVuZGVyX2dvdmVybm9yID0gZmFsc2UKCXJlY2Vu
dF9jcHUgPSAwCgoJLS0gcGVyZm9ybWFuY2UgdmFsaWRhdGlvbiBtb2RlOiBkaXNhYmxlcyBDUFUg
Z292ZXJub3IgdG8gc3RhYmlsaXplIG1lYXN1cmVtZW50cwoJcGVyZl92YWxpZGF0aW9uID0gZmFs
c2UKCgktLSBkaWFnbm9zdGljIGNvdW50ZXJzIGZvciBwZXJmb3JtYW5jZSB0cmFja2luZyAocmVm
cmVzaGVkIGVhY2ggZnJhbWUpCglkaWFnX2ZyYW1lX2NvdW50ID0gMAoJZGlhZ193YWxsX2NvbHVt
bnMgPSAwCglkaWFnX3dhbGxfbG9kX2NvbHVtbnMgPSAwCglkaWFnX2Zsb29yX3Jvd3MgPSAwCglk
aWFnX2Zsb29yX2JhdGNoZXMgPSAwCglkaWFnX3Nwcml0ZV9jb2x1bW5zID0gMAoJZGlhZ19zcHJp
dGVfaW1wb3N0b3JfY29sdW1ucyA9IDAKCWRpYWdfYWN0aXZlX3JheXMgPSByYXlfY291bnQKCWxh
c3RfY3B1X3NhbXBsZSA9IDAKCgktLSB0ZXN0IGRvb3IgbW9kZQoJdGVzdF9kb29yX21vZGUgPSBm
YWxzZQoKCS0tIGNyZWF0ZSB0aW50ZWQgZXJyb3IgdGV4dHVyZXMgZm9yIGRpZmZlcmVudCBvYmpl
Y3QgdHlwZXMgKGNoZWNrZXJib2FyZCBwYXR0ZXJuKQoJLS0gd2FsbHM6IG1hZ2VudGEvcGluayAo
OC8xNCksIGZsb29yOiBibHVlL2N5YW4gKDEyLzEzKSwgY2VpbGluZzogZ3JlZW4vZGFyayBncmVl
biAoMTEvMykKCS0tIHNwcml0ZXM6IHllbGxvdy9vcmFuZ2UgKDEwLzkpLCBwcm9wczogcmVkL2Jy
b3duICg4LzQpCgllcnJvcl90ZXh0dXJlcyA9IHsKCQl3YWxsID0gdXNlcmRhdGEoInU4IiwgMzIs
IDMyKSwKCQlkb29yID0gdXNlcmRhdGEoInU4IiwgMzIsIDMyKSwKCQlmbG9vciA9IHVzZXJkYXRh
KCJ1OCIsIDMyLCAzMiksCgkJY2VpbGluZyA9IHVzZXJkYXRhKCJ1OCIsIDMyLCAzMiksCgkJc3By
aXRlID0gdXNlcmRhdGEoInU4IiwgMzIsIDMyKSwKCQlkZWZhdWx0ID0gdXNlcmRhdGEoInU4Iiwg
MzIsIDMyKQoJfQoKCS0tIGdlbmVyYXRlIHRpbnRlZCBjaGVja2VyYm9hcmRzIGZvciBlYWNoIHR5
cGUKCWxvY2FsIHRpbnRzID0gewoJCXdhbGwgPSB7IDgsIDE0IH0sIC0tIG1hZ2VudGEvcGluawoJ
CWRvb3IgPSB7IDIsIDYgfSwgLS0gcHVycGxlL2JsdWUgKGRpc3RpbmN0IGZyb20gd2FsbHMpCgkJ
Zmxvb3IgPSB7IDEyLCAxMyB9LCAtLSBibHVlL2N5YW4KCQljZWlsaW5nID0geyAxMSwgMyB9LCAt
LSBncmVlbi9kYXJrIGdyZWVuCgkJc3ByaXRlID0geyAxMCwgOSB9LCAtLSB5ZWxsb3cvb3Jhbmdl
CgkJZGVmYXVsdCA9IHsgOCwgMTQgfSAtLSBtYWdlbnRhL3BpbmsgKGZhbGxiYWNrKQoJfQoKCWZv
ciB0eXBlX25hbWUsIGNvbG9ycyBpbiBwYWlycyh0aW50cykgZG8KCQlmb3IgeSA9IDAsIDMxIGRv
CgkJCWZvciB4ID0gMCwgMzEgZG8KCQkJCWxvY2FsIGNvbG9yID0gKChmbHIoeCAvIDQpICsgZmxy
KHkgLyA0KSkgJSAyID09IDApIGFuZCBjb2xvcnNbMV0gb3IgY29sb3JzWzJdCgkJCQllcnJvcl90
ZXh0dXJlc1t0eXBlX25hbWVdOnNldCh4LCB5LCBjb2xvcikKCQkJZW5kCgkJZW5kCgllbmQKCgkt
LSBtYWludGFpbiBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggc2luZ2xlIGVycm9yX3RleHR1
cmUKCWVycm9yX3RleHR1cmUgPSBlcnJvcl90ZXh0dXJlcy5kZWZhdWx0CgoJLS0gcmVzZXJ2ZSBz
cHJpdGUgaW5kZXhlcyBmb3IgZXJyb3IgdGV4dHVyZXMgKGJhdGNoaW5nIHByZWZlcnMgc3ByaXRl
IGluZGV4ZXMpCglFUlJPUl9JRFggPSB7IHdhbGwgPSA4MDAwLCBkb29yID0gODAwMSwgZmxvb3Ig
PSA4MDAyLCBjZWlsaW5nID0gODAwMywgc3ByaXRlID0gODAwNCwgZGVmYXVsdCA9IDgwMDUgfQoJ
Zm9yIG5hbWUsIHVkIGluIHBhaXJzKGVycm9yX3RleHR1cmVzKSBkbwoJCWxvY2FsIGlkeCA9IEVS
Uk9SX0lEWFtuYW1lXSBvciBFUlJPUl9JRFguZGVmYXVsdAoJCXNldF9zcHIoaWR4LCB1ZCkKCWVu
ZAoKCS0tIFByZWxvYWQgdGV4dHVyZSBjYWNoZSBmb3IgY29tbW9ubHktdXNlZCBzcHJpdGVzICgw
LTIwMCkKCS0tIFBvcHVsYXRlIHRleF9jYWNoZSBkaXJlY3RseSB1c2luZyBnZXRfc3ByKCkgdG8g
YXZvaWQgd2FybmluZ3MKCWxvZy5kZWJ1ZygicHJlbG9hZGluZyB0ZXh0dXJlIGNhY2hlLi4uIikK
CWxvY2FsIHByZWxvYWRfc3RhcnQgPSB0aW1lKCkKCWZvciBpID0gMCwgMjAwIGRvCgkJbG9jYWwg
c3JjID0gZ2V0X3NwciBhbmQgZ2V0X3NwcihpKQoJCWlmIHNyYyBhbmQgY2FjaGVfdGV4IHRoZW4K
CQkJY2FjaGVfdGV4KGksIHNyYywgZmFsc2UpCgkJZW5kCgllbmQKCWxvY2FsIHByZWxvYWRfdGlt
ZSA9ICh0aW1lKCkgLSBwcmVsb2FkX3N0YXJ0KSAqIDEwMDAKCWxvZy5kZWJ1ZygidGV4dHVyZSBj
YWNoZSBwcmVsb2FkZWQ6ICVzbXMiLCB0b3N0cmluZyhwcmVsb2FkX3RpbWUpKQoJLS0gVHJpZ2dl
ciBHQyBhZnRlciBwcmVsb2FkaW5nIChQaWNvdHJvbiBndWlkZWxpbmU6IHN0YXQoMCkgZHVyaW5n
IHBhdXNlcyBvbmx5KQoJc3RhdCgwKQoKCS0tIGxvZ2dpbmcgaGVscGVyOiBjb25zb2xlICsgcmlu
ZyBidWZmZXIgZm9yIG9wdGlvbmFsIG9uLXNjcmVlbiBlY2hvCgktLSByZW1vdmVkIGxlZ2FjeSBs
b2NhbCBsb2coKSB0byBhdm9pZCBjbGFzaGluZyB3aXRoIGdsb2JhbCBsb2dnZXIKCgktLSB2YWxp
ZGF0ZSBhbGwgY29uZmlndXJlZCBzcHJpdGVzIGV4aXN0IChjb21tZW50IG91dCBmb3IgcHJvZHVj
dGlvbikKCXZhbGlkYXRlX3Nwcml0ZV9jb25maWd1cmF0aW9uKCkKCglsb2cuaW5mbygicGljb3Ry
b24gcmF5Y2FzdCBlbmdpbmUgdjEuMCIpCglzd2l0Y2hfc2NlbmUoIm1lbnUiKQplbmQKCi0tIHZh
bGlkYXRlIHNwcml0ZSBjb25maWd1cmF0aW9uIGF0IHN0YXJ0dXAgKG9wdGlvbmFsLCBjYW4gYmUg
ZGlzYWJsZWQgZm9yIHBlcmZvcm1hbmNlKQpmdW5jdGlvbiB2YWxpZGF0ZV9zcHJpdGVfY29uZmln
dXJhdGlvbigpCgktLSBjaGVjayBlbmVteSBzcHJpdGVzCglmb3IgZW5lbXkgaW4gYWxsKGVuZW15
X3R5cGVzKSBkbwoJCWlmIG5vdCBnZXRfc3ByKGVuZW15LnNwcml0ZSkgdGhlbgoJCQlsb2cud2Fy
bigiZW5lbXkgc3ByaXRlICVzICglcykgbm90IGZvdW5kIGluIEdGWCBmaWxlcyIsIHRvc3RyaW5n
KGVuZW15LnNwcml0ZSksIHRvc3RyaW5nKGVuZW15Lm5hbWUpKQoJCWVuZAoJZW5kCgoJLS0gY2hl
Y2sgZGVjb3JhdGlvbiBzcHJpdGVzCglmb3IgZGVjIGluIGFsbChkZWNvcmF0aW9uX3R5cGVzKSBk
bwoJCWlmIG5vdCBnZXRfc3ByKGRlYy5zcHJpdGUpIHRoZW4KCQkJbG9nLndhcm4oImRlY29yYXRp
b24gc3ByaXRlICVzICglcykgbm90IGZvdW5kIGluIEdGWCBmaWxlcyIsIHRvc3RyaW5nKGRlYy5z
cHJpdGUpLCB0b3N0cmluZyhkZWMubmFtZSkpCgkJZW5kCgllbmQKCgktLSBjaGVjayB3YWxsIHRl
eHR1cmUgc3ByaXRlcwoJZm9yIHRleHNldCBpbiBhbGwodGV4c2V0cykgZG8KCQlmb3IgdmFyaWFu
dCBpbiBhbGwodGV4c2V0LnZhcmlhbnRzKSBkbwoJCQlpZiBub3QgZ2V0X3Nwcih2YXJpYW50KSB0
aGVuCgkJCQlsb2cud2Fybigid2FsbCB0ZXh0dXJlIHNwcml0ZSAlcyBub3QgZm91bmQgaW4gR0ZY
IGZpbGVzIiwgdG9zdHJpbmcodmFyaWFudCkpCgkJCWVuZAoJCWVuZAoJZW5kCgoJLS0gY2hlY2sg
Zmxvb3IvY2VpbGluZyBzcHJpdGVzCglmb3IgdHlwIGluIGFsbChwbGFuZXR5cHMpIGRvCgkJaWYg
bm90IGdldF9zcHIodHlwLnRleCkgdGhlbgoJCQlsb2cud2FybigiZmxvb3IvY2VpbGluZyBzcHJp
dGUgJXMgbm90IGZvdW5kIGluIEdGWCBmaWxlcyIsIHRvc3RyaW5nKHR5cC50ZXgpKQoJCWVuZAoJ
ZW5kCmVuZAoKZnVuY3Rpb24gdXBkYXRlX2dhbWVwbGF5KCkKCS0tIGluY3JlbWVudCBmcmFtZSBj
b3VudGVyCglmcmFtZV9jdCArPSAxCgoJLS0gb3B0aW9uYWw6IHNhbXBsZSBDUFUgb3V0c2lkZSBy
ZW5kZXIgZnJhbWUgKGV2ZXJ5IDMwIGZyYW1lcykgZm9yIG5vbi1yZW5kZXIgZ292ZXJub3IKCWlm
IGVuYWJsZV9ub25yZW5kZXJfZ292ZXJub3IgYW5kIChmcmFtZV9jdCAlIDMwID09IDApIHRoZW4K
CQlyZWNlbnRfY3B1ID0gc3RhdCgxKSBvciAwCgllbmQKCgktLSBjb21iYXQgZ2F0aW5nOiBza2lw
IG5vcm1hbCB1cGRhdGVzIHdoZW4gaW4gY29tYmF0CglpZiBpbl9jb21iYXQgdGhlbgoJCXVwZGF0
ZV9jb21iYXQoKQoJCXJldHVybgoJZW5kCgoJdXBkYXRlX2lucHV0KCkKCXVwZGF0ZV9kb29ycygp
CgoJLS0gdXBkYXRlIG5wYyBhaSAocmF0ZSBsaW1pdGVkLCBkZXRlcm1pbmlzdGljIGZyYW1lIGNo
ZWNrKQoJaWYgZnJhbWVfY3QgJSBhaV91cGRhdGVfcmF0ZSA9PSAwIHRoZW4KCQl1cGRhdGVfbnBj
X2FpKCkKCWVuZAoKCWNhbSA9IHsgcGxheWVyLngsIHBsYXllci55IH0KCgktLSB1cGRhdGUgZmxv
b3IvY2VpbGluZyBzY3JvbGxpbmcKCWZsb29yLnggKz0gZmxvb3IudHlwLnh2ZWwgb3IgMAoJZmxv
b3IueSArPSBmbG9vci50eXAueXZlbCBvciAwCglyb29mLnggKz0gcm9vZi50eXAueHZlbCBvciAw
Cglyb29mLnkgKz0gcm9vZi50eXAueXZlbCBvciAwCgoJLS0gdXBkYXRlIG9iamVjdCBhbmltYXRp
b25zCglmb3Igb2IgaW4gYWxsKGFuaW1hdGVkX29iamVjdHMpIGRvCgkJaWYgb2IudHlwIGFuZCBv
Yi50eXAuZnJhbWVjdCB0aGVuCgkJCW9iLmZyYW1lICs9IG9iLnR5cC5hbmltc3BkCgkJCWlmIG9i
LmFuaW1sb29wIHRoZW4KCQkJCW9iLmZyYW1lID0gb2IuZnJhbWUgJSBvYi50eXAuZnJhbWVjdAoJ
CQllbHNlCgkJCQlvYi5mcmFtZSA9IG1pbihvYi5mcmFtZSwgb2IudHlwLmZyYW1lY3QgLSAxKQoJ
CQllbmQKCQllbmQKCWVuZAoKCS0tIHRvZ2dsZSB2aWV3IG1vZGUgKGRlYnVnIG9ubHkpCglpZiBk
ZWJ1Z19tb2RlIGFuZCAoa2V5cCgieCIpIG9yIGJ0bnAoNSkpIHRoZW4KCQl2aWV3X21vZGUgPSB2
aWV3X21vZGUgPT0gIjNkIiBhbmQgIjJkIiBvciAiM2QiCgllbmQKCgktLSBkZWJ1ZyBtb2RlIHRv
Z2dsZSAobW92ZWQgZnJvbSBidG5wKDQpIHRvIGF2b2lkIGNvbmZsaWN0KQoJaWYga2V5cCgidGFi
IikgdGhlbgoJCWRlYnVnX21vZGUgPSBub3QgZGVidWdfbW9kZQoJZW5kCgoJLS0gZGlhZ25vc3Rp
Y3Mgb3ZlcmxheSByZW1vdmVkOyBtZXJnZWQgaW50byBkZWJ1ZyBwYW5lbCAoVGFiKQoKCS0tIHRv
Z2dsZSBkaWFnbm9zdGljcyBsb2dnaW5nIChjb250cm9sbGVyIGJ1dHRvbiAxMikKCWlmIGJ0bnAo
MTIpIHRoZW4KCQllbmFibGVfZGlhZ25vc3RpY3NfbG9nZ2luZyA9IG5vdCBlbmFibGVfZGlhZ25v
c3RpY3NfbG9nZ2luZwoJCWxvZy5pbmZvKCJEaWFnbm9zdGljcyBsb2dnaW5nOiAlcyIsIHRvc3Ry
aW5nKGVuYWJsZV9kaWFnbm9zdGljc19sb2dnaW5nKSkKCWVuZAoKCS0tIGRlY3JlbWVudCB0cmFw
IG1lc3NhZ2UgdGltZXIKCWlmIHRyYXBfbXNnX3RpbWVyID4gMCB0aGVuCgkJdHJhcF9tc2dfdGlt
ZXIgLT0gMQoJZW5kCgoJLS0gdG9nZ2xlIHRlc3QgZG9vciBtb2RlICh3aGVuIG5vdCBpbiAyZCBt
YXAgdmlldykKCWlmIHZpZXdfbW9kZSA9PSAiM2QiIGFuZCAoa2V5cCgidiIpIG9yIGJ0bnAoMTUp
KSB0aGVuCgkJdGVzdF9kb29yX21vZGUgPSBub3QgdGVzdF9kb29yX21vZGUKCWVuZAoKCS0tIGN5
Y2xlIHRlc3QgZG9vciBvcGVuIHZhbHVlICgwLjAgdG8gMS4wKQoJaWYgdGVzdF9kb29yX21vZGUg
dGhlbgoJCWlmIGtleXAoImMiKSB0aGVuCgkJCXRlc3RfZG9vcl9vcGVuID0gKHRlc3RfZG9vcl9v
cGVuIG9yIDApICsgMC4xCgkJCWlmIHRlc3RfZG9vcl9vcGVuID4gMSB0aGVuIHRlc3RfZG9vcl9v
cGVuID0gMCBlbmQKCQllbmQKCQlpZiBrZXlwKCJkIikgdGhlbgoJCQl0ZXN0X2Rvb3Jfb3BlbiA9
ICh0ZXN0X2Rvb3Jfb3BlbiBvciAwKSAtIDAuMQoJCQlpZiB0ZXN0X2Rvb3Jfb3BlbiA8IDAgdGhl
biB0ZXN0X2Rvb3Jfb3BlbiA9IDEgZW5kCgkJZW5kCgllbmQKCgktLSBjeWNsZSBmbG9vciB0eXBl
IChmb3IgdGVzdGluZykgd2hlbiBub3QgaW4gZG9vciB0ZXN0IG1vZGUKCWlmIG5vdCB0ZXN0X2Rv
b3JfbW9kZSBhbmQga2V5cCgiYyIpIHRoZW4KCQlsb2NhbCBjdXJyZW50X2lkeCA9IDEKCQlmb3Ig
aSA9IDEsICNwbGFuZXR5cHMgZG8KCQkJaWYgcGxhbmV0eXBzW2ldLnRleCA9PSBmbG9vci50eXAu
dGV4IHRoZW4KCQkJCWN1cnJlbnRfaWR4ID0gaQoJCQkJYnJlYWsKCQkJZW5kCgkJZW5kCgkJZmxv
b3IudHlwID0gcGxhbmV0eXBzWyhjdXJyZW50X2lkeCAlICNwbGFuZXR5cHMpICsgMV0KCQlmbG9v
ci54LCBmbG9vci55ID0gMCwgMAoJCS0tIFRlc3QgbW9kZTogY2xlYXIgY2FjaGUgd2hlbiBjeWNs
aW5nIGZsb29yIHR5cGVzIChjYW4gYmUgZGlzYWJsZWQgaW4gcHJvZHVjdGlvbikKCQlpZiBjbGVh
cl90ZXh0dXJlX2NhY2hlcyB0aGVuIGNsZWFyX3RleHR1cmVfY2FjaGVzKCkgZW5kCgllbmQKCgkt
LSBjeWNsZSByb29mIHR5cGUgKGZvciB0ZXN0aW5nKSB3aGVuIG5vdCBpbiBkb29yIHRlc3QgbW9k
ZQoJaWYgbm90IHRlc3RfZG9vcl9tb2RlIGFuZCBrZXlwKCJkIikgdGhlbgoJCWxvY2FsIGN1cnJl
bnRfaWR4ID0gMQoJCWZvciBpID0gMSwgI3BsYW5ldHlwcyBkbwoJCQlpZiBwbGFuZXR5cHNbaV0u
dGV4ID09IHJvb2YudHlwLnRleCB0aGVuCgkJCQljdXJyZW50X2lkeCA9IGkKCQkJCWJyZWFrCgkJ
CWVuZAoJCWVuZAoJCXJvb2YudHlwID0gcGxhbmV0eXBzWyhjdXJyZW50X2lkeCAlICNwbGFuZXR5
cHMpICsgMV0KCQlyb29mLngsIHJvb2YueSA9IDAsIDAKCQktLSBUZXN0IG1vZGU6IGNsZWFyIGNh
Y2hlIHdoZW4gY3ljbGluZyByb29mIHR5cGVzIChjYW4gYmUgZGlzYWJsZWQgaW4gcHJvZHVjdGlv
bikKCQlpZiBjbGVhcl90ZXh0dXJlX2NhY2hlcyB0aGVuIGNsZWFyX3RleHR1cmVfY2FjaGVzKCkg
ZW5kCgllbmQKCgktLSBkZWJ1ZyByYXkgY2FzdGluZyAocmVtb3ZlZCAtIHVzZSBkaWFnbm9zdGlj
cyBvdmVybGF5IGluc3RlYWQgd2l0aCBUYWIga2V5KQoJLS0gTGVnYWN5IHJheWNhc3QoKS9oaXRz
Y2FuKCkgZnVuY3Rpb25zIG5vIGxvbmdlciBhdmFpbGFibGUgYWZ0ZXIgcmVuZGVyZXIgcmVmYWN0
b3IKCS0tIFVzZSByX2RpYWcgZGlhZ25vc3RpY3Mgb3ZlcmxheSAoVGFiIGtleSkgZm9yIHBlcmZv
cm1hbmNlIG1ldHJpY3MKZW5kCgpmdW5jdGlvbiBkcmF3X2dhbWVwbGF5KCkKCWNsaXAoMCwgMCwg
c2NyZWVuX3dpZHRoLCBzY3JlZW5faGVpZ2h0KQoJY2xzKDApCgoJbG9jYWwgZnJhbWVfc3RhcnQg
PSB0aW1lKCkKCglkaWFnX2ZyYW1lX2NvdW50ICs9IDEKCgktLSByZXNldCBwZXItZnJhbWUgZGlh
Z25vc3RpY3MKCWRpYWdfd2FsbF9jb2x1bW5zID0gMAoJZGlhZ193YWxsX2xvZF9jb2x1bW5zID0g
MAoJZGlhZ19mbG9vcl9yb3dzID0gMAoJZGlhZ19mbG9vcl9iYXRjaGVzID0gMAoJZGlhZ19zcHJp
dGVfY29sdW1ucyA9IDAKCWRpYWdfc3ByaXRlX2ltcG9zdG9yX2NvbHVtbnMgPSAwCgoJLS0gRW5z
dXJlIGFkYXB0aXZlIGNvbnRyb2xzIGFyZSBpbml0aWFsaXplZCBvbmNlCglpZiBub3QgYWN0aXZl
X3JheV9jb3VudCB0aGVuIGFjdGl2ZV9yYXlfY291bnQgPSByYXlfY291bnQgZW5kCglpZiBub3Qg
cm93X3N0cmlkZV9keW5hbWljIHRoZW4gcm93X3N0cmlkZV9keW5hbWljID0gcm93X3N0cmlkZSBl
bmQKCglsb2NhbCBmdW5jdGlvbiBhZGp1c3RfcmF5X2J1ZGdldChjcHVfc2FtcGxlKQoJCWxvY2Fs
IG1pbl9yYXlzID0gbWF4KDQ4LCBmbHIocmF5X2NvdW50ICogMC4yNSkpCgkJaWYgY3B1X3NhbXBs
ZSA_IDAuOTAgdGhlbgoJCQlhY3RpdmVfcmF5X2NvdW50ID0gbWF4KG1pbl9yYXlzLCBhY3RpdmVf
cmF5X2NvdW50IC0gMTYpCgkJZWxzZWlmIGNwdV9zYW1wbGUgPCAwLjcwIHRoZW4KCQkJYWN0aXZl
X3JheV9jb3VudCA9IG1pbihyYXlfY291bnQsIGFjdGl2ZV9yYXlfY291bnQgKyA4KQoJCWVuZAoJ
ZW5kCgoJLS0gQ29udGludW91cyBDUFUgc2FtcGxpbmcgZm9yIGFkYXB0aXZlIGJ1ZGdldAoJbG9j
YWwgY3B1X3NhbXBsZSA9IHN0YXQoMSkgb3IgbGFzdF9jcHVfc2FtcGxlIG9yIDAKCWlmIG5vdCBw
ZXJmX3ZhbGlkYXRpb24gYW5kIG5vdCBlbmFibGVfbm9ucmVuZGVyX2dvdmVybm9yIHRoZW4KCQlh
ZGp1c3RfcmF5X2J1ZGdldChjcHVfc2FtcGxlKQoJZW5kCgoJLS0gT3B0aW9uYWwgbm9uLXJlbmRl
ciBnb3Zlcm5vcjogdXNlcyBDUFUgc2FtcGxlZCBpbiBfdXBkYXRlKCkKCWlmIGVuYWJsZV9ub25y
ZW5kZXJfZ292ZXJub3IgdGhlbgoJCWFkanVzdF9yYXlfYnVkZ2V0KHJlY2VudF9jcHUgb3IgY3B1
X3NhbXBsZSkKCWVuZAoJbGFzdF9jcHVfc2FtcGxlID0gY3B1X3NhbXBsZQoJZGlhZ19hY3RpdmVf
cmF5cyA9IGFjdGl2ZV9yYXlfY291bnQKCgktLSBQcmVwYXJlIGZyYW1lIGluIG5ldyByZW5kZXJl
cgoJcl9zdGF0ZS5wcmVwYXJlX2ZyYW1lKCkKCXJfc3RhdGUuY29uZmlnLmRlYnVnX21vZGUgPSBk
ZWJ1Z19tb2RlCgoJLS0gVXBkYXRlIGRlYnVnIG1vZGUKCXJfc3RhdGUuY29uZmlnLmRlYnVnX21v
ZGUgPSBkZWJ1Z19tb2RlCgoJaWYgdmlld19tb2RlID09ICIzZCIgdGhlbgoJCS0tIEJ1aWxkIGNh
bWVyYSB0YWJsZQoJCWxvY2FsIGNhbWVyYSA9IHsgeCA9IHBsYXllci54LCB5ID0gcGxheWVyLnks
IGEgPSBwbGF5ZXIuYSB9CgoJCS0tIFVwZGF0ZSB2aWV3IChjYW1lcmEgYmFzaXMgYW5kIHJheSBM
VVRzKQoJCXJfdmlldy51cGRhdGUoY2FtZXJhLCByX3N0YXRlLCBmb3YsIGFjdGl2ZV9yYXlfY291
bnQpCgkJbG9jYWwgdF92aWV3ID0gdGltZSgpCgoJCS0tIENhc3QgcmF5cwoJCWxvY2FsIGdhbWVf
c3RhdGVfY2FzdCA9IHsKCQkJZ2V0X3dhbGwgPSBnZXRfd2FsbCwKCQkJaXNfZG9vciA9IGlzX2Rv
b3IsCgkJCWRvb3JncmlkID0gZG9vcmdyaWQsCgkJCXRlc3RfZG9vcl9tb2RlID0gdGVzdF9kb29y
X21vZGUsCgkJCXRlc3RfZG9vcl9vcGVuID0gdGVzdF9kb29yX29wZW4sCgkJCWZhcl9wbGFuZSA9
IGZhcl9wbGFuZSwKCQkJbWFwX3NpemUgPSBtYXBfc2l6ZQoJCX0KCQlyX2Nhc3QuY2FzdF9zY2Vu
ZShjYW1lcmEsIHJfdmlldywgcl9zdGF0ZSwgZ2FtZV9zdGF0ZV9jYXN0KQoJCWxvY2FsIHRfcmF5
Y2FzdCA9IHRpbWUoKQoKCQktLSBEcmF3IGZsb29yIGFuZCBjZWlsaW5nCgkJbG9jYWwgZ2FtZV9z
dGF0ZV9mbG9vciA9IHsKCQkJZmxvb3IgPSBmbG9vciwKCQkJcm9vZiA9IHJvb2YsCgkJCXNwcml0
ZV9zaXplID0gc3ByaXRlX3NpemUsCgkJCXBlcl9jZWxsX2Zsb29yc19lbmFibGVkID0gcGVyX2Nl
bGxfZmxvb3JzX2VuYWJsZWQsCgkJCWdldF9mbG9vciA9IGdldF9mbG9vciwKCQkJcGxhbmV0eXBz
ID0gcGxhbmV0eXBzLAoJCQlFUlJPUl9JRFggPSBFUlJPUl9JRFgsCgkJCWdldF9zcHIgPSBnZXRf
c3ByLAoJCQllcnJvcl90ZXh0dXJlcyA9IGVycm9yX3RleHR1cmVzCgkJfQoJCXJfZmxvb3IuZHJh
d19mbG9vcl9jZWlsaW5nKGNhbWVyYSwgcl92aWV3LCByX3N0YXRlLCByX2JhdGNoLCBnYW1lX3N0
YXRlX2Zsb29yKQoJCWxvY2FsIHRfZmxvb3IgPSB0aW1lKCkKCgkJLS0gRHJhdyB3YWxscwoJCWxv
Y2FsIGdhbWVfc3RhdGVfd2FsbHMgPSB7CgkJCXdhbGxfbG9kX2Rpc3RhbmNlID0gd2FsbF9sb2Rf
ZGlzdGFuY2UsCgkJCXdhbGxfdGlueV9zY3JlZW5fcHggPSB3YWxsX3Rpbnlfc2NyZWVuX3B4LAoJ
CQlzcHJpdGVfc2l6ZSA9IHNwcml0ZV9zaXplLAoJCQlpc19kb29yID0gaXNfZG9vciwKCQkJZ2V0
X3NwciA9IGdldF9zcHIsCgkJCWVycm9yX3RleHR1cmVzID0gZXJyb3JfdGV4dHVyZXMsCgkJCUVS
Uk9SX0lEWCA9IEVSUk9SX0lEWAoJCX0KCQlyX3dhbGxzLmRyYXdfc3BhbnMoY2FtZXJhLCByX3Zp
ZXcsIHJfc3RhdGUsIHJfYmF0Y2gsIGdhbWVfc3RhdGVfd2FsbHMpCgkJbG9jYWwgdF93YWxscyA9
IHRpbWUoKQoKCQktLSBEcmF3IHNwcml0ZXMKCQlsb2NhbCBnYW1lX3N0YXRlX3Nwcml0ZXMgPSB7
CgkJCW9iamVjdHMgPSBvYmplY3RzLAoJCQlmYXJfcGxhbmUgPSBmYXJfcGxhbmUsCgkJCXNwcml0
ZV9sb2RfcmF0aW8gPSBzcHJpdGVfbG9kX3JhdGlvLAoJCQlmb2dfZmFyID0gZm9nX2ZhciwKCQkJ
c3ByaXRlX3NpemUgPSBzcHJpdGVfc2l6ZSwKCQkJZ2V0X3NwciA9IGdldF9zcHIsCgkJCWVycm9y
X3RleHR1cmVzID0gZXJyb3JfdGV4dHVyZXMKCQl9CgkJcl9zcHJpdGVzLmRyYXcoY2FtZXJhLCBy
X3ZpZXcsIHJfc3RhdGUsIHJfYmF0Y2gsIGdhbWVfc3RhdGVfc3ByaXRlcykKCQlsb2NhbCB0X3Nw
cml0ZXMgPSB0aW1lKCkKCgkJbG9jYWwgbXNfdmlldyA9ICh0X3ZpZXcgLSBmcmFtZV9zdGFydCkg
KiAxMDAwCgkJbG9jYWwgbXNfcmF5Y2FzdCA9ICh0X3JheWNhc3QgLSB0X3ZpZXcpICogMTAwMAoJ
CWxvY2FsIG1zX2Zsb29yID0gKHRfZmxvb3IgLSB0X3JheWNhc3QpICogMTAwMAoJCWxvY2FsIG1z
X3dhbGxzID0gKHRfd2FsbHMgLSB0X2Zsb29yKSAqIDEwMDAKCQlsb2NhbCBtc19zcHJpdGVzID0g
KHRfc3ByaXRlcyAtIHRfd2FsbHMpICogMTAwMAoJCWxvY2FsIGZyYW1lX21zID0gKHRfc3ByaXRl
cyAtIGZyYW1lX3N0YXJ0KSAqIDEwMDAKCgkJLS0gaHVkIChtaW5pbWFsKQoJCXByaW50KCJwb3M6
IiAuLiBmbHIocGxheWVyLngpIC4uICIsIiAuLiBmbHIocGxheWVyLnkpLCAyLCAyLCA3KQoJCXBy
aW50KCJhbmc6IiAuLiAoZmxyKHBsYXllci5hICogMTAwKSAvIDEwMCksIDIsIDEwLCA3KQoJCXBy
aW50KCJmcHM6IiAuLiBzdGF0KDcpLCAyLCAxOCwgNykKCQlwcmludCgiaHA6IiAuLiBwbGF5ZXIu
aHAsIDIsIDI2LCA3KQoKCQktLSBpbnRlcmFjdGlvbiBwcm9tcHQKCQlpZiBpbnRlcmFjdGlvbl9h
Y3RpdmUgYW5kIGN1cnJlbnRfaW50ZXJhY3QgdGhlbgoJCQlwcmludCgiW0VdL1o6IGludGVyYWN0
Iiwgc2NyZWVuX2NlbnRlcl94IC0gNDAsIHNjcmVlbl9oZWlnaHQgLSAyMCwgMTEpCgkJZW5kCgoJ
CS0tIHRyYXAgbWVzc2FnZQoJCWlmIHRyYXBfbXNnX3RpbWVyID4gMCB0aGVuCgkJCXByaW50KCJ0
cmFwIHNwcnVuZyEiLCBzY3JlZW5fY2VudGVyX3ggLSAzMCwgc2NyZWVuX2NlbnRlcl95LCA4KQoJ
CWVuZAoKCQktLVtbIERFQlVHIFBBTkVMIFJFTU9WRUQgRk9SIFBST0RVQ1RJT04gUEVSRk9STUFO
Q0UKIGlmIGRlYnVnX21vZGUgdGhlbgogIC0tIHJlbW92ZWQKIGVuZAogXV0KCgkJLS1bWyBQRVJJ
T0RJQyBMT0dHSU5HIFJFTU9WRUQgRk9SIFBST0RVQ1RJT04gUEVSRk9STUFOQ0UKIGlmIGVuYWJs
ZV9kaWFnbm9zdGljc19sb2dnaW5nIGFuZCBkaWFnX2ZyYW1lX2NvdW50JTYwPT0wIHRoZW4KICAt
LSByZW1vdmVkCiBlbmQKIF1dCgoJCS0tIG1pbmltYXAgSFVEIG92ZXJsYXkKCQlkcmF3X21pbmlt
YXBfaHVkKCkKCWVsc2UKCQlkcmF3X21pbmltYXAoKQoJZW5kCgoJLS0gY29tYmF0IG92ZXJsYXkK
CWlmIGluX2NvbWJhdCB0aGVuCgkJcmVjdGZpbGwoMCwgc2NyZWVuX2hlaWdodCAtIDQwLCBzY3Jl
ZW5fd2lkdGgsIHNjcmVlbl9oZWlnaHQsIDApCgkJcHJpbnQoImVudGVyaW5nIGNvbWJhdC4uLiIs
IHNjcmVlbl9jZW50ZXJfeCAtIDQwLCBzY3JlZW5fY2VudGVyX3ksIDgpCgkJcHJpbnQoIltlbnRl
cl0gZXhpdCAodGVtcCkiLCBzY3JlZW5fY2VudGVyX3ggLSA0MCwgc2NyZWVuX2NlbnRlcl95ICsg
MTAsIDcpCgllbmQKCgktLSByZXN0b3JlIHBhbGV0dGUgZnJvbSBmb2cgcmVtYXBwaW5nIChzaW5n
bGUgcmVzdG9yZSBwZXIgZnJhbWUpCglwYWwoKQoJLS0gcmVzZXQgZm9nIHN0YXRlIHNvIGZpcnN0
IHNldF9mb2cgYXBwbGllcyBtYXBwaW5nIG5leHQgZnJhbWUKCWxhc3RfZm9nX2xldmVsID0gLTEK
CXByZXZfcGFsID0ge30KCgktLSBEcmF3IGRpYWdub3N0aWNzIG92ZXJsYXkgKG5ldyByZW5kZXJl
cikKCXJfZGlhZy5kcmF3KHJfc3RhdGUsIGZyYW1lX21zLCBjcHVfc2FtcGxlKQplbmQKCmxvY2Fs
IGZ1bmN0aW9uIGdlbmVyYXRlX2xhYl9kdW5nZW9uKHN0YXRlLCBzZWVkKQoJbG9jYWwgdGFyZ2V0
X3NlZWQgPSBzZWVkIG9yICgxICsgZmxyKHJuZCg5OTk5OTkpKSkKCWlmIHRhcmdldF9zZWVkIDwg
MSB0aGVuIHRhcmdldF9zZWVkID0gMSBlbmQKCXN0YXJ0X3BvcywgZ2VuX3N0YXRzID0gZ2VuZXJh
dGVfZHVuZ2Vvbih7IHNlZWQgPSB0YXJnZXRfc2VlZCB9KQoJc3RhdGUuc2VlZCA9IGdlbl9zdGF0
cy5zZWVkCglzdGF0ZS5nZW5fc3RhdHMgPSBnZW5fc3RhdHMKCXN0YXRlLmhpc3RvcnkgPSBnZW5f
c3RhdHMuaGlzdG9yeSBvciB7fQoJc3RhdGUuaGlzdG9yeV9jdXJzb3IgPSBtYXgoMCwgI3N0YXRl
Lmhpc3RvcnkgLSAyMCkKCXN0YXRlLmhhcm5lc3NfcmVzdWx0ID0gc3RhdGUuaGFybmVzc19yZXN1
bHQgb3IgbmlsCgl2aWV3X21vZGUgPSAiMmQiCmVuZAoKbG9jYWwgZnVuY3Rpb24gZHJhd19sYWJf
bWFwKHN0YXRlKQoJbG9jYWwgbWFyZ2luX291dGVyID0gNAoJbG9jYWwgbWFwX3BhZGRpbmcgPSAz
Cglsb2NhbCBsb2dfcGFuZWxfd2lkdGggPSAxNzYKCWxvY2FsIGxvZ19wYW5lbF9tYXJnaW4gPSA4
CgoJbG9jYWwgbGVmdF94MCA9IG1hcmdpbl9vdXRlcgoJbG9jYWwgbGVmdF94MSA9IHNjcmVlbl93
aWR0aCAtIGxvZ19wYW5lbF93aWR0aCAtIGxvZ19wYW5lbF9tYXJnaW4gLSAxCglpZiBsZWZ0X3gx
IDwgbGVmdF94MCArIDMyIHRoZW4gbGVmdF94MSA9IGxlZnRfeDAgKyAzMiBlbmQKCWxvY2FsIGxl
ZnRfd2lkdGggPSBsZWZ0X3gxIC0gbGVmdF94MCArIDEKCWxvY2FsIGxlZnRfdG9wID0gbWFyZ2lu
X291dGVyCglsb2NhbCBsZWZ0X2JvdHRvbSA9IHNjcmVlbl9oZWlnaHQgLSBtYXJnaW5fb3V0ZXIK
CXJlY3RmaWxsKGxlZnRfeDAsIGxlZnRfdG9wLCBsZWZ0X3gxLCBsZWZ0X2JvdHRvbSwgMCkKCWNs
aXAobGVmdF94MCwgbGVmdF90b3AsIGxlZnRfd2lkdGgsIGxlZnRfYm90dG9tIC0gbGVmdF90b3Ag
KyAxKQoKCWxvY2FsIG1pbl94ID0gbWFwX3NpemUKCWxvY2FsIG1pbl95ID0gbWFwX3NpemUKCWxv
Y2FsIG1heF94ID0gLTEKCWxvY2FsIG1heF95ID0gLTEKCWxvY2FsIGZ1bmN0aW9uIGV4dGVuZF9i
Ym94KHgwLCB5MCwgeDEsIHkxKQoJCWlmIHgwIDwgbWluX3ggdGhlbiBtaW5feCA9IHgwIGVuZAoJ
CWlmIHkwIDwgbWluX3kgdGhlbiBtaW5feSA9IHkwIGVuZAoJCWlmIHgxID4gbWF4X3ggdGhlbiBt
YXhfeCA9IHgxIGVuZAoJCWlmIHkxID4gbWF4X3kgdGhlbiBtYXhfeSA9IHkxIGVuZAoJZW5kCglm
b3Igbm9kZSBpbiBhbGwoZ2VuX25vZGVzKSBkbwoJCWxvY2FsIHJlY3QgPSBub2RlLnJlY3QKCQll
eHRlbmRfYmJveChyZWN0WzFdLCByZWN0WzJdLCByZWN0WzNdLCByZWN0WzRdKQoJZW5kCglmb3Ig
ZWRnZSBpbiBhbGwoZ2VuX2VkZ2VzKSBkbwoJCWlmIGVkZ2UuYjEgdGhlbiBleHRlbmRfYmJveChl
ZGdlLmIxLngsIGVkZ2UuYjEueSwgZWRnZS5iMS54LCBlZGdlLmIxLnkpIGVuZAoJCWlmIGVkZ2Uu
YjIgdGhlbiBleHRlbmRfYmJveChlZGdlLmIyLngsIGVkZ2UuYjIueSwgZWRnZS5iMi54LCBlZGdl
LmIyLnkpIGVuZAoJCWlmIGVkZ2UubWV0YWRhdGEgYW5kIGVkZ2UubWV0YWRhdGEuYW5jaG9yIHRo
ZW4KCQkJbG9jYWwgYW5jaG9yID0gZWRnZS5tZXRhZGF0YS5hbmNob3IKCQkJZXh0ZW5kX2Jib3go
YW5jaG9yLngsIGFuY2hvci55LCBhbmNob3IueCwgYW5jaG9yLnkpCgkJZW5kCgllbmQKCWlmIG1p
bl94ID4gbWF4X3ggb3IgbWluX3kgPiBtYXhfeSB0aGVuCgkJbWluX3ggPSAwCgkJbWluX3kgPSAw
CgkJbWF4X3ggPSBtYXBfc2l6ZSAtIDEKCQltYXhfeSA9IG1hcF9zaXplIC0gMQoJZW5kCglsb2Nh
bCBiYm94X21hcmdpbiA9IDIKCW1pbl94ID0gbWF4KDAsIG1pbl94IC0gYmJveF9tYXJnaW4pCglt
aW5feSA9IG1heCgwLCBtaW5feSAtIGJib3hfbWFyZ2luKQoJbWF4X3ggPSBtaW4obWFwX3NpemUg
LSAxLCBtYXhfeCArIGJib3hfbWFyZ2luKQoJbWF4X3kgPSBtaW4obWFwX3NpemUgLSAxLCBtYXhf
eSArIGJib3hfbWFyZ2luKQoKCWxvY2FsIGJib3hfdyA9IG1heF94IC0gbWluX3ggKyAxCglsb2Nh
bCBiYm94X2ggPSBtYXhfeSAtIG1pbl95ICsgMQoKCWxvY2FsIGF2YWlsYWJsZV93ID0gbGVmdF93
aWR0aCAtIG1hcF9wYWRkaW5nICogMgoJbG9jYWwgYXZhaWxhYmxlX2ggPSAobGVmdF9ib3R0b20g
LSBsZWZ0X3RvcCArIDEpIC0gbWFwX3BhZGRpbmcgKiAyCglsb2NhbCBtYXhfc2NhbGUgPSBmbHIo
bWluKGF2YWlsYWJsZV93IC8gYmJveF93LCBhdmFpbGFibGVfaCAvIGJib3hfaCkpCglsb2NhbCBk
ZXNpcmVkX3NjYWxlID0gMgoJbG9jYWwgc2NhbGUgPSBtYXgoMSwgbWluKG1heF9zY2FsZSwgZGVz
aXJlZF9zY2FsZSkpCglsb2NhbCBtYXBfcHhfdyA9IGJib3hfdyAqIHNjYWxlCglsb2NhbCBtYXBf
cHhfaCA9IGJib3hfaCAqIHNjYWxlCglsb2NhbCBveCA9IGxlZnRfeDAgKyBtYXBfcGFkZGluZyAr
IGZscigoYXZhaWxhYmxlX3cgLSBtYXBfcHhfdykgLyAyKQoJbG9jYWwgb3kgPSBsZWZ0X3RvcCAr
IG1hcF9wYWRkaW5nICsgZmxyKChhdmFpbGFibGVfaCAtIG1hcF9weF9oKSAvIDIpCgoJcmVjdGZp
bGwob3ggLSAyLCBveSAtIDIsIG94ICsgbWFwX3B4X3cgKyAxLCBveSArIG1hcF9weF9oICsgMSwg
MSkKCWZvciB4ID0gbWluX3gsIG1heF94IGRvCgkJZm9yIHkgPSBtaW5feSwgbWF4X3kgZG8KCQkJ
bG9jYWwgd2FsbCA9IGdldF93YWxsKHgsIHkpCgkJCWxvY2FsIGZsb29yX3ZhbCA9IGdldF9mbG9v
cih4LCB5KQoJCQlsb2NhbCBjb2xvcgoJCQlpZiB3YWxsID4gMCB0aGVuCgkJCQljb2xvciA9IDUK
CQkJZWxzZWlmIGZsb29yX3ZhbCA_IDAgdGhlbgoJCQkJY29sb3IgPSA2CgkJCWVsc2UKCQkJCWNv
bG9yID0gMAoJCQllbmQKCQkJbG9jYWwgcHgwID0gb3ggKyAoeCAtIG1pbl94KSAqIHNjYWxlCgkJ
CWxvY2FsIHB5MCA9IG95ICsgKHkgLSBtaW5feSkgKiBzY2FsZQoJCQlyZWN0ZmlsbChweDAsIHB5
MCwgcHgwICsgc2NhbGUgLSAxLCBweTAgKyBzY2FsZSAtIDEsIGNvbG9yKQoJCWVuZAoJZW5kCglm
b3Igbm9kZSBpbiBhbGwoZ2VuX25vZGVzKSBkbwoJCWxvY2FsIHIgPSBub2RlLnJlY3QKCQlyZWN0
KG94ICsgKHJbMV0gLSBtaW5feCkgKiBzY2FsZSwgb3kgKyAoclsyXSAtIG1pbl95KSAqIHNjYWxl
LCBveCArIChyWzNdIC0gbWluX3gpICogc2NhbGUsIG95ICsgKHJbNF0gLSBtaW5feSkgKiBzY2Fs
ZSwgMTEpCgllbmQKCWZvciBlZGdlIGluIGFsbChnZW5fZWRnZXMpIGRvCgkJbG9jYWwgYyA9IGVk
Z2UubG9ja2VkIGFuZCA4IG9yIDEyCgkJbG9jYWwgeDEgPSBveCArIChlZGdlLm4xLm1pZHggLSBt
aW5feCkgKiBzY2FsZQoJCWxvY2FsIHkxID0gb3kgKyAoZWRnZS5uMS5taWR5IC0gbWluX3kpICog
c2NhbGUKCQlsb2NhbCB4MiA9IG94ICsgKGVkZ2UubjIubWlkeCAtIG1pbl94KSAqIHNjYWxlCgkJ
bG9jYWwgeTIgPSBveSArIChlZGdlLm4yLm1pZHkgLSBtaW5feSkgKiBzY2FsZQoJCWxpbmUoeDEs
IHkxLCB4MiwgeTIsIGMpCgkJaWYgZWRnZS5iMSB0aGVuCgkJCWxvY2FsIGJ4ID0gb3ggKyAoZWRn
ZS5iMS54IC0gbWluX3gpICogc2NhbGUKCQkJbG9jYWwgYnkgPSBveSArIChlZGdlLmIxLnkgLSBt
aW5feSkgKiBzY2FsZQoJCQlyZWN0ZmlsbChieCwgYnksIGJ4ICsgc2NhbGUgLSAxLCBieSArIHNj
YWxlIC0gMSwgYykKCQllbmQKCQlpZiBlZGdlLmIyIHRoZW4KCQkJbG9jYWwgYnggPSBveCArIChl
ZGdlLmIyLnggLSBtaW5feCkgKiBzY2FsZQoJCQlsb2NhbCBieSA9IG95ICsgKGVkZ2UuYjIueSAt
IG1pbl95KSAqIHNjYWxlCgkJCXJlY3RmaWxsKGJ4LCBieSwgYnggKyBzY2FsZSAtIDEsIGJ5ICsg
c2NhbGUgLSAxLCBjKQoJCWVuZAoJZW5kCglmb3IgZG9vciBpbiBhbGwoZG9vcnMpIGRvCgkJbG9j
YWwgYyA9IGRvb3IuZHR5cGUgPT0gZG9vcl9sb2NrZWQgYW5kIDggb3IgMTAKCQlsb2NhbCBkeCA9
IG94ICsgKGRvb3IueCAtIG1pbl94KSAqIHNjYWxlCgkJbG9jYWwgZHkgPSBveSArIChkb29yLnkg
LSBtaW5feSkgKiBzY2FsZQoJCXJlY3RmaWxsKGR4LCBkeSwgZHggKyBzY2FsZSAtIDEsIGR5ICsg
c2NhbGUgLSAxLCBjKQoJZW5kCglmb3Igb2IgaW4gYWxsKG9iamVjdHMpIGRvCgkJaWYgb2IucG9z
IHRoZW4KCQkJbG9jYWwgY3ggPSBveCArIChvYi5wb3NbMV0gLSBtaW5feCkgKiBzY2FsZQoJCQls
b2NhbCBjeSA9IG95ICsgKG9iLnBvc1syXSAtIG1pbl95KSAqIHNjYWxlCgkJCWxvY2FsIGNvbG9y
ID0gNwoJCQlpZiBvYi50eXAgPT0gb2JqX3R5cGVzLmtleSB0aGVuCgkJCQljb2xvciA9IDkKCQkJ
ZWxzZWlmIG9iLnR5cCA9PSBvYmpfdHlwZXMuaG9zdGlsZV9ucGMgdGhlbgoJCQkJY29sb3IgPSA4
CgkJCWVsc2VpZiBvYi50eXAgPT0gb2JqX3R5cGVzLm5vbl9ob3N0aWxlX25wYyB0aGVuCgkJCQlj
b2xvciA9IDEzCgkJCWVsc2VpZiBvYi50eXAgYW5kIG9iLnR5cC5raW5kID09ICJpbnRlcmFjdGFi
bGUiIHRoZW4KCQkJCWNvbG9yID0gMTIKCQkJZW5kCgkJCWNpcmNmaWxsKGN4LCBjeSwgbWF4KDEs
IHNjYWxlIFwgMiksIGNvbG9yKQoJCWVuZAoJZW5kCgljbGlwKCkKCXByaW50KCJjb250cm9sczog
Wj1yYW5kb20gIFg9cmVwbGF5ICDihpAv4oaSIHNlZWQgIEY9aGFybmVzcyIsIGxlZnRfeDAsIHNj
cmVlbl9oZWlnaHQgLSAyMCwgNykKCXByaW50KCJzY3JvbGwgbG9nOiDihpEv4oaTICAgIG1lbnU6
IEcgb3IgTUVOVSIsIGxlZnRfeDAsIHNjcmVlbl9oZWlnaHQgLSAxMiwgNykKZW5kCgpsb2NhbCBm
dW5jdGlvbiBkcmF3X2xhYl9oaXN0b3J5KHN0YXRlKQoJbG9jYWwgbG9nX3BhbmVsX3dpZHRoID0g
MTc2Cglsb2NhbCBsb2dfcGFuZWxfbWFyZ2luID0gOAoJbG9jYWwgcGFuZWxfeCA9IHNjcmVlbl93
aWR0aCAtIGxvZ19wYW5lbF93aWR0aCAtIGxvZ19wYW5lbF9tYXJnaW4KCWxvY2FsIHBhbmVsX3cg
PSBsb2dfcGFuZWxfd2lkdGgKCWxvY2FsIHBhbmVsX3RvcCA9IDEyCglsb2NhbCBwYW5lbF9ib3R0
b20gPSBzY3JlZW5faGVpZ2h0IC0gMTIKCWxvY2FsIHBhbmVsX2ggPSBwYW5lbF9ib3R0b20gLSBw
YW5lbF90b3AKCglyZWN0ZmlsbChwYW5lbF94IC0gNCwgcGFuZWxfdG9wIC0gNCwgcGFuZWxfeCAr
IHBhbmVsX3cgKyAyLCBwYW5lbF9ib3R0b20sIDApCglyZWN0KHBhbmVsX3ggLSA1LCBwYW5lbF90
b3AgLSA1LCBwYW5lbF94ICsgcGFuZWxfdyArIDMsIHBhbmVsX2JvdHRvbSArIDEsIDEpCgljbGlw
KHBhbmVsX3ggLSA0LCBwYW5lbF90b3AgLSA0LCBwYW5lbF93ICsgNiwgcGFuZWxfaCArIDYpCgoJ
bG9jYWwgeSA9IHBhbmVsX3RvcAoJbG9jYWwgc2VlZF90ZXh0ID0gInNlZWQ6ICIgLi4gKHN0YXRl
LnNlZWQgb3IgIj8iKQoJbG9jYWwgcm9vbXNfdGV4dCA9ICJyb29tczogIiAuLiAoI2dlbl9ub2Rl
cyBvciAwKQoJbG9jYWwgbG9ja2VkX2NvdW50ID0gMAoJaWYgZ2VuX2xvY2tlZF9lZGdlcyB0aGVu
CgkJZm9yIGUgaW4gYWxsKGdlbl9sb2NrZWRfZWRnZXMpIGRvCgkJCWlmIGUubG9ja2VkIHRoZW4g
bG9ja2VkX2NvdW50ICs9IDEgZW5kCgkJZW5kCgllbmQKCWxvY2FsIGxvY2tlZF90ZXh0ID0gImxv
Y2tlZCBlZGdlczogIiAuLiBsb2NrZWRfY291bnQKCXByaW50KHNlZWRfdGV4dCwgcGFuZWxfeCwg
eSwgNykKCXkgKz0gOAoJcHJpbnQocm9vbXNfdGV4dCwgcGFuZWxfeCwgeSwgNykKCXkgKz0gOAoJ
cHJpbnQobG9ja2VkX3RleHQsIHBhbmVsX3gsIHksIDcpCgl5ICs9IDEyCgoJbG9jYWwgaGlzdG9y
eSA9IHN0YXRlLmhpc3Rvcnkgb3Ige30KCWxvY2FsIGF2YWlsYWJsZV9zcGFjZSA9IHBhbmVsX2gg
LSAoeSAtIHBhbmVsX3RvcCkgLSAyNAoJbG9jYWwgbGluZV9oID0gOAoJbG9jYWwgbWF4X2xpbmVz
ID0gbWF4KDAsIGZscihhdmFpbGFibGVfc3BhY2UgLyBsaW5lX2gpKQoJbG9jYWwgbWF4X2NoYXJz
ID0gbWF4KDEsIGZscigocGFuZWxfdyAtIDEyKSAvIDQpKQoKCXByaW50KCJnZW5lcmF0aW9uIGxv
ZyIsIHBhbmVsX3gsIHksIDExKQoJeSArPSBsaW5lX2gKCglpZiBtYXhfbGluZXMgPD0gMCB0aGVu
CgkJcHJpbnQoIihwYW5lbCB0b28gc21hbGwpIiwgcGFuZWxfeCwgeSwgOCkKCWVsc2UKCQlsb2Nh
bCBjdXJzb3IgPSBzdGF0ZS5oaXN0b3J5X2N1cnNvciBvciAwCgkJbG9jYWwgbWF4X2N1cnNvciA9
IG1heCgwLCAjaGlzdG9yeSAtIDEpCgkJaWYgY3Vyc29yID4gbWF4X2N1cnNvciB0aGVuIGN1cnNv
ciA9IG1heF9jdXJzb3IgZW5kCgkJaWYgY3Vyc29yIDwgMCB0aGVuIGN1cnNvciA9IDAgZW5kCgkJ
c3RhdGUuaGlzdG9yeV9jdXJzb3IgPSBjdXJzb3IKCQlpZiAjaGlzdG9yeSA9PSAwIHRoZW4KCQkJ
cHJpbnQoIihubyBldmVudHMpIiwgcGFuZWxfeCwgeSwgNSkKCQllbHNlCgkJCWxvY2FsIGxpbmVz
X3JlbWFpbmluZyA9IG1heF9saW5lcwoJCQlsb2NhbCBpZHggPSBjdXJzb3IgKyAxCgkJCXdoaWxl
IGlkeCA8PSAjaGlzdG9yeSBhbmQgbGluZXNfcmVtYWluaW5nID4gMCBkbwoJCQkJbG9jYWwgZW50
cnkgPSBoaXN0b3J5W2lkeF0KCQkJCWlmIGVudHJ5IHRoZW4KCQkJCQlsb2NhbCBwb3MgPSAxCgkJ
CQkJd2hpbGUgcG9zIDw9ICNlbnRyeSBhbmQgbGluZXNfcmVtYWluaW5nID4gMCBkbwoJCQkJCQls
b2NhbCBjaHVuayA9IHN1YihlbnRyeSwgcG9zLCBwb3MgKyBtYXhfY2hhcnMgLSAxKQoJCQkJCQlw
cmludChjaHVuaywgcGFuZWxfeCwgeSwgNykKCQkJCQkJeSArPSBsaW5lX2gKCQkJCQkJbGluZXNf
cmVtYWluaW5nIC09IDEKCQkJCQkJcG9zICs9IG1heF9jaGFycwoJCQkJCWVuZAoJCQkJZW5kCgkJ
CQlpZHggKz0gMQoJCQllbmQKCQllbmQKCWVuZAoKCXkgPSBwYW5lbF9ib3R0b20gLSAxNgoJaWYg
c3RhdGUuaGFybmVzc19yZXN1bHQgdGhlbgoJCWxvY2FsIHJlcyA9IHN0YXRlLmhhcm5lc3NfcmVz
dWx0CgkJbG9jYWwgZmFpbHVyZXMgPSByZXMuZmFpbHVyZXMgb3IgMAoJCWxvY2FsIGNvbG9yID0g
ZmFpbHVyZXMgPiAwIGFuZCA4IG9yIDExCgkJcHJpbnQoImhhcm5lc3M6ICIgLi4gKHJlcy50b3Rh
bCBvciAwKSwgcGFuZWxfeCwgeSwgY29sb3IpCgkJeSArPSBsaW5lX2gKCQlwcmludCgiZmFpbHVy
ZXM6ICIgLi4gZmFpbHVyZXMsIHBhbmVsX3gsIHksIGNvbG9yKQoJCXkgKz0gbGluZV9oCgllbmQK
CXByaW50KCJzY3JvbGw6IOKGkS-ihpMgICBtZW51OiBHL01FTlUiLCBwYW5lbF94LCB5LCA2KQoJ
Y2xpcCgpCmVuZAoKc2NlbmVzLm1lbnUgPSB7CgllbnRlciA9IGZ1bmN0aW9uKHN0YXRlKQoJCXN0
YXRlLm9wdGlvbnMgPSB7ICJTdGFydCBHYW1lcGxheSIsICJEdW5nZW9uIExhYiIgfQoJCXN0YXRl
LmluZGV4ID0gc3RhdGUuaW5kZXggb3IgMQoJCXN0YXRlLm1lc3NhZ2UgPSAiIgoJZW5kLAoJdXBk
YXRlID0gZnVuY3Rpb24oc3RhdGUpCgkJbG9jYWwgbW92ZV91cCA9IGJ0bnAoMikgb3Iga2V5cCgi
dXAiKSBvciBrZXlwKCJ3IikKCQlsb2NhbCBtb3ZlX2Rvd24gPSBidG5wKDMpIG9yIGtleXAoImRv
d24iKSBvciBrZXlwKCJzIikKCQlpZiBtb3ZlX3VwIHRoZW4KCQkJc3RhdGUuaW5kZXggPSBtYXgo
MSwgc3RhdGUuaW5kZXggLSAxKQoJCWVsc2VpZiBtb3ZlX2Rvd24gdGhlbgoJCQlzdGF0ZS5pbmRl
eCA9IG1pbigjc3RhdGUub3B0aW9ucywgc3RhdGUuaW5kZXggKyAxKQoJCWVuZAoKCQlsb2NhbCBj
b25maXJtID0gYnRucCg0KSBvciBidG5wKDUpIG9yIGtleXAoInoiKSBvciBrZXlwKCJ4Iikgb3Ig
a2V5cCgiZW50ZXIiKSBvciBrZXlwKCJyZXR1cm4iKQoJCWlmIGNvbmZpcm0gdGhlbgoJCQlsb2Nh
bCBjaG9pY2UgPSBzdGF0ZS5vcHRpb25zW3N0YXRlLmluZGV4XQoJCQlpZiBjaG9pY2UgPT0gIlN0
YXJ0IEdhbWVwbGF5IiB0aGVuCgkJCQlzd2l0Y2hfc2NlbmUoImdhbWVwbGF5Iiwge30pCgkJCWVs
c2VpZiBjaG9pY2UgPT0gIkR1bmdlb24gTGFiIiB0aGVuCgkJCQlzd2l0Y2hfc2NlbmUoImR1bmdl
b25fbGFiIiwge30pCgkJCWVuZAoJCWVuZAoJZW5kLAoJZHJhdyA9IGZ1bmN0aW9uKHN0YXRlKQoJ
CWNscygwKQoJCXByaW50KCJSYXljYXN0IEVuZ2luZSIsIHNjcmVlbl9jZW50ZXJfeCAtIDQ4LCA0
MCwgMTEpCgkJcHJpbnQoIk1haW4gTWVudSIsIHNjcmVlbl9jZW50ZXJfeCAtIDMyLCA1NiwgNykK
CQlmb3IgaWR4LCBvcHQgaW4gaXBhaXJzKHN0YXRlLm9wdGlvbnMpIGRvCgkJCWxvY2FsIHkgPSA4
MCArIChpZHggLSAxKSAqIDEyCgkJCWxvY2FsIGNvbG9yID0gKGlkeCA9PSBzdGF0ZS5pbmRleCkg
YW5kIDEwIG9yIDcKCQkJcHJpbnQoKGlkeCA9PSBzdGF0ZS5pbmRleCBhbmQgIj4iIG9yICIgIikg
Li4gIiAiIC4uIG9wdCwgc2NyZWVuX2NlbnRlcl94IC0gNDAsIHksIGNvbG9yKQoJCWVuZAoJCXBy
aW50KCJbWl0gY29uZmlybSAgW1VQL0RPV05dIG5hdmlnYXRlIiwgc2NyZWVuX2NlbnRlcl94IC0g
NjQsIHNjcmVlbl9oZWlnaHQgLSAzMiwgNykKCWVuZAp9CgpzY2VuZXMuZ2FtZXBsYXkgPSB7Cgll
bnRlciA9IGZ1bmN0aW9uKHN0YXRlLCBwYXJhbXMpCgkJbG9jYWwgc2VlZCA9IHBhcmFtcyBhbmQg
cGFyYW1zLnNlZWQKCQlzdGFydF9wb3MsIGdlbl9zdGF0cyA9IGdlbmVyYXRlX2R1bmdlb24oeyBz
ZWVkID0gc2VlZCB9KQoJCXBsYXllci54ID0gc3RhcnRfcG9zLngKCQlwbGF5ZXIueSA9IHN0YXJ0
X3Bvcy55CgkJdmlld19tb2RlID0gIjNkIgoJCXN0YXRlLnNlZWQgPSBnZW5fc3RhdHMuc2VlZAoJ
ZW5kLAoJdXBkYXRlID0gZnVuY3Rpb24oc3RhdGUpCgkJaWYgYnRucCg2KSBvciBrZXlwKCJnIikg
dGhlbgoJCQlzd2l0Y2hfc2NlbmUoIm1lbnUiKQoJCQlyZXR1cm4KCQllbmQKCQl1cGRhdGVfZ2Ft
ZXBsYXkoKQoJZW5kLAoJZHJhdyA9IGZ1bmN0aW9uKHN0YXRlKQoJCWRyYXdfZ2FtZXBsYXkoKQoJ
CXByaW50KCJbTUVOVV0vRyB0byByZXR1cm4iLCBzY3JlZW5fd2lkdGggLSAxMjAsIHNjcmVlbl9o
ZWlnaHQgLSAxMCwgNykKCWVuZAp9CgpzY2VuZXMuZHVuZ2Vvbl9sYWIgPSB7CgllbnRlciA9IGZ1
bmN0aW9uKHN0YXRlLCBwYXJhbXMpCgkJc3RhdGUuc2VlZCA9IHBhcmFtcyBhbmQgcGFyYW1zLnNl
ZWQKCQlnZW5lcmF0ZV9sYWJfZHVuZ2VvbihzdGF0ZSwgc3RhdGUuc2VlZCkKCWVuZCwKCXVwZGF0
ZSA9IGZ1bmN0aW9uKHN0YXRlKQoJCWlmIGJ0bnAoNikgb3Iga2V5cCgiZyIpIHRoZW4KCQkJc3dp
dGNoX3NjZW5lKCJtZW51IikKCQkJcmV0dXJuCgkJZW5kCgkJaWYga2V5cCgieiIpIHRoZW4KCQkJ
Z2VuZXJhdGVfbGFiX2R1bmdlb24oc3RhdGUsIG5pbCkKCQllbHNlaWYga2V5cCgieCIpIHRoZW4K
CQkJZ2VuZXJhdGVfbGFiX2R1bmdlb24oc3RhdGUsIHN0YXRlLnNlZWQpCgkJZWxzZWlmIGtleXAo
ImxlZnQiKSBvciBidG5wKDApIHRoZW4KCQkJbG9jYWwgc2VlZCA9IChzdGF0ZS5zZWVkIG9yIDEp
IC0gMQoJCQlpZiBzZWVkIDwgMSB0aGVuIHNlZWQgPSAxIGVuZAoJCQlnZW5lcmF0ZV9sYWJfZHVu
Z2VvbihzdGF0ZSwgc2VlZCkKCQllbHNlaWYga2V5cCgicmlnaHQiKSBvciBidG5wKDEpIHRoZW4K
CQkJbG9jYWwgc2VlZCA9IChzdGF0ZS5zZWVkIG9yIDEpICsgMQoJCQlnZW5lcmF0ZV9sYWJfZHVu
Z2VvbihzdGF0ZSwgc2VlZCkKCQllbHNlaWYga2V5cCgiZiIpIHRoZW4KCQkJbG9jYWwgcHJldmlv
dXNfc2VlZCA9IHN0YXRlLnNlZWQKCQkJc3RhdGUuaGFybmVzc19yZXN1bHQgPSBkdW5nZW9uX2hh
cm5lc3MucnVuKCkKCQkJZ2VuZXJhdGVfbGFiX2R1bmdlb24oc3RhdGUsIHByZXZpb3VzX3NlZWQp
CgkJZWxzZWlmIGJ0bnAoMikgb3Iga2V5cCgidXAiKSB0aGVuCgkJCXN0YXRlLmhpc3RvcnlfY3Vy
c29yID0gbWF4KDAsIChzdGF0ZS5oaXN0b3J5X2N1cnNvciBvciAwKSAtIDEpCgkJZWxzZWlmIGJ0
bnAoMykgb3Iga2V5cCgiZG93biIpIHRoZW4KCQkJbG9jYWwgaGlzdG9yeSA9IHN0YXRlLmhpc3Rv
cnkgb3Ige30KCQkJbG9jYWwgbWF4X2N1cnNvciA9IG1heCgwLCAjaGlzdG9yeSAtIDEpCgkJCXN0
YXRlLmhpc3RvcnlfY3Vyc29yID0gbWluKG1heF9jdXJzb3IsIChzdGF0ZS5oaXN0b3J5X2N1cnNv
ciBvciAwKSArIDEpCgkJZW5kCgllbmQsCglkcmF3ID0gZnVuY3Rpb24oc3RhdGUpCgkJZHJhd19s
YWJfbWFwKHN0YXRlKQoJCWRyYXdfbGFiX2hpc3Rvcnkoc3RhdGUpCgllbmQKfQoKZnVuY3Rpb24g
X3VwZGF0ZSgpCglzY2VuZV91cGRhdGUoKQplbmQKCmZ1bmN0aW9uIF9kcmF3KCkKCXNjZW5lX2Ry
YXcoKQplbmQKCi0tIGRyYXcgMmQgbWluaW1hcCBmb3IgdGVzdGluZwotLSBQdXJwb3NlOiBSZW5k
ZXIgMkQgdG9wLWRvd24gZGVidWcgdmlldyBvZiBkdW5nZW9uCi0tIEFsZ29yaXRobTogU2NhbGUg
MTI4w5cxMjggbWFwIHRvIDI1NsOXMjU2IHBpeGVscyAoc2NhbGU9MikKLS0gRGlzcGxheXM6IFdh
bGxzLCByb29tcywgZG9vcnMsIG9iamVjdHMsIHBsYXllciBwb3NpdGlvbiBhbmQgZmFjaW5nCi0t
IE5vdGVzOiBUb2dnbGVkIHdpdGggWCBidXR0b24sIHVzZWZ1bCBmb3IgZGVidWdnaW5nIGdlbmVy
YXRpb24KZnVuY3Rpb24gZHJhd19taW5pbWFwKCkKCWxvY2FsIHNjYWxlID0gMgoJbG9jYWwgb3gs
IG95ID0gMTAsIDEwCgoJLS0gYmF0Y2ggYWxsIHRpbGUgZHJhd2luZyB0byByZWR1Y2UgZHJhdyBj
YWxsIGNvdW50CglyYmF0Y2hfcmVzZXQoKQoKCS0tIGRyYXcgd2FsbHMgZnJvbSBtYXAud2FsbHMg
dXNlcmRhdGEgd2l0aCBmbG9vciBkYXRhIHRvIGRpc3Rpbmd1aXNoIGNvcnJpZG9ycyBmcm9tIHZv
aWQKCWZvciB4ID0gMCwgMTI3IGRvCgkJZm9yIHkgPSAwLCAxMjcgZG8KCQkJbG9jYWwgd2FsbCA9
IGdldF93YWxsKHgsIHkpCgkJCWxvY2FsIGZsb29yX3ZhbCA9IGdldF9mbG9vcih4LCB5KQoJCQls
b2NhbCBjb2xvcgoJCQlpZiB3YWxsID4gMCB0aGVuCgkJCQktLSB3YWxsIHRpbGUKCQkJCWNvbG9y
ID0gNQoJCQllbHNlaWYgZmxvb3JfdmFsID4gMCB0aGVuCgkJCQktLSBjYXJ2ZWQgY29ycmlkb3Iv
cm9vbSBmbG9vciAoZmxvb3IgdHlwZSBzZXQgZHVyaW5nIGdlbmVyYXRpb24pCgkJCQljb2xvciA9
IDYKCQkJZWxzZQoJCQkJLS0gdW5jYXJ2ZWQgdm9pZCAod2FsbD0wLCBmbG9vcj0wKQoJCQkJY29s
b3IgPSAxCgkJCWVuZAoJCQlyYmF0Y2hfcHVzaChveCArIHggKiBzY2FsZSwgb3kgKyB5ICogc2Nh
bGUsIG94ICsgeCAqIHNjYWxlICsgc2NhbGUgLSAxLCBveSArIHkgKiBzY2FsZSArIHNjYWxlIC0g
MSwgY29sb3IpCgkJZW5kCgllbmQKCglyYmF0Y2hfc3VibWl0KCkKCgktLSBkcmF3IHJvb21zCglm
b3Igbm9kZSBpbiBhbGwoZ2VuX25vZGVzKSBkbwoJCWxvY2FsIHIgPSBub2RlLnJlY3QKCQlyZWN0
KG94ICsgclsxXSAqIHNjYWxlLCBveSArIHJbMl0gKiBzY2FsZSwgb3ggKyByWzNdICogc2NhbGUs
IG95ICsgcls0XSAqIHNjYWxlLCAxMSkKCWVuZAoKCS0tIGJhdGNoIGRvb3IgZHJhd2luZwoJcmJh
dGNoX3Jlc2V0KCkKCWZvciBkb29yIGluIGFsbChkb29ycykgZG8KCQlsb2NhbCBjID0gZG9vci5k
dHlwZSA9PSBkb29yX2xvY2tlZCBhbmQgOCBvciAxMgoJCXJiYXRjaF9wdXNoKG94ICsgZG9vci54
ICogc2NhbGUsIG95ICsgZG9vci55ICogc2NhbGUsIG94ICsgZG9vci54ICogc2NhbGUgKyBzY2Fs
ZSAtIDEsIG95ICsgZG9vci55ICogc2NhbGUgKyBzY2FsZSAtIDEsIGMpCgllbmQKCXJiYXRjaF9z
dWJtaXQoKQoKCS0tIGRyYXcgb2JqZWN0cwoJZm9yIG9iIGluIGFsbChvYmplY3RzKSBkbwoJCWxv
Y2FsIGMgPSA3CgkJaWYgb2IudHlwIGFuZCBvYi50eXAua2luZCA9PSAiaG9zdGlsZV9ucGMiIHRo
ZW4KCQkJYyA9IDgKCQllbHNlaWYgb2IudHlwIGFuZCBvYi50eXAua2luZCA9PSAiZGlyZWN0X3Bp
Y2t1cCIgdGhlbgoJCQlpZiBvYi50eXAuc3VidHlwZSA9PSAiaGVhcnQiIHRoZW4KCQkJCWMgPSAx
NAoJCQllbHNlaWYgb2IudHlwLnN1YnR5cGUgPT0gImtleSIgdGhlbgoJCQkJYyA9IDkKCQkJZW5k
CgkJZWxzZWlmIG9iLnR5cCBhbmQgb2IudHlwLmtpbmQgPT0gImludGVyYWN0YWJsZSIgdGhlbgoJ
CQlpZiBvYi50eXAuc3VidHlwZSA9PSAiZXhpdCIgdGhlbiBjID0gMTIgZW5kCgkJZWxzZWlmIG9i
LnR5cCBhbmQgb2IudHlwLmtpbmQgPT0gImRlY29yYXRpdmUiIHRoZW4KCQkJYyA9IDEzCgkJZW5k
CgkJbG9jYWwgeCA9IG9iLnBvc1sxXQoJCWxvY2FsIHkgPSBvYi5wb3NbMl0KCQljaXJjZmlsbChv
eCArIHggKiBzY2FsZSwgb3kgKyB5ICogc2NhbGUsIDEsIGMpCgllbmQKCgktLSBkcmF3IHBsYXll
cgoJbG9jYWwgcHgsIHB5ID0gb3ggKyBwbGF5ZXIueCAqIHNjYWxlLCBveSArIHBsYXllci55ICog
c2NhbGUKCWNpcmNmaWxsKHB4LCBweSwgMiwgMTApCglsb2NhbCBzYSwgY2EgPSBzaW4ocGxheWVy
LmEpLCBjb3MocGxheWVyLmEpCglsaW5lKHB4LCBweSwgcHggKyBjYSAqIDYsIHB5ICsgc2EgKiA2
LCAxMCkKCgktLSBzdGF0cwoJcHJpbnQoIjJkIG1hcCB2aWV3IiwgMTAsIDIsIDcpCglwcmludCgi
cm9vbXM6ICIgLi4gZ2VuX3N0YXRzLnJvb21zLCAxMCwgMTAsIDcpCglwcmludCgib2JqZWN0czog
IiAuLiBnZW5fc3RhdHMub2JqZWN0cywgMTAsIDE4LCA3KQoJcHJpbnQoInNlZWQ6ICIgLi4gZ2Vu
X3N0YXRzLnNlZWQsIDEwLCAyNiwgNykKCWlmIGRlYnVnX21vZGUgdGhlbgoJCXByaW50KCJbeF0g
dG9nZ2xlIDNkIiwgMTAsIDM0LCA3KQoJZW5kCmVuZAoKLS0gZHJhdyBodWQgbWluaW1hcCBvdmVy
bGF5Ci0tIFB1cnBvc2U6IFJlbmRlciBzY3JvbGxpbmcgdmlld3BvcnQgbWluaW1hcCBpbiB0b3At
cmlnaHQgY29ybmVyIGR1cmluZyAzRCB2aWV3Ci0tIEFsZ29yaXRobTogUGxheWVyLWNlbnRlcmVk
IGNhbWVyYSB3aXRoIGNsaXBwZWQgZHJhd2luZyBvZiB2aXNpYmxlIHRpbGVzIG9ubHkKLS0gRGlz
cGxheXM6IFdhbGxzLCBmbG9vcnMsIGRvb3JzLCBvYmplY3RzLCBwbGF5ZXIgKGF1dG8tc2Nyb2xs
cyBhcyBwbGF5ZXIgbW92ZXMpCi0tIE5vdGVzOiBGaXhlZCAxMjDDlzY4cHggdmlld3BvcnQgYXQg
dG9wLXJpZ2h0LCBzY2FsZT0yLCBvbmx5IGRyYXdzIHZpc2libGUgdGlsZSByYW5nZQpmdW5jdGlv
biBkcmF3X21pbmltYXBfaHVkKCkKCWxvY2FsIGh1ZF93ID0gbWF0aC5jZWlsKHNjcmVlbl93aWR0
aCAqIDAuMjUpCglsb2NhbCBodWRfaCA9IG1hdGguY2VpbChzY3JlZW5faGVpZ2h0ICogMC4yNSkK
CWxvY2FsIGh1ZF94ID0gc2NyZWVuX3dpZHRoIC0gaHVkX3cgLSA4Cglsb2NhbCBodWRfeSA9IDgK
CWxvY2FsIHNjYWxlID0gMgoKCS0tIGNhbWVyYSBvZmZzZXQgdG8gY2VudGVyIHBsYXllciBpbiB2
aWV3cG9ydAoJbG9jYWwgY2FtX3ggPSBwbGF5ZXIueCAqIHNjYWxlIC0gaHVkX3cgLyAyCglsb2Nh
bCBjYW1feSA9IHBsYXllci55ICogc2NhbGUgLSBodWRfaCAvIDIKCgktLSBjYWxjdWxhdGUgdmlz
aWJsZSB0aWxlIHJhbmdlCglsb2NhbCB4X21pbiA9IG1heCgwLCBmbHIoY2FtX3ggLyBzY2FsZSkp
Cglsb2NhbCB4X21heCA9IG1pbigxMjcsIGZscigoY2FtX3ggKyBodWRfdykgLyBzY2FsZSkpCgls
b2NhbCB5X21pbiA9IG1heCgwLCBmbHIoY2FtX3kgLyBzY2FsZSkpCglsb2NhbCB5X21heCA9IG1p
bigxMjcsIGZscigoY2FtX3kgKyBodWRfaCkgLyBzY2FsZSkpCgoJLS0gc2V0IGNsaXAgcmVnaW9u
CgljbGlwKGh1ZF94LCBodWRfeSwgaHVkX3csIGh1ZF9oKQoKCS0tIGRyYXcgYmFja2dyb3VuZAoJ
cmVjdGZpbGwoaHVkX3gsIGh1ZF95LCBodWRfeCArIGh1ZF93IC0gMSwgaHVkX3kgKyBodWRfaCAt
IDEsIDApCgoJLS0gYmF0Y2ggbWFwIHRpbGVzIChvbmx5IHZpc2libGUgcmFuZ2UpCglyYmF0Y2hf
cmVzZXQoKQoJZm9yIHggPSB4X21pbiwgeF9tYXggZG8KCQlmb3IgeSA9IHlfbWluLCB5X21heCBk
bwoJCQlsb2NhbCBzeCA9IGh1ZF94ICsgKHggKiBzY2FsZSAtIGNhbV94KQoJCQlsb2NhbCBzeSA9
IGh1ZF95ICsgKHkgKiBzY2FsZSAtIGNhbV95KQoKCQkJLS0gYWRkaXRpb25hbCBib3VuZHMgY2hl
Y2sKCQkJaWYgc3ggPj0gaHVkX3ggYW5kIHN4IDwgaHVkX3ggKyBodWRfdyBhbmQgc3kgPj0gaHVk
X3kgYW5kIHN5IDwgaHVkX3kgKyBodWRfaCB0aGVuCgkJCQlsb2NhbCB3YWxsID0gZ2V0X3dhbGwo
eCwgeSkKCQkJCWxvY2FsIGZsb29yX3ZhbCA9IGdldF9mbG9vcih4LCB5KQoJCQkJbG9jYWwgY29s
b3IKCgkJCQlpZiB3YWxsID4gMCB0aGVuCgkJCQkJY29sb3IgPSA1CgkJCQllbHNlaWYgZmxvb3Jf
dmFsID4gMCB0aGVuCgkJCQkJY29sb3IgPSA2CgkJCQllbHNlCgkJCQkJY29sb3IgPSAxCgkJCQll
bmQKCgkJCQlyYmF0Y2hfcHVzaChzeCwgc3ksIHN4ICsgc2NhbGUgLSAxLCBzeSArIHNjYWxlIC0g
MSwgY29sb3IpCgkJCWVuZAoJCWVuZAoJZW5kCglyYmF0Y2hfc3VibWl0KCkKCgktLSBiYXRjaCBk
b29yIGRyYXdpbmcgdmlhIHNwYXRpYWwgcXVlcnkgb3ZlciB2aXNpYmxlIHRpbGVzCglyYmF0Y2hf
cmVzZXQoKQoJZm9yIHggPSB4X21pbiwgeF9tYXggZG8KCQlmb3IgeSA9IHlfbWluLCB5X21heCBk
bwoJCQlsb2NhbCBkb29yID0gZG9vcmdyaWRbeF0gYW5kIGRvb3JncmlkW3hdW3ldIG9yIG5pbAoJ
CQlpZiBkb29yIHRoZW4KCQkJCWxvY2FsIHN4ID0gaHVkX3ggKyAoeCAqIHNjYWxlIC0gY2FtX3gp
CgkJCQlsb2NhbCBzeSA9IGh1ZF95ICsgKHkgKiBzY2FsZSAtIGNhbV95KQoJCQkJaWYgc3ggPj0g
aHVkX3ggYW5kIHN4IDwgaHVkX3ggKyBodWRfdyBhbmQgc3kgPj0gaHVkX3kgYW5kIHN5IDwgaHVk
X3kgKyBodWRfaCB0aGVuCgkJCQkJbG9jYWwgYyA9IGRvb3IuZHR5cGUgPT0gZG9vcl9sb2NrZWQg
YW5kIDggb3IgMTIKCQkJCQlyYmF0Y2hfcHVzaChzeCwgc3ksIHN4ICsgc2NhbGUgLSAxLCBzeSAr
IHNjYWxlIC0gMSwgYykKCQkJCWVuZAoJCQllbmQKCQllbmQKCWVuZAoJcmJhdGNoX3N1Ym1pdCgp
CgoJLS0gZHJhdyBvYmplY3RzIHZpYSBmbGF0IGFycmF5IGl0ZXJhdGlvbiB3aXRoaW4gdmlld3Bv
cnQgYm91bmRzCglmb3Igb2IgaW4gYWxsKG9iamVjdHMpIGRvCgkJaWYgb2IucG9zIHRoZW4KCQkJ
bG9jYWwgc3ggPSBodWRfeCArIChvYi5wb3NbMV0gKiBzY2FsZSAtIGNhbV94KQoJCQlsb2NhbCBz
eSA9IGh1ZF95ICsgKG9iLnBvc1syXSAqIHNjYWxlIC0gY2FtX3kpCgkJCWlmIHN4ID49IGh1ZF94
IGFuZCBzeCA8IGh1ZF94ICsgaHVkX3cgYW5kIHN5ID49IGh1ZF95IGFuZCBzeSA8IGh1ZF95ICsg
aHVkX2ggdGhlbgoJCQkJbG9jYWwgYyA9IDcKCQkJCWlmIG9iLnR5cCBhbmQgb2IudHlwLmtpbmQg
PT0gImhvc3RpbGVfbnBjIiB0aGVuCgkJCQkJYyA9IDgKCQkJCWVsc2VpZiBvYi50eXAgYW5kIG9i
LnR5cC5raW5kID09ICJkaXJlY3RfcGlja3VwIiB0aGVuCgkJCQkJaWYgb2IudHlwLnN1YnR5cGUg
PT0gImhlYXJ0IiB0aGVuCgkJCQkJCWMgPSAxNAoJCQkJCWVsc2VpZiBvYi50eXAuc3VidHlwZSA9
PSAia2V5IiB0aGVuCgkJCQkJCWMgPSA5CgkJCQkJZW5kCgkJCQllbHNlaWYgb2IudHlwIGFuZCBv
Yi50eXAua2luZCA9PSAiaW50ZXJhY3RhYmxlIiB0aGVuCgkJCQkJaWYgb2IudHlwLnN1YnR5cGUg
PT0gImV4aXQiIHRoZW4gYyA9IDEyIGVuZAoJCQkJZWxzZWlmIG9iLnR5cCBhbmQgb2IudHlwLmtp
bmQgPT0gImRlY29yYXRpdmUiIHRoZW4KCQkJCQljID0gMTMKCQkJCWVuZAoJCQkJY2lyY2ZpbGwo
c3gsIHN5LCAxLCBjKQoJCQllbmQKCQllbmQKCWVuZAoKCS0tIGRyYXcgcGxheWVyIChhbHdheXMg
Y2VudGVyZWQgYnkgY2FtZXJhIGRlc2lnbikKCWxvY2FsIHB4ID0gaHVkX3ggKyAocGxheWVyLngg
KiBzY2FsZSAtIGNhbV94KQoJbG9jYWwgcHkgPSBodWRfeSArIChwbGF5ZXIueSAqIHNjYWxlIC0g
Y2FtX3kpCgljaXJjZmlsbChweCwgcHksIDIsIDEwKQoJbG9jYWwgY2EgPSBjb3MocGxheWVyLmEp
Cglsb2NhbCBzYSA9IHNpbihwbGF5ZXIuYSkKCWxpbmUocHgsIHB5LCBweCArIGNhICogNiwgcHkg
KyBzYSAqIDYsIDEwKQoKCS0tIG9wdGlvbmFsIGZyYW1lCglyZWN0KGh1ZF94LCBodWRfeSwgaHVk
X3ggKyBodWRfdyAtIDEsIGh1ZF95ICsgaHVkX2ggLSAxLCA3KQoKCS0tIHJlc2V0IGNsaXAKCWNs
aXAoKQplbmQKCi0tIHVuaWZpZWQgY29sbGlzaW9uIGNoZWNrIGZvciB3YWxscywgZG9vcnMsIGFu
ZCBvYmplY3RzCi0tIFB1cnBvc2U6IFVuaWZpZWQgY29sbGlzaW9uIGRldGVjdGlvbiBmb3Igd2Fs
bHMsIGRvb3JzLCBhbmQgb2JqZWN0cwotLSBQYXJhbWV0ZXJzOiBweCwgcHkgKHdvcmxkIHBvc2l0
aW9uKSwgcmFkaXVzIChjb2xsaXNpb24gcmFkaXVzKSwgb3BlbmRvb3JzIChhdXRvLW9wZW4gZG9v
cnMpLCBpc3BsYXllciAoZW5hYmxlIGtleSBjaGVja2luZykKLS0gUmV0dXJuczogYm9vbGVhbiAo
dHJ1ZSBpZiBjb2xsaXNpb24gZGV0ZWN0ZWQpCi0tIEFsZ29yaXRobTogR3JpZC1iYXNlZCB3YWxs
IGNoZWNrICsgc3BhdGlhbCBwYXJ0aXRpb25pbmcgZm9yIG9iamVjdHMKLS0gU2lkZSBlZmZlY3Rz
OiBPcGVucyBkb29ycywgcHJldmVudHMgZG9vciBjbG9zaW5nIHdoZW4gcGxheWVyIGluc2lkZQpm
dW5jdGlvbiBpc2NvbChweCwgcHksIHJhZGl1cywgb3BlbmRvb3JzLCBpc3BsYXllcikKCWxvY2Fs
IGNvbCA9IGZhbHNlCglvcGVuZG9vcnMgPSBvcGVuZG9vcnMgb3IgZmFsc2UKCWlzcGxheWVyID0g
aXNwbGF5ZXIgb3IgZmFsc2UKCgktLSBjaGVjayBncmlkIGNlbGxzIGFyb3VuZCBwb3NpdGlvbgoJ
Zm9yIHggPSBmbHIocHggLSByYWRpdXMpLCBmbHIocHggKyByYWRpdXMpIGRvCgkJZm9yIHkgPSBm
bHIocHkgLSByYWRpdXMpLCBmbHIocHkgKyByYWRpdXMpIGRvCgkJCS0tIGJvdW5kcyBjaGVjawoJ
CQlpZiB4IDwgMCBvciB4ID49IDEyOCBvciB5IDwgMCBvciB5ID49IDEyOCB0aGVuCgkJCQljb2wg
PSB0cnVlCgkJCQlicmVhawoJCQllbHNlCgkJCQlsb2NhbCB0aWxlID0gZ2V0X3dhbGwoeCwgeSkK
CgkJCQktLSBjaGVjayBpZiBkb29yIHRpbGUKCQkJCWlmIHRpbGUgPT0gZG9vcl9ub3JtYWwgb3Ig
dGlsZSA9PSBkb29yX2xvY2tlZCBvciB0aWxlID09IGRvb3Jfc3RheV9vcGVuIHRoZW4KCQkJCQls
b2NhbCBkb29yID0gZG9vcmdyaWRbeF1beV0KCQkJCQlpZiBkb29yIHRoZW4KCQkJCQkJaWYgZG9v
ci5vcGVuID09IDEgdGhlbgoJCQkJCQkJLS0gZnVsbHkgb3BlbjogcHJldmVudCBjbG9zaW5nCgkJ
CQkJCQlkb29yLm9wZW5pbmcgPSB0cnVlCgkJCQkJCWVsc2UKCQkJCQkJCS0tIGRvb3IgcGFydGlh
bGx5IG9wZW4gb3IgY2xvc2VkOiBjb2xsaXNpb24gZGV0ZWN0ZWQKCQkJCQkJCWNvbCA9IHRydWUK
CQkJCQkJCS0tIGhhbmRsZSB1bmxvY2tpbmcvb3BlbmluZyBiZWZvcmUgZXhpdGluZyBpbm5lciBs
b29wCgkJCQkJCQlpZiBvcGVuZG9vcnMgdGhlbgoJCQkJCQkJCWlmIGRvb3Iua2V5bnVtIHRoZW4K
CQkJCQkJCQkJLS0gY2hlY2sgaW52ZW50b3J5IGZvciBrZXkKCQkJCQkJCQkJaWYgaXNwbGF5ZXIg
dGhlbgoJCQkJCQkJCQkJZm9yIGksIGl0ZW0gaW4gaXBhaXJzKHBsYXllci5rZXlzKSBkbwoJCQkJ
CQkJCQkJCWlmIGl0ZW0ua2V5bnVtID09IGRvb3Iua2V5bnVtIHRoZW4KCQkJCQkJCQkJCQkJLS0g
cmVtb3ZlIGtleQoJCQkJCQkJCQkJCQlkZWxpKHBsYXllci5rZXlzLCBpKQoJCQkJCQkJCQkJCQlk
b29yLmtleW51bSA9IG5pbAoJCQkJCQkJCQkJCQlkb29yLm9wZW5pbmcgPSB0cnVlCgkJCQkJCQkJ
CQkJCS0tIGtlZXAgY29sPXRydWUsIGRvbid0IGNsZWFyIGltbWVkaWF0ZWx5CgkJCQkJCQkJCQkJ
CWJyZWFrCgkJCQkJCQkJCQkJZW5kCgkJCQkJCQkJCQllbmQKCQkJCQkJCQkJZW5kCgkJCQkJCQkJ
ZWxzZQoJCQkJCQkJCQktLSB1bmxvY2tlZAoJCQkJCQkJCQlkb29yLm9wZW5pbmcgPSB0cnVlCgkJ
CQkJCQkJCS0tIGtlZXAgY29sPXRydWUsIGRvbid0IGNsZWFyIGltbWVkaWF0ZWx5CgkJCQkJCQkJ
ZW5kCgkJCQkJCQllbmQKCQkJCQkJCS0tIGVhcmx5IGV4aXQgZnJvbSBpbm5lciBsb29wIG9uIGNv
bGxpc2lvbiAoYWZ0ZXIgb3BlbmRvb3JzIGhhbmRsaW5nKQoJCQkJCQkJYnJlYWsKCQkJCQkJZW5k
CgkJCQkJZW5kCgkJCQkJLS0gY2hlY2sgaWYgZXhpdCBwb3J0YWwKCQkJCWVsc2VpZiAodGlsZSA9
PSBleGl0X3N0YXJ0IG9yIHRpbGUgPT0gZXhpdF9lbmQpIGFuZCBpc3BsYXllciB0aGVuCgkJCQkJ
LS0gcGxhY2Vob2xkZXIgZm9yIGxldmVsIGNvbXBsZXRpb24KCQkJCQktLSBjaGVjayBpZiB3YWxs
CgkJCQllbHNlaWYgdGlsZSA_IDAgdGhlbgoJCQkJCWNvbCA9IHRydWUKCQkJCQlicmVhawoJCQkJ
ZW5kCgkJCWVuZAoJCWVuZAoJCWlmIGNvbCB0aGVuIGJyZWFrIGVuZAoJZW5kCgoJLS0gY2hlY2sg
c29saWQgb2JqZWN0cyBhcm91bmQgcG9zaXRpb24gdmlhIGZsYXQgYXJyYXkgd2l0aCBlYXJseSBk
aXN0YW5jZSBjdWxsCglmb3Igb2IgaW4gYWxsKG9iamVjdHMpIGRvCgkJaWYgb2IudHlwIGFuZCBv
Yi50eXAuc29saWQgYW5kIG9iLnBvcyB0aGVuCgkJCWxvY2FsIG94ID0gb2IucG9zWzFdIC0gcHgK
CQkJbG9jYWwgb3kgPSBvYi5wb3NbMl0gLSBweQoJCQktLSBlYXJseSBheGlzLWFsaWduZWQgY3Vs
bAoJCQlpZiBhYnMob3gpIDwgKHJhZGl1cyArIChvYi50eXAudyBvciAwKSkgYW5kIGFicyhveSkg
PCAocmFkaXVzICsgKG9iLnR5cC53IG9yIDApKSB0aGVuCgkJCQlpZiBtYXgoYWJzKG94KSwgYWJz
KG95KSkgPCAob2IudHlwLncgb3IgMCkgdGhlbgoJCQkJCWNvbCA9IHRydWUKCQkJCQktLSB0cmln
Z2VyIGludGVyYWN0aW9uIG9uIHNvbGlkIGNvbnRhY3QgaWYgcGxheWVyCgkJCQkJaWYgaXNwbGF5
ZXIgdGhlbgoJCQkJCQljaGVja19pbnRlcmFjdGlvbnNfYXQocHgsIHB5KQoJCQkJCWVuZAoJCQkJ
CWJyZWFrCgkJCQllbmQKCQkJZW5kCgkJZW5kCgllbmQKCglyZXR1cm4gY29sCmVuZAoKLS0gbW92
ZW1lbnQgd3JhcHBlciB3aXRoIHNsaWRpbmcgY29sbGlzaW9uCi0tIFB1cnBvc2U6IE1vdmVtZW50
IHdpdGggc2xpZGluZyBjb2xsaXNpb24gKHRyeSBkaWFnb25hbCwgdGhlbiBYLCB0aGVuIFkpCi0t
IFBhcmFtZXRlcnM6IHBvcyAodGFibGUgd2l0aCB4LHkpLCB0YXJnZXRfeCwgdGFyZ2V0X3ksIHJh
ZGl1cywgb3BlbmRvb3JzLCBpc3BsYXllcgotLSBSZXR1cm5zOiBib29sZWFuICh0cnVlIGlmIGFu
eSBtb3ZlbWVudCBzdWNjZWVkZWQpCi0tIEFsZ29yaXRobTogVGhyZWUtcGhhc2UgY29sbGlzaW9u
IGNoZWNrIGZvciBzbW9vdGggd2FsbCBzbGlkaW5nCmZ1bmN0aW9uIHRyeW1vdmV0byhwb3MsIHRh
cmdldF94LCB0YXJnZXRfeSwgcmFkaXVzLCBvcGVuZG9vcnMsIGlzcGxheWVyKQoJcmFkaXVzID0g
cmFkaXVzIG9yIHBsYXllcl9jb2xsaXNpb25fcmFkaXVzCglvcGVuZG9vcnMgPSBvcGVuZG9vcnMg
b3IgZmFsc2UKCWlzcGxheWVyID0gaXNwbGF5ZXIgb3IgZmFsc2UKCgktLSB0cnkgZGlyZWN0IG1v
dmVtZW50CglpZiBub3QgcmFkaXVzIG9yIG5vdCBpc2NvbCh0YXJnZXRfeCwgdGFyZ2V0X3ksIHJh
ZGl1cywgb3BlbmRvb3JzLCBpc3BsYXllcikgdGhlbgoJCXBvcy54LCBwb3MueSA9IHRhcmdldF94
LCB0YXJnZXRfeQoJCXJldHVybiB0cnVlCgllbmQKCgktLSB0cnkgeC1vbmx5IG1vdmVtZW50Cglp
ZiBhYnMocG9zLnggLSB0YXJnZXRfeCkgPiAwLjAxIGFuZCBub3QgaXNjb2wodGFyZ2V0X3gsIHBv
cy55LCByYWRpdXMsIG9wZW5kb29ycywgaXNwbGF5ZXIpIHRoZW4KCQlwb3MueCA9IHRhcmdldF94
CgkJcmV0dXJuIHRydWUKCWVuZAoKCS0tIHRyeSB5LW9ubHkgbW92ZW1lbnQKCWlmIGFicyhwb3Mu
eSAtIHRhcmdldF95KSA_IDAuMDEgYW5kIG5vdCBpc2NvbChwb3MueCwgdGFyZ2V0X3ksIHJhZGl1
cywgb3BlbmRvb3JzLCBpc3BsYXllcikgdGhlbgoJCXBvcy55ID0gdGFyZ2V0X3kKCQlyZXR1cm4g
dHJ1ZQoJZW5kCgoJcmV0dXJuIGZhbHNlCmVuZAoKLS0gbW92ZW1lbnQgd3JhcHBlciBmb3IgcG9z
WzFdL3Bvc1syXSBhcnJheSBwb3NpdGlvbnMKZnVuY3Rpb24gdHJ5bW92ZXRvX3Bvcyhwb3NfYXJy
YXksIHRhcmdldF94LCB0YXJnZXRfeSwgcmFkaXVzLCBvcGVuZG9vcnMsIGlzcGxheWVyKQoJcmFk
aXVzID0gcmFkaXVzIG9yIHBsYXllcl9jb2xsaXNpb25fcmFkaXVzCglvcGVuZG9vcnMgPSBvcGVu
ZG9vcnMgb3IgZmFsc2UKCWlzcGxheWVyID0gaXNwbGF5ZXIgb3IgZmFsc2UKCgktLSB0cnkgZGly
ZWN0IG1vdmVtZW50CglpZiBub3QgcmFkaXVzIG9yIG5vdCBpc2NvbCh0YXJnZXRfeCwgdGFyZ2V0
X3ksIHJhZGl1cywgb3BlbmRvb3JzLCBpc3BsYXllcikgdGhlbgoJCXBvc19hcnJheVsxXSwgcG9z
X2FycmF5WzJdID0gdGFyZ2V0X3gsIHRhcmdldF95CgkJcmV0dXJuIHRydWUKCWVuZAoKCS0tIHRy
eSB4LW9ubHkgbW92ZW1lbnQKCWlmIGFicyhwb3NfYXJyYXlbMV0gLSB0YXJnZXRfeCkgPiAwLjAx
IGFuZCBub3QgaXNjb2wodGFyZ2V0X3gsIHBvc19hcnJheVsyXSwgcmFkaXVzLCBvcGVuZG9vcnMs
IGlzcGxheWVyKSB0aGVuCgkJcG9zX2FycmF5WzFdID0gdGFyZ2V0X3gKCQlyZXR1cm4gdHJ1ZQoJ
ZW5kCgoJLS0gdHJ5IHktb25seSBtb3ZlbWVudAoJaWYgYWJzKHBvc19hcnJheVsyXSAtIHRhcmdl
dF95KSA_IDAuMDEgYW5kIG5vdCBpc2NvbChwb3NfYXJyYXlbMV0sIHRhcmdldF95LCByYWRpdXMs
IG9wZW5kb29ycywgaXNwbGF5ZXIpIHRoZW4KCQlwb3NfYXJyYXlbMl0gPSB0YXJnZXRfeQoJCXJl
dHVybiB0cnVlCgllbmQKCglyZXR1cm4gZmFsc2UKZW5kCgpmdW5jdGlvbiB1cGRhdGVfaW5wdXQo
KQoJbG9jYWwgc2EsIGNhID0gc2luKHBsYXllci5hKSwgY29zKHBsYXllci5hKQoKCS0tIG1vdmVt
ZW50CgktLSBjb21iaW5lIGtleXMgdG8gYXZvaWQgZG91YmxlLXByb2Nlc3NpbmcgYW5kIGZpeCBk
aXJlY3Rpb246CgktLSBwb3NpdGl2ZSB0dXJuID0gbGVmdCwgbmVnYXRpdmUgdHVybiA9IHJpZ2h0
Cglsb2NhbCB0dXJuID0gKGJ0bigwKSBhbmQgMSBvciAwKSAtIChidG4oMSkgYW5kIDEgb3IgMCkK
CWlmIHR1cm4gfj0gMCB0aGVuCgkJcGxheWVyLmEgKz0gdHVybiAqIHBsYXllcl9yb3RhdGlvbl9z
cGVlZAoJZW5kCglpZiBidG4oMikgdGhlbgoJCS0tIHVwCgkJbG9jYWwgbnggPSBwbGF5ZXIueCAr
IGNhICogcGxheWVyLnNwZAoJCWxvY2FsIG55ID0gcGxheWVyLnkgKyBzYSAqIHBsYXllci5zcGQK
CQl0cnltb3ZldG8ocGxheWVyLCBueCwgbnksIHBsYXllcl9jb2xsaXNpb25fcmFkaXVzLCB0cnVl
LCB0cnVlKQoJZW5kCglpZiBidG4oMykgdGhlbgoJCS0tIGRvd24KCQlsb2NhbCBueCA9IHBsYXll
ci54IC0gY2EgKiBwbGF5ZXIuc3BkCgkJbG9jYWwgbnkgPSBwbGF5ZXIueSAtIHNhICogcGxheWVy
LnNwZAoJCXRyeW1vdmV0byhwbGF5ZXIsIG54LCBueSwgcGxheWVyX2NvbGxpc2lvbl9yYWRpdXMs
IHRydWUsIHRydWUpCgllbmQKCgktLSBjaGVjayBmb3IgaW50ZXJhY3Rpb25zIGV2ZXJ5IGZyYW1l
CgljaGVja19pbnRlcmFjdGlvbnMoKQoKCS0tIGludGVyYWN0aW9uIGlucHV0OiBFIGtleSBvciBa
IGJ1dHRvbgoJaWYga2V5cCgiZSIpIG9yIGJ0bnAoNCkgdGhlbgoJCWhhbmRsZV9pbnRlcmFjdCgp
CgllbmQKZW5kCgotLSBjaGVjayBpbnRlcmFjdGlvbnMgYXJvdW5kIHBsYXllciBwb3NpdGlvbgot
LSBQdXJwb3NlOiBTY2FuIG5lYXJieSBvYmplY3RzIGZvciBwcm94aW1pdHktYmFzZWQgaW50ZXJh
Y3Rpb25zCi0tIEFsZ29yaXRobTogM8OXMyBvYmpncmlkIGNlbGwgc2NhbiBhcm91bmQgcGxheWVy
Ci0tIFNpZGUgZWZmZWN0czogQXV0by1jb2xsZWN0cyBwaWNrdXBzLCB0cmlnZ2VycyBjb21iYXQs
IHNldHMgaW50ZXJhY3Rpb24gZmxhZ3MKLS0gTm90ZXM6IENhbGxlZCBldmVyeSBmcmFtZSBpbiBf
dXBkYXRlKCkKZnVuY3Rpb24gY2hlY2tfaW50ZXJhY3Rpb25zKCkKCWNoZWNrX2ludGVyYWN0aW9u
c19hdChwbGF5ZXIueCwgcGxheWVyLnkpCmVuZAoKLS0gY2hlY2sgaW50ZXJhY3Rpb25zIGF0IHNw
ZWNpZmljIHBvc2l0aW9uIChhdm9pZHMgcmVjdXJzaW9uKQpmdW5jdGlvbiBjaGVja19pbnRlcmFj
dGlvbnNfYXQocHgsIHB5KQoJLS0gc2NhbiBhbGwgb2JqZWN0cyB3aXRoIGRpc3RhbmNlIGN1bGxp
bmcKCWxvY2FsIGNsb3Nlc3RfaW50ZXJhY3QgPSBuaWwKCWxvY2FsIGNsb3Nlc3RfZGlzdCA9IDk5
OQoKCWZvciBvYiBpbiBhbGwob2JqZWN0cykgZG8KCQlpZiBvYi5wb3MgYW5kIG9iLnR5cCB0aGVu
CgkJCWxvY2FsIGR4ID0gb2IucG9zWzFdIC0gcHgKCQkJbG9jYWwgZHkgPSBvYi5wb3NbMl0gLSBw
eQoJCQlsb2NhbCBkaXN0ID0gYWJzKGR4KSArIGFicyhkeSkKCgkJCS0tIGRpcmVjdCBwaWNrdXA6
IGF1dG8tY29sbGVjdAoJCQlpZiBvYi50eXAua2luZCA9PSAiZGlyZWN0X3BpY2t1cCIgYW5kIGRp
c3QgPCBpbnRlcmFjdGlvbl9yYW5nZSB0aGVuCgkJCQljb2xsZWN0X2l0ZW0ob2IpCgkJCQlkZWwo
b2JqZWN0cywgb2IpCgkJCQlpZiBvYi5hdXRvYW5pbSB0aGVuIGRlbChhbmltYXRlZF9vYmplY3Rz
LCBvYikgZW5kCgoJCQkJLS0gaG9zdGlsZSBucGM6IHRyaWdnZXIgY29tYmF0CgkJCWVsc2VpZiBv
Yi50eXAua2luZCA9PSAiaG9zdGlsZV9ucGMiIGFuZCBkaXN0IDwgY29tYmF0X3RyaWdnZXJfcmFu
Z2UgdGhlbgoJCQkJaW5fY29tYmF0ID0gdHJ1ZQoJCQkJY3VycmVudF90YXJnZXQgPSBvYgoKCQkJ
CS0tIGludGVyYWN0YWJsZTogc2V0IGZsYWcgZm9yIGNsb3Nlc3QKCQkJZWxzZWlmIG9iLnR5cC5r
aW5kID09ICJpbnRlcmFjdGFibGUiIGFuZCBkaXN0IDwgaW50ZXJhY3Rpb25fcmFuZ2UgdGhlbgoJ
CQkJLS0gdHJhcDogaW1tZWRpYXRlIGVmZmVjdAoJCQkJaWYgb2IudHlwLnN1YnR5cGUgPT0gInRy
YXAiIHRoZW4KCQkJCQlwbGF5ZXIuaHAgPSBtYXgoMCwgcGxheWVyLmhwIC0gMTApCgkJCQkJdHJh
cF9tc2dfdGltZXIgPSA2MAoJCQkJCWRlbChvYmplY3RzLCBvYikKCQkJCQlpZiBvYi5hdXRvYW5p
bSB0aGVuIGRlbChhbmltYXRlZF9vYmplY3RzLCBvYikgZW5kCgkJCQllbHNlaWYgZGlzdCA8IGNs
b3Nlc3RfZGlzdCB0aGVuCgkJCQkJY2xvc2VzdF9pbnRlcmFjdCA9IG9iCgkJCQkJY2xvc2VzdF9k
aXN0ID0gZGlzdAoJCQkJZW5kCgkJCWVuZAoJCWVuZAoJZW5kCgoJLS0gdXBkYXRlIGludGVyYWN0
aW9uIHN0YXRlCglpZiBjbG9zZXN0X2ludGVyYWN0IHRoZW4KCQlpbnRlcmFjdGlvbl9hY3RpdmUg
PSB0cnVlCgkJY3VycmVudF9pbnRlcmFjdCA9IGNsb3Nlc3RfaW50ZXJhY3QKCWVsc2UKCQlpbnRl
cmFjdGlvbl9hY3RpdmUgPSBmYWxzZQoJCWN1cnJlbnRfaW50ZXJhY3QgPSBuaWwKCWVuZAplbmQK
Ci0tIGNvbGxlY3QgaXRlbSAocGlja3VwKQotLSBQdXJwb3NlOiBIYW5kbGUgcGlja3VwIGNvbGxl
Y3Rpb24gYW5kIGludmVudG9yeSB1cGRhdGVzCi0tIFBhcmFtZXRlcnM6IG9iIChvYmplY3Qgd2l0
aCB0eXAuc3VidHlwZSkKLS0gU2lkZSBlZmZlY3RzOiBBZGRzIHRvIHBsYXllci5rZXlzLCBpbmNy
ZWFzZXMgcGxheWVyLmhwCi0tIE5vdGVzOiBDYWxsZWQgYnkgY2hlY2tfaW50ZXJhY3Rpb25zX2F0
KCkgZm9yIGRpcmVjdF9waWNrdXAgb2JqZWN0cwpmdW5jdGlvbiBjb2xsZWN0X2l0ZW0ob2IpCglp
ZiBvYi50eXAuc3VidHlwZSA9PSAia2V5IiBhbmQgb2Iua2V5bnVtIHRoZW4KCQlhZGQocGxheWVy
LmtleXMsIHsga2V5bnVtID0gb2Iua2V5bnVtIH0pCgkJbG9nLmluZm8oImNvbGxlY3RlZCBrZXkg
JXMiLCB0b3N0cmluZyhvYi5rZXludW0pKQoJZWxzZWlmIG9iLnR5cC5zdWJ0eXBlID09ICJoZWFy
dCIgdGhlbgoJCXBsYXllci5ocCA9IG1pbigxMDAsIHBsYXllci5ocCArIDIwKQoJCWxvZy5pbmZv
KCJjb2xsZWN0ZWQgaGVhcnQiKQoJZWxzZQoJCWxvZy5pbmZvKCJjb2xsZWN0ZWQgaXRlbSIpCgll
bmQKZW5kCgotLSBoYW5kbGUgaW50ZXJhY3Rpb24gd2hlbiBwbGF5ZXIgcHJlc3NlcyBFL1oKLS0g
UHVycG9zZTogUHJvY2VzcyBwbGF5ZXItaW5pdGlhdGVkIGludGVyYWN0aW9ucyAoRSBrZXkgLyBa
IGJ1dHRvbikKLS0gQWxnb3JpdGhtOiBTd2l0Y2ggb24gY3VycmVudF9pbnRlcmFjdC50eXAuc3Vi
dHlwZQotLSBTaWRlIGVmZmVjdHM6IE9wZW5zIGNoZXN0cywgYWN0aXZhdGVzIHNocmluZXMsIHJl
YWRzIG5vdGVzLCB0cmlnZ2VycyBmbG9vciB0cmFuc2l0aW9uCi0tIE5vdGVzOiBPbmx5IHJ1bnMg
d2hlbiBpbnRlcmFjdGlvbl9hY3RpdmUgZmxhZyBpcyB0cnVlCmZ1bmN0aW9uIGhhbmRsZV9pbnRl
cmFjdCgpCglpZiBub3QgaW50ZXJhY3Rpb25fYWN0aXZlIG9yIG5vdCBjdXJyZW50X2ludGVyYWN0
IHRoZW4gcmV0dXJuIGVuZAoKCWxvY2FsIHN1YnR5cGUgPSBjdXJyZW50X2ludGVyYWN0LnR5cCBh
bmQgY3VycmVudF9pbnRlcmFjdC50eXAuc3VidHlwZSBvciAidW5rbm93biIKCglpZiBzdWJ0eXBl
ID09ICJjaGVzdCIgdGhlbgoJCS0tIG9wZW4gY2hlc3QgKHBsYWNlaG9sZGVyKQoJCXBsYXllci5o
cCA9IG1pbigxMDAsIHBsYXllci5ocCArIDEwKQoJCWxvZy5pbmZvKCJvcGVuZWQgY2hlc3QiKQoJ
CWRlbChvYmplY3RzLCBjdXJyZW50X2ludGVyYWN0KQoJCWlmIGN1cnJlbnRfaW50ZXJhY3QuYXV0
b2FuaW0gdGhlbiBkZWwoYW5pbWF0ZWRfb2JqZWN0cywgY3VycmVudF9pbnRlcmFjdCkgZW5kCgll
bHNlaWYgc3VidHlwZSA9PSAic2hyaW5lIiB0aGVuCgkJLS0gYWN0aXZhdGUgc2hyaW5lIChwbGFj
ZWhvbGRlcikKCQlwbGF5ZXIuaHAgPSAxMDAKCQlsb2cuaW5mbygiYWN0aXZhdGVkIHNocmluZSIp
CgllbHNlaWYgc3VidHlwZSA9PSAibm90ZSIgdGhlbgoJCS0tIHJlYWQgbm90ZSAocGxhY2Vob2xk
ZXIpCgkJbG9nLmluZm8oInJlYWQgbm90ZSIpCgkJZGVsKG9iamVjdHMsIGN1cnJlbnRfaW50ZXJh
Y3QpCgkJaWYgY3VycmVudF9pbnRlcmFjdC5hdXRvYW5pbSB0aGVuIGRlbChhbmltYXRlZF9vYmpl
Y3RzLCBjdXJyZW50X2ludGVyYWN0KSBlbmQKCWVsc2VpZiBzdWJ0eXBlID09ICJleGl0IiB0aGVu
CgkJLS0gdHJpZ2dlciBuZXh0IGZsb29yCgkJbG9nLmluZm8oInVzaW5nIGV4aXQgcG9ydGFsIikK
CQlnZW5lcmF0ZV9uZXdfZmxvb3IoKQoJZW5kCgoJLS0gY2xlYXIgaW50ZXJhY3Rpb24gc3RhdGUg
YWZ0ZXIgaGFuZGxpbmcKCWludGVyYWN0aW9uX2FjdGl2ZSA9IGZhbHNlCgljdXJyZW50X2ludGVy
YWN0ID0gbmlsCmVuZAoKLS0gZ2VuZXJhdGUgbmV3IGZsb29yIChyZWdlbmVyYXRlIGR1bmdlb24p
CmZ1bmN0aW9uIGdlbmVyYXRlX25ld19mbG9vcigpCgktLSBpbmNyZW1lbnQgZGlmZmljdWx0eQoJ
Z2VuX3BhcmFtcy5kaWZmaWN1bHR5ID0gbWluKGdlbl9wYXJhbXMubWF4X2RpZmZpY3VsdHksIGdl
bl9wYXJhbXMuZGlmZmljdWx0eSArIDEpCgoJLS0gY2xlYXIgZXhpc3Rpbmcgb2JqZWN0cwoJb2Jq
ZWN0cyA9IHt9CglhbmltYXRlZF9vYmplY3RzID0ge30KCWRvb3JzID0ge30KCS0tIGFsc28gY2xl
YXIgZG9vcmdyaWQgdG8gcHJldmVudCBzdGFsZSByZWZlcmVuY2VzCglmb3IgaSA9IDAsIDEyNyBk
bwoJCWlmIGRvb3JncmlkW2ldIHRoZW4KCQkJZm9yIGogPSAwLCAxMjcgZG8KCQkJCWRvb3Jncmlk
W2ldW2pdID0gbmlsCgkJCWVuZAoJCWVuZAoJZW5kCgoJLS0gcmVnZW5lcmF0ZSBkdW5nZW9uCglz
dGFydF9wb3MsIGdlbl9zdGF0cyA9IGdlbmVyYXRlX2R1bmdlb24oKQoJLS0gVHJpZ2dlciBHQyBh
ZnRlciBkdW5nZW9uIGdlbmVyYXRpb24gKFBpY290cm9uIGd1aWRlbGluZTogYXZvaWQgbWlkLWdh
bWVwbGF5IHN0dXR0ZXIpCglzdGF0KDApCgktLSBpbnZhbGlkYXRlIHBlcnNpc3RlbnQgcmVuZGVy
IGNhY2hlcyBmb3IgbmV3IGZsb29yCgktLSBQcm9kdWN0aW9uOiBjbGVhciBjYWNoZSBvbiBsZXZl
bCBsb2FkIHRvIHByZXZlbnQgc3RhbGUgdGV4dHVyZSByZWZlcmVuY2VzCglpZiBjbGVhcl90ZXh0
dXJlX2NhY2hlcyB0aGVuIGNsZWFyX3RleHR1cmVfY2FjaGVzKCkgZW5kCgoJbG9nLmluZm8oImZs
b29yIGNvbXBsZXRlISBkaWZmaWN1bHR5OiAlcyIsIHRvc3RyaW5nKGdlbl9wYXJhbXMuZGlmZmlj
dWx0eSkpCgoJLS0gbGV2ZWwgbG9hZCBkaWFnbm9zdGljIHN1bW1hcnkKCWxvZy5kZWJ1ZygiPT09
IExFVkVMIExPQUQgRElBR05PU1RJQ1MgPT09IikKCWxvZy5kZWJ1ZygiRmxvb3I6ICVzIiwgdG9z
dHJpbmcoY3VycmVudF9mbG9vciBvciAidW5rbm93biIpKQoJbG9nLmRlYnVnKCJEaWZmaWN1bHR5
OiAlcyIsIHRvc3RyaW5nKGdlbl9wYXJhbXMuZGlmZmljdWx0eSkpCglsb2cuZGVidWcoIlJvb21z
OiAlcyIsIHRvc3RyaW5nKGdlbl9zdGF0cy5yb29tcykpCglsb2cuZGVidWcoIk9iamVjdHM6ICVz
IiwgdG9zdHJpbmcoZ2VuX3N0YXRzLm9iamVjdHMpKQoJbG9nLmRlYnVnKCJTZWVkOiAlcyIsIHRv
c3RyaW5nKGdlbl9zdGF0cy5zZWVkKSkKZW5kCgotLSB1cGRhdGUgY29tYmF0IChwbGFjZWhvbGRl
cikKZnVuY3Rpb24gdXBkYXRlX2NvbWJhdCgpCgktLSB0ZW1wIGV4aXQ6IHByZXNzIFEgb3IgRW50
ZXIKCWlmIGtleXAoInEiKSBvciBrZXlwKCJlbnRlciIpIHRoZW4KCQlpbl9jb21iYXQgPSBmYWxz
ZQoJCWN1cnJlbnRfdGFyZ2V0ID0gbmlsCgkJbG9nLmluZm8oImV4aXRlZCBjb21iYXQiKQoJZW5k
CmVuZAoKLS0gdXBkYXRlIG5wYyBhaSAoYmFzaWMgcGF0cm9sIGFuZCBmb2xsb3cpCmZ1bmN0aW9u
IHVwZGF0ZV9ucGNfYWkoKQoJZm9yIG9iIGluIGFsbChvYmplY3RzKSBkbwoJCWlmIG9iLnR5cCBh
bmQgb2IudHlwLmtpbmQgPT0gImhvc3RpbGVfbnBjIiBhbmQgb2IuYWlfdHlwZSB0aGVuCgkJCWxv
Y2FsIG9sZF94LCBvbGRfeSA9IG9iLnBvc1sxXSwgb2IucG9zWzJdCgoJCQlpZiBvYi5haV90eXBl
ID09ICJwYXRyb2wiIHRoZW4KCQkJCS0tIHBhdHJvbDogY3ljbGUgdGhyb3VnaCBwYXRyb2xfcG9p
bnRzCgkJCQlpZiBvYi5wYXRyb2xfcG9pbnRzIGFuZCAjb2IucGF0cm9sX3BvaW50cyA_IDAgdGhl
bgoJCQkJCS0tIGluaXRpYWxpemUgcGF0cm9sX2luZGV4IGlmIG5pbCBvciAwCgkJCQkJaWYgbm90
IG9iLnBhdHJvbF9pbmRleCBvciBvYi5wYXRyb2xfaW5kZXggPT0gMCB0aGVuCgkJCQkJCW9iLnBh
dHJvbF9pbmRleCA9IDEKCQkJCQllbmQKCgkJCQkJbG9jYWwgdGFyZ2V0ID0gb2IucGF0cm9sX3Bv
aW50c1tvYi5wYXRyb2xfaW5kZXhdCgkJCQkJaWYgdGFyZ2V0IHRoZW4KCQkJCQkJbG9jYWwgZHgg
PSB0YXJnZXQueCAtIG9iLnBvc1sxXQoJCQkJCQlsb2NhbCBkeSA9IHRhcmdldC55IC0gb2IucG9z
WzJdCgkJCQkJCWxvY2FsIGRpc3QgPSBzcXJ0KGR4ICogZHggKyBkeSAqIGR5KQoKCQkJCQkJLS0g
cmVhY2hlZCB3YXlwb2ludDogYWR2YW5jZSB0byBuZXh0CgkJCQkJCWlmIGRpc3QgPCAwLjEgdGhl
bgoJCQkJCQkJb2IucGF0cm9sX2luZGV4ID0gKG9iLnBhdHJvbF9pbmRleCAlICNvYi5wYXRyb2xf
cG9pbnRzKSArIDEKCQkJCQkJZWxzZQoJCQkJCQkJLS0gbW92ZSB0b3dhcmQgY3VycmVudCB3YXlw
b2ludAoJCQkJCQkJaWYgZGlzdCA_IDAgdGhlbgoJCQkJCQkJCWxvY2FsIHNwZCA9IG9iLnR5cC5w
YXRyb2xfc3BlZWQgb3IgMC4wMwoJCQkJCQkJCWxvY2FsIG54ID0gb2IucG9zWzFdICsgZHggLyBk
aXN0ICogc3BkCgkJCQkJCQkJbG9jYWwgbnkgPSBvYi5wb3NbMl0gKyBkeSAvIGRpc3QgKiBzcGQK
CQkJCQkJCQl0cnltb3ZldG9fcG9zKG9iLnBvcywgbngsIG55LCBvYi50eXAudyBvciAwLjQsIGZh
bHNlLCBmYWxzZSkKCQkJCQkJCWVuZAoJCQkJCQllbmQKCQkJCQllbmQKCQkJCWVuZAoJCQllbHNl
aWYgb2IuYWlfdHlwZSA9PSAiZm9sbG93IiB0aGVuCgkJCQktLSBmb2xsb3c6IG1vdmUgdG93YXJk
IHBsYXllciBpZiBpbiByYW5nZQoJCQkJbG9jYWwgZHggPSBwbGF5ZXIueCAtIG9iLnBvc1sxXQoJ
CQkJbG9jYWwgZHkgPSBwbGF5ZXIueSAtIG9iLnBvc1syXQoJCQkJbG9jYWwgZGlzdCA9IHNxcnQo
ZHggKiBkeCArIGR5ICogZHkpCgkJCQlsb2NhbCBmb2xsb3dfcmFuZ2UgPSBvYi50eXAuZm9sbG93
X3JhbmdlIG9yIDIwCgkJCQlpZiBkaXN0IDwgZm9sbG93X3JhbmdlIGFuZCBkaXN0ID4gMC4xIHRo
ZW4KCQkJCQlsb2NhbCBzcGQgPSBvYi50eXAuZm9sbG93X3NwZWVkIG9yIDAuMDUKCQkJCQlsb2Nh
bCBueCA9IG9iLnBvc1sxXSArIGR4IC8gZGlzdCAqIHNwZAoJCQkJCWxvY2FsIG55ID0gb2IucG9z
WzJdICsgZHkgLyBkaXN0ICogc3BkCgkJCQkJdHJ5bW92ZXRvX3BvcyhvYi5wb3MsIG54LCBueSwg
b2IudHlwLncgb3IgMC40LCBmYWxzZSwgZmFsc2UpCgkJCQllbmQKCQkJZW5kCgkJZW5kCgllbmQK
ZW5k
:: src/.info.pod
--[[pod,created="2025-11-07 22:14:13",modified="2025-11-12 15:40:09"]]
:: src/docs/.info.pod
--[[pod,created="2025-11-12 15:40:09",modified="2025-11-12 15:40:09"]]
:: src/docs/AgentRequirements.md
b64$R29pbmcgZm9yd2FyZCwgcGxhbm5pbmcgaGFzIHRvIGluY2x1ZGU6DQripoEJRXhwbGljaXQg
Y29udHJhY3RzIGZvciBldmVyeSBtb2R1bGUgYm91bmRhcnkuDQripoEJSGFybmVzcyBvciBhc3Nl
cnRpb24gd29yayBpdGVtcyB0byBwcm92ZSB0aG9zZSBjb250cmFjdHMuDQripoEJR2F0ZXMgdGhh
dCBzdG9wIHByb2dyZXNzIHVudGlsIHRoZSBwcm9vZiBleGlzdHMuDQoNCg==
:: src/docs/ProcGenPipeline.md
b64$IyMgR3VpZGluZyBDb25zdHJhaW50cw0KDQotICoqRGV0ZXJtaW5pc3RpYyBmaXJzdCoqOiBF
dmVyeSBjYWxsIHRvIGBnZW5lcmF0ZV9kdW5nZW9uKG9wdHMpYCBzZWVkcyBMdWEncyBSTkcgKGBz
cmFuZChzZWVkKWApLCByZWNvcmRzIHRoZSBzZWVkIGluIGBnZW5faGlzdG9yeWAsIGFuZCBtaXJy
b3JzIGl0IGluIHRoZSByZXR1cm5lZCBtZXRhZGF0YSBzbyBkdW5nZW9uIGxheW91dHMgY2FuIGJl
IHJlcHJvZHVjZWQgYW5kIHJlZ3Jlc3Npb24tdGVzdGVkLg0KLSAqKkFkYXB0aXZlIGJ1dCBib3Vu
ZGVkIGhldXJpc3RpY3MqKjogUm9vbSBzcGFjaW5nLCBwbGFjZW1lbnQgcmV0cmllcywgYW5kIGNv
cnJpZG9yIHNlbGVjdGlvbiBmZWVkIHRocm91Z2ggYGFkYXB0aXZlX3NldHRpbmdzYC4gU3BhY2lu
ZyBjYW4gcmVsYXggdGVtcG9yYXJpbHkgYnV0IGFsd2F5cyByZXN0b3JlcyB0byB0aGUgYmFzZWxp
bmUgZGVmaW5lZCBpbiBgZ2VuX3BhcmFtc2AsIGtlZXBpbmcgcmV0cnkgc3Rvcm1zIGJvdW5kZWQg
KGBtYXhfcm9vbV9mYWlsdXJlc2AsIGBzcGFjaW5nX21heF9yZWxheGApLg0KLSAqKlRoZW1lLWF3
YXJlIHdpdGhvdXQgYnJhbmNoaW5nIGV4cGxvc2lvbioqOiBUaGVtZXMgc3VwcGx5IGN1cmF0ZWQg
cnVsZSB0YWJsZXMgKGB0aGVtZXMuKi5ydWxlc2ApLiBUaGUgZ2VuZXJhdG9yIHJlYWRzIHRoZW0g
b25jZSBwZXIgcnVuIChgZW5zdXJlX3RoZW1lX3J1bGVzYCkgYW5kIGFwcGxpZXMgdGhlIGRlbHRh
cyAoc2hhcGUgd2VpZ2h0cywgY29ycmlkb3Igam9nIG9kZHMsIGVyb3Npb24gaW50ZW5zaXR5KSB3
aXRob3V0IHBlci1yb29tIGNvbmRpdGlvbmFscy4NCi0gKipTaW5nbGUgc291cmNlIG9mIHRydXRo
Kio6IEFsbCBjb25maWd1cmF0aW9uIGxpdmVzIGluIGBjb25maWcubHVhYC4gVGhlIGdlbmVyYXRv
ciBuZXZlciBoYXJkY29kZXMgbnVtZXJpYyBsaW1pdHM7IGl0IHJlYWRzIGZpZWxkcyBzdWNoIGFz
IGBnZW5fcGFyYW1zLm1heF9yb29tc2AsIGBlbmVteV90eXBlc2AsIGFuZCBgZGVjb3JhdGlvbl90
eXBlc2AuDQotICoqT2JzZXJ2YWJsZSBieSBkZXNpZ24qKjogRXZlcnkgc2lnbmlmaWNhbnQgZGVj
aXNpb24gaXMgbG9nZ2VkIHZpYSBgZ2VuX2xvZygpYCBhbmQgc3RvcmVkIGluIGBnZW5faGlzdG9y
eWAuIExvZ2dpbmcgcmVzcGVjdHMgdGhlIGBnZW5fb2JzZXJ2YWJpbGl0eWAgY29udHJhY3Qgc28g
cmVsZWFzZSBidWlsZHMgY2FuIGRpc2FibGUgaXQgZW50aXJlbHkuDQotICoqU2FmZSBkb29yL2Nv
cnJpZG9yIGhhbmRsaW5nKio6IERvb3IgcGxhY2VtZW50LCBmYWxsYmFjayBjYXJ2aW5nLCBhbmQg
a2V5IHJlYXNzaWdubWVudCBwcm90ZWN0IGV4aXN0aW5nIG9wZW5pbmdzIChgcHJvdGVjdF90aWxl
YCkgYW5kIGd1YXJhbnRlZSBwcm9ncmVzc2lvbiB2aWEgYHZhbGlkYXRlX2FuZF9yZXBhaXJfcHJv
Z3Jlc3Npb25gLg0KDQotLS0NCg0KIyMgRmluYWwgUHJvY0dlbiBCbHVlcHJpbnQgKHYyKQ0KDQoj
IyMgTW9kdWxlcw0KDQp8IE1vZHVsZSB8IFB1cnBvc2UgfCBOb3RlcyB8DQp8LS0tLS0tLS18LS0t
LS0tLS0tfC0tLS0tLS18DQp8IGBzcmMvcHJvY2dlbi9kdW5nZW9uX2dlbi5sdWFgIHwgQ29yZSBw
cm9jZWR1cmFsIGdlbmVyYXRpb24gcGlwZWxpbmUgKHJvb21zLCBjb3JyaWRvcnMsIGdhbWVwbGF5
IGxheWVyaW5nLCBvYnNlcnZhYmlsaXR5KS4gfCBFeHBvc2VzIGBnZW5lcmF0ZV9kdW5nZW9uKG9w
dHMpYCBwbHVzIGhlbHBlciBob29rcyAoYGdlbmVyYXRlX25wY3NgLCBgZ2VuZXJhdGVfaXRlbXNg
LCBldGMuKS4gfA0KfCBgc3JjL3Byb2NnZW4vZHVuZ2Vvbl9oYXJuZXNzLmx1YWAgfCBEZXRlcm1p
bmlzdGljIGhhcm5lc3MgdGhhdCByZXBsYXlzIGZpeGVkIHNlZWRzLCB2YWxpZGF0aW5nIGNvbm5l
Y3Rpdml0eSAmIGtleS9kb29yIGNvbnRyYWN0cy4gfCBVc2VkIG1hbnVhbGx5IG9yIGZyb20gdGhl
IGR1bmdlb24gbGFiIHNjZW5lLiB8DQp8IGBzcmMvZG9vcl9zeXN0ZW0ubHVhYCB8IERvb3IgYW5p
bWF0aW9uL3N0YXRlIG1hY2hpbmUuIHwgYGR1bmdlb25fZ2VuYCBvbmx5IGNyZWF0ZXMgZG9vcnM7
IGFsbCBydW50aW1lIHVwZGF0ZXMgZmxvdyB0aHJvdWdoIGBkb29yX3N5c3RlbWAuIHwNCnwgYGNv
bmZpZy5sdWFgIHwgQXV0aG9yaXRhdGl2ZSBjb25maWd1cmF0aW9uIGZvciBtYXAgc2l6ZSwgYGdl
bl9wYXJhbXNgLCB0aGVtZSBkZWZpbml0aW9ucywgYW5kIGFkYXB0aXZlIHNldHRpbmdzLiB8IFRv
Z2dsaW5nIGRlZmF1bHRzIGhlcmUgaW1wYWN0cyB0aGUgZ2VuZXJhdG9yIHdpdGhvdXQgdG91Y2hp
bmcgY29kZS4gfA0KfCBgbWFpbi5sdWFgIChkdW5nZW9uIGxhYiBzY2VuZSkgfCBVSSB0byBzcGF3
biBkdW5nZW9ucywgaW5zcGVjdCBgZ2VuX2hpc3RvcnlgLCBhbmQgcnVuIHRoZSBoYXJuZXNzLiB8
IFVzZXMgdGhlIGV4cG9ydGVkIG1ldGFkYXRhIHRvIGZvcm1hdCB2aXN1YWxzL2xvZ3MuIHwNCg0K
IyMjIEdlbmVyYXRpb24gRmxvdw0KDQoxLiAqKlNlZWQgJiBSZXNldCoqICANCiAgIC0gQWNjZXB0
IG9wdGlvbmFsIGBvcHRzLnNlZWRgIC8gYG9wdHMudGhlbWVgLiAgDQogICAtIGBzcmFuZChzZWVk
KWAgdGhlbiB3aXBlIGFsbCBnZW5lcmF0b3IgZ2xvYmFscyAoYGdlbl9yZWN0c2AsIGBnZW5fbm9k
ZXNgLCBgZG9vcmdyaWRgLCBldGMuKSBhbmQgcmVzZXQgYWRhcHRpdmUgc3BhY2luZy4NCg0KMi4g
KipUaGVtZSBTZWxlY3Rpb24gJiBTdXJmYWNlcyoqICANCiAgIC0gQ2hvb3NlIHRoZW1lIChleHBs
aWNpdCBvciB3ZWlnaHRlZCByYW5kb20pIGFuZCBsb2FkIGl0cyBydWxlcy4gIA0KICAgLSBVcGRh
dGUgZmxvb3IvY2VpbGluZyBzdXJmYWNlcyAoYGZsb29yLnR5cGAsIGByb29mLnR5cGApIGFuZCBj
YWNoZSBgZ2VuX2Zsb29yX2lkYC4NCg0KMy4gKipGaXJzdCBSb29tIFBsYWNlbWVudCoqICANCiAg
IC0gQ3JlYXRlIGEgc2VlZCByb29tIHZpYSBgcmFuZG9tX3Jvb20obmlsLGZhbHNlKWAsIHN0b3Jl
IGl0IHdpdGggYGFkZF9yb29tYCwgY2FydmUgdGlsZXMgKGBmaWxsX3JlY3RgICsgYHNldF9mbG9v
cmApLCBhbmQgbWFyayBzdWNjZXNzIChgcmVnaXN0ZXJfcm9vbV9zdWNjZXNzYCkuDQoNCjQuICoq
Um9vbSBFeHBhbnNpb24gTG9vcCoqICANCiAgIC0gVGFyZ2V0IGBybmQobWF4X3Jvb21zLW1pbl9y
b29tcysxKSttaW5fcm9vbXNgIHJvb21zLiAgDQogICAtIEVhY2ggYXR0ZW1wdCBzYW1wbGVzIHdl
aWdodGVkIHJvb20gc2hhcGVzLCBhcHBsaWVzIGFkYXB0aXZlIHNwYWNpbmcsIGFuZCBhYm9ydHMg
d2hlbiBgbWF4X3Jvb21fZmFpbHVyZXNgIHRyaWdnZXJzIHNwYWNpbmcgcmVsYXhhdGlvbi4gIA0K
ICAgLSBTdWNjZXNzZnVsIHJvb21zIGFyZSBjYXJ2ZWQgYW5kIGNvbm5lY3RlZCB2aWEgYGNyZWF0
ZV9jb3JyaWRvcmAsIHdoaWNoIGhhbmRsZXMgZG9vciBwbGFjZW1lbnQsIGp1bmN0aW9uIGNyZWF0
aW9uLCBhbmQgbWV0YWRhdGEgKGBlZGdlLnNoYXBlYCwgYGVkZ2UuYipgKS4NCg0KNS4gKipTdXJm
YWNlICYgRG9vciBSZWNvbmNpbGlhdGlvbioqICANCiAgIC0gQXBwbHkgdGhlbWUtc3BlY2lmaWMg
d2FsbCB0ZXh0dXJlcyAoYGFwcGx5X3Jvb21fd2FsbHNgKS4gIA0KICAgLSBSZWFzc2VydCBsb2dp
Y2FsIGRvb3JzIG9udG8gdGhlIHRpbGVtYXAgKGBlbmZvcmNlX2Rvb3JfdGlsZXNgKS4NCg0KNi4g
KipHYW1lcGxheSBMYXllcmluZyoqICANCiAgIC0gYGdlbmVyYXRlX2dhbWVwbGF5KClgIG9yY2hl
c3RyYXRlcyBleGl0cywgZXJvc2lvbiwgcHJvZ3Jlc3Npb24vbG9ja3MsIE5QQ3MsIGl0ZW1zLCBh
bmQgZGVjb3JhdGlvbnM6ICANCiAgICAgLSBgZXJvZGVfbWFwYCByZXNwZWN0cyBgcHJvdGVjdGVk
X3RpbGVzYC4gIA0KICAgICAtIGBnZW5lcmF0ZV9wcm9ncmVzc2lvbl9sb29wYCBsb2NrcyBlZGdl
cywgc3Bhd25zIGtleXMsIGFuZCB2YWxpZGF0ZXMgYWNjZXNzaWJpbGl0eSAod2l0aCBrZXkgcmVs
b2NhdGlvbiBmYWxsYmFjaykuICANCiAgICAgLSBgZ2VuZXJhdGVfbnBjc2AsIGBnZW5lcmF0ZV9p
dGVtc2AsIGBnZW5lcmF0ZV9kZWNvcmF0aW9uc2AgdXNlIHRoZW1lICsgZGlmZmljdWx0eSB0YWJs
ZXMuICANCiAgIC0gYHZhbGlkYXRlX2FuZF9yZXBhaXJfcHJvZ3Jlc3Npb25gIGd1YXJhbnRlZXMg
bm8gc29mdGxvY2tzIHJlbWFpbi4NCg0KNy4gKipQb3N0IFByb2Nlc3NpbmcqKiAgDQogICAtIEVu
Zm9yY2UgcGVyaW1ldGVyIHdhbGxzIChgZW5mb3JjZV9ib3JkZXJfcmluZ2ApIHdoaWxlIHByZXNl
cnZpbmcgZG9vcnMvZXhpdHMuICANCiAgIC0gUmUtcnVuIGBlbmZvcmNlX2Rvb3JfdGlsZXNgIHRv
IGhlYWwgYW55IHBlcmltZXRlciBvdmVyd3JpdGVzLg0KDQo4LiAqKkV4cG9ydCoqICANCiAgIC0g
UHJvbW90ZSBgZ2VuX29iamVjdHNgIHRvIHRoZSBnbG9iYWwgYG9iamVjdHNgIGFycmF5IGFuZCBi
dWlsZCBgYW5pbWF0ZWRfb2JqZWN0c2AuICANCiAgIC0gUmV0dXJuIHBsYXllciBzdGFydCwgcGx1
cyBzdGF0cyBge3Jvb21zLCBvYmplY3RzLCBzZWVkLCBoaXN0b3J5fWAgZm9yIGRpYWdub3N0aWNz
L1VJLg0KDQotLS0NCg0KIyMgRGF0YSBTdHJ1Y3R1cmVzDQoNCnwgU3ltYm9sIHwgVHlwZSB8IERl
c2NyaXB0aW9uIHwNCnwtLS0tLS0tLXwtLS0tLS18LS0tLS0tLS0tLS0tLXwNCnwgYGdlbl9yZWN0
c2AgfCBhcnJheSBvZiBge3gwLHkwLHgxLHkxfWAgfCBBeGlzLWFsaWduZWQgcmVjdGFuZ2xlcyBm
b3IgZXZlcnkgY2FydmVkIHJvb20vanVuY3Rpb24uIHwNCnwgYGdlbl9ub2Rlc2AgfCBhcnJheSBv
ZiBge3JlY3QsbWlkeCxtaWR5LGVkZ2VzLGlzX2p1bmN0aW9uLHN0eWxlLGFyZWEsaW5kZXh9YCB8
IFJvb20gZ3JhcGggbm9kZXMgdXNlZCBmb3IgY29ycmlkb3IgbGlua2luZyBhbmQgcHJvZ3Jlc3Np
b24gY2hlY2tzLiB8DQp8IGBnZW5fZWRnZXNgIHwgYXJyYXkgb2YgYHtuMSxuMixiMSxiMixzdWNj
ZXNzLHNoYXBlLG1ldGFkYXRhfWAgfCBDb3JyaWRvciBkZXNjcmlwdG9ycyBjYXB0dXJpbmcgYm91
bmRhcnkgdGlsZXMsIG9yaWVudGF0aW9uLCBhbmQgb3B0aW9uYWwganVuY3Rpb24gbWV0YWRhdGEu
IHwNCnwgYGdlbl9pbnZlbnRvcnlgIHwgcXVldWUgb2YgYHt0eXBlPS4uLiwga2V5bnVtP31gIHwg
SXRlbXMgd2FpdGluZyBmb3IgcGxhY2VtZW50IChrZXlzLCBoZWFsdGgsIGV0Yy4pLiB8DQp8IGBn
ZW5fb2JqZWN0c2AgfCBhcnJheSBvZiBvYmplY3QgZGVmaW5pdGlvbnMgfCBGaW5hbCBvYmplY3Rz
IHNwYXduZWQgYWNyb3NzIHJvb21zIChOUENzLCBpdGVtcywgZGVjb3JhdGlvbnMpLiB8DQp8IGBn
ZW5fbG9ja2VkX2VkZ2VzYCB8IGFycmF5IHwgU3Vic2V0IG9mIGBnZW5fZWRnZXNgIGNhcnJ5aW5n
IGxvY2tzL2tleXMgZm9yIGxhdGVyIHZlcmlmaWNhdGlvbi4gfA0KfCBgZ2VuX2hpc3RvcnlgIHwg
cmluZyBidWZmZXIgb2Ygc3RyaW5ncyB8IE9yZGVyZWQgbG9nIG9mIGdlbmVyYXRpb24gZGVjaXNp
b25zIChyb29tIGZhaWx1cmVzLCBjb3JyaWRvciBmYWxsYmFjaywgcHJvZ3Jlc3Npb24gcmVzdWx0
cykuIHwNCnwgYHByb3RlY3RlZF90aWxlc2AgfCBzcGFyc2UgbWFwIHwgQ29vcmRpbmF0ZXMgc2hp
ZWxkZWQgZnJvbSBlcm9zaW9uIG9yIHJld3JpdGVzIChkb29ycywgY29ycmlkb3IgYm91bmRhcmll
cykuIHwNCnwgYGRvb3JncmlkYCB8IGBtYXBfc2l6ZSDDlyBtYXBfc2l6ZWAgdGFibGUgfCBTaGFy
ZWQgd2l0aCBkb29yIHN5c3RlbTsgZ2VuZXJhdG9yIHBvcHVsYXRlcyBzdGF0ZXMsIGxhdGVyIGNv
bnN1bWVkIGJ5IHJ1bnRpbWUgZG9vciBsb2dpYy4gfA0KDQotLS0NCg0KIyMgT2JzZXJ2YWJpbGl0
eSAmIERpYWdub3N0aWNzDQoNCi0gYGdlbl9vYnNlcnZhYmlsaXR5YCAoY29uZmlndXJhYmxlIGlu
IGBjb25maWcubHVhYCkgZ2F0ZXMgY29uc29sZSBsb2dnaW5nLCBoaXN0b3J5IGNhcHR1cmUsIGFu
ZCB3aGljaCBzdWJzeXN0ZW1zIGVtaXQgZW50cmllcyAoc3BhY2luZywgY29ycmlkb3JzLCBwcm9n
cmVzc2lvbiwgcmVwYWlycykuDQotIGBnZW5faGlzdG9yeWAgaXMgcmV0dXJuZWQgd2l0aCBldmVy
eSBydW4gYW5kIHBvd2VycyB0aGUgZHVuZ2VvbiBsYWIgc2lkZWJhcjsgaXQgaXMgYWxzbyBjb25z
dW1lZCBieSBgZHVuZ2Vvbl9oYXJuZXNzYC4NCi0gRG9vci9sb2NrIHZhbGlkYXRpb24gb2NjdXJz
IHR3aWNlOiBkdXJpbmcgcHJvZ3Jlc3Npb24gKGltbWVkaWF0ZSByZXBhaXIvcmVsb2NhdGUpIGFu
ZCBpbnNpZGUgdGhlIGhhcm5lc3MgKGB2YWxpZGF0ZV9sb2NrZWRfZWRnZXNgKS4NCi0gVGhlIGR1
bmdlb24gbGFiIHNjZW5lIGV4cG9zZXMgZGV0ZXJtaW5pc3RpYyBoYXJuZXNzIHJ1bnMgKGBGYCks
IHNlZWQgcmVwbGF5LCBhbmQgc2Nyb2xsaW5nIGxvZ3MgZm9yIG1hbnVhbCBpbnNwZWN0aW9uLg0K
DQotLS0NCg0KIyMgSW1wbGVtZW50YXRpb24gU2VxdWVuY2UgKFJlY29tbWVuZGVkKQ0KDQoxLiAq
KkRlZmluZSAvIGFkanVzdCBrbm9icyBpbiBgY29uZmlnLmx1YWAqKiAoYGdlbl9wYXJhbXNgLCBg
Z2VuX29ic2VydmFiaWxpdHlgLCBgZ2VuX2FkYXB0aXZlX3NldHRpbmdzYCwgYHRoZW1lc2ApLiAg
DQoyLiAqKk1vZGlmeSBjb3JlIGdlbmVyYXRpb24qKiBpbnNpZGUgYGR1bmdlb25fZ2VuLmx1YWAg
KHJvb20gc2FtcGxpbmcsIGNvcnJpZG9yIGhldXJpc3RpY3MsIGdhbWVwbGF5IGxheWVyaW5nKS4g
S2VlcCBoZWxwZXIgZnVuY3Rpb25zIHB1cmUgYW5kIGxldmVyYWdlIGV4aXN0aW5nIHNwYWNpbmcg
YW5kIGxvZ2dpbmcgaG9va3MuICANCjMuICoqVXBkYXRlIGdhbWVwbGF5IGxheWVycyoqIChgZ2Vu
ZXJhdGVfbnBjc2AsIGBnZW5lcmF0ZV9pdGVtc2AsIGBnZW5lcmF0ZV9kZWNvcmF0aW9uc2ApIGVu
c3VyaW5nIHRoZXkgcmVzcGVjdCBuZXcgY29uZmlnIGRhdGEuICANCjQuICoqUnVuIGRldGVybWlu
aXN0aWMgaGFybmVzcyoqIChgZHVuZ2Vvbl9oYXJuZXNzLnJ1bmApIGFjcm9zcyB0aGUgZGVmYXVs
dCBzZWVkIHN1aXRlOyByZXNvbHZlIGFueSByZXBvcnRlZCBpc3N1ZXMuICANCjUuICoqSW5zcGVj
dCB2aXN1YWxseSoqIHZpYSB0aGUgZHVuZ2VvbiBsYWIgc2NlbmUgdG8gY29uZmlybSBtYXAgcmVh
ZGFiaWxpdHksIHByb2dyZXNzaW9uLCBhbmQgbG9nIGNsYXJpdHkuICANCjYuICoqRG9jdW1lbnQg
Y2hhbmdlcyoqICh1cGRhdGUgdGhpcyBwaXBlbGluZSBkb2MgYW5kIGBjb25maWcubHVhYCBjb21t
ZW50cykgc28gZG93bnN0cmVhbSBzeXN0ZW1zIHN0YXkgYWxpZ25lZC4NCg0KLS0tDQoNCiMjIE1h
aW50ZW5hbmNlIEd1YXJkcmFpbHMNCg0KLSBBbHdheXMgY2FsbCBgcmVzZXRfYWRhcHRpdmVfc3Bh
Y2luZygpYCB3aGVuIGFkZGluZyBuZXcgZ2VuZXJhdGlvbiBlbnRyeSBwb2ludHMgdG8gZW5zdXJl
IHNwYWNpbmcgc3RhdGUgc3RhcnRzIGNsZWFuLg0KLSBXaGVuIGludHJvZHVjaW5nIG5ldyBsb2cg
dGFncywgYWRkIHRoZW0gdG8gdGhlIHNpZGViYXIgcGFyc2VyL1VJIHNvIHRoZXkgcmVtYWluIHZp
c2libGUuDQotIEd1YXJkIGVyb3Npb24gb3IgZGVzdHJ1Y3RpdmUgcGFzc2VzIHdpdGggYHByb3Rl
Y3RlZF90aWxlc2AgdG8gYXZvaWQgYnJlYWtpbmcgZG9vci9jb3JyaWRvciBjb250cmFjdHMuDQot
IEtlZXAgZ2FtZXBsYXkgYWRkaXRpb25zIGRldGVybWluaXN0aWM7IGFueSB1c2Ugb2YgYHJuZCgp
YCBtdXN0IHJ1biBhZnRlciBgc3JhbmQoc2VlZClgIGFuZCBiZWZvcmUgb2JqZWN0cyBhcmUgZXhw
b3J0ZWQuDQotIFVzZSBgZHVuZ2Vvbl9oYXJuZXNzYCB3aGVuZXZlciBwcm9ncmVzc2lvbiBsb2dp
YyBjaGFuZ2Vz4oCUa2V5cyByZWxvY2F0aW5nIGJhY2sgdG8gdGhlIHN0YXJ0IGlzIHRoZSBmaW5h
bCBzYWZldHkgbmV0LCBub3QgdGhlIGZpcnN0IHNvbHV0aW9uLg0KDQotLS0NCg0KIyMgTW9kdWxl
IENvbnRyYWN0cw0KDQojIyMgYGdlbmVyYXRlX2R1bmdlb24ob3B0cylgDQoNCioqUHJlY29uZGl0
aW9ucyoqDQotIGBjb25maWcubHVhYCB0YWJsZXMgKGBnZW5fcGFyYW1zYCwgYHRoZW1lc2AsIGBl
bmVteV90eXBlc2AsIGV0Yy4pIGFyZSBpbml0aWFsaXNlZC4NCi0gYGRvb3JncmlkYCBhbmQgdGls
ZSBsYXllcnMgKGBzZXRfd2FsbGAsIGBzZXRfZmxvb3JgKSBhcmUgYXZhaWxhYmxlIChpbml0aWFs
aXplZCBpbiBgbWFpbi5sdWFgKS4NCg0KKipQb3N0Y29uZGl0aW9ucyoqDQotIE1hcCB0aWxlcyBj
b250YWluIGEgZnVsbHkgY2FydmVkIGR1bmdlb24gd2l0aCBlbmZvcmNlZCBwZXJpbWV0ZXIuDQot
IGBvYmplY3RzYC9gYW5pbWF0ZWRfb2JqZWN0c2AgZmlsbGVkIHdpdGggZXZlcnkgc3Bhd25lZCBl
bnRpdHkuDQotIE1ldGFkYXRhIGB7cm9vbXMsIG9iamVjdHMsIHNlZWQsIGhpc3Rvcnl9YCByZXR1
cm5lZC4NCg0KIyMjIFJvb20gJiBDb3JyaWRvciBIZWxwZXJzDQoNCi0gYHJhbmRvbV9yb29tKGJh
c2Vfbm9kZSxpc19zcGVjaWFsKWAgcmVzcGVjdHMgYWN0aXZlIHRoZW1lIHJ1bGVzOyBjYWxsZXJz
IG11c3QgdmFsaWRhdGUgYm91bmRzL292ZXJsYXAuDQotIGBjcmVhdGVfY29ycmlkb3IobjEsbjIp
YCBtdXN0IGJlIHN1cHBsaWVkIHdpdGggcm9vbXMgYWxyZWFkeSBjYXJ2ZWQ7IGl0IHJlY29yZHMg
Ym91bmRhcnkgdGlsZXMgZm9yIHByb2dyZXNzaW9uIGFuZCBwcm90ZWN0cyB0aGVtIGFnYWluc3Qg
ZXJvc2lvbi4NCi0gYHRyeV9wbGFjZV9kb29yX3dpdGhfZmFsbGJhY2tgIGFuZCBgcGxhY2VfYm91
bmRhcnlfZG9vcl93aXRoX3JldHJ5YCBvbmx5IHdyaXRlIHRocm91Z2ggYHNldF93YWxsYDsgY2Fs
bGVycyBoYW5kbGUgbG9nZ2luZyBzZW1hbnRpY3MuDQoNCiMjIyBHYW1lcGxheSBMYXllciBGdW5j
dGlvbnMNCg0KLSBgZ2VuZXJhdGVfcHJvZ3Jlc3Npb25fbG9vcChzdGFydF9ub2RlKWAgYXNzdW1l
cyBgZ2VuX2VkZ2VzYCBpcyBwb3B1bGF0ZWQgYW5kIG11dGF0ZXMgZG9vcnMva2V5cyBhY2NvcmRp
bmdseS4gQWx3YXlzIGNhbGwgYHZhbGlkYXRlX2FuZF9yZXBhaXJfcHJvZ3Jlc3Npb25gIGFmdGVy
d2FyZC4NCi0gYGdlbmVyYXRlX25wY3MvaXRlbXMvZGVjb3JhdGlvbnNgIHJlbHkgb24gYGZpbmRf
c3Bhd25fcG9pbnRgIGFuZCB1cGRhdGUgYGdlbl9vYmplY3RzYDsgdGhleSBkbyBub3Qgd3JpdGUg
ZGlyZWN0bHkgdG8gdGlsZSBsYXllcnMuDQoNCiMjIyBIYXJuZXNzIChgZHVuZ2Vvbl9oYXJuZXNz
LnJ1bmApDQoNCi0gRXhwZWN0cyBnbG9iYWwgZ2VuZXJhdG9yIGhlbHBlcnMgKGBnZW5lcmF0ZV9k
dW5nZW9uYCwgYGdlbl9sb2NrZWRfZWRnZXNgLCBgZ2VuX29iamVjdHNgLCBldGMuKSB0byBleGlz
dC4NCi0gUmV0dXJucyBhIHN1bW1hcnkgd2l0aCBwZXItc2VlZCBmaW5kaW5nczsgY29uc3VtaW5n
IFVJcyBzaG91bGQgc3VyZmFjZSBgcmVjb3JkLmlzc3Vlc2AgZm9yIGRlYnVnZ2luZy4NCg0KLS0t
IA0KDQpCeSBmb2xsb3dpbmcgdGhpcyBwaXBlbGluZSBhbmQgaG9ub3VyaW5nIHRoZSBjb250cmFj
dHMgYWJvdmUsIHRoZSBwcm9jZWR1cmFsIGdlbmVyYXRpb24gc3lzdGVtIHN0YXlzIGRldGVybWlu
aXN0aWMsIG9ic2VydmFibGUsIGFuZCByZXNpbGllbnQgdG8gdHVuaW5nIGNoYW5nZXMgd2hpbGUg
cmVtYWluaW5nIGZ1bGx5IGFsaWduZWQgd2l0aCB0aGUgY3VycmVudCBMdWEgaW1wbGVtZW50YXRp
b24uDQoNCg==
:: src/docs/ProjectTemplate-README.md
b64$IyBQaWNvdHJvbiBHYW1lIFRlbXBsYXRlCgpUaGlzIHRlbXBsYXRlIHNlcnZlcyBhcyBhIGZv
dW5kYXRpb24gZm9yIGRldmVsb3BpbmcgZ2FtZXMgdXNpbmcgdGhlIFBpY290cm9uIGZhbnRhc3kg
Y29tcHV0ZXIgZW52aXJvbm1lbnQuIEl0IG9mZmVycyBhIHdlbGwtb3JnYW5pemVkIHNldHVwIGZv
ciBtYW5hZ2luZyBMdWEgY29kZSwgbG9nZ2luZywgYW5kIHVuaXQgdGVzdGluZywgZW5zdXJpbmcg
eW91ciBnYW1lJ3Mgc3RhYmlsaXR5IGFuZCBzY2FsYWJpbGl0eSBkdXJpbmcgZGV2ZWxvcG1lbnQu
CgotIFtJbnRyb2R1Y3Rpb25dKCNpbnRyb2R1Y3Rpb24pCi0gW1Byb2plY3QgU3RydWN0dXJlXSgj
cHJvamVjdC1zdHJ1Y3R1cmUpCi0gW0luc3RhbGxhdGlvbl0oI2luc3RhbGxhdGlvbikKLSBbVXNh
Z2VdKCN1c2FnZSkKICAgIC0gW1J1bm5pbmcgdGhlIEdhbWVdKCNydW5uaW5nLXRoZS1nYW1lKQog
ICAgLSBbQ3VzdG9taXppbmcgQ29uZmlndXJhdGlvbl0oI2N1c3RvbWl6aW5nLWNvbmZpZ3VyYXRp
b24pCi0gW0x1YSBgcmVxdWlyZSgpYCBhbmQgTW9kdWxlIFN5c3RlbV0oI2x1YS1yZXF1aXJlLWFu
ZC1tb2R1bGUtc3lzdGVtKQotIFtMb2dnaW5nIFN5c3RlbV0oI2xvZ2dpbmctc3lzdGVtKQogICAg
LSBbVXNpbmcgdGhlIExvZ2dpbmcgU3lzdGVtXSgjdXNpbmctdGhlLWxvZ2dpbmctc3lzdGVtKQog
ICAgLSBbTG9nZ2luZyBFeGFtcGxlXSgjbG9nZ2luZy1leGFtcGxlKQogICAgLSBbTG9nIFZpZXdl
ciAoYGxvZ3ZpZXcubHVhYCldKCNsb2ctdmlld2VyLWxvZ3ZpZXdsdWEpCiAgICAtIFtJbXBvcnRh
bnQgTm90ZXNdKCNpbXBvcnRhbnQtbm90ZXMpCi0gW1VuaXQgVGVzdGluZ10oI3VuaXQtdGVzdGlu
ZykKICAgIC0gW1J1bm5pbmcgVW5pdCBUZXN0c10oI3J1bm5pbmctdW5pdC10ZXN0cykKICAgIC0g
W1dyaXRpbmcgVW5pdCBUZXN0c10oI3dyaXRpbmctdW5pdC10ZXN0cykKICAgICAgICAtIFtUZXN0
IEZpeHR1cmUgRXhhbXBsZSBmb3IgYHBsYXllci5sdWFgXSgjdGVzdC1maXh0dXJlLWV4YW1wbGUt
Zm9yLXBsYXllcmx1YSkKICAgICAgICAtIFtUZXN0IExpZmVjeWNsZSBEZXRhaWxzXSgjdGVzdC1s
aWZlY3ljbGUtZGV0YWlscykKICAgICAgICAtIFtSdW5uaW5nIHRoZSBUZXN0c10oI3J1bm5pbmct
dGhlLXRlc3RzKQogICAgICAgIC0gW1NhbXBsZSBUZXN0IE91dHB1dF0oI3NhbXBsZS10ZXN0LW91
dHB1dCkKLSBbQXNzZXJ0aW9uIExpYnJhcnldKCNhc3NlcnRpb24tbGlicmFyeSkKICAgIC0gW1By
YWN0aWNhbCBBc3NlcnRpb24gRXhhbXBsZXNdKCNwcmFjdGljYWwtYXNzZXJ0aW9uLWV4YW1wbGVz
KQogICAgLSBbRXJyb3IgSGFuZGxpbmcgaW4gQXNzZXJ0aW9uc10oI2Vycm9yLWhhbmRsaW5nLWlu
LWFzc2VydGlvbnMpCi0gW0xpY2Vuc2VdKCNsaWNlbnNlKQotIFtBZGRpdGlvbmFsIFJlc291cmNl
c10oI2FkZGl0aW9uYWwtcmVzb3VyY2VzKQotIFtDb250cmlidXRpbmddKCNjb250cmlidXRpbmcp
CiAgICAtIFtIb3cgdG8gQ29udHJpYnV0ZV0oI2hvdy10by1jb250cmlidXRlKQogICAgLSBbQ29u
dHJpYnV0aW9uIEd1aWRlbGluZXNdKCNjb250cmlidXRpb24tZ3VpZGVsaW5lcykKICAgIC0gW1Jl
cG9ydGluZyBJc3N1ZXNdKCNyZXBvcnRpbmctaXNzdWVzKQoKIyMgSW50cm9kdWN0aW9uCgpQaWNv
dHJvbiBpcyBhIGZhbnRhc3kgY29tcHV0ZXIgZGV2ZWxvcGVkIGJ5IExleGFsb2ZmbGUsIG9mZmVy
aW5nIGEgY3JlYXRpdmUgcGxhdGZvcm0gZm9yIGRldmVsb3BpbmcgZ2FtZXMsIGRlbW9zLCBhbmQg
dG9vbHMgdXNpbmcgcGl4ZWwgZ3JhcGhpY3MgYW5kIEx1YSBwcm9ncmFtbWluZy4gVGhpcyB0ZW1w
bGF0ZSBzdHJlYW1saW5lcyBnYW1lIGRldmVsb3BtZW50IGJ5IHByb3ZpZGluZyBhbiBvcmdhbml6
ZWQgcHJvamVjdCBzdHJ1Y3R1cmUsIGVzc2VudGlhbCB1dGlsaXRpZXMgKHN1Y2ggYXMgbG9nZ2lu
ZyBhbmQgYXNzZXJ0aW9uIHRvb2xzKSwgYW5kIGEgdW5pdCB0ZXN0aW5nIGZyYW1ld29yay4KCiMj
IFByb2plY3QgU3RydWN0dXJlCgpUaGUgcHJvamVjdCBpcyBzdHJ1Y3R1cmVkIGFzIGZvbGxvd3M6
CgpgYGBwbGFpbnRleHQKUFJPSkVDVF9ST09ULwrilJzilIDilIAgbGliLwrilIIgICAg4pSc4pSA
4pSAIGFzc2VydC5sdWEgICAgICAgICAjIEFzc2VydGlvbiB1dGlsaXRpZXMgZm9yIHRlc3RpbmcK
4pSCICAgIOKUnOKUgOKUgCBsb2cubHVhICAgICAgICAgICAgIyBMb2dnaW5nIHV0aWxpdGllcyBm
b3IgcnVudGltZSBldmVudHMK4pSc4pSA4pSAIHNyYy8gICAgICAgICAgICAgICAgICAgICMgU291
cmNlIGNvZGUgZm9yIHlvdXIgZ2FtZSAoZXhwYW5kYWJsZSkK4pSc4pSA4pSAIHRlc3QvICAgICAg
ICAgICAgICAgICAgICMgRGlyZWN0b3J5IGZvciB1bml0IHRlc3RzCuKUnOKUgOKUgCAuZ2l0YXR0
cmlidXRlcyAgICAgICAgICAjIEdpdCBjb25maWd1cmF0aW9uIGZvciBoYW5kbGluZyBsaW5lIGVu
ZGluZ3MK4pSc4pSA4pSAIGNvbmZpZ3VyYXRpb24ubHVhICAgICAgICMgR2xvYmFsIGNvbmZpZ3Vy
YXRpb24gc2V0dGluZ3MK4pSc4pSA4pSAIGdsb2JhbHMubHVhICAgICAgICAgICAgICMgR2xvYmFs
IHV0aWxpdHkgZnVuY3Rpb25zCuKUnOKUgOKUgCBMSUNFTlNFICAgICAgICAgICAgICAgICAjIExp
Y2Vuc2UgZmlsZSBmb3IgdGhlIHByb2plY3QgKEdOVSBHUEx2MykK4pSc4pSA4pSAIGxvZ3ZpZXcu
bHVhICAgICAgICAgICAgICMgTG9nIHZpZXdlciBmb3IgaW5zcGVjdGluZyBsb2dzIGluIGEgR1VJ
IHdpbmRvdwrilJzilIDilIAgbWFpbi5sdWEgICAgICAgICAgICAgICAgIyBFbnRyeSBwb2ludCBm
b3IgdGhlIGdhbWUK4pSc4pSA4pSAIFJFQURNRS5tZCAgICAgICAgICAgICAgICMgUHJvamVjdCBk
b2N1bWVudGF0aW9uCuKUnOKUgOKUgCByZXF1aXJlLmx1YSAgICAgICAgICAgICAjIE1vZHVsZSBs
b2FkaW5nIHN5c3RlbSAoY3VzdG9tIGByZXF1aXJlKClgKQrilJzilIDilIAgcnVuX3Rlc3RzLmx1
YSAgICAgICAgICAgIyBTY3JpcHQgdG8gcnVuIHVuaXQgdGVzdHMK4pSU4pSA4pSAIHRlc3RfY29u
ZmlndXJhdGlvbi5sdWEgICMgQ29uZmlndXJhdGlvbiBzZXR0aW5ncyBmb3IgdGVzdHMKYGBgCgoj
IyBJbnN0YWxsYXRpb24KCjEuIENsb25lIHRoaXMgcmVwb3NpdG9yeSB0byB5b3VyIGxvY2FsIG1h
Y2hpbmU6CgogICAgYGBgYmFzaAogICAgZ2l0IGNsb25lIGh0dHBzOi8vZ2l0aHViLmNvbS95b3Vy
dXNlcm5hbWUvcGljb3Ryb24tZ2FtZS10ZW1wbGF0ZS5naXQKICAgIGBgYAoKMi4gSW5zdGFsbCB0
aGUgW1BpY290cm9uIEZhbnRhc3kgQ29tcHV0ZXJdKGh0dHBzOi8vd3d3LmxleGFsb2ZmbGUuY29t
L2RsL2RvY3MvcGljb3Ryb25fbWFudWFsLmh0bWwpIGZvbGxvd2luZyB0aGUgb2ZmaWNpYWwgaW5z
dHJ1Y3Rpb25zLgoKMy4gQ29weSB5b3VyIHByb2plY3QgZm9sZGVyIGludG8gdGhlIFBpY290cm9u
IHdvcmtzcGFjZSB0byBiZWdpbiBkZXZlbG9waW5nLgoKIyMgVXNhZ2UKCiMjIyBSdW5uaW5nIHRo
ZSBHYW1lCgpUbyBzdGFydCB5b3VyIGdhbWUsIG9wZW4gUGljb3Ryb24gYW5kIG5hdmlnYXRlIHRv
IHRoZSBgbWFpbi5sdWFgIGZpbGUuIFRoaXMgZmlsZSBzZXJ2ZXMgYXMgdGhlIGVudHJ5IHBvaW50
IGZvciB5b3VyIGdhbWUuIEN1c3RvbWl6ZSBpdCBhcyBuZWVkZWQgdG8gaW5jb3Jwb3JhdGUgeW91
ciBnYW1lJ3MgbG9naWMuCgojIyMgQ3VzdG9taXppbmcgQ29uZmlndXJhdGlvbgoKR2xvYmFsIHNl
dHRpbmdzLCBzdWNoIGFzIGVuYWJsaW5nL2Rpc2FibGluZyBmZWF0dXJlcyBsaWtlIGxvZ2dpbmcg
b3IgZGVmaW5pbmcgZ2FtZS1zcGVjaWZpYyB2YXJpYWJsZXMsIGNhbiBiZSBtb2RpZmllZCBpbiB0
aGUgYGNvbmZpZ3VyYXRpb24ubHVhYCBmaWxlLiBUaGlzIGZpbGUgY2VudHJhbGl6ZXMgYWxsIGNy
aXRpY2FsIGNvbmZpZ3VyYXRpb25zIGZvciB0aGUgZ2FtZS4KCiMjIEx1YSBgcmVxdWlyZSgpYCBh
bmQgTW9kdWxlIFN5c3RlbQoKVGhpcyB0ZW1wbGF0ZSBpbmNsdWRlcyBhIGN1c3RvbSBpbXBsZW1l
bnRhdGlvbiBvZiB0aGUgTHVhIGByZXF1aXJlKClgIGZ1bmN0aW9uLCBjb21wYXRpYmxlIHdpdGgg
THVhIDUuNCwgdG8gc2ltcGxpZnkgbW9kdWxlIGxvYWRpbmcgYW5kIGNhY2hpbmcsIG1ha2luZyB5
b3VyIGdhbWUgZWFzaWVyIHRvIG1hbmFnZSBhbmQgdGVzdC4KCjEuICoqTW9kdWxhciBEZXNpZ24q
KjoKICAgIE9yZ2FuaXplIHlvdXIgY29kZSBieSBkaXN0cmlidXRpbmcgZnVuY3Rpb25hbGl0eSBh
Y3Jvc3MgZGlmZmVyZW50IG1vZHVsZXMgKGZpbGVzKS4gTW9kdWxlcyBjYW4gY29udGFpbiBnYW1l
IGxvZ2ljLCB1dGlsaXRpZXMsIG9yIGNvbmZpZ3VyYXRpb24gc2V0dGluZ3MuIFVzZSBgcmVxdWly
ZSgpYCB0byBsb2FkIHRoZW0uCgoyLiAqKk1vZHVsZSBDYWNoaW5nKio6CiAgICBPbmNlIGEgbW9k
dWxlIGlzIGxvYWRlZCwgaXQgaXMgY2FjaGVkIHRvIGF2b2lkIG11bHRpcGxlIHJlbG9hZHMsIGlt
cHJvdmluZyBwZXJmb3JtYW5jZSBieSByZXVzaW5nIGxvYWRlZCBtb2R1bGVzLgoKMy4gKipVc2lu
ZyBgcmVxdWlyZSgpYCB0byBMb2FkIE1vZHVsZXMqKjoKICAgIExvYWQgYSBtb2R1bGUgdXNpbmcg
aXRzIGZpbGVuYW1lLiBUaGUgYHJlcXVpcmUoKWAgZnVuY3Rpb24gcmV0dXJucyB0aGUgbW9kdWxl
J3MgY29udGVudCwgdHlwaWNhbGx5IGEgdGFibGUgb2YgZnVuY3Rpb25zIG9yIGRhdGEuCgogICAg
RXhhbXBsZToKICAgIGBgYGx1YQogICAgbG9jYWwgcGxheWVyID0gcmVxdWlyZSgicGxheWVyIikK
ICAgIHBsYXllci5tb3ZlKDEwLCAyMCkKICAgIHByaW50KCJQbGF5ZXIgaGVhbHRoOiAiIC4uIHBs
YXllci5oZWFsdGgpCiAgICBwbGF5ZXIudGFrZV9kYW1hZ2UoNSkKICAgIHByaW50KCJQbGF5ZXIg
aGVhbHRoIGFmdGVyIGRhbWFnZTogIiAuLiBwbGF5ZXIuaGVhbHRoKQogICAgYGBgCgo0LiAqKkFk
ZGluZyBDdXN0b20gU2VhcmNoIFBhdGhzKio6CiAgICBEZWZpbmUgYWRkaXRpb25hbCBzZWFyY2gg
cGF0aHMgdG8gb3JnYW5pemUgeW91ciBtb2R1bGVzIGluIGRpZmZlcmVudCBkaXJlY3Rvcmllcy4K
CiAgICBFeGFtcGxlOgogICAgYGBgbHVhCiAgICBhZGRfbW9kdWxlX3BhdGgoIi9hZGRpdGlvbmFs
X21vZHVsZV9kaXJlY3RvcnkvIikKICAgIGBgYAoKNS4gKipDbGVhcmluZyB0aGUgTW9kdWxlIENh
Y2hlKio6CiAgICBDbGVhciB0aGUgbW9kdWxlIGNhY2hlIHRvIHJlbG9hZCBzcGVjaWZpYyBtb2R1
bGVzLCB3aGljaCBpcyB1c2VmdWwgZHVyaW5nIHRlc3RpbmcuCgogICAgRXhhbXBsZToKICAgIGBg
YGx1YQogICAgY2xlYXJfbW9kdWxlX2NhY2hlKHsgImxvZyIgfSkgIC0tIENsZWFycyBhbGwgY2Fj
aGVkIG1vZHVsZXMgZXhjZXB0IHRoZSBsb2cgbW9kdWxlCiAgICBgYGAKCjYuICoqTW9jayBNb2R1
bGVzIGZvciBUZXN0aW5nKio6CiAgICBMb2FkIG1vY2sgdmVyc2lvbnMgb2YgbW9kdWxlcyBkdXJp
bmcgdGVzdGluZyBieSB1c2luZyBhbGlhc2VzLCBhbGxvd2luZyB5b3UgdG8gc2ltdWxhdGUgYmVo
YXZpb3Igd2l0aG91dCBhZmZlY3RpbmcgdGhlIGFjdHVhbCBnYW1lLgoKICAgIEV4YW1wbGU6CiAg
ICBgYGBsdWEKICAgIGxvY2FsIGxvZyA9IHJlcXVpcmUoIm1vY2tfbG9nIiwgImxvZyIpICAtLSBN
b2NrIGxvZyBtb2R1bGUgdW5kZXIgdGhlIHJlYWwgbG9nIGFsaWFzCiAgICBsb2cuaW5mbygiVGVz
dGluZyBzdGFydGVkIikKICAgIGBgYAoKIyMgTG9nZ2luZyBTeXN0ZW0KClRoaXMgdGVtcGxhdGUg
aW5jbHVkZXMgYSBjb21wcmVoZW5zaXZlIGxvZ2dpbmcgc3lzdGVtIHRvIHRyYWNrIGdhbWUgZXZl
bnRzLCBkZWJ1ZyBpbmZvcm1hdGlvbiwgYW5kIGVycm9ycy4gVGhlIHN5c3RlbSBhbGxvd3MgeW91
IHRvIGxvZyBtZXNzYWdlcyB0byBlaXRoZXIgdGhlIGNvbnNvbGUgb3IgYW4gZXh0ZXJuYWwgcHJv
Y2Vzcywgc3VjaCBhcyB0aGUgaW5jbHVkZWQgbG9nIHZpZXdlciwgcHJvdmlkaW5nIHJlYWwtdGlt
ZSB2aXNpYmlsaXR5IGludG8geW91ciBnYW1l4oCZcyBiZWhhdmlvci4KCjEuICoqTG9nIExldmVs
cyoqOgogICAgRGlmZmVyZW50IGxvZyBsZXZlbHMgY29udHJvbCB0aGUgdmVyYm9zaXR5IG9mIHRo
ZSBvdXRwdXQuIFNldCB0aGUgYXBwcm9wcmlhdGUgbG9nIGxldmVsIGJlZm9yZSBpbml0aWFsaXpp
bmcgdGhlIGxvZ2dpbmcgc3lzdGVtLiBBdmFpbGFibGUgbG9nIGxldmVscyBhcmU6CiAgICAtIGBU
UkFDRWA6IFZlcnkgZGV0YWlsZWQgbG9nZ2luZywgdXNlZnVsIGZvciB0cmFjaW5nIGZ1bmN0aW9u
IGNhbGxzLgogICAgLSBgREVCVUdgOiBEZXRhaWxlZCBpbmZvcm1hdGlvbiB0byBoZWxwIHdpdGgg
ZGVidWdnaW5nLgogICAgLSBgSU5GT2A6IEdlbmVyYWwgZ2FtZSBleGVjdXRpb24gaW5mb3JtYXRp
b24gKGUuZy4sICJHYW1lIHN0YXJ0ZWQiKS4KICAgIC0gYFdBUk5gOiBXYXJuaW5ncyBhYm91dCBw
b3RlbnRpYWwgaXNzdWVzIHRoYXQgZG8gbm90IHN0b3AgdGhlIGdhbWUuCiAgICAtIGBFUlJPUmA6
IENyaXRpY2FsIGVycm9ycyByZXF1aXJpbmcgaW1tZWRpYXRlIGF0dGVudGlvbi4KCjIuICoqTG9n
IFRhcmdldHMqKjoKICAgIExvZ3MgY2FuIGJlIGRpcmVjdGVkIHRvIGVpdGhlcjoKICAgIC0gKipD
b25zb2xlKio6IExvZ3MgcHJpbnRlZCBkaXJlY3RseSBpbiB0aGUgY29uc29sZS4KICAgIC0gKipF
eHRlcm5hbCBQcm9jZXNzKio6IExvZ3Mgc2VudCB0byBhbiBleHRlcm5hbCBwcm9jZXNzIHN1Y2gg
YXMgdGhlIGxvZyB2aWV3ZXIgKGBsb2d2aWV3Lmx1YWApLgoKMy4gKipFeHRlcm5hbCBMb2dnaW5n
Kio6CiAgICBXaGVuIGxvZ2dpbmcgdG8gYW4gZXh0ZXJuYWwgcHJvY2VzcywgdGhlIHN5c3RlbSBz
ZW5kcyBtZXNzYWdlcyB0byBhbm90aGVyIHByb2dyYW0gKGUuZy4sIGBsb2d2aWV3Lmx1YWApLCBh
bGxvd2luZyByZWFsLXRpbWUgbW9uaXRvcmluZyBpbiBhIHNlcGFyYXRlIHdpbmRvdy4KCjQuICoq
VGltZXN0YW1wZWQgRW50cmllcyoqOgogICAgRWFjaCBsb2cgZW50cnkgaXMgYXV0b21hdGljYWxs
eSB0aW1lc3RhbXBlZCwgd2hpY2ggaGVscHMgd2l0aCBkZWJ1Z2dpbmcgYW5kIHRyYWNraW5nIGV2
ZW50IG9yZGVyLgoKNS4gKipEeW5hbWljIENvbnRyb2wgT3ZlciBMb2dnaW5nKio6CiAgICBBZGp1
c3QgdGhlIGxvZyBsZXZlbCB0byBjb250cm9sIHdoaWNoIG1lc3NhZ2VzIGFyZSBsb2dnZWQuIEZv
ciBleGFtcGxlLCBzZXR0aW5nIHRoZSBsb2cgbGV2ZWwgdG8gYEVSUk9SYCB3aWxsIG9ubHkgbG9n
IGNyaXRpY2FsIGVycm9ycy4KCiMjIyBVc2luZyB0aGUgTG9nZ2luZyBTeXN0ZW0KCjEuICoqU2V0
dGluZyBMb2cgTGV2ZWwgYW5kIFRhcmdldCoqOgogICAgU2V0IHRoZSBsb2cgbGV2ZWwgYW5kIHRh
cmdldCBiZWZvcmUgY2FsbGluZyBgaW5pdCgpYC4KCiAgICBFeGFtcGxlOgogICAgYGBgbHVhCiAg
ICBsb2cuc2V0X2xldmVsKGxvZy5sZXZlbHMuREVCVUcpICAgICAgLS0gU2V0IGxvZyBsZXZlbCB0
byBERUJVRwogICAgbG9nLnNldF90YXJnZXQobG9nLnRhcmdldHMuQ09OU09MRSkgIC0tIFNldCBs
b2cgdGFyZ2V0IHRvIGNvbnNvbGUKICAgIGxvZy5pbml0KCkgICAgICAgICAgICAgICAgICAgICAg
ICAgICAtLSBJbml0aWFsaXplIGxvZ2dpbmcKICAgIGBgYAoKMi4gKipMb2dnaW5nIE1lc3NhZ2Vz
Kio6CiAgICBMb2cgbWVzc2FnZXMgYXQgZGlmZmVyZW50IGxldmVscyAoYFRSQUNFYCwgYERFQlVH
YCwgYElORk9gLCBgV0FSTmAsIGBFUlJPUmApLgoKICAgIGBgYGx1YQogICAgbG9nLmluZm8oIkdh
bWUgaW5pdGlhbGl6ZWQiKSAgICAgICAtLSBMb2dzIGFuIGluZm8gbWVzc2FnZQogICAgbG9nLmVy
cm9yKCJGYWlsZWQgdG8gbG9hZCBhc3NldCIpICAtLSBMb2dzIGFuIGVycm9yIG1lc3NhZ2UKICAg
IGBgYAoKMy4gKipSZWluaXRpYWxpemluZyB0aGUgTG9nIFN5c3RlbSoqOgogICAgSWYgeW91IGNo
YW5nZSB0aGUgbG9nIGxldmVsIG9yIHRhcmdldCBhZnRlciB0aGUgaW5pdGlhbCBzZXR1cCwgcmVp
bml0aWFsaXplIHRoZSBsb2dnaW5nIHN5c3RlbSBieSBjYWxsaW5nIGBpbml0KClgIGFnYWluLgoK
ICAgIGBgYGx1YQogICAgbG9nLnNldF9sZXZlbChsb2cubGV2ZWxzLlRSQUNFKSAgICAgICAgICAg
ICAgIC0tIENoYW5nZSBsb2cgbGV2ZWwgdG8gVFJBQ0UKICAgIGxvZy5zZXRfdGFyZ2V0KGxvZy50
YXJnZXRzLkVYVEVSTkFMX1BST0NFU1MpICAtLSBDaGFuZ2UgdGFyZ2V0IHRvIGV4dGVybmFsIHBy
b2Nlc3MKICAgIGxvZy5pbml0KCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAt
LSBSZWluaXRpYWxpemUgbG9nZ2luZyBzeXN0ZW0KICAgIGBgYAoKNC4gKipUcmFjaW5nIEZ1bmN0
aW9uIENhbGxzKio6CiAgICBVc2UgYHRyYWNlX2Z1bmN0aW9uKClgIHRvIGxvZyBmdW5jdGlvbiBl
bnRyeSBhbmQgZXhpdCBwb2ludHMsIG1ha2luZyBpdCBlYXNpZXIgdG8gdHJhY2UgdGhlIGZsb3cg
b2YgZnVuY3Rpb24gY2FsbHMuCgogICAgYGBgbHVhCiAgICBsb2NhbCByZXN1bHQgPSBsb2cudHJh
Y2VfZnVuY3Rpb24oIm1vdmVfcGxheWVyIiwgbW92ZV9wbGF5ZXIsIHBsYXllciwgZHgsIGR5KQog
ICAgYGBgCgojIyMgTG9nZ2luZyBFeGFtcGxlCgpgYGBsdWEKbG9nLnNldF9sZXZlbChsb2cubGV2
ZWxzLklORk8pCmxvZy5zZXRfdGFyZ2V0KGxvZy50YXJnZXRzLkVYVEVSTkFMX1BST0NFU1MpCmxv
Zy5pbml0KCkgIC0tIEluaXRpYWxpemUgbG9nZ2luZwoKbG9nLmluZm8oIkdhbWUgc3RhcnRlZCIp
CmxvZy53YXJuKCJMb3cgcGxheWVyIGhlYWx0aCBkZXRlY3RlZCIpCgppZiBub3QgcGxheWVyIHRo
ZW4KICAgIGxvZy5lcnJvcigiRmFpbGVkIHRvIGxvYWQgcGxheWVyIGRhdGEiKQplbmQKYGBgCgoj
IyMgTG9nIFZpZXdlciAoYGxvZ3ZpZXcubHVhYCkKClRoZSBgbG9ndmlldy5sdWFgIHNjcmlwdCBw
cm92aWRlcyBhIGdyYXBoaWNhbCBpbnRlcmZhY2UgZm9yIHZpZXdpbmcgbG9nIG1lc3NhZ2VzIGlu
IHJlYWwtdGltZS4gSXQgZGlzcGxheXMgdXAgdG8gNTAwIGxvZyBlbnRyaWVzLCByZW1vdmluZyB0
aGUgb2xkZXN0IGVudHJpZXMgYXMgbmV3IG9uZXMgYXJlIGFkZGVkLgoKIyMjIEltcG9ydGFudCBO
b3RlcwotIEFsd2F5cyBzZXQgdGhlIGxvZyBsZXZlbCBhbmQgdGFyZ2V0ICoqYmVmb3JlKiogY2Fs
bGluZyBgbG9nLmluaXQoKWAuCi0gUmVpbml0aWFsaXplIHRoZSBsb2dnaW5nIHN5c3RlbSBpZiB0
aGUgbG9nIGxldmVsIG9yIHRhcmdldCBpcyBjaGFuZ2VkIGFmdGVyIGluaXRpYWxpemF0aW9uLgoK
IyMgVW5pdCBUZXN0aW5nCgpUaGlzIHRlbXBsYXRlIGluY2x1ZGVzIGEgdW5pdCB0ZXN0aW5nIHN5
c3RlbSB0byBlbnN1cmUgdGhhdCB5b3VyIGdhbWUgZnVuY3Rpb25zIHJlbGlhYmx5IGFuZCBhcyBl
eHBlY3RlZC4gSXQgYWxsb3dzIGZvciBvcmdhbml6ZWQgdGVzdGluZyB3aXRoIG1vZHVsYXIgdGVz
dCBmaWxlcywgc2V0dXAvdGVhcmRvd24gZnVuY3Rpb25zLCBhbmQgaW50ZWdyYXRpb24gd2l0aCB0
aGUgbG9nZ2luZyBzeXN0ZW0gdG8gbWFpbnRhaW4gY29kZSBxdWFsaXR5IGFuZCBjYXRjaCBidWdz
IGVhcmx5LgoKMS4gKipNb2R1bGFyIFRlc3QgU3RydWN0dXJlKio6IAogICAgVGVzdHMgYXJlIG9y
Z2FuaXplZCBpbnRvIEx1YSBmaWxlcyAoZml4dHVyZXMpIHN0b3JlZCBpbiB0aGUgYHRlc3QvYCBk
aXJlY3RvcnkuIEVhY2ggZml4dHVyZSBjb250YWlucyBtdWx0aXBsZSB0ZXN0IGNhc2VzLCBmb2N1
c2luZyBvbiBzcGVjaWZpYyBwYXJ0cyBvZiB0aGUgZ2FtZS4KCjIuICoqVGVzdCBMaWZlY3ljbGUg
TWFuYWdlbWVudCoqOiAKICAgIFRoZSBmcmFtZXdvcmsgc3VwcG9ydHMgbGlmZWN5Y2xlIGhvb2tz
IHRvIG1hbmFnZSB0aGUgdGVzdCBlbnZpcm9ubWVudDoKICAgIC0gKipgYmVmb3JlX2FsbCgpYCoq
OiBSdW5zIG9uY2UgYmVmb3JlIGFueSB0ZXN0cyBpbiB0aGUgZml4dHVyZSwgdXNlZnVsIGZvciBp
bml0aWFsaXppbmcgcmVzb3VyY2VzLgogICAgLSAqKmBiZWZvcmVfZWFjaCgpYCoqOiBSdW5zIGJl
Zm9yZSBlYWNoIHRlc3QgY2FzZSB0byBwcmVwYXJlIG9yIHJlc2V0IHRoZSBlbnZpcm9ubWVudC4K
ICAgIC0gKipUZXN0IEZ1bmN0aW9ucyoqOiBFYWNoIHRlc3QgY2FzZSBpcyBkZWZpbmVkIGFzIGEg
c2VwYXJhdGUgZnVuY3Rpb24gaW4gdGhlIGZpeHR1cmUuCiAgICAtICoqYGFmdGVyX2VhY2goKWAq
KjogQ2xlYW5zIHVwIGFmdGVyIGVhY2ggdGVzdCBjYXNlIHRvIGVuc3VyZSBhIGZyZXNoIHN0YXRl
LgogICAgLSAqKmBhZnRlcl9hbGwoKWAqKjogUnVucyBhZnRlciBhbGwgdGVzdHMgaW4gdGhlIGZp
eHR1cmUsIHR5cGljYWxseSB1c2VkIGZvciBmaW5hbCBjbGVhbnVwIG9mIHNoYXJlZCByZXNvdXJj
ZXMuCgogICAgRXhhbXBsZSB0ZXN0IGZpeHR1cmUgc3RydWN0dXJlOgogICAgYGBgbHVhCiAgICAt
LSBJbXBvcnRpbmcgcmVxdWlyZWQgbW9kdWxlcwogICAgbG9jYWwgYXNzZXJ0ID0gcmVxdWlyZSgi
YXNzZXJ0IikgIC0tIFVzZWQgZm9yIGFzc2VydGlvbnMgaW4gdGVzdCBjYXNlcwogICAgbG9jYWwg
bG9nID0gcmVxdWlyZSgibG9nIikgICAgICAgIC0tIFVzZWQgZm9yIGxvZ2dpbmcgZHVyaW5nIHRl
c3QgZXhlY3V0aW9uCgogICAgLS0gRGVmaW5lIGEgZml4dHVyZSB0YWJsZSB0byBob2xkIHRoZSB0
ZXN0IHNldHVwLCB0ZWFyZG93biwgYW5kIHRlc3QgZnVuY3Rpb25zCiAgICBsb2NhbCBmaXh0dXJl
ID0geyB9CgogICAgLS0gQ2FsbGVkIG9uY2UgYmVmb3JlIGFueSB0ZXN0cyBhcmUgcnVuIChmaXh0
dXJlIGluaXRpYWxpemF0aW9uKQogICAgZnVuY3Rpb24gZml4dHVyZS5iZWZvcmVfYWxsKCkKICAg
ICAgICAtLSBTZXR1cCBsb2dpYyB0aGF0IHJ1bnMgYmVmb3JlIGFsbCB0ZXN0cyBpbiB0aGUgZml4
dHVyZQogICAgZW5kCgogICAgLS0gQ2FsbGVkIGJlZm9yZSBlYWNoIGluZGl2aWR1YWwgdGVzdCBp
cyBleGVjdXRlZCAodGVzdCBjYXNlIGluaXRpYWxpemF0aW9uKQogICAgZnVuY3Rpb24gZml4dHVy
ZS5iZWZvcmVfZWFjaCgpCiAgICAgICAgLS0gU2V0dXAgbG9naWMgdGhhdCBydW5zIGJlZm9yZSBl
YWNoIHRlc3QgY2FzZSBpbiB0aGUgZml4dHVyZQogICAgZW5kCgogICAgLS0gRmlyc3QgdGVzdCBj
YXNlOiBXcml0ZSB5b3VyIHRlc3QgbG9naWMgaGVyZQogICAgZnVuY3Rpb24gZml4dHVyZS50ZXN0
X3NvbWV0aGluZygpCiAgICAgICAgLS0gVGVzdCBzb21ldGhpbmcKICAgIGVuZAoKICAgIC0tIFNl
Y29uZCB0ZXN0IGNhc2U6IEFub3RoZXIgZXhhbXBsZSB0ZXN0CiAgICBmdW5jdGlvbiBmaXh0dXJl
LnRlc3Rfc29tZXRoaW5nMigpCiAgICAgICAgLS0gVGVzdCBzb21ldGhpbmcgZWxzZQogICAgZW5k
CgogICAgLS0gQ2FsbGVkIGFmdGVyIGVhY2ggaW5kaXZpZHVhbCB0ZXN0IGlzIGV4ZWN1dGVkICh0
ZXN0IGNhc2UgY2xlYW51cCkKICAgIGZ1bmN0aW9uIGZpeHR1cmUuYWZ0ZXJfZWFjaCgpCiAgICAg
ICAgLS0gQ2xlYW51cCBsb2dpYyB0aGF0IHJ1bnMgYWZ0ZXIgZWFjaCB0ZXN0IGNhc2UgaW4gdGhl
IGZpeHR1cmUKICAgIGVuZAoKICAgIC0tIENhbGxlZCBvbmNlIGFmdGVyIGFsbCB0ZXN0cyBhcmUg
cnVuIChmaXh0dXJlIGNsZWFudXApCiAgICBmdW5jdGlvbiBmaXh0dXJlLmFmdGVyX2FsbCgpCiAg
ICAgICAgLS0gQ2xlYW51cCBsb2dpYyB0aGF0IHJ1bnMgYWZ0ZXIgYWxsIHRlc3RzIGluIHRoZSBm
aXh0dXJlCiAgICBlbmQKCiAgICAtLSBSZXR1cm4gdGhlIGZpeHR1cmUgdGFibGUgdG8gYmUgdXNl
ZCBieSB0aGUgdGVzdCBmcmFtZXdvcmsKICAgIHJldHVybiBmaXh0dXJlCiAgICBgYGAKCjMuICoq
TG9nZ2luZyBJbnRlZ3JhdGlvbioqOiAKICAgIFRoZSBzeXN0ZW0gbG9ncyB0ZXN0IHJlc3VsdHMg
aW4gcmVhbC10aW1lLCBwcm92aWRpbmcgZGV0YWlsZWQgZXJyb3IgbWVzc2FnZXMgaWYgdGVzdHMg
ZmFpbC4KCjQuICoqQXV0b21hdGljIFRlc3QgRGlzY292ZXJ5Kio6IAogICAgVGhlIGBydW5fdGVz
dHMubHVhYCBzY3JpcHQgYXV0b21hdGljYWxseSBkZXRlY3RzIGFuZCBydW5zIGFsbCB0ZXN0IGZp
bGVzIGluIHRoZSBgdGVzdC9gIGRpcmVjdG9yeS4KCjUuICoqRGV0YWlsZWQgRXJyb3IgUmVwb3J0
aW5nKio6IAogICAgVGhlIHN5c3RlbSBsb2dzIGRldGFpbGVkIGVycm9yIG1lc3NhZ2VzLCBpbmNs
dWRpbmcgdGhlIGxpbmUgbnVtYmVyLCBtYWtpbmcgaXQgZWFzeSB0byBpZGVudGlmeSB0aGUgc291
cmNlIG9mIHByb2JsZW1zLgoKIyMjIFJ1bm5pbmcgVW5pdCBUZXN0cwoKVG8gcnVuIGFsbCB0ZXN0
cywgZXhlY3V0ZSB0aGUgYHJ1bl90ZXN0cy5sdWFgIHNjcmlwdDoKCmBgYApydW5fdGVzdHMubHVh
CmBgYAoKVG8gcnVuIHNwZWNpZmljIHRlc3RzOgoKYGBgCnJ1bl90ZXN0cy5sdWEgdGVzdF9wbGF5
ZXIubHVhIHRlc3RfaW52ZW50b3J5Lmx1YQpgYGAKCiMjIyBXcml0aW5nIFVuaXQgVGVzdHMKCkVh
Y2ggdGVzdCBmaWxlIChmaXh0dXJlKSBjb250YWlucyBtdWx0aXBsZSB0ZXN0IGNhc2VzIHVzaW5n
IGxpZmVjeWNsZSBob29rcyB0byBtYW5hZ2Ugc2V0dXAgYW5kIHRlYXJkb3duLiBCZWxvdyBpcyBh
biBleGFtcGxlIHRlc3QgZml4dHVyZSBmb3IgdGhlIGBwbGF5ZXIubHVhYCBtb2R1bGUuCgojIyMj
IFRlc3QgRml4dHVyZSBFeGFtcGxlIGZvciBgcGxheWVyLmx1YWAKCmBgYGx1YQpsb2NhbCBhc3Nl
cnQgPSByZXF1aXJlKCJhc3NlcnQiKQpsb2NhbCBsb2cgPSByZXF1aXJlKCJsb2ciKQpsb2NhbCBw
bGF5ZXIgPSByZXF1aXJlKCJwbGF5ZXIiKQoKbG9jYWwgZml4dHVyZSA9IHt9CgpmdW5jdGlvbiBm
aXh0dXJlLmJlZm9yZV9lYWNoKCkKICAgIHBsYXllci54LCBwbGF5ZXIueSA9IDAsIDAKICAgIHBs
YXllci5oZWFsdGggPSAxMDAKICAgIHBsYXllci5pbnZlbnRvcnkgPSB7fQogICAgbG9nLmluZm8o
IlBsYXllciBzdGF0ZSByZXNldCBmb3IgYSBuZXcgdGVzdCIpCmVuZAoKZnVuY3Rpb24gZml4dHVy
ZS50ZXN0X3BsYXllcl9tb3Zlc19jb3JyZWN0bHkoKQogICAgbG9jYWwgaW5pdGlhbF94LCBpbml0
aWFsX3kgPSBwbGF5ZXIueCwgcGxheWVyLnkKICAgIGxvY2FsIGR4LCBkeSA9IDUsIDMKICAgIHBs
YXllci5tb3ZlKGR4LCBkeSkKICAgIGFzc2VydC5hcmVfZXF1YWwocGxheWVyLngsIGluaXRpYWxf
eCArIGR4LCAiUGxheWVyIHgtY29vcmRpbmF0ZSBzaG91bGQgdXBkYXRlIGNvcnJlY3RseSIpCiAg
ICBhc3NlcnQuYXJlX2VxdWFsKHBsYXllci55LCBpbml0aWFsX3kgKyBkeSwgIlBsYXllciB5LWNv
b3JkaW5hdGUgc2hvdWxkIHVwZGF0ZSBjb3JyZWN0bHkiKQplbmQKCmZ1bmN0aW9uIGZpeHR1cmUu
dGVzdF9wbGF5ZXJfdGFrZXNfZGFtYWdlX2NvcnJlY3RseSgpCiAgICBsb2NhbCBkYW1hZ2UgPSA0
MAogICAgbG9jYWwgaW5pdGlhbF9oZWFsdGggPSBwbGF5ZXIuaGVhbHRoCiAgICBwbGF5ZXIudGFr
ZV9kYW1hZ2UoZGFtYWdlKQogICAgYXNzZXJ0LmFyZV9lcXVhbChwbGF5ZXIuaGVhbHRoLCBpbml0
aWFsX2hlYWx0aCAtIGRhbWFnZSwgIlBsYXllciBoZWFsdGggc2hvdWxkIGRlY3JlYXNlIGJ5IHRo
ZSBkYW1hZ2UgYW1vdW50IikKZW5kCgpmdW5jdGlvbiBmaXh0dXJlLnRlc3RfcGxheWVyX2hlYWxp
bmdfbGltaXRzX3RvX21heGltdW0oKQogICAgcGxheWVyLnRha2VfZGFtYWdlKDUwKQogICAgbG9j
YWwgaGVhbF9hbW91bnQgPSA2MAogICAgcGxheWVyLmhlYWwoaGVhbF9hbW91bnQpCiAgICBhc3Nl
cnQuYXJlX2VxdWFsKHBsYXllci5oZWFsdGgsIDEwMCwgIlBsYXllciBoZWFsdGggc2hvdWxkIG5v
dCBleGNlZWQgMTAwIikKZW5kCgpyZXR1cm4gZml4dHVyZQpgYGAKCiMjIyMgVGVzdCBMaWZlY3lj
bGUgRGV0YWlscwoKMS4gKipgYmVmb3JlX2VhY2goKWAqKjogCiAgICBSZXNldHMgdGhlIHBsYXll
ciBzdGF0ZSBiZWZvcmUgZWFjaCB0ZXN0IGNhc2UuCgoyLiAqKlRlc3QgRnVuY3Rpb25zKio6CiAg
ICBFYWNoIHRlc3QgY2FzZSBjaGVja3Mgc3BlY2lmaWMgYmVoYXZpb3IsIHN1Y2ggYXMgcGxheWVy
IG1vdmVtZW50LCBoZWFsdGggbWFuYWdlbWVudCwgb3IgaW52ZW50b3J5IGhhbmRsaW5nLgoKMy4g
KipgYWZ0ZXJfZWFjaCgpYCoqOiAKICAgIENsZWFucyB1cCBhZnRlciBlYWNoIHRlc3QuCgo0LiAq
KkVycm9yIEhhbmRsaW5nKio6CiAgICBJZiBhIHRlc3QgZmFpbHMsIHRoZSBzeXN0ZW0gY2FwdHVy
ZXMgYW5kIGxvZ3MgdGhlIGVycm9yLCBjb250aW51aW5nIHRvIHRoZSBuZXh0IHRlc3QuCgojIyMj
IFJ1bm5pbmcgdGhlIFRlc3RzCgpSdW4gdGhlIHRlc3RzIHVzaW5nIGBydW5fdGVzdHMubHVhYC4g
VGhlIHN5c3RlbSB3aWxsIGV4ZWN1dGUgZWFjaCB0ZXN0IGNhc2UgYW5kIGxvZyB0aGUgcmVzdWx0
cy4KCmBgYApydW5fdGVzdHMubHVhCmBgYAoKIyMjIyBTYW1wbGUgVGVzdCBPdXRwdXQKCmBgYHBs
YWludGV4dApbSU5GT10gVGVzdCAndGVzdF9wbGF5ZXJfbW92ZXNfY29ycmVjdGx5JyBwYXNzZWQu
CltJTkZPXSBUZXN0ICd0ZXN0X3BsYXllcl90YWtlc19kYW1hZ2VfY29ycmVjdGx5JyBwYXNzZWQu
CltJTkZPXSBUZXN0ICd0ZXN0X3BsYXllcl9oZWFsaW5nX2xpbWl0c190b19tYXhpbXVtJyBwYXNz
ZWQuCmBgYAoKIyMgQXNzZXJ0aW9uIExpYnJhcnkKClRoZSBgYXNzZXJ0Lmx1YWAgbW9kdWxlIHBy
b3ZpZGVzIGN1c3RvbSBhc3NlcnRpb24gZnVuY3Rpb25zIHRvIGFzc2lzdCB3aXRoIHRlc3Rpbmcu
IEFzc2VydGlvbnMgYXJlIGNvbmRpdGlvbnMgdGhhdCBtdXN0IGJlIHRydWUgZHVyaW5nIHByb2dy
YW0gZXhlY3V0aW9uLCBhbmQgaWYgdGhleSBmYWlsLCB0aGUgcHJvZ3JhbSBoYWx0cyBhbmQgcmVw
b3J0cyBhbiBlcnJvci4KCjEuICoqQ29tcGFyaXNvbiBBc3NlcnRpb25zKio6CiAgICAtICoqYGFz
c2VydC5hcmVfZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSlgKio6IFZlcmlmaWVzIHRo
YXQgdHdvIHZhbHVlcyBhcmUgZXF1YWwuCiAgICAtICoqYGFzc2VydC5hcmVfbm90X2VxdWFsKGFj
dHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpYCoqOiBWZXJpZmllcyB0aGF0IHR3byB2YWx1ZXMgYXJl
IG5vdCBlcXVhbC4KICAgIC0gKipgYXNzZXJ0LmFyZV9lcXVhbF90YWJsZXMoYWN0dWFsLCBleHBl
Y3RlZCwgbWVzc2FnZSlgKio6IFZlcmlmaWVzIHRoYXQgdHdvIHRhYmxlcyBhcmUgZGVlcGx5IGVx
dWFsLgogICAgLSAqKmBhc3NlcnQuYXJlX2VxdWFsX3RhYmxlc19pZ25vcmVfbmlsKGFjdHVhbCwg
ZXhwZWN0ZWQsIG1lc3NhZ2UpYCoqOiBJZ25vcmVzIGBuaWxgIHZhbHVlcyBkdXJpbmcgdGFibGUg
Y29tcGFyaXNvbi4KCjIuICoqVHlwZSBhbmQgVmFsdWUgQXNzZXJ0aW9ucyoqOgogICAgLSAqKmBh
c3NlcnQuaXNfbmlsKHZhbHVlLCBtZXNzYWdlKWAqKjogRW5zdXJlcyB0aGF0IHRoZSB2YWx1ZSBp
cyBgbmlsYC4KICAgIC0gKipgYXNzZXJ0LmlzX25vdF9uaWwodmFsdWUsIG1lc3NhZ2UpYCoqOiBF
bnN1cmVzIHRoZSB2YWx1ZSBpcyBub3QgYG5pbGAuCiAgICAtICoqYGFzc2VydC5pc190eXBlKHZh
bHVlLCBleHBlY3RlZF90eXBlLCBtZXNzYWdlKWAqKjogRW5zdXJlcyB0aGF0IHRoZSB2YWx1ZSBp
cyBvZiBhIHNwZWNpZmljIHR5cGUuCiAgICAtICoqYGFzc2VydC5pc190cnVlKHZhbHVlLCBtZXNz
YWdlKWAqKjogRW5zdXJlcyB0aGUgdmFsdWUgaXMgYHRydWVgLgogICAgLSAqKmBhc3NlcnQuaXNf
ZmFsc2UodmFsdWUsIG1lc3NhZ2UpYCoqOiBFbnN1cmVzIHRoZSB2YWx1ZSBpcyBgZmFsc2VgLgoK
My4gKipOdW1iZXIgQ29tcGFyaXNvbnMqKjoKICAgIC0gKipgYXNzZXJ0LmlzX2dyZWF0ZXJfdGhh
bihhY3R1YWwsIHRocmVzaG9sZCwgbWVzc2FnZSlgKio6IEVuc3VyZXMgYSBudW1iZXIgaXMgZ3Jl
YXRlciB0aGFuIGEgZ2l2ZW4gdGhyZXNob2xkLgogICAgLSAqKmBhc3NlcnQuaXNfbGVzc190aGFu
KGFjdHVhbCwgdGhyZXNob2xkLCBtZXNzYWdlKWAqKjogRW5zdXJlcyBhIG51bWJlciBpcyBsZXNz
IHRoYW4gYSBnaXZlbiB0aHJlc2hvbGQuCgo0LiAqKlRhYmxlIEFzc2VydGlvbnMqKjoKICAgIC0g
KipgYXNzZXJ0LmNvbnRhaW5zKHRhYmxlLCB2YWx1ZSwgbWVzc2FnZSlgKio6IEVuc3VyZXMgYSB0
YWJsZSBjb250YWlucyBhIHNwZWNpZmljIHZhbHVlLgogICAgLSAqKmBhc3NlcnQuaGFzX2tleSh0
YWJsZSwga2V5LCBtZXNzYWdlKWAqKjogRW5zdXJlcyBhIHRhYmxlIGNvbnRhaW5zIGEgc3BlY2lm
aWMga2V5LgogICAgLSAqKmBhc3NlcnQuaGFzX2xlbmd0aCh0YWJsZSwgZXhwZWN0ZWRfbGVuZ3Ro
LCBtZXNzYWdlKWAqKjogRW5zdXJlcyBhIHRhYmxlIG9yIHN0cmluZyBoYXMgdGhlIGV4cGVjdGVk
IGxlbmd0aC4KCjUuICoqUGF0dGVybiBNYXRjaGluZyoqOgogICAgLSAqKmBhc3NlcnQubWF0Y2hl
c19wYXR0ZXJuKHZhbHVlLCBwYXR0ZXJuLCBtZXNzYWdlKWAqKjogRW5zdXJlcyB0aGF0IGEgc3Ry
aW5nIG1hdGNoZXMgYSBnaXZlbiBMdWEgcGF0dGVybi4KCiMjIyBQcmFjdGljYWwgQXNzZXJ0aW9u
IEV4YW1wbGVzCgpJbiB1bml0IHRlc3RpbmcsIGFzc2VydGlvbnMgdmVyaWZ5IHRoYXQgZnVuY3Rp
b25zIGJlaGF2ZSBhcyBleHBlY3RlZC4gSGVyZeKAmXMgYSBzaW1wbGUgZXhhbXBsZToKCmBgYGx1
YQpsb2NhbCBhc3NlcnQgPSByZXF1aXJlKCJhc3NlcnQiKQoKbG9jYWwgcGxheWVyID0geyBoZWFs
dGggPSAxMDAgfQoKYXNzZXJ0LmFyZV9lcXVhbChwbGF5ZXIuaGVhbHRoLCAxMDAsICJQbGF5ZXIg
aGVhbHRoIHNob3VsZCBzdGFydCBhdCAxMDAiKQoKcGxheWVyLmhlYWx0aCA9IHBsYXllci5oZWFs
dGggLSAyMAphc3NlcnQuaXNfZ3JlYXRlcl90aGFuKHBsYXllci5oZWFsdGgsIDAsICJQbGF5ZXIg
c2hvdWxkIGhhdmUgaGVhbHRoIGFmdGVyIGRhbWFnZSIpCgpwbGF5ZXIuaGVhbHRoID0gcGxheWVy
LmhlYWx0aCAtIDkwCmFzc2VydC5pc19ncmVhdGVyX3RoYW4ocGxheWVyLmhlYWx0aCwgMCwgIlBs
YXllciBoZWFsdGggc2hvdWxkIG5vdCBnbyBiZWxvdyB6ZXJvIikKYGBgCgojIyMgRXJyb3IgSGFu
ZGxpbmcgaW4gQXNzZXJ0aW9ucwoKSWYgYW4gYXNzZXJ0aW9uIGZhaWxzLCBhbiBlcnJvciBtZXNz
YWdlIGlzIHRocm93biBhbmQgdGhlIHByb2dyYW0gaGFsdHMuCgpFeGFtcGxlIGVycm9yIG1lc3Nh
Z2UgZm9yIGEgZmFpbGVkIGBhcmVfZXF1YWxgIGFzc2VydGlvbjoKCmBgYApBc3NlcnRpb24gZmFp
bGVkOiBleHBlY3RlZCAnMTAwJywgZ290ICc5MCcKYGBgCgojIyBDb250cmlidXRpbmcKCldlIHdl
bGNvbWUgY29udHJpYnV0aW9ucyB0byB0aGUgUGljb3Ryb24gR2FtZSBUZW1wbGF0ZSEgV2hldGhl
ciB5b3Ugd2FudCB0byBpbXByb3ZlIGV4aXN0aW5nIGZlYXR1cmVzLCBhZGQgbmV3IG9uZXMsIG9y
IGZpeCBidWdzLCB5b3VyIGhlbHAgaXMgZ3JlYXRseSBhcHByZWNpYXRlZC4gVG8gY29udHJpYnV0
ZSwgcGxlYXNlIGZvbGxvdyB0aGVzZSBzdGVwczoKCiMjIyBIb3cgdG8gQ29udHJpYnV0ZQoKMS4g
KipGb3JrIHRoZSBSZXBvc2l0b3J5Kio6CiAgICBGb3JrIHRoaXMgcmVwb3NpdG9yeSB0byB5b3Vy
IEdpdEh1YiBhY2NvdW50IGJ5IGNsaWNraW5nIHRoZSAiRm9yayIgYnV0dG9uIGF0IHRoZSB0b3Ag
b2YgdGhlIHBhZ2UuCgoyLiAqKkNsb25lIFlvdXIgRm9yayoqOgogICAgQ2xvbmUgdGhlIGZvcmtl
ZCByZXBvc2l0b3J5IHRvIHlvdXIgbG9jYWwgbWFjaGluZToKICAgIAogICAgYGBgYmFzaAogICAg
Z2l0IGNsb25lIGh0dHBzOi8vZ2l0aHViLmNvbS95b3VydXNlcm5hbWUvcGljb3Ryb24tZ2FtZS10
ZW1wbGF0ZS5naXQKICAgIGBgYAoKMy4gKipDcmVhdGUgYSBOZXcgQnJhbmNoKio6CiAgICBDcmVh
dGUgYSBuZXcgYnJhbmNoIGZvciB5b3VyIGZlYXR1cmUgb3IgYnVnIGZpeDoKICAgIAogICAgYGBg
YmFzaAogICAgZ2l0IGNoZWNrb3V0IC1iIG15LW5ldy1mZWF0dXJlCiAgICBgYGAKCjQuICoqTWFr
ZSBZb3VyIENoYW5nZXMqKjoKICAgIEltcGxlbWVudCB5b3VyIGZlYXR1cmUsIGJ1ZyBmaXgsIG9y
IGltcHJvdmVtZW50LiBCZSBzdXJlIHRvIHdyaXRlIGNsZWFyLCBjb25jaXNlLCBhbmQgd2VsbC1k
b2N1bWVudGVkIGNvZGUuIEVuc3VyZSB0aGF0IHlvdXIgY2hhbmdlcyBkbyBub3QgYnJlYWsgZXhp
c3RpbmcgZnVuY3Rpb25hbGl0eSBieSBydW5uaW5nIHRoZSB1bml0IHRlc3RzLgoKNS4gKipUZXN0
IFlvdXIgQ2hhbmdlcyoqOgogICAgQmVmb3JlIHN1Ym1pdHRpbmcgeW91ciBjaGFuZ2VzLCBydW4g
YWxsIHRlc3RzIHRvIGVuc3VyZSB0aGF0IGV2ZXJ5dGhpbmcgaXMgd29ya2luZyBhcyBleHBlY3Rl
ZDoKICAgIAogICAgYGBgYmFzaAogICAgcnVuX3Rlc3RzLmx1YQogICAgYGBgCgo2LiAqKkNvbW1p
dCBhbmQgUHVzaCoqOgogICAgT25jZSB5b3UncmUgc2F0aXNmaWVkIHdpdGggeW91ciBjaGFuZ2Vz
LCBjb21taXQgeW91ciB3b3JrIHdpdGggYSBkZXNjcmlwdGl2ZSBtZXNzYWdlIGFuZCBwdXNoIGl0
IHRvIHlvdXIgZm9yazoKICAgIAogICAgYGBgYmFzaAogICAgZ2l0IGFkZCAuCiAgICBnaXQgY29t
bWl0IC1tICJBZGQgbXkgZmVhdHVyZSBvciBmaXggYSBidWciCiAgICBnaXQgcHVzaCBvcmlnaW4g
bXktbmV3LWZlYXR1cmUKICAgIGBgYAoKNy4gKipTdWJtaXQgYSBQdWxsIFJlcXVlc3QqKjoKICAg
IE9wZW4gYSBwdWxsIHJlcXVlc3QgZnJvbSB5b3VyIGZvcmsgYmFjayB0byB0aGUgbWFpbiByZXBv
c2l0b3J5LiBQcm92aWRlIGEgY2xlYXIgZXhwbGFuYXRpb24gb2YgeW91ciBjaGFuZ2VzIGFuZCB3
aHkgdGhleSBzaG91bGQgYmUgbWVyZ2VkLgoKIyMjIENvbnRyaWJ1dGlvbiBHdWlkZWxpbmVzCgot
ICoqRm9sbG93IHRoZSBFeGlzdGluZyBDb2RlIFN0eWxlKio6IEVuc3VyZSB0aGF0IHlvdXIgY29k
ZSBtYXRjaGVzIHRoZSBzdHlsZSBhbmQgY29udmVudGlvbnMgdXNlZCBpbiB0aGUgcmVzdCBvZiB0
aGUgcHJvamVjdC4KLSAqKldyaXRlIFRlc3RzKio6IElmIGFwcGxpY2FibGUsIGFkZCB1bml0IHRl
c3RzIGZvciBuZXcgZmVhdHVyZXMgb3IgYnVnIGZpeGVzLgotICoqS2VlcCBJdCBNb2R1bGFyKio6
IEVuc3VyZSB5b3VyIGNoYW5nZXMgYXJlIHdlbGwtc3RydWN0dXJlZCBhbmQgbWFpbnRhaW5hYmxl
LCBhZGhlcmluZyB0byB0aGUgbW9kdWxhciBuYXR1cmUgb2YgdGhlIHByb2plY3QuCi0gKipEb2N1
bWVudCBZb3VyIENoYW5nZXMqKjogVXBkYXRlIHJlbGV2YW50IHNlY3Rpb25zIG9mIHRoZSBSRUFE
TUUgYW5kIGFkZCBjb21tZW50cyB0byB0aGUgY29kZSB3aGVyZSBuZWNlc3NhcnkgdG8gaGVscCBv
dGhlcnMgdW5kZXJzdGFuZCB5b3VyIGNvbnRyaWJ1dGlvbi4KCiMjIyBSZXBvcnRpbmcgSXNzdWVz
CgpJZiB5b3UgZmluZCBhIGJ1ZyBvciBoYXZlIHN1Z2dlc3Rpb25zIGZvciBpbXByb3ZlbWVudHMs
IGZlZWwgZnJlZSB0byBvcGVuIGFuIGlzc3VlIG9uIEdpdEh1Yi4gUGxlYXNlIHByb3ZpZGUgZGV0
YWlsZWQgaW5mb3JtYXRpb24gdG8gaGVscCB1cyB1bmRlcnN0YW5kIHRoZSBpc3N1ZSBvciB5b3Vy
IHByb3Bvc2FsLgoKV2UgbG9vayBmb3J3YXJkIHRvIHlvdXIgY29udHJpYnV0aW9ucyEKCiMjIExp
Y2Vuc2UKClRoaXMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgR05VIEdlbmVyYWwgUHVi
bGljIExpY2Vuc2UgdjMuMC4gU2VlIHRoZSBgTElDRU5TRWAgZmlsZSBmb3IgbW9yZSBkZXRhaWxz
LgoKIyMgQWRkaXRpb25hbCBSZXNvdXJjZXMKCi0gW1BpY290cm9uIE1hbnVhbF0oaHR0cHM6Ly93
d3cubGV4YWxvZmZsZS5jb20vZGwvZG9jcy9waWNvdHJvbl9tYW51YWwuaHRtbCkK
:: src/docs/README.md
b64$ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICANCuKWkeKWiOKWgOKWiOKWkeKWiOKWgOKWiOKWkeKWiOKWgOKWiOKWkeKWiOKW
gOKWhOKWkeKWiOKWgOKWiOKWkeKWiOKWkeKWiA0K4paR4paI4paR4paI4paR4paI4paR4paI4paR
4paI4paR4paI4paR4paI4paA4paE4paR4paI4paR4paI4paR4paR4paI4paRDQrilpHiloDilpHi
loDilpHiloDiloDiloDilpHiloDilpHiloDilpHiloDiloDilpHilpHiloDiloDiloDilpHilpHi
loDilpEgICANCg0K44OA44Oz44K444On44Oz44Kv44Ot44Km44OpDQpQaWNvdHJvbiBFbmdpbmUN
Cg0KLS0tDQoNCiMjIFRhYmxlIG9mIENvbnRlbnRzDQoNCjEuIFtPdmVydmlld10oI292ZXJ2aWV3
KQ0KMi4gW0FyY2hpdGVjdHVyZV0oI2FyY2hpdGVjdHVyZSkNCjMuIFtDb3JlIFN5c3RlbXNdKCNj
b3JlLXN5c3RlbXMpDQo0LiBbQ29uZmlndXJhdGlvbl0oI2NvbmZpZ3VyYXRpb24pDQo1LiBbUGVy
Zm9ybWFuY2UgQ2hhcmFjdGVyaXN0aWNzXSgjcGVyZm9ybWFuY2UtY2hhcmFjdGVyaXN0aWNzKQ0K
Ni4gW0ZpbGUgU3RydWN0dXJlXSgjZmlsZS1zdHJ1Y3R1cmUpDQo3LiBbVGVjaG5pY2FsIERldGFp
bHNdKCN0ZWNobmljYWwtZGV0YWlscykNCjguIFtEZXZlbG9wbWVudCAmIERlYnVnZ2luZ10oI2Rl
dmVsb3BtZW50LS1kZWJ1Z2dpbmcpDQoNCi0tLQ0KDQojIyBPdmVydmlldw0KDQpUaGUgTk9OQk9Z
IOODgOODs_OCuOODp_ODs_OCr_ODreOCpuODqSBFbmdpbmUgYWltcyB0byBiZSBhIGNvbXBsZXRl
IDNEIGdhbWUgZW5naW5lIGJ1aWx0IG9uIHJheWNhc3RpbmcgcHJpbmNpcGxlcywgb3B0aW1pemVk
IGZvciBMZXhhbG9mZmxlIFBpY290cm9uLiBGZWF0dXJpbmc6DQoNCi0gKipEZWNvdXBsZWQgcmF5
X2NvdW50IGFyY2hpdGVjdHVyZSoqIC0gSW5kZXBlbmRlbnQgcmF5IGNvdW50IGZyb20gc2NyZWVu
IHJlc29sdXRpb24gZm9yIGZsZXhpYmxlIHBlcmZvcm1hbmNlIHR1bmluZw0KLSAqKlVuaWZpZWQg
Zm9nIHN5c3RlbSoqIC0gU2luZ2xlIGxpbmVhciBmb2cgbW9kZWwgd2l0aCAxNiBsZXZlbHMgYW5k
IGh5c3RlcmVzaXMgb3B0aW1pemF0aW9uDQotICoqQWR2YW5jZWQgTE9EKiogLSBGb2ctZHJpdmVu
IGxldmVsLW9mLWRldGFpbCBmb3Igd2FsbHMgYW5kIHNwcml0ZXMNCi0gKipQZXItY29sdW1uIGRl
cHRoIGJ1ZmZlcioqIC0gQWNjdXJhdGUgc3ByaXRlIG9jY2x1c2lvbiB3aXRoIG9uZSB6IHBlciBz
Y3JlZW4gY29sdW1uDQotICoqRnJ1c3R1bS1iYXNlZCBjdWxsaW5nKiogLSBHZW9tZXRyaWMgc3By
aXRlIGN1bGxpbmcgaW5kZXBlbmRlbnQgb2Ygd2FsbCBoaXRzDQotICoqRGVwdGgtYnVja2V0IHNv
cnRpbmcqKiAtIE8obikgc3ByaXRlIHNvcnRpbmcgd2l0aCAxNiBkZXB0aCBidWNrZXRzDQotICoq
UGVyLWNlbGwgZmxvb3IgcmVuZGVyaW5nKiogLSBNdWx0aS10ZXh0dXJlIGZsb29ycyB3aXRoIHJ1
biBkZXRlY3Rpb24gYW5kIG1lcmdpbmcNCi0gKipDb21wcmVoZW5zaXZlIGRpYWdub3N0aWNzKiog
LSBSZWFsLXRpbWUgcGVyZm9ybWFuY2UgbW9uaXRvcmluZyBhbmQgbG9nZ2luZw0KLSAqKkJhdGNo
ZWQgcmVuZGVyaW5nKiogLSBCYXRjaCB0bGluZTNkIGNhbGxzIGZvciBmbG9vcnMsIHdhbGxzLCBh
bmQgc3ByaXRlcyB0byBtaW5pbWl6ZSBMdWEgY2FsbCBvdmVyaGVhZA0KLSAqKkFsbG9jYXRpb24t
ZnJlZSBmbG9vciBydW5zKiogLSBQcmVhbGxvY2F0ZWQgdXNlcmRhdGEgYnVmZmVycyBmb3IgcGVy
LWNlbGwgZmxvb3Igc2VnbWVudGF0aW9uIChubyBwZXItZnJhbWUgdGFibGVzKQ0KLSAqKk9wdGlt
aXplZCBmb2cvei1idWZmZXIqKiAtIERpc3BsYXkgcGFsZXR0ZSBmb2cgdXBkYXRlcyB3aXRoIGh5
c3RlcmVzaXMgYW5kIGEgZnJhbWXigJFzdGFtcGVkIHotYnVmZmVyIChubyBwZXItZnJhbWUgY2xl
YXIpDQotICoqQWRhcHRpdmUgcXVhbGl0eSBnb3Zlcm5vcioqIC0gYHN0YXQoMSlgLWRyaXZlbiBk
eW5hbWljIHJheSBidWRnZXQgYW5kIGZsb29yIHN0cmlkZSBmb3Igc3RlYWRpZXIgRlBTDQotICoq
SW50ZWdyYXRlZCBkdW5nZW9uIGxhYioqIC0gTWFpbiBtZW51IHJvdXRlIHRvIGluc3BlY3QgZHVu
Z2VvbiBncmFwaHMsIHJldmlldyBnZW5lcmF0aW9uIGxvZ3MsIGFuZCBydW4gZGV0ZXJtaW5pc3Rp
YyBoYXJuZXNzIGNoZWNrcw0KDQoqKlRhcmdldCBQZXJmb3JtYW5jZSoqOiA1MC02MCBGUFMgaW4g
dHlwaWNhbCBzY2VuZXMgKDEyOCByYXlzLCBzdHJpZGU9MSwgTE9EIGVuYWJsZWQpDQoNCi0tLQ0K
DQojIyBBcmNoaXRlY3R1cmUNCg0KIyMjIEhpZ2gtTGV2ZWwgRGF0YSBGbG93DQoNCmBgYG1lcm1h
aWQNCmZsb3djaGFydCBURA0KICBJW0luaXRpYWxpemF0aW9uIChfaW5pdCldIC0tPiBVW1VwZGF0
ZSBMb29wIChfdXBkYXRlKV0NCiAgVSAtLT58SW5wdXR8IE1bTW92ZW1lbnQgJiBDb2xsaXNpb25d
DQogIFUgLS0_fERvb3JzfCBEW0Rvb3IgVXBkYXRlc10NCiAgVSAtLT58QUl8IEFbQUkgKHJhdGUt
bGltaXRlZCldDQogIFUgLS0_IFJbUmVuZGVyIExvb3AgKF9kcmF3KV0NCiAgUiAtLT4gUFtQcmVj
b21wdXRlXG7igKIgQ2FjaGUgc2luL2NvcyDigKIgQ29tcHV0ZSBzcGFucyDigKIgei1zdGFtcCAo
bm8gY2xlYXIpXQ0KICBSIC0tPiBSQ1tSYXljYXN0IFBoYXNlIChyYXljYXN0X3NjZW5lKVxu4oCi
IENhc3QgcmF5cyDigKIgRmlsbCByYXlfei9yYnVmIOKAoiBGcnVzdHVtIEFBQkJdDQogIFIgLS0_
IEZbRmxvb3IvQ2VpbGluZ1xu4oCiIFN0cmlkZSByb3dzIOKAoiBQZXItY2VsbCBmbG9vciBydW5z
IOKAoiBVbmlmaWVkIGZvZ10NCiAgUiAtLT4gV1tXYWxsc1xu4oCiIFNwYW4tYmFzZWQg4oCiIFBl
ci1jb2x1bW4gemJ1ZiDigKIgTE9EIGJleW9uZCAxNC4wIOKAoiBVLWludGVycF0NCiAgUiAtLT4g
U1tTcHJpdGVzXG7igKIgRnJ1c3R1bStvYmpncmlkIGN1bGwg4oCiIDE2IGRlcHRoIGJ1Y2tldHMg
4oCiIFotdGVzdCDigKIgTE9EXQ0KICBSIC0tPiBIW0hVRCAmIERpYWdub3N0aWNzXG7igKIgU3Rh
dHMg4oCiIFByb21wdHMg4oCiIE1pbmltYXAg4oCiIFNpbmdsZSBwYWwoKSByZXN0b3JlXQ0KICBj
bGFzc0RlZiBib3ggZmlsbDojMTExLHN0cm9rZTojNjY2LGNvbG9yOiNkZGQ7DQogIGNsYXNzIEks
VSxSLFAsUkMsRixXLFMsSCxNLEQsQSBib3g7DQpgYGANCg0KIyMjIEtleSBBcmNoaXRlY3R1cmFs
IFByaW5jaXBsZXMNCg0KMS4gKipTaW5nbGUgU291cmNlIG9mIFRydXRoKio6IEFsbCBjb25maWd1
cmF0aW9uIGluIGBzcmMvY29uZmlnLmx1YWANCjIuICoqRGF0YS1Ecml2ZW4qKjogTm8gaGFyZGNv
ZGVkIGNvbnN0YW50czsgYWxsIHN5c3RlbXMgcmVhZCBmcm9tIGNvbmZpZw0KMy4gKipMb2Nrc3Rl
cCBFeGVjdXRpb24qKjogQ2xlYXIgaW5wdXQvb3V0cHV0IGNvbnRyYWN0cyBiZXR3ZWVuIHN5c3Rl
bXMNCjQuICoqUGVyZm9ybWFuY2UgQnVkZ2V0cyoqOiBCb3VuZGVkIHdvcnN0LWNhc2Ugd29yayB2
aWEgRERBIGd1YXJkcywgTE9ELCBzdHJpZGUNCjUuICoqRGlhZ25vc3RpYy1GaXJzdCoqOiBDb21w
cmVoZW5zaXZlIGluc3RydW1lbnRhdGlvbiBmb3IgZGF0YS1kcml2ZW4gb3B0aW1pemF0aW9uDQoN
Ci0tLQ0KDQojIyBDb3JlIFN5c3RlbXMNCg0KIyMjIDEuIFJheWNhc3RpbmcgU3lzdGVtIChgc3Jj
L3JheWNhc3QubHVhYCkNCg0KKipQdXJwb3NlKio6IENhc3QgcmF5cyBpbnRvIHRoZSB3b3JsZCB0
byBkZXRlcm1pbmUgdmlzaWJsZSBnZW9tZXRyeSBhbmQgZGVwdGhzLg0KDQpUaGUgcmF5Y2FzdGVy
IHVzZXMgYSBndWFyZGVkIEREQSB3aXRoIGR1YWwgc3RlcHBpbmcgYW5kIHN0cmljdCBlYXJseS1v
dXRzIHRvIGJvdW5kIHdvcmsgcGVyIHJheS4gUGVyLXJheSBzY3JlZW4gc3BhbnMgYXJlIGRlY291
cGxlZCBmcm9tIHJlc29sdXRpb24sIGFuZCBhIGdlb21ldHJpYyBmcnVzdHVtIEFBQkIgaXMgY29t
cHV0ZWQgaW5kZXBlbmRlbnRseSBvZiB3YWxsIGhpdHMgc28gc3ByaXRlIGN1bGxpbmcgcmVtYWlu
cyByb2J1c3QgaW4gb3BlbiBhcmVhcy4NCg0KKipLZXkgRnVuY3Rpb25zKio6DQotIGByYXljYXN0
KHgsIHksIGR4LCBkeSwgZngsIGZ5KWAgLSBEREEgcmF5Y2FzdGluZyB3aXRoIGRvb3Igc3VwcG9y
dA0KLSBgcmF5Y2FzdF9zY2VuZSgpYCAtIENhc3QgYWxsIHJheXMsIGNvbXB1dGUgc3BhbnMsIGJ1
aWxkIGZydXN0dW0gQUFCQg0KLSBgY29tcHV0ZV9mcnVzdHVtX2FhYmIoKWAgLSBHZW9tZXRyaWMg
ZnJ1c3R1bSBmb3Igc3ByaXRlIGN1bGxpbmcNCi0gYGhpdHNjYW4oeCwgeSwgZHgsIGR5KWAgLSBM
aW5lLW9mLXNpZ2h0IGZvciBwcm9qZWN0aWxlcy9BSQ0KDQoqKkREQSBHdWFyZHMqKjoNCjEuICoq
RmFyLXBsYW5lIGNoZWNrKio6IEVhcmx5LW91dCB3aGVuIGB6ID4gZmFyX3BsYW5lYCAoMjUuMCB1
bml0cykNCjIuICoqSXJyZXZlcnNpYmxlIE9PQioqOiBEZXRlY3QgcmF5cyBtb3ZpbmcgYXdheSBm
cm9tIG1hcCBib3VuZHMNCjMuICoqSXRlcmF0aW9uIGNhcCoqOiBHZW9tZXRyaWMgbGltaXQgYmFz
ZWQgb24gcmVtYWluaW5nIGdyaWQgY3Jvc3NpbmdzDQrigJQgV2hhdDogUHJldmVudHMgdW5ib3Vu
ZGVkIEREQSBzdGVwcyBhbmQgb2ZmLW1hcCB0cmF2ZXJzYWwuICANCuKAlCBIb3c6IENvbXBhcmUg
YG1pbihoeiwgdnopYCB0byBgZmFyX3BsYW5lYCwgdGVzdCBzdGVwIGRpcmVjdGlvbiB2cyBib3Vu
ZHMsIGNhcCBieSBjcm9zc2luZ3MuICANCuKAlCBXaHk6IFN0YWJpbGl6ZXMgZnJhbWUgdGltZSBp
biB3b3JzdC1jYXNlIGxheW91dHMuDQoNCioqUGVyLVJheSBTcGFuIENvbXB1dGF0aW9uKio6DQpg
YGBsdWENCnJheV94MFtpXSA9IGZscihpICogc2NyZWVuX3dpZHRoIC8gcmF5X2NvdW50KQ0KcmF5
X3gxW2ldID0gbWF4KHJheV94MFtpXSwgZmxyKChpKzEpICogc2NyZWVuX3dpZHRoIC8gcmF5X2Nv
dW50KSAtIDEpDQpgYGANClRoaXMgZGVjb3VwbGVzIGByYXlfY291bnRgICgxMjgpIGZyb20gYHNj
cmVlbl93aWR0aGAgKDQ4MCksIGFsbG93aW5nIGFyYml0cmFyeSByYXkgY291bnRzLg0K4oCUIFdo
YXQ6IEFzc2lnbnMgZWFjaCByYXkgYSBjb250aWd1b3VzIHBpeGVsIHNwYW4uICANCuKAlCBIb3c6
IFByb3BvcnRpb25hbCBzbGljaW5nIGVuc3VyZXMgbm8gZ2FwcyBldmVuIHdoZW4gY291bnRzIGRp
ZmZlci4gIA0K4oCUIFdoeTogVHVuYWJsZSBwZXJmb3JtYW5jZSBpbmRlcGVuZGVudCBvZiByZXNv
bHV0aW9uLg0KDQoqKkZydXN0dW0gQUFCQioqOg0KLSBDb21wdXRlcyA0IGZydXN0dW0gY29ybmVy
cyBhdCBgZmFyX3BsYW5lYCBkaXN0YW5jZQ0KLSBUcmFuc2Zvcm1zIHRvIHdvcmxkIHNwYWNlIHVz
aW5nIGNhbWVyYSBiYXNpcw0KLSBQcm92aWRlcyBpbmRlcGVuZGVudCBzcHJpdGUgY3VsbGluZyBi
b3VuZHMgKG5vdCB3YWxsLWhpdC1kZXBlbmRlbnQpDQrigJQgV2hhdDogR2VvbWV0cnktb25seSB2
aXNpYmlsaXR5IGJvdW5kcyBmb3Igc3ByaXRlcy4gIA0K4oCUIEhvdzogQnVpbGQgZmFyLXBsYW5l
IHdlZGdlOyB0cmFuc2Zvcm0gdmlhIGNhbWVyYSBiYXNpcy4gIA0K4oCUIFdoeTogS2VlcHMgc3By
aXRlIGN1bGxpbmcgdmFsaWQgd2hlbiB3YWxsIGhpdHMgYXJlIHNwYXJzZS4NCg0KKipPdXRwdXRz
Kio6DQotIGByYXlfelswLi4xMjddYCAtIFBlci1yYXkgZGVwdGhzICg5OTkgPSBtaXNzKQ0KLSBg
cmJ1ZlswLi4xMjddYCAtIFBlci1yYXkgaGl0IGRhdGEgKHRpbGUsIHR4KQ0KLSBgcmF5X3gwL3gx
WzAuLjEyN11gIC0gUGVyLXJheSBzY3JlZW4gc3BhbnMNCi0gYGZydXN0dW1fbWlueC9tYXh4L21p
bnkvbWF4eWAgLSBTcHJpdGUgY3VsbGluZyBBQUJCDQoNCi0tLQ0KDQojIyMgMi4gUmVuZGVyaW5n
IFN5c3RlbSAoYHNyYy9yZW5kZXIubHVhYCkNCg0KKipQdXJwb3NlKio6IFRyYW5zZm9ybSByYXlj
YXN0IGRhdGEgaW50byAzRCB2aXN1YWxzIHdpdGggZm9nLCBMT0QsIGFuZCBwZXItcGl4ZWwgZGVw
dGguDQoNClRoZSByZW5kZXJlciBtaW5pbWl6ZXMgb3ZlcmRyYXcgYW5kIHN0YXRlIGNodXJuIHZp
YSBoeXN0ZXJlc2lzLWRyaXZlbiBmb2csIHNwYW4tYmFzZWQgd2FsbCB3cml0ZXMgdG8gYSBwZXIt
cGl4ZWwgei1idWZmZXIsIHN0cmlkZSByZW5kZXJpbmcgZm9yIGZsb29ycy9jZWlsaW5ncywgYW5k
IHNvbGlkLWNvbG9yIGltcG9zdG9ycyBmb3IgZGlzdGFudCBnZW9tZXRyeSB1c2luZyBjYWNoZWQg
YXZlcmFnZSB0ZXh0dXJlIGNvbG9ycy4gQmF0Y2hlZCBgdGxpbmUzZGAgYWNjZXB0cyBwZXItcm93
IGZsYWdzIChlLmcuLCBgMHg0MDBgIGZvciBuZWFyLW9ubHkgaGlnaC1xdWFsaXR5KSwgYW5kIGEg
ZnJhbWXigJFzdGFtcGVkIHotYnVmZmVyIGF2b2lkcyBwZXItZnJhbWUgY2xlYXJzLg0KDQojIyMj
IEJhdGNoZWQgRHJhdyBTdWJtaXNzaW9uDQoNCi0gRmxvb3JzOiBQZXItc2NhbmxpbmUgdGxpbmUz
ZCBjYWxscyBhcmUgYmF0Y2hlZCBpbnRvIGEgc2luZ2xlIHN1Ym1pc3Npb24gdXNpbmcgYW4gZjY0
IHVzZXJkYXRhIGJ1ZmZlci4gUGVyLWNlbGwgZmxvb3IgcnVucyAod2hlbiBlbmFibGVkKSBhcmUg
YWxzbyBiYXRjaGVkIGludG8gb25lIHN1Ym1pdCBwZXIgc2NhbmxpbmUuDQotIFdhbGxzOiBQZXIt
Y29sdW1uIHdhbGwgZHJhd3MgaW4gdGhlIOKAnGV4cGVuc2l2ZSBwYXRo4oCdIGFyZSBwdXNoZWQg
aW50byBvbmUgYmF0Y2hlZCB0bGluZTNkIHN1Ym1pdCBwZXIgcmF5IHNwYW47IGJhdGNoIHJvd3Mg
aW5jbHVkZSBhIGBmbGFnc2AgZmllbGQuDQotIFNwcml0ZXM6IFBlci1jb2x1bW4gc3ByaXRlIGRy
YXdzIGFyZSBiYXRjaGVkIGludG8gYSBzaW5nbGUgc3VibWl0IHBlciBzcHJpdGUgd2hlbiB2aXNp
YmxlIGNvbHVtbnMgYXJlIHByZXNlbnQuDQrigJQgV2hhdDogQ29sbGFwc2UgbWFueSBkcmF3IGNh
bGxzIGludG8gYSBzaW5nbGUgYmF0Y2hlZCBjYWxsIHBlciBzY2FubGluZS9zcGFuL29iamVjdC4g
IA0K4oCUIFdoeTogRHJhbWF0aWNhbGx5IHJlZHVjZXMgTHVhIGNhbGwgb3ZlcmhlYWQgd2hpbGUg
cHJlc2VydmluZyB2aXN1YWxzLg0KDQojIyMjIEFsbG9jYXRpb24tRnJlZSBGbG9vciBSdW5zDQoN
Ci0gUGVyLWNlbGwgZmxvb3IgcnVuIHNlZ21lbnRhdGlvbiB1c2VzIHByZWFsbG9jYXRlZCB1c2Vy
ZGF0YSgiaTE2IikgYnVmZmVycyBmb3IgeDAveDEvZmxvb3JfaWQgYW5kIG1lcmdlZCBydW5zIHRv
IGF2b2lkIHBlci1mcmFtZSB0YWJsZSBhbGxvY2F0aW9uIGFuZCBHQyBjaHVybi4NCuKAlCBXaGF0
OiBSdW4gZGV0ZWN0aW9uIHdpdGhvdXQgTHVhIHRhYmxlIGNodXJuLiAgDQrigJQgV2h5OiBTdGFi
aWxpemVzIGZyYW1lIHRpbWUgaW5kZXBlbmRlbnQgb2Ygc2NlbmUgZGVuc2l0eS4NCg0KIyMjIyBV
bmlmaWVkIEZvZyBNYW5hZ2VyDQoNCioqU2luZ2xlIExpbmVhciBGb3JtdWxhKio6DQpgYGBsdWEN
CmZvZ19sZXZlbCA9IGZscihjbGFtcCgoeiAtIGZvZ19uZWFyKSAvIChmb2dfZmFyIC0gZm9nX25l
YXIpLCAwLCAxKSAqIDE1KQ0KYGBgDQotIDE2IGZvZyBsZXZlbHMgKDAtMTUpIG1hcHBpbmcgdG8g
YHBhbHNgIGFycmF5DQotIGBmb2dfbmVhcj01LjBgLCBgZm9nX2Zhcj0yMC4wYCBmcm9tIGNvbmZp
Zw0KLSBIeXN0ZXJlc2lzOiBPbmx5IHVwZGF0ZSB3aGVuIGB6YCBjaGFuZ2VzIGJ5IGBmb2dfaHlz
dGVyZXNpc2AgKDAuNSkNCuKAlCBXaGF0OiBEaXN0YW5jZS1iYXNlZCBwYWxldHRlIHJlbWFwLiAg
DQrigJQgSG93OiBDb21wdXRlIGxldmVsIDAuLjE1OyBhcHBseSBvbmx5IGNoYW5nZWQgZW50cmll
cyB0byByZWR1Y2UgYHBhbCgpYCBjYWxscy4gIA0K4oCUIFdoeTogQXZvaWRzIHBhbGV0dGUgdGhy
YXNoaW5nIHdoaWxlIGtlZXBpbmcgZm9nIHNtb290aC4NCg0KKipJbmNyZW1lbnRhbCBQYWxldHRl
IFVwZGF0ZXMqKjoNCmBgYGx1YQ0KZm9yIGk9MCw2MyBkbw0KICBpZiBwW2krMV0gfj0gcHJldl9w
YWxbaV0gdGhlbg0KICAgIHBhbChpLCBwW2krMV0pICAtLSBPbmx5IHVwZGF0ZSBjaGFuZ2VkIGNv
bG9ycw0KICBlbmQNCmVuZA0KYGBgDQpSZWR1Y2VzIHBhbGV0dGUgb3BlcmF0aW9ucyBmcm9tIH4z
MjAvZnJhbWUgdG8gfjEwLTIwL2ZyYW1lLg0KDQoqKlNpbmdsZSBGcmFtZS1FbmQgUmVzdG9yZSoq
Og0KLSBObyBtaWQtc2VjdGlvbiBgcGFsKClgIHJlc2V0cw0KLSBTaW5nbGUgYHBhbCgpYCBjYWxs
IGF0IGVuZCBvZiBgX2RyYXcoKWANCuKAlCBXaGF0OiBPbmUgcmVzdG9yZSBwZXIgZnJhbWUuICAN
CuKAlCBIb3c6IERlZmVyIGdsb2JhbCBgcGFsKClgIHJlc2V0IHRvIGBfZHJhdygpYCBlbmQuICAN
CuKAlCBXaHk6IEtlZXBzIHNlY3Rpb25zIGlzb2xhdGVkIGFuZCBjaGVhcGVyLg0KDQojIyMjIFdh
bGwgUmVuZGVyaW5nDQoNCioqU3Bhbi1CYXNlZCBBcmNoaXRlY3R1cmUqKjoNCmBgYGx1YQ0KZm9y
IHJheV9pZHg9MCwgcmF5X2NvdW50LTEgZG8NCiAgbG9jYWwgeiA9IHJheV96W3JheV9pZHhdDQog
IGxvY2FsIHgwID0gcmF5X3gwW3JheV9pZHhdDQogIGxvY2FsIHgxID0gcmF5X3gxW3JheV9pZHhd
DQoNCiAgbG9jYWwgZHUgPSAodTEtdTApLyh4MS14MCswLjAxKSAgLS0gcHJlY29tcHV0ZQ0KICBs
b2NhbCB1ID0gdTANCiAgbG9jYWwgZmxhZ3MgPSAoeiA8PSBuZWFyX3RocmVzaG9sZCkgYW5kIDB4
NDAwIG9yIDAgIC0tIHNlbGVjdGl2ZSBIUQ0KICBmb3IgeD14MCwgeDEgZG8NCiAgICB0bGluZTNk
KHNyYywgeCwgeTAsIHgsIHkxLCB1LCB2MCwgdSwgdjEsIDEsIDEsIGZsYWdzKQ0KICAgIHp3cml0
ZSh4KzEsIHopICAtLSBmcmFtZS1zdGFtcGVkIHogd3JpdGUNCiAgICB1ICs9IGR1DQogIGVuZA0K
ZW5kDQpgYGANCg0KKipVLUludGVycG9sYXRpb24qKjoNCi0gT25seSBpbnRlcnBvbGF0ZXMgd2hl
biBjb25zZWN1dGl2ZSByYXlzIGhpdCB0aGUgc2FtZSB0aWxlDQotIFByZXZlbnRzIHRleHR1cmUg
c2VhbXMgYXQgdGlsZSBib3VuZGFyaWVzDQotIFNtb290aCB0ZXh0dXJlIHRyYW5zaXRpb25zIGFj
cm9zcyBzcGFucw0K4oCUIFdoYXQ6IFNlYW0tZnJlZSBjb2x1bW4gY29udGludWl0eS4gIA0K4oCU
IEhvdzogSW50ZXJwb2xhdGUgb25seSBhY3Jvc3Mgc2FtZS10aWxlIHJheXM7IGNsYW1wIFVWcyB3
aGVuIGNsaXBwZWQuICANCuKAlCBXaHk6IEF2b2lkcyBzaGltbWVyaW5nIGFuZCBzZWFtcyB3aXRo
IG1pbmltYWwgbWF0aC4NCg0KLSoqTE9EIFN5c3RlbSoqOg0KLSAqKlRocmVzaG9sZCoqOiBgd2Fs
bF9sb2RfZGlzdGFuY2UgPSBmb2dfZmFyICogMC40ID0gOC4wYCB1bml0cw0KLSAqKkJleW9uZCBM
T0QqKjogRHJhdyBzb2xpZCBhdmVyYWdlIGNvbG9yIChzYW1wbGVkIGZyb20gdGV4dHVyZSBjZW50
ZXIpDQotICoqQmVuZWZpdCoqOiBTaWduaWZpY2FudCByZWR1Y3Rpb24gaW4gYHRsaW5lM2RgIGNh
bGxzIGZvciBkaXN0YW50IHdhbGxzDQrigJQgV2hhdDogU29saWQgaW1wb3N0b3JzIGZvciBkaXN0
YW50IHdhbGxzLiAgDQrigJQgSG93OiBDYWNoZSBgYXZnX2NvbG9yYCBwZXIgdGlsZSAoY2VudGVy
IHNhbXBsZSk7IGZpbGwgc3BhbiBhbmQgd3JpdGUgei4gIA0K4oCUIFdoeTogRm9nIGhpZGVzIGRl
dGFpbDsgZmlsbC1yYXRlIHdpbi4NCg0KIyMjIyBGbG9vci9DZWlsaW5nIFJlbmRlcmluZw0KDQoq
KkZ1bGwtUXVhbGl0eSBTY2FubGluZXMqKjoNCmBgYGx1YQ0KZm9yIHk9eTAsIHkxIGRvDQogIC0t
IERyYXcgZXZlcnkgc2NhbmxpbmUgd2l0aCBhY2N1cmF0ZSBVVnMNCiAgdGxpbmUzZChzcmMsIDAs
IHNjcmVlbl9jZW50ZXJfeSt5LCBzY3JlZW5fd2lkdGgtMSwgc2NyZWVuX2NlbnRlcl95K3ksIC4u
LikNCmVuZA0KYGBgDQotICoqUGVyZm9ybWFuY2UqKjogSGlnaGVzdCBxdWFsaXR5OyByZWx5IG9u
IGFkYXB0aXZlIHJheSBidWRnZXQgZm9yIHRocm90dGxpbmcNCi0gKipRdWFsaXR5Kio6IE5vIGJh
bmRpbmcgb3IgZHVwbGljYXRlZCByb3dzDQrigJQgV2hhdDogQWx3YXlzIGRyYXcgZXZlcnkgZmxv
b3IvY2VpbGluZyByb3cuICANCuKAlCBIb3c6IEtlZXAgYHJvd19zdHJpZGVgIGF0IDE7IGdvdmVy
bm9yIG9ubHkgYWRqdXN0cyByYXkgY291bnQuICANCuKAlCBXaHk6IFByZXNlcnZlcyBwZXJzcGVj
dGl2ZSBjb3JyZWN0bmVzcyB3aGlsZSBvdGhlciBzdWJzeXN0ZW1zIG9wdGltaXplIGNvc3QuDQoN
CioqUGVyLUNlbGwgRmxvb3IgVHlwZXMqKjoNCjEuICoqU2FtcGxlKiogYG1hcC5mbG9vcnNgIGV2
ZXJ5IDQgcGl4ZWxzIGFsb25nIHNjYW5saW5lDQoyLiAqKkRldGVjdCBydW5zKiogc2hhcmluZyBz
YW1lIGZsb29yIHR5cGUgSUQNCjMuICoqTWVyZ2UgcnVucyoqIDwgNCBwaXhlbHMgdG8gbGltaXQg
ZHJhdyBjYWxscw0KNC4gKipSZW5kZXIqKiBlYWNoIHJ1biB3aXRoIGNvcnJlc3BvbmRpbmcgdGV4
dHVyZSBmcm9tIGBwbGFuZXR5cHNgDQrigJQgV2hhdDogTWl4ZWQgbWF0ZXJpYWxzIHBlciBzY2Fu
bGluZS4gIA0K4oCUIEhvdzogQnVpbGQvbWVyZ2UgcnVuczsgZHJhdyBlYWNoIHdpdGggaXRzIHRl
eHR1cmUuICANCuKAlCBXaHk6IFZhcmlldHkgd2l0aG91dCBleHBsb2RpbmcgZHJhdyBjYWxscy4N
Cg0KKipGb2cgQXBwbGljYXRpb24qKjoNCi0gQ29tcHV0ZSBmb2cgbGV2ZWwgcGVyIHNjYW5saW5l
DQotIE9ubHkgY2FsbCBgc2V0X2ZvZyh6KWAgd2hlbiBsZXZlbCBjaGFuZ2VzDQotIFVuaWZvcm0g
YXBwbGljYXRpb24gKG5vIGBsaXRgIGV4ZW1wdGlvbnMpDQrigJQgV2hhdDogQ29hbGVzY2VkIGZv
ZyB1cGRhdGVzLiAgDQrigJQgSG93OiBUcmFjayBsYXN0IGxldmVsIGFuZCBza2lwIHJlZHVuZGFu
dCBgcGFsKClgLiAgDQrigJQgV2h5OiBLZWVwcyBmbG9vciBzZWN0aW9uIGNoZWFwLg0KDQotLS0N
Cg0KIyMjIDMuIFNwcml0ZSBTeXN0ZW0gKGBzcmMvcmVuZGVyX3Nwcml0ZS5sdWFgKQ0KDQoqKlB1
cnBvc2UqKjogUmVuZGVyIDNEIG9iamVjdHMgKGVuZW1pZXMsIGl0ZW1zLCBkZWNvcmF0aW9ucykg
d2l0aCBjb3JyZWN0IG9jY2x1c2lvbi4NCg0KU3ByaXRlcyBhcmUgY3VsbGVkIGJ5IGEgZ2VvbWV0
cmljIGZydXN0dW0gaW50ZXJzZWN0ZWQgd2l0aCBhbiBvYmplY3QgZ3JpZCwgc29ydGVkIGludG8g
MTYgZGVwdGggYnVja2V0cyB0byBrZWVwIHBlci1mcmFtZSBzb3J0cyBsb2NhbCwgYW5kIHJlbmRl
cmVkIGJhY2stdG8tZnJvbnQuIEZhciBzcHJpdGVzIHVzZSBzb2xpZCBpbXBvc3RvcnM7IG5lYXIg
c3ByaXRlcyBkcmF3IHBlci1jb2x1bW4gd2l0aCB6LXRlc3RzIGFnYWluc3QgdGhlIHdhbGwgei1i
dWZmZXIuDQoNCiMjIyMgRnJ1c3R1bStPYmpncmlkIEN1bGxpbmcNCg0KKipPYmpncmlkIFF1ZXJ5
Kio6DQpgYGBsdWENCmZvciBneD1mbHIoZnJ1c3R1bV9taW54L29iamdyaWRfc2l6ZSksIGZscihm
cnVzdHVtX21heHgvb2JqZ3JpZF9zaXplKSBkbw0KICBmb3IgZ3k9ZmxyKGZydXN0dW1fbWlueS9v
YmpncmlkX3NpemUpLCBmbHIoZnJ1c3R1bV9tYXh5L29iamdyaWRfc2l6ZSkgZG8NCiAgICBmb3Ig
b2IgaW4gYWxsKG9iamdyaWRbZ3grMV1bZ3krMV0pIGRvDQogICAgICAtLSBUcmFuc2Zvcm0gdG8g
Y2FtZXJhIHNwYWNlDQogICAgICAtLSBDdWxsIGJlaGluZC9vdXRzaWRlL2JleW9uZCBmYXItcGxh
bmUNCiAgICAgIC0tIEFkZCB0byBkZXB0aCBidWNrZXRzDQogICAgZW5kDQogIGVuZA0KZW5kDQpg
YGANCg0KKipDdWxsaW5nIENoZWNrcyoqOg0KMS4gKipCZWhpbmQgY2FtZXJhKio6IGB6X2NhbSA8
PSAwYA0KMi4gKipPdXRzaWRlIGZydXN0dW0gd2VkZ2UqKjogYGFicyh4X2NhbSkgPiB6X2NhbSAq
IHRhbihmb3YpYA0KMy4gKipCZXlvbmQgZmFyLXBsYW5lKio6IGB6X2NhbSA_IGZhcl9wbGFuZWAg
KDI1LjApDQo0LiAqKkJleW9uZCB3YWxsIGRlcHRoKio6IGB6X2NhbSA_PSBtYXh6YCAoc2Vjb25k
YXJ5LCB3YWxsLWJhc2VkKQ0K4oCUIFdoYXQ6IEVhcmx5IHJlamVjdCBub24tdmlzaWJsZSBzcHJp
dGVzLiAgDQrigJQgSG93OiBDYW1lcmEtc3BhY2UgdGVzdHMsIGZhci1wbGFuZSBjYXAsIGFuZCBt
YXggd2FsbCBkZXB0aCBnYXRlLiAgDQrigJQgV2h5OiBLZWVwcyBzcHJpdGUgY29zdCBwcm9wb3J0
aW9uYWwgdG8gdmlzaWJpbGl0eS4NCg0KIyMjIyBEZXB0aC1CdWNrZXQgU29ydGluZw0KDQoqKjE2
IEJ1Y2tldHMqKjoNCi0gQnVja2V0cyAwLTc6IFVwcmlnaHQgc3ByaXRlcyAoMC4wLTI1LjAgdW5p
dHMsIDMuMTI1IHBlciBidWNrZXQpDQotIEJ1Y2tldHMgOC0xNTogRmxhdCBzcHJpdGVzIChvZmZz
ZXQgYnkgOCBmb3Igc2VwYXJhdGUgbGF5ZXJpbmcpDQoNCioqQnVja2V0IEFzc2lnbm1lbnQqKjoN
CmBgYGx1YQ0KbG9jYWwgYnVja2V0X3NpemUgPSBmYXJfcGxhbmUgLyA4ICAtLSAzLjEyNSB1bml0
cw0KbG9jYWwgYnVja2V0X2lkeCA9IG1pbig3LCBmbHIoel9jYW0gLyBidWNrZXRfc2l6ZSkpDQpp
ZiBvYi50eXAuZmxhdCB0aGVuDQogIGJ1Y2tldF9pZHggPSBidWNrZXRfaWR4ICsgOCAgLS0gRmxh
dCBzcHJpdGVzIHVzZSBhIHNlcGFyYXRlIGJ1Y2tldCByYW5nZQ0KZW5kDQphZGQoc3ByaXRlX2J1
Y2tldHNbYnVja2V0X2lkeF0sIG9iKQ0KYGBgDQoNCioqQmFjay10by1Gcm9udCBJdGVyYXRpb24q
KjoNCmBgYGx1YQ0KZm9yIGJ1Y2tldF9pZHg9MTUsIDAsIC0xIGRvICAtLSBQYWludGVyJ3MgYWxn
b3JpdGhtDQogIGZvciBvYiBpbiBhbGwoc3ByaXRlX2J1Y2tldHNbYnVja2V0X2lkeF0pIGRvDQog
ICAgZHJhd29ial9zaW5nbGUob2IsIHNhLCBjYSkNCiAgZW5kDQplbmQNCmBgYA0KDQoqKkludHJh
LUJ1Y2tldCBTb3J0aW5nKio6DQotIEluc2VydGlvbiBzb3J0IHdpdGhpbiBlYWNoIGJ1Y2tldCBv
bmx5IHdoZW4gc2l6ZSA_IDYgKGd1YXJkKQ0KLSBIYW5kbGVzIHNwcml0ZS1zcHJpdGUgb2NjbHVz
aW9uIHdpdGhpbiBzYW1lIGRlcHRoIHJhbmdlDQrigJQgV2hhdDogUGFpbnRlcuKAmXMgb3JkZXIg
d2l0aCBsb2NhbCBzb3J0LiAgDQrigJQgSG93OiBCdWNrZXQgYnkgZGVwdGg7IGluc2VydGlvbiBz
b3J0IHBlciBidWNrZXQuICANCuKAlCBXaHk6IEF2b2lkIE8obsKyKSBnbG9iYWwgc29ydHMgd2hp
bGUgcHJlc2VydmluZyBvcmRlcmluZy4NCg0KIyMjIyBTcHJpdGUgTE9EDQoNCioqVGhyZXNob2xk
Kio6IGBzcHJpdGVfbG9kX2Rpc3RhbmNlID0gZm9nX2ZhciAqIDAuOCA9IDE2LjBgIHVuaXRzDQoN
CioqSW1wb3N0b3IgUmVuZGVyaW5nKio6DQpgYGBsdWENCmlmIHogPiBzcHJpdGVfbG9kX2Rpc3Rh
bmNlIHRoZW4NCiAgbG9jYWwgYXZnX2NvbG9yID0gc3JjOmdldCgxNiwgMTYpIG9yIDUgIC0tIFNh
bXBsZSBjZW50ZXIgcGl4ZWwNCiAgc2V0X2ZvZyh6KQ0KICBmb3IgcHg9eDAsIHgxIGRvDQogICAg
aWYgeiA8IHpyZWFkKHB4KSB0aGVuDQogICAgICByZWN0ZmlsbChweCwgeTAsIHB4LCB5MSwgYXZn
X2NvbG9yKQ0KICAgIGVuZA0KICBlbmQNCmVuZA0KYGBgDQoNCioqUGVyLUNvbHVtbiBaLVRlc3Qq
KjoNCmBgYGx1YQ0KZm9yIHB4PXgwLCB4MSBkbw0KICBpZiB6IDwgenJlYWQocHgpIHRoZW4NCiAg
ICB0bGluZTNkKHNyYywgcHgsIHkwLCBweCwgeTEsIHUsIHYwLCB1LCB2MSwgMSwgMSkNCiAgZW5k
DQplbmQNCmBgYA0KRW5zdXJlcyBjb3JyZWN0IG9jY2x1c2lvbiB3aXRoIHdhbGxzIGFuZCBvdGhl
ciBzcHJpdGVzLg0K4oCUIFdoYXQ6IEZhciBpbXBvc3RvcnM7IG5lYXIgcGVyLWNvbHVtbiB6LXRl
c3RlZCBkcmF3cy4gIA0K4oCUIEhvdzogQ2VudGVyLWNvbG9yIGZpbGwgdnMgMzLDlzMyIFVWIHNh
bXBsaW5nLiAgDQrigJQgV2h5OiBNYXRjaGVzIGZvZy1kcml2ZW4gcGVyY2VwdHVhbCBkZXRhaWws
IG1pbmltaXplcyBjb3N0Lg0KDQotLS0NCg0KIyMjIDQuIER1bmdlb24gR2VuZXJhdGlvbiAoYHNy
Yy9kdW5nZW9uX2dlbi5sdWFgKQ0KDQoqKlB1cnBvc2UqKjogUHJvY2VkdXJhbGx5IGdlbmVyYXRl
IGR1bmdlb25zIHdpdGggcm9vbXMsIGNvcnJpZG9ycywgZG9vcnMsIGFuZCBvYmplY3RzLg0KDQpU
aGUgZ2VuZXJhdG9yIGJ1aWxkcyBhIGdyYXBoIG9mIHJvb21zIGNvbm5lY3RlZCBieSBjb3JyaWRv
cnMgd2l0aCBib3VuZGFyeSBkb29ycywgYXBwbGllcyB0aGVtZS1hcHByb3ByaWF0ZSB0ZXh0dXJl
cywgcGxhY2VzIHN0YXJ0L2VuZCBleGl0cyBvbiByb29tIHBlcmltZXRlcnMsIGFuZCBwb3B1bGF0
ZXMgb2JqZWN0cy4gQSBwcm9ncmVzc2lvbiBsb29wIGxvY2tzIGNlcnRhaW4gY29ycmlkb3IgZG9v
cnMgYW5kIGd1YXJhbnRlZXMgbWF0Y2hpbmcga2V5IHBsYWNlbWVudCBpbiBjdXJyZW50bHkgYWNj
ZXNzaWJsZSByb29tcyB0byBwcmV2ZW50IGRlYWQtZW5kcy4NCg0KKipHZW5lcmF0aW9uIFBpcGVs
aW5lKio6DQoxLiAqKlNlZWQgJiBUaGVtZSoqIC0gSW5pdGlhbGl6ZSBSTkcsIHNlbGVjdCB0aGVt
ZSAoZHVuZ2Vvbi9vdXRkb29yL2RlbW9uaWMpDQoyLiAqKkZpbGwgV2FsbHMqKiAtIFN0YXJ0IHdp
dGggc29saWQgbWFwDQozLiAqKkNhcnZlIFJvb21zKiogLSBQbGFjZSA1LTE1IHJvb21zICg0eDQg
dG8gMTJ4MTIpDQo0LiAqKkNhcnZlIENvcnJpZG9ycyoqIC0gQ29ubmVjdCByb29tcyB3aXRoIEwt
c2hhcGVkIGNvcnJpZG9ycw0KNS4gKipQbGFjZSBEb29ycyoqIC0gQWRkIGRvb3JzIGF0IHJvb20g
ZW50cmFuY2VzICgzMCUgcHJvYmFiaWxpdHkpDQo2LiAqKlBsYWNlIEV4aXRzKiogLSBTdGFpcnMg
dG8gbmV4dCBmbG9vcg0KNy4gKipTcGF3biBPYmplY3RzKiogLSBFbmVtaWVzLCBpdGVtcywgZGVj
b3JhdGlvbnMgYmFzZWQgb24gZGlmZmljdWx0eQ0KOC4gKipFcm9zaW9uKiogLSBTbW9vdGggd2Fs
bHMsIGFkZCB2YXJpZXR5DQo5LiAqKkJvcmRlciBSaW5nKiogLSBFbmZvcmNlIDEtdGlsZSB3YWxs
IHJpbmcNCjEwLiAqKkRvb3IgVGlsZXMqKiAtIFJlLWFzc2VydCBkb29yIGNvbnNpc3RlbmN5DQoN
CioqSGV1cmlzdGljcyAmIE9ic2VydmFiaWxpdHkqKjoNCi0gQWRhcHRpdmUgc3BhY2luZyByZWxh
eC9yZXN0b3JlICh0dW5lZCBieSBgZ2VuX2FkYXB0aXZlX3NldHRpbmdzYCkga2VlcHMgaGlnaCBy
b29tIHN1Y2Nlc3MgcmF0ZXMgd2hpbGUgbG9nZ2luZyBmYWlsdXJlcyBmb3IgcmV2aWV3Lg0KLSBU
aGVtZS1zcGVjaWZpYyBgcnVsZXNgIGJpYXMgcm9vbSBwcm9wb3J0aW9ucywgY29ycmlkb3Igam9n
cywgYW5kIGVyb3Npb24gaW50ZW5zaXR5IHdpdGhvdXQgc2FjcmlmaWNpbmcgcmVjdGFuZ3VsYXIg
aW52YXJpYW50cy4NCi0gQ29ycmlkb3IgbWV0YWRhdGEgKGBlZGdlLnNoYXBlYCwganVuY3Rpb24g
bm9kZXMsIGJvdW5kYXJ5IHByZXNlcnZhdGlvbikgc3VwcG9ydHMgcHJvZ3Jlc3Npb24gYW5hbHl0
aWNzIGFuZCBmdXR1cmUgbWluaW1hcCByZW5kZXJpbmcuDQotIEFsbCBjcml0aWNhbCBhY3Rpb25z
IChkb29yIHJlcGFpcnMsIGxvY2tzLCBzcGFjaW5nIHJlbGF4YXRpb25zKSBmbG93IGludG8gYGdl
bl9vYnNlcnZhYmlsaXR5Lmhpc3RvcnlgLCBzdXJmYWNlZCBpbiB0aGUgRHVuZ2VvbiBMYWIgc2lk
ZWJhci4NCg0KKipCb3JkZXIgUmluZyBFbmZvcmNlbWVudCoqOg0KYGBgbHVhDQpmdW5jdGlvbiBl
bmZvcmNlX2JvcmRlcl9yaW5nKCkNCiAgZm9yIHg9MCwgbWFwX3NpemUtMSBkbw0KICAgIGxvY2Fs
IHRpbGUgPSBnZXRfd2FsbCh4LCAwKQ0KICAgIGlmIG5vdCBpc19kb29yKHRpbGUpIGFuZCBub3Qg
aXNfZXhpdCh0aWxlKSB0aGVuDQogICAgICBzZXRfd2FsbCh4LCAwLCB3YWxsX2ZpbGxfdGlsZSkg
IC0tIFByZXNlcnZlIGRvb3JzL2V4aXRzDQogICAgZW5kDQogICAgLS0gUmVwZWF0IGZvciBib3R0
b20sIGxlZnQsIHJpZ2h0IGVkZ2VzDQogIGVuZA0KZW5kDQpgYGANCuKAlCBXaGF0OiBTZWFscyB0
aGUgb3V0ZXJtb3N0IHJpbmcuICANCuKAlCBIb3c6IFdyaXRlcyBgd2FsbF9maWxsX3RpbGVgIG9u
IGVkZ2VzIHVubGVzcyBhIGRvb3IvZXhpdCBvY2N1cGllcyB0aGF0IGNlbGwuICANCuKAlCBXaHk6
IFByZXZlbnRzIE9PQiB0cmF2ZXJzYWwgYW5kIGtlZXBzIEREQSByYXlzIGJvdW5kZWQuDQoNCioq
RG9vciBUaWxlIFJlLUFzc2VydGlvbioqOg0KYGBgbHVhDQpmdW5jdGlvbiBlbmZvcmNlX2Rvb3Jf
dGlsZXMoKQ0KICBmb3IgZG9vciBpbiBhbGwoZG9vcnMpIGRvDQogICAgaWYgbm90IGlzX2Rvb3Io
Z2V0X3dhbGwoZG9vci54LCBkb29yLnkpKSB0aGVuDQogICAgICBzZXRfd2FsbChkb29yLngsIGRv
b3IueSwgZG9vci5kdHlwZSBvciBkb29yX25vcm1hbCkNCiAgICBlbmQNCiAgZW5kDQplbmQNCmBg
YA0K4oCUIFdoYXQ6IFJlc3RvcmVzIHdhbGwgdGlsZXMgZm9yIGxvZ2ljYWxseSBwcmVzZW50IGRv
b3JzLiAgDQrigJQgSG93OiBDcm9zcy1jaGVja3MgYGRvb3JzL2Rvb3JncmlkYCBhZ2FpbnN0IGBt
YXAud2FsbHNgIGFuZCBmaXhlcyBtaXNtYXRjaGVzLiAgDQrigJQgV2h5OiBLZWVwcyByZW5kZXJp
bmcvY29sbGlzaW9uIGF1dGhvcml0YXRpdmUgYWZ0ZXIgbGF0ZXIgcGFzc2VzLg0KDQoqKkRpZmZp
Y3VsdHkgU2NhbGluZyoqOg0KLSBJbmNyZWFzZXMgd2l0aCBmbG9vciBudW1iZXIgKDEtOSkNCi0g
TW9yZSBlbmVtaWVzLCB0b3VnaGVyIGVuZW15IHR5cGVzDQotIE1vcmUgZGVjb3JhdGlvbnMsIGNv
bXBsZXggbGF5b3V0cw0K4oCUIFdoYXQ6IFNjYWxlcyBjaGFsbGVuZ2UgYnkgZmxvb3IuICANCuKA
lCBIb3c6IEZpbHRlcnMgYGVuZW15X3R5cGVzYCBieSBgZGlmZmljdWx0eWAgYW5kIGFkanVzdHMg
ZGVuc2l0aWVzLiAgDQrigJQgV2h5OiBFbnN1cmVzIHByb2dyZXNzaW9uIGFjcm9zcyBmbG9vcnMu
DQoNCioqU3BhdGlhbCBHcmlkcyoqOg0KLSBgb2JqZ3JpZFsyNl1bMjZdYCAtIDV4NSB1bml0IGNl
bGxzIGZvciBmYXN0IG9iamVjdCBxdWVyaWVzDQotIGBkb29yZ3JpZFsxMjhdWzEyOF1gIC0gRG9v
ciBzdGF0ZSB0cmFja2luZw0K4oCUIFdoYXQ6IFNlcGFyYXRlIGdyaWRzIGZvciBvYmplY3RzIGFu
ZCBkb29ycy4gIA0K4oCUIEhvdzogYG9iamdyaWRgIGFjY2VsZXJhdGVzIGN1bGxpbmcvY29sbGlz
aW9uOyBgZG9vcmdyaWRgIGNlbnRyYWxpemVzIGRvb3Igc3RhdGVzLiAgDQrigJQgV2h5OiBLZWVw
cyBxdWVyaWVzIGFuZCB1cGRhdGVzIGxvY2FsLg0KDQojIyMjIEV4aXQgUGxhY2VtZW50DQrigJQg
V2hhdDogU3RhcnQgKGBleGl0X3N0YXJ0YCkgYW5kIGVuZCAoYGV4aXRfZW5kYCkgZXhpdHMgcGxh
Y2VkIG9uIHJvb20gcGVyaW1ldGVycyBhbmQgbWlycm9yZWQgYXMgaW50ZXJhY3RhYmxlIGV4aXQg
b2JqZWN0cy4gIA0K4oCUIEhvdzogYGdlbmVyYXRlX2V4aXQocmVjdCwgZXhpdF90eXBlKWAgc2Ft
cGxlcyBwZXJpbWV0ZXIgY2VsbHMgYWRqYWNlbnQgdG8gd2FsbHMsIHdyaXRlcyBleGl0IHRpbGUg
aW50byBgbWFwLndhbGxzYCwgYW5kIGFkZHMgYW4gYGludGVyYWN0YWJsZV9leGl0YCBvYmplY3Qg
YXQgdGhlIHNhbWUgZ3JpZCAoY2VudGVyZWQgYXQgKzAuNSkuIENhbGxlZCBmb3IgdGhlIGZpcnN0
IGFuZCBsYXN0IHJvb21zIGR1cmluZyBgZ2VuZXJhdGVfZ2FtZXBsYXkoKWAuICANCuKAlCBXaHk6
IEVuc3VyZXMgZXhpdHMgYXJlIHZpc2libGUsIHJlYWNoYWJsZSwgYW5kIGNvbnNpc3RlbnQgYmV0
d2VlbiB0aWxlcyBhbmQgb2JqZWN0cy4NCg0KIyMjIyBQcm9ncmVzc2lvbiBMb29wIChMb2NrZWQg
RG9vcnMgYW5kIEtleXMpDQrigJQgV2hhdDogTG9ja3Mgc2VsZWN0ZWQgY29ycmlkb3IgYm91bmRh
cnkgZG9vcnMgYW5kIHNwYXducyBtYXRjaGluZyBrZXlzIGluIHJvb21zIHRoYXQgcmVtYWluIGFj
Y2Vzc2libGUgd2l0aG91dCB0aG9zZSBrZXlzLiAgDQrigJQgSG93OiBgZ2VuZXJhdGVfcHJvZ3Jl
c3Npb25fbG9vcChzdGFydF9ub2RlKWAgY29tcHV0ZXMgYWNjZXNzaWJsZSByb29tcywgc2h1ZmZs
ZXMgZWRnZXMsIHRlbnRhdGl2ZWx5IGxvY2tzIG9uZSBib3VuZGFyeSBkb29yIHBlciBjaG9zZW4g
ZWRnZSAoYGRvb3JfbG9ja2VkYCB3aXRoIGBrZXludW1gKSwgcmVjb21wdXRlcyBhY2Nlc3NpYmls
aXR5LCBhbmQgZW5xdWV1ZXMgYSBtYXRjaGluZyBrZXkgaW50byBgZ2VuX2ludmVudG9yeWAuIEtl
eXMgYXJlIHRoZW4gcGxhY2VkIG9ubHkgaW4gY3VycmVudGx5IGFjY2Vzc2libGUgcm9vbXMsIHdp
dGggcmV0cmllcyBhbmQgZmFsbGJhY2sgdG8gdGhlIHN0YXJ0IHJvb20gaWYgbmVlZGVkLiBCb3Vu
ZGFyeSBkb29yIHBsYWNlbWVudCB1c2VzIHJldHJpZXMgYW5kLCBpZiBhbGwgZmFpbCwgYGVuc3Vy
ZV9ib3VuZGFyeV9wYXNzYWdlYCBjbGVhcnMgYSBibG9ja2luZyB3YWxsIHRvIHByZXNlcnZlIGNv
bm5lY3Rpdml0eS4gIA0K4oCUIFdoeTogR3VhcmFudGVlcyBmb3J3YXJkIHByb2dyZXNzIGFuZCBw
cmV2ZW50cyBzb2Z0LWxvY2tzIHdoaWxlIGludHJvZHVjaW5nIGxpZ2h0d2VpZ2h0IGdhdGluZy4N
Cg0KLS0tDQoNCiMjIyA1LiBEb29yIFN5c3RlbSAoYHNyYy9kb29yX3N5c3RlbS5sdWFgKQ0KDQoq
KlB1cnBvc2UqKjogQW5pbWF0ZWQgZG9vcnMgd2l0aCBjb2xsaXNpb24sIHN0YXRlIG1hbmFnZW1l
bnQsIGFuZCBhdXRvLWNsb3NlLg0KDQpEb29ycyBhcmUgcmVwcmVzZW50ZWQgaW4gYm90aCBsb2dp
Y2FsIChgZG9vcnNgLCBgZG9vcmdyaWRgKSBhbmQgdGlsZSAoYG1hcC53YWxsc2ApIGxheWVycy4g
QW5pbWF0aW9uIGlzIGRldGVybWluaXN0aWMsIHN1cHBvcnRzIGEgdGVzdCBtb2RlIHRoYXQgYXZv
aWRzIHBlcm1hbmVudCBzdGF0ZSBtdXRhdGlvbiwgYW5kIGludGVncmF0ZXMgd2l0aCBjb2xsaXNp
b24gYW5kIHJheWNhc3RpbmcuDQoNCioqRG9vciBTdGF0ZXMqKjoNCi0gYG9wZW5gIC0gMC4wIChj
bG9zZWQpIHRvIDEuMCAoZnVsbHkgb3BlbikNCi0gYG9wZW5pbmdgIC0gQm9vbGVhbiBmbGFnDQot
IGBjbG9zaW5nYCAtIEJvb2xlYW4gZmxhZw0KLSBgY2xvc2VfdGltZXJgIC0gRnJhbWVzIHVudGls
IGF1dG8tY2xvc2UgKDkwIGZyYW1lcyBkZWZhdWx0KQ0K4oCUIFdoYXQ6IE1pbmltYWwgcGVyLWRv
b3IgRlNNLiAgDQrigJQgSG93OiBPcGVucyB0byAxLjAsIHN0YXJ0cyB0aW1lciwgY2xvc2VzIHdo
ZW4gdGltZXIgZWxhcHNlcyAodW5sZXNzIGBzdGF5b3BlbmApLiAgDQrigJQgV2h5OiBQcmVkaWN0
YWJsZSBiZWhhdmlvciBjb21wYXRpYmxlIHdpdGggY29sbGlzaW9uIGFuZCB2aXN1YWxzLg0KDQoq
KkRvb3IgVHlwZXMqKjoNCi0gYGRvb3Jfbm9ybWFsYCAoMjQpIC0gU3RhbmRhcmQgZG9vcg0KLSBg
ZG9vcl9sb2NrZWRgICgyNSkgLSBSZXF1aXJlcyBrZXkNCi0gYGRvb3Jfc3RheV9vcGVuYCAoMjYp
IC0gTmV2ZXIgY2xvc2VzDQrigJQgV2hhdDogRW5jb2RlcyBzZW1hbnRpY3MgYW5kIHByb2dyZXNz
aW9uLiAgDQrigJQgSG93OiBgZG9vcl9sb2NrZWRgIGhvbGRzIGBrZXludW1gOyBgZG9vcl9zdGF5
X29wZW5gIGJ5cGFzc2VzIGF1dG8tY2xvc2UuICANCuKAlCBXaHk6IFN1cHBvcnRzIGdhdGluZyBh
bmQgVVggZXhwZWN0YXRpb25zLg0KDQoqKkFuaW1hdGlvbioqOg0KYGBgbHVhDQpmdW5jdGlvbiB1
cGRhdGVfZG9vcnMoKQ0KICBmb3IgZG9vciBpbiBhbGwoZG9vcnMpIGRvDQogICAgaWYgZG9vci5v
cGVuaW5nIHRoZW4NCiAgICAgIGRvb3Iub3BlbiA9IG1pbigxLjAsIGRvb3Iub3BlbiArIGRvb3Jf
YW5pbV9zcGVlZCkNCiAgICBlbHNlaWYgZG9vci5jbG9zaW5nIHRoZW4NCiAgICAgIGRvb3Iub3Bl
biA9IG1heCgwLjAsIGRvb3Iub3BlbiAtIGRvb3JfYW5pbV9zcGVlZCkNCiAgICBlbmQNCiAgZW5k
DQplbmQNCmBgYA0K4oCUIFdoYXQ6IENvbnN0YW50LXNwZWVkIG9wZW4vY2xvc2UuICANCuKAlCBI
b3c6IEFwcGxpZXMgYGRvb3JfYW5pbV9zcGVlZGAgcGVyIGZyYW1lOyB1c2VzIGBkb29yX2Nsb3Nl
X2RlbGF5YCB0aW1lci4gIA0K4oCUIFdoeTogU2ltcGxlLCBzdGFibGUsIGxvdy1jb3N0Lg0KDQoq
KkNvbGxpc2lvbiBJbnRlZ3JhdGlvbioqOg0KLSBSYXljYXN0IGNoZWNrcyBkb29yIG9wZW4gc3Rh
dGUNCi0gUGFydGlhbCBvcGVuaW5nIGFsbG93cyBwYXJ0aWFsIHBhc3NhZ2UNCi0gQ29sbGlzaW9u
IHN5c3RlbSByZXNwZWN0cyBkb29yIGdlb21ldHJ5DQrigJQgV2hhdDogVW5pZmllZCBtb3ZlbWVu
dCByZXNwZWN0cyBkb29yczsgcmF5cyB0cmVhdCBwYXJ0aWFsbHkgb3BlbiBkb29ycyBhcyBvY2Ns
dWRlcnMuICANCuKAlCBIb3c6IGBpc2NvbCgpYCBjb25zdWx0cyBgZG9vcmdyaWRgLCBjYW4gYXV0
by1vcGVuIGRvb3JzIGlmIHBsYXllciBoYXMgYSBrZXkuICANCuKAlCBXaHk6IEtlZXBzIHBoeXNp
Y3MgYW5kIHZpc3VhbHMgY29uc2lzdGVudC4NCg0KLS0tDQoNCiMjIyA2LiBBSSBTeXN0ZW0gKG1h
aW4ubHVhKQ0KDQoqKlB1cnBvc2UqKjogTlBDIGJlaGF2aW9yIHdpdGggcGF0cm9sIGFuZCBmb2xs
b3cgbW9kZXMuDQoNCkFJIHVwZGF0ZXMgYXJlIHJhdGUtbGltaXRlZC4gUGF0cm9sIGN5Y2xlcyB3
YXlwb2ludHM7IGZvbGxvdyBzdGVlcnMgdG93YXJkIHRoZSBwbGF5ZXIgd2l0aGluIGEgcmFuZ2Uu
IE1vdmVtZW50IHVzZXMgdW5pZmllZCBzbGlkaW5nIGNvbGxpc2lvbiBhbmQgdXBkYXRlcyB0aGUg
c3BhdGlhbCBncmlkIG9uIGNlbGwgdHJhbnNpdGlvbnMuDQoNCioqQUkgVHlwZXMqKjoNCjEuICoq
Rm9sbG93KiogLSBDaGFzZSBwbGF5ZXIgd2hlbiBpbiByYW5nZQ0KMi4gKipQYXRyb2wqKiAtIFdh
eXBvaW50LWJhc2VkIG1vdmVtZW50DQrigJQgV2hhdDogVHdvIGxpZ2h0d2VpZ2h0IGJlaGF2aW9y
cy4gIA0K4oCUIEhvdzogRm9sbG93IHVzZXMgZGlyZWN0IHN0ZWVyaW5nIGluLXJhbmdlOyBwYXRy
b2wgZm9sbG93cyBwcmVjb21wdXRlZCB3YXlwb2ludHMuICANCuKAlCBXaHk6IEtlZXBzIGJlaGF2
aW9yIGV4cHJlc3NpdmUgYnV0IGNoZWFwLg0KDQoqKlVwZGF0ZSBMb29wKio6DQpgYGBsdWENCmZ1
bmN0aW9uIHVwZGF0ZV9ucGNfYWkoKQ0KICBmb3Igb2IgaW4gYWxsKG9iamVjdHMpIGRvDQogICAg
aWYgb2Iua2luZCA9PSAiaG9zdGlsZV9ucGMiIHRoZW4NCiAgICAgIGlmIGRpc3RhbmNlX3RvX3Bs
YXllciA8IGZvbGxvd19yYW5nZSB0aGVuDQogICAgICAgIC0tIEZvbGxvdyBwbGF5ZXINCiAgICAg
ICAgbW92ZV90b3dhcmRzKHBsYXllci54LCBwbGF5ZXIueSwgZm9sbG93X3NwZWVkKQ0KICAgICAg
ZWxzZQ0KICAgICAgICAtLSBQYXRyb2wgd2F5cG9pbnRzDQogICAgICAgIG1vdmVfdG93YXJkcyh3
YXlwb2ludC54LCB3YXlwb2ludC55LCBwYXRyb2xfc3BlZWQpDQogICAgICBlbmQNCiAgICBlbmQN
CiAgZW5kDQplbmQNCmBgYA0K4oCUIFdoYXQ6IFJhdGUtbGltaXRlZCB1cGRhdGVzIGFjcm9zcyBv
YmplY3QgZ3JpZC4gIA0K4oCUIEhvdzogRGV0ZXJtaW5pc3RpYyBmcmFtZSBjaGVjayAoYGFpX3Vw
ZGF0ZV9yYXRlYCkgd2l0aCBwZXItb2JqZWN0IGxvZ2ljLiAgDQrigJQgV2h5OiBBdm9pZHMgcGVy
LWZyYW1lIHNwaWtlcyB3aGVuIHBvcHVsYXRpb25zIGluY3JlYXNlLg0KDQoqKkNvbGxpc2lvbi1B
d2FyZSBNb3ZlbWVudCoqOg0KLSBVc2VzIGB0cnltb3ZldG8oKWAgd2l0aCBzbGlkaW5nIGNvbGxp
c2lvbg0KLSBVcGRhdGVzIGBvYmpncmlkYCBhZnRlciBtb3ZlbWVudA0KLSBSZXNwZWN0cyB3YWxs
cywgZG9vcnMsIGFuZCBzb2xpZCBvYmplY3RzDQrigJQgV2hhdDogU2hhcmVkIG1vdmVtZW50IGNv
cmUuICANCuKAlCBIb3c6IFRyeSBkaWFnb25hbCB0aGVuIGF4ZXM7IHVuaWZ5IGBpc2NvbCgpYCBj
aGVja3MgYW5kIHVwZGF0ZSBgb2JqZ3JpZGAuICANCuKAlCBXaHk6IFNtb290aCBtb3ZlbWVudCB3
aXRob3V0IHR1bm5lbGluZzsga2VlcHMgY3VsbGluZyBpbiBzeW5jLg0KDQotLS0NCg0KIyMgQ29u
ZmlndXJhdGlvbg0KDQpBbGwgY29uZmlndXJhdGlvbiBpcyBjZW50cmFsaXplZCBpbiBgc3JjL2Nv
bmZpZy5sdWFgLg0KDQojIyMgU2NyZWVuICYgVmlldw0KDQpgYGBsdWENCnNjcmVlbl93aWR0aCA9
IDQ4MA0Kc2NyZWVuX2hlaWdodCA9IDI3MA0Kc2NyZWVuX2NlbnRlcl94ID0gMjQwDQpzY3JlZW5f
Y2VudGVyX3kgPSAxMzUNCnJheV9jb3VudCA9IDEyOCAgICAgICAgICAtLSBJbmRlcGVuZGVudCBv
ZiBzY3JlZW5fd2lkdGg7IGFkYXB0aXZlIGdvdmVybm9yIGNhbiBsb3dlciB0aGlzDQpmb3YgPSAw
LjUgICAgICAgICAgICAgICAgLS0gSGFsZi1hbmdsZSBpbiByYWRpYW5zICh_MjguNsKwKQ0KZmFy
X3BsYW5lID0gMjUuMCAgICAgICAgIC0tIE1heGltdW0gcmF5Y2FzdCBkaXN0YW5jZQ0KYGBgDQoN
CiMjIyBGb2cgU3lzdGVtDQoNCmBgYGx1YQ0KZm9nX25lYXIgPSA1LjAgICAgICAgICAgIC0tIEZv
ZyBzdGFydHMgYXQgNSB1bml0cw0KZm9nX2ZhciA9IDIwLjAgICAgICAgICAgIC0tIEZvZyBtYXhp
bXVtIGF0IDIwIHVuaXRzDQpmb2dfaHlzdGVyZXNpcyA9IDAuNSAgICAgLS0gTWluaW11bSB6IGNo
YW5nZSB0byB1cGRhdGUgZm9nDQpgYGANCg0KIyMjIExPRCBTeXN0ZW0NCg0KYGBgbHVhDQp3YWxs
X2xvZF9yYXRpbyA9IDAuNCAgICAgLS0gV2FsbCBMT0QgYXQgZm9nX2ZhciAqIDAuNCA9IDguMA0K
c3ByaXRlX2xvZF9yYXRpbyA9IDAuNSAgIC0tIFNwcml0ZSBMT0QgYXQgZm9nX2ZhciAqIDAuNSA9
IDEwLjANCndhbGxfbG9kX2Rpc3RhbmNlID0gZm9nX2ZhciAqIHdhbGxfbG9kX3JhdGlvICAtLSBD
b21wdXRlZA0KYGBgDQoNCiMjIyBSZW5kZXJpbmcNCg0KYGBgbHVhDQpyb3dfc3RyaWRlID0gMSAg
ICAgICAgICAgLS0gRmxvb3IvY2VpbGluZyBzdHJpZGUgKGtlcHQgYXQgMSBmb3IgZnVsbCBxdWFs
aXR5KQ0KYGBgDQoNCiMjIyBNYXAgJiBTcGF0aWFsDQoNCmBgYGx1YQ0KbWFwX3NpemUgPSAxMjgg
ICAgICAgICAgIC0tIDEyOHgxMjggZ3JpZA0Kb2JqZ3JpZF9zaXplID0gNSAgICAgICAgIC0tIDV4
NSB1bml0IGNlbGxzDQpvYmpncmlkX2FycmF5X3NpemUgPSAyNiAgLS0gMjZ4MjYgZ3JpZCAoMTI4
LzUgcm91bmRlZCB1cCkNCmBgYA0KDQojIyMgUGxheWVyIE1vdmVtZW50DQoNCmBgYGx1YQ0KcGxh
eWVyX3JvdGF0aW9uX3NwZWVkID0gMC4wMDggIC0tIFJhZGlhbnMgcGVyIGZyYW1lDQpwbGF5ZXJf
bW92ZV9zcGVlZCA9IDAuMDQgICAgICAgLS0gVW5pdHMgcGVyIGZyYW1lDQpgYGANCg0KIyMjIERv
b3IgU3lzdGVtDQoNCmBgYGx1YQ0KZG9vcl9hbmltX3NwZWVkID0gMC4wNiAgIC0tIE9wZW4vY2xv
c2Ugc3BlZWQgcGVyIGZyYW1lDQpkb29yX2Nsb3NlX2RlbGF5ID0gOTAgICAgLS0gRnJhbWVzIGJl
Zm9yZSBhdXRvLWNsb3NlDQpgYGANCg0KIyMjIEFJDQoNCmBgYGx1YQ0KYWlfdXBkYXRlX3JhdGUg
PSAyICAgICAgIC0tIEZyYW1lcyBiZXR3ZWVuIEFJIHVwZGF0ZXMNCmludGVyYWN0aW9uX3Jhbmdl
ID0gMC41ICAtLSBQcm94aW1pdHkgZm9yIHRyaWdnZXJzDQpjb21iYXRfdHJpZ2dlcl9yYW5nZSA9
IDAuMyAgLS0gRGlzdGFuY2UgdG8gdHJpZ2dlciBjb21iYXQNCmBgYA0KDQojIyMgR2VuZXJhdGlv
bg0KDQpgYGBsdWENCmdlbl9wYXJhbXMgPSB7DQogIG1pbl9yb29tcyA9IDUsDQogIG1heF9yb29t
cyA9IDE1LA0KICBtaW5fc2l6ZSA9IDQsDQogIG1heF9zaXplID0gMTIsDQogIHNwYWNpbmcgPSAy
LA0KICByb29tX2Rvb3JfcHJvYiA9IDAuMywNCiAgZXJvZGVfYW1vdW50ID0gNTAsDQogIGRpZmZp
Y3VsdHkgPSAxLA0KICBtYXhfZGlmZmljdWx0eSA9IDksDQogIG1heF9lbmVtaWVzX3Blcl9yb29t
ID0gOCwNCiAgbWF4X2RlY29yYXRpb25zX3Blcl9yb29tID0gMTIsDQogIG5wY19ob3N0aWxlX3Jh
dGlvID0gMC43LA0KICBpdGVtc19wZXJfcm9vbSA9IDIsDQogIHBpY2t1cF9kZW5zaXR5ID0gMC4x
DQp9DQpgYGANCg0KIyMjIEdlbmVyYXRpb24gT2JzZXJ2YWJpbGl0eQ0KDQpgYGBsdWENCmdlbl9v
YnNlcnZhYmlsaXR5ID0gew0KICBlbmFibGVfY29uc29sZSA9IGZhbHNlLA0KICBjYXB0dXJlX2hp
c3RvcnkgPSB0cnVlLA0KICBoaXN0b3J5X2xpbWl0ID0gNDAwLA0KICBsb2dfc2VlZCA9IHRydWUs
DQogIGxvZ19yb29tX2F0dGVtcHRzID0gdHJ1ZSwNCiAgbG9nX2NvcnJpZG9ycyA9IHRydWUsDQog
IGxvZ19wcm9ncmVzc2lvbiA9IHRydWUsDQogIGxvZ19yZXBhaXJzID0gdHJ1ZQ0KfQ0KYGBgDQoN
CiMjIyBBZGFwdGl2ZSBHZW5lcmF0aW9uIFNldHRpbmdzDQoNCmBgYGx1YQ0KZ2VuX2FkYXB0aXZl
X3NldHRpbmdzID0gew0KICBzcGFjaW5nX3JlbGF4X3RocmVzaG9sZCA9IDQsDQogIHNwYWNpbmdf
cmVsYXhfc3RlcCA9IDEsDQogIHNwYWNpbmdfbWF4X3JlbGF4ID0gNCwNCiAgc3BhY2luZ19yZXN0
b3JlX2RlbGF5ID0gMiwNCiAgc3BhY2luZ19yZXN0b3JlX3N0ZXAgPSAxLA0KICBtYXhfcm9vbV9m
YWlsdXJlcyA9IDI0LA0KICBvZmZjZW50ZXJfYmlhcyA9IDAuNjUsDQogIGJpYXNfcmFkaXVzID0g
MTIsDQogIGp1bmN0aW9uX3JldHJ5X2xpbWl0ID0gNiwNCiAgY29ycmlkb3Jfam9nX2NoYW5jZSA9
IDAuMjUNCn0NCmBgYA0KDQpFYWNoIHRoZW1lIGluIGBjb25maWcubHVhYCBtYXkgc3BlY2lmeSBh
IGBydWxlc2AgdGFibGUgKHNoYXBlIHdlaWdodHMsIHNwYWNpbmcgYmlhcywgY29ycmlkb3Igam9n
IGNoYW5jZSwgZXJvc2lvbiBpbnRlbnNpdHkpLiBUaGVzZSBydWxlcyBkcml2ZSB0aGUgYWRhcHRp
dmUgaGV1cmlzdGljcyBkZXNjcmliZWQgaW4gdGhlIER1bmdlb24gR2VuZXJhdGlvbiBzZWN0aW9u
Lg0KDQotLS0NCg0KIyMgUGVyZm9ybWFuY2UgQ2hhcmFjdGVyaXN0aWNzDQoNCiMjIyBUeXBpY2Fs
IFNjZW5lIChhZGFwdGl2ZSByYXlzL3N0cmlkZSwgTE9EIGVuYWJsZWQpDQoNCioqVGFyZ2V0Kio6
IFN0YWJsZSA1MOKAkzYwIEZQUyBpbiB0eXBpY2FsIHNjZW5lcyB3aXRoIHRoZSBhZGFwdGl2ZSBn
b3Zlcm5vciAoZHluYW1pYyByYXkgYnVkZ2V0KSBhbmQgZm9n4oCRZHJpdmVuIExPRC4NCg0KVXNl
IHRoZSBidWlsdC1pbiBkaWFnbm9zdGljcyAoRyBvdmVybGF5LCBGIGxvZ2dpbmcpIHRvIHR1bmU6
DQotIEREQSBzdGVwcy9yYXkgYW5kIGVhcmx5LW91dHMgKHJheWNhc3RpbmcgY29zdCkNCi0gV2Fs
bCBjb2x1bW5zIHZzIExPRCBzb2xpZCBmaWxscyAod2FsbCBjb3N0KQ0KLSBBY3RpdmUgcmF5IGJ1
ZGdldCAoZ292ZXJub3IgaW1wYWN0KQ0KLSBTcHJpdGUgY29sdW1ucyBkcmF3biAoY3VsbGluZy9i
dWNrZXRzL0xPRCBpbXBhY3QpDQotIEZvZyBzd2l0Y2hlcyAocGFsZXR0ZSB3b3JrKQ0KDQojIyMg
UGVyZm9ybWFuY2UgVHVuaW5nIEtub2JzDQoNCjEuICoqcmF5X2NvdW50KiogKDY0LzEyOC8xOTIp
DQogICAtIExvd2VyID0gZmFzdGVyIHJheWNhc3RpbmcsIGJsb2NraWVyIHdhbGxzDQogICAtIEhp
Z2hlciA9IHNsb3dlciByYXljYXN0aW5nLCBzbW9vdGhlciB3YWxscw0KDQoyLiAqKnJvd19zdHJp
ZGUqKiAobG9ja2VkIGF0IDEgZm9yIGNvcnJlY3QgcGVyc3BlY3RpdmUpDQogICAtIFJhaXNpbmcg
dGhpcyB0cmFkZXMgY29ycmVjdG5lc3MgZm9yIHNwZWVkOyBsZWF2ZSBhdCAxIGZvciBwcm9kdWN0
aW9uDQoNCjMuICoqd2FsbF9sb2RfcmF0aW8qKiAoMC41LTAuOSkNCiAgIC0gTG93ZXIgPSBtb3Jl
IExPRCwgZmFzdGVyIGJ1dCBsZXNzIGRldGFpbA0KICAgLSBIaWdoZXIgPSBsZXNzIExPRCwgc2xv
d2VyIGJ1dCBtb3JlIGRldGFpbA0KDQo0LiAqKnNwcml0ZV9sb2RfcmF0aW8qKiAoMC42LTAuOSkN
CiAgIC0gTG93ZXIgPSBtb3JlIGltcG9zdG9ycywgZmFzdGVyIGJ1dCBsZXNzIGRldGFpbA0KICAg
LSBIaWdoZXIgPSBmZXdlciBpbXBvc3RvcnMsIHNsb3dlciBidXQgbW9yZSBkZXRhaWwNCg0KNS4g
KipGbG9vciBydW4gc2FtcGxpbmcvbWVyZ2luZyoqDQogICAtIEluY3JlYXNlIHNhbXBsaW5nIGlu
dGVydmFsIChjb2RlKSBvciByYWlzZSBtZXJnZSB0aHJlc2hvbGQgdG8gcmVkdWNlIGRyYXcgY2Fs
bHMNCg0KNi4gKipBZGFwdGl2ZSBnb3Zlcm5vciAoY29kZSkqKg0KICAgLSBTaHJpbmsgYnVkZ2V0
cyB3aGVuIGBzdGF0KDEpID4gMC45MGAsIGdyb3cgd2hlbiBgPCAwLjcwYA0KICAgLSBgYWN0aXZl
X3JheV9jb3VudGAgYm91bmRzOiA2NCAuLiBgcmF5X2NvdW50YA0KICAgLSBUdW5lIHRocmVzaG9s
ZHMvc3RlcHMgZm9yIHlvdXIgZGV2aWNlDQoNCjcuICoqdGxpbmUzZCAweDQwMCBuZWFyIGJhbmQg
KGNvZGUpKioNCiAgIC0gS2VlcCBuZWFyIGJhbmQgc21hbGw7IHdpZGVyIGJhbmQgPSBjcmlzcGVy
IG5lYXIgd2FsbHMgYnV0IG5vdGljZWFibHkgc2xvd2VyDQoNCi0tLQ0KDQojIyBGaWxlIFN0cnVj
dHVyZQ0KDQpgYGANCnJheWNhc3RfZW5naW5lX3YyLw0K4pSc4pSA4pSAIG1haW4ubHVhICAgICAg
ICAgICAgICAgICAgICAjIEVudHJ5IHBvaW50LCBnYW1lIGxvb3AsIGNvbGxpc2lvbiwgQUkNCuKU
nOKUgOKUgCBzcmMvDQrilIIgICDilJzilIDilIAgY29uZmlnLmx1YSAgICAgICAgICAgICAgIyBD
b25maWd1cmF0aW9uIChzaW5nbGUgc291cmNlIG9mIHRydXRoKQ0K4pSCICAg4pSc4pSA4pSAIHJh
eWNhc3QubHVhICAgICAgICAgICAgICMgRERBIHJheWNhc3RpbmcsIGZydXN0dW0gQUFCQg0K4pSC
ICAg4pSc4pSA4pSAIHJlbmRlci5sdWEgICAgICAgICAgICAgICMgV2FsbC9mbG9vciByZW5kZXJp
bmcsIGZvZyBtYW5hZ2VyDQrilIIgICDilJzilIDilIAgcmVuZGVyX3Nwcml0ZS5sdWEgICAgICAg
IyBTcHJpdGUgcmVuZGVyaW5nLCBkZXB0aCBidWNrZXRzDQrilIIgICDilJzilIDilIAgZG9vcl9z
eXN0ZW0ubHVhICAgICAgICAgIyBEb29yIGFuaW1hdGlvbiBhbmQgc3RhdGUNCuKUgiAgIOKUlOKU
gOKUgCBkdW5nZW9uX2dlbi5sdWEgICAgICAgICAjIFByb2NlZHVyYWwgZ2VuZXJhdGlvbg0K4pSc
4pSA4pSAIFJFQURNRS5tZCAgICAgICAgICAgICAgICAgICAjIFRoaXMgZmlsZQ0K4pSU4pSA4pSA
IG5iYWR2LnA2NCAgICAgICAgICAgICAgICAgICAjIFBpY290cm9uIGNhcnRyaWRnZQ0KYGBgDQoN
Ci0tLQ0KDQojIyBUZWNobmljYWwgRGV0YWlscw0KDQojIyMgQ29vcmRpbmF0ZSBTeXN0ZW1zDQoN
CioqV29ybGQgU3BhY2UqKjoNCi0gT3JpZ2luOiAoMCwgMCkgYXQgdG9wLWxlZnQgb2YgbWFwDQot
IFgtYXhpczogUmlnaHQNCi0gWS1heGlzOiBEb3duDQotIFVuaXRzOiAxLjAgPSAxIGdyaWQgY2Vs
bA0KDQoqKkNhbWVyYSBTcGFjZSoqOg0KLSBPcmlnaW46IFBsYXllciBwb3NpdGlvbg0KLSBaLWF4
aXM6IEZvcndhcmQgKGNhbWVyYSBkaXJlY3Rpb24pDQotIFgtYXhpczogUmlnaHQgKHBlcnBlbmRp
Y3VsYXIgdG8gZm9yd2FyZCkNCi0gWS1heGlzOiBVcCAoc2NyZWVuIHZlcnRpY2FsKQ0KDQoqKlNj
cmVlbiBTcGFjZSoqOg0KLSBPcmlnaW46ICgwLCAwKSBhdCB0b3AtbGVmdCBvZiBzY3JlZW4NCi0g
WC1heGlzOiBSaWdodCAoMC00NzkpDQotIFktYXhpczogRG93biAoMC0yNjkpDQotIENlbnRlcjog
KDI0MCwgMTM1KQ0KDQojIyMgRERBIEFsZ29yaXRobQ0KDQoqKkRpZ2l0YWwgRGlmZmVyZW50aWFs
IEFuYWx5emVyKiogLSBHcmlkIHRyYXZlcnNhbCBmb3IgcmF5Y2FzdGluZy4NCg0KKipJbml0aWFs
aXphdGlvbioqOg0KYGBgbHVhDQotLSBIb3Jpem9udGFsIHJheSAoY3Jvc3NlcyB2ZXJ0aWNhbCBn
cmlkbGluZXMpDQpoeCwgaHkgPSB4LCB5DQpoZHgsIGhkeSA9IHNnbihkeCksIGR5IC8gYWJzKGR4
KQ0KaGR6ID0gaGR4ICogZnggKyBoZHkgKiBmeSAgLS0gRGVwdGggaW5jcmVtZW50DQoNCi0tIFZl
cnRpY2FsIHJheSAoY3Jvc3NlcyBob3Jpem9udGFsIGdyaWRsaW5lcykNCnZ4LCB2eSA9IHgsIHkN
CnZkeCwgdmR5ID0gZHggLyBhYnMoZHkpLCBzZ24oZHkpDQp2ZHogPSB2ZHggKiBmeCArIHZkeSAq
IGZ5ICAtLSBEZXB0aCBpbmNyZW1lbnQNCmBgYA0KDQoqKk1hcmNoaW5nKio6DQpgYGBsdWENCmZv
ciBpdGVyPTEsIGl0ZXJhdGlvbl9saW1pdCBkbw0KICBpZiBoeiA8IHZ6IHRoZW4NCiAgICAtLSBI
b3Jpem9udGFsIGNsb3NlciwgY2hlY2sgZ3JpZCBjZWxsDQogICAgZ3ggPSBmbHIoaHgpICsgKGhk
eDwwIGFuZCAtMSBvciAwKQ0KICAgIGd5ID0gZmxyKGh5KQ0KICAgIGlmIGdldF93YWxsKGd4LCBn
eSkgPiAwIHRoZW4NCiAgICAgIHJldHVybiBoeiwgaHgsIGh5LCB0aWxlLCB0eA0KICAgIGVuZA0K
ICAgIGh4ICs9IGhkeA0KICAgIGh5ICs9IGhkeQ0KICAgIGh6ICs9IGhkeg0KICBlbHNlDQogICAg
LS0gVmVydGljYWwgY2xvc2VyLCBjaGVjayBncmlkIGNlbGwNCiAgICAtLSAuLi4gc2ltaWxhciBs
b2dpYyAuLi4NCiAgZW5kDQplbmQNCmBgYA0KDQoqKkd1YXJkcyoqOg0KMS4gKipGYXItcGxhbmUq
KjogYGlmIG1pbihoeiwgdnopID4gZmFyX3BsYW5lIHRoZW4gcmV0dXJuIG1pc3NgDQoyLiAqKkly
cmV2ZXJzaWJsZSBPT0IqKjogYGlmIChneDwwIGFuZCBoZHg8MCkgb3IgKGd4Pj1tYXBfc2l6ZSBh
bmQgaGR4PjApIHRoZW4gcmV0dXJuIG1pc3NgDQozLiAqKkl0ZXJhdGlvbiBjYXAqKjogYGl0ZXJh
dGlvbl9saW1pdCA9IG1pbigyNTYsIGhvcml6b250YWxfY3Jvc3NpbmdzICsgdmVydGljYWxfY3Jv
c3NpbmdzICsgMTApYA0KDQojIyMgRm9nIFBhbGV0dGUgU3lzdGVtDQoNCioqMTYgRm9nIExldmVs
cyoqICgwLTE1KToNCi0gTGV2ZWwgMDogTm8gZm9nIChvcmlnaW5hbCBjb2xvcnMpDQotIExldmVs
IDE1OiBNYXhpbXVtIGZvZyAobW9zdCBjb2xvcnMg4oaSIGNvbG9yIDUpDQoNCioqUGFsZXR0ZSBS
ZW1hcHBpbmcqKjoNCmBgYGx1YQ0KcGFscyA9IHsNCiAgWzFdID0gezAsMSwyLDMsNCw1LDYsNyw4
LDksMTAsMTEsMTIsMTMsMTQsMTUsLi4ufSwgIC0tIExldmVsIDANCiAgWzJdID0gezAsMSwyLDMs
NCw1LDYsNyw4LDksMTAsMTEsMTIsMTMsMTQsNSwuLi59LCAgIC0tIExldmVsIDENCiAgLi4uDQog
IFsxNl0gPSB7MCw1LDUsNSw1LDUsNSw1LDUsNSw1LDUsNSw1LDUsNSwuLi59ICAgICAgICAtLSBM
ZXZlbCAxNQ0KfQ0KYGBgDQoNCioqQXBwbGljYXRpb24qKjoNCmBgYGx1YQ0KZnVuY3Rpb24gc2V0
X2ZvZyh6KQ0KICBsb2NhbCBsZXZlbCA9IGNvbXB1dGVfZm9nX2xldmVsKHopDQogIGlmIGxldmVs
IH49IGxhc3RfZm9nX2xldmVsIHRoZW4NCiAgICBsb2NhbCBwID0gcGFsc1tsZXZlbCsxXQ0KICAg
IGZvciBpPTAsNjMgZG8NCiAgICAgIGlmIHBbaSsxXSB_PSBwcmV2X3BhbFtpXSB0aGVuDQogICAg
ICAgIHBhbChpLCBwW2krMV0pICAtLSBJbmNyZW1lbnRhbCB1cGRhdGUNCiAgICAgIGVuZA0KICAg
IGVuZA0KICBlbmQNCmVuZA0KYGBgDQoNCiMjIyBEZXB0aCBCdWZmZXINCg0KKipGcmFtZeKAkVN0
YW1wZWQgcGVy4oCRY29sdW1uIHpidWYgKG5vIHBlcuKAkWZyYW1lIGNsZWFyKSoqOg0KYGBgbHVh
DQotLSBSZWFkICgraW5mIGlmIG5vdCB3cml0dGVuIHRoaXMgZnJhbWUpLiBPbmUgeiBwZXIgc2Ny
ZWVuIGNvbHVtbiAoeCkuDQpmdW5jdGlvbiB6cmVhZCh4KQ0KICByZXR1cm4gKHpzdGFtcFt4XT09
ZnJhbWVfaWQpIGFuZCB6YnVmW3hdIG9yIDk5OQ0KZW5kDQotLSBXcml0ZSArIHN0YW1wIChjb2x1
bW4geikNCmZ1bmN0aW9uIHp3cml0ZSh4LCB6KQ0KICB6YnVmW3hdID0geg0KICB6c3RhbXBbeF0g
PSBmcmFtZV9pZA0KZW5kDQpgYGANCldhbGxzIGNhbGwgYHp3cml0ZWAgcGVyIHBpeGVsIGFmdGVy
IGRyYXdpbmcgdGhlIGNvbHVtbjsgc3ByaXRlcyB0ZXN0IGB6IDwgenJlYWQocHgpYCBiZWZvcmUg
ZHJhd2luZyBhIGNvbHVtbiBhbmQgdGhlbiBgendyaXRlYCBvbiBzdWNjZXNzLg0KDQojIyMgU3Bh
dGlhbCBHcmlkcw0KDQoqKm9iamdyaWQqKiAtIDI2w5cyNiBncmlkIG9mIG9iamVjdCBsaXN0czoN
CmBgYGx1YQ0Kb2JqZ3JpZFtneCsxXVtneSsxXSA9IHtvYjEsIG9iMiwgLi4ufSAgLS0gMS1iYXNl
ZCBpbmRleGluZw0KYGBgDQotIENlbGwgc2l6ZTogNcOXNSB3b3JsZCB1bml0cw0KLSBGYXN0IHNw
YXRpYWwgcXVlcmllcyBmb3IgcmVuZGVyaW5nIGFuZCBjb2xsaXNpb24NCg0KKipkb29yZ3JpZCoq
IC0gMTI4w5cxMjggZ3JpZCBvZiBkb29yIHN0YXRlczoNCmBgYGx1YQ0KZG9vcmdyaWRbeF1beV0g
PSB7b3Blbj0wLjUsIG9wZW5pbmc9dHJ1ZSwgY2xvc2VfdGltZXI9OTB9DQpgYGANCi0gVHJhY2tz
IGRvb3IgYW5pbWF0aW9uIHN0YXRlDQotIFN5bmNocm9uaXplZCB3aXRoIGBtYXAud2FsbHNgIGxh
eWVyDQoNCi0tLQ0KDQojIyBEZXZlbG9wbWVudCAmIERlYnVnZ2luZw0KDQojIyMgVXNlciBJbnRl
cmZhY2UNCg0KLSAqKkhVRCoqOiBQb3NpdGlvbiwgYW5nbGUsIEZQUywgSFAuIEludGVyYWN0aW9u
IHByb21wdCBhcHBlYXJzIHdoZW4gYW4gaW50ZXJhY3RhYmxlIGlzIGluIHJhbmdlLiBDb21iYXQg
b3ZlcmxheSBkaXNwbGF5cyBkdXJpbmcgZW5jb3VudGVycy4gIA0KLSAqKkRlYnVnICYgRGlhZ25v
c3RpY3MgUGFuZWwgKFRhYikqKjogQ29uc29saWRhdGVkIG9uLXNjcmVlbiBjb3VudGVycyAoRERB
IHN0ZXBzLCBlYXJseS1vdXRzLCBmb2cgc3dpdGNoZXMsIHdhbGwgY29sdW1ucywgZmxvb3Igcm93
cywgZmxvb3IgZHJhdyBjYWxscywgc3ByaXRlIGNvbHVtbnMsIEZQUywgZnJhbWUpIGluIGEgaGln
aC1jb250cmFzdCBwYW5lbCB3aXRoIG1hcmdpbnMuICANCi0gKipEaWFnbm9zdGljcyBMb2dnaW5n
IChCdXR0b24gMTIpKio6IFBlcmlvZGljIGBwcmludGhgIHN1bW1hcnkgZXZlcnkgNjAgZnJhbWVz
IChpbmNsdWRlcyBDUFUlKS4gIA0KLSAqKk1pbmltYXAqKjogIA0KICAtIEZ1bGwgMkQgbWluaW1h
cDogcHJlc3MgWCAoZGVidWcgbW9kZSkgdG8gdG9nZ2xlIGJldHdlZW4gYDNkYCBhbmQgYDJkYCB2
aWV3cy4gIA0KICAtIEhVRCBtaW5pbWFwOiBhdXRvLXNjcm9sbGluZyBjbGlwcGVkIHZpZXdwb3J0
IGluIDNEIHZpZXcgKHdhbGxzL2Zsb29ycy9kb29ycy9vYmplY3RzL3BsYXllcikuICANCi0gKipE
b29yIFRlc3QgTW9kZSoqOiBQcmVzcyBWIHRvIHRvZ2dsZS4gV2hpbGUgYWN0aXZlLCBDL0QgYWRq
dXN0IGZvcmNlZCBvcGVuIGFtb3VudC4gV2hlbiBub3QgaW4gdGVzdCBtb2RlLCBDIGN5Y2xlcyBm
bG9vciB0eXBlOyBEIGN5Y2xlcyByb29mIHR5cGUuDQoNCiMjIyBEdW5nZW9uIExhYiAmIFRlc3Qg
SGFybmVzcw0KDQotIFRoZSBzdGFydHVwIGZsb3cgbm93IG9wZW5zIGEgbWFpbiBtZW51LiBDaG9v
c2UgKipEdW5nZW9uIExhYioqIHRvIGVudGVyIGEgZGVkaWNhdGVkIGdlbmVyYXRpb24gc2FuZGJv
eCB3aXRoIGFuIG92ZXJoZWFkIDJEIHZpc3VhbGl6YXRpb24uDQotIENvbnRyb2xzOiBgWmAgbmV3
IHJhbmRvbSBzZWVkLCBgWGAgcmVwbGF5IGN1cnJlbnQgc2VlZCwgYOKGkC-ihpJgIHR3ZWFrIHNl
ZWQgbnVtZXJpY2FsbHksIGBIYCBydW4gdGhlIGRldGVybWluaXN0aWMgaGFybmVzcywgYEovS2Ag
c2Nyb2xsIGdlbmVyYXRpb24gbG9ncywgYE1gIHJldHVybiB0byB0aGUgbWVudS4NCi0gVGhlIGhh
cm5lc3MgKGB0ZXN0cy9kdW5nZW9uX2hhcm5lc3MubHVhYCkgcmVnZW5lcmF0ZXMgYSBzZWVkZWQg
c3VpdGUsIHZhbGlkYXRpbmcgcm9vbSBjb3VudHMsIGxvY2tlZCBkb29yIHRpbGVzLCBhbmQga2V5
IGRpc3RyaWJ1dGlvbjsgdGhlIHN1bW1hcnkgaXMgc2hvd24gaW4gdGhlIGxhYiBzaWRlYmFyLg0K
LSBSZWNlbnQgZ2VuZXJhdGlvbiBoaXN0b3J5IChkb29yIHBsYWNlbWVudHMsIHNwYWNpbmcgcmVs
YXhhdGlvbnMsIHByb2dyZXNzaW9uIGV2ZW50cykgaXMgc3VyZmFjZWQgdmlhIGBnZW5fb2JzZXJ2
YWJpbGl0eWAgYW5kIHJlbmRlcmVkIGluIHRoZSBzaWRlYmFyIHRvIGFpZCByZWdyZXNzaW9uIGh1
bnRpbmcuDQoNCiMjIyBEaWFnbm9zdGljIFN5c3RlbQ0KDQoqKlRvZ2dsZSBLZXlzIC8gQnV0dG9u
cyoqOg0KLSAqKlRhYioqOiBUb2dnbGUgY29uc29saWRhdGVkIGRlYnVnICYgZGlhZ25vc3RpY3Mg
cGFuZWwNCi0gKipCdXR0b24gMTIqKjogVG9nZ2xlIHBlcmlvZGljIHByaW50aCBsb2dnaW5nDQoN
CioqT24tU2NyZWVuIERpc3BsYXkqKiAoQ29uc29saWRhdGVkIFBhbmVsKToNCmBgYA0KPT09IERJ
QUdOT1NUSUNTID09PQ0KRERBIHN0ZXBzL3JheTogOC4zDQpFYXJseS1vdXRzOiAxMg0KRm9nIHN3
aXRjaGVzOiA3DQpXYWxsIGNvbHVtbnM6IDQ4MA0KRmxvb3Igcm93czogMTM1DQpTcHJpdGUgY29s
dW1uczogMTU2DQpGUFM6IDU4DQpGcmFtZTogMzYwMA0KYGBgDQoNCioqUGVyaW9kaWMgTG9nZ2lu
ZyoqIChldmVyeSA2MCBmcmFtZXMsIHdoZW4gZW5hYmxlZCk6DQpgYGANCj09PSBGUkFNRSAzNjAw
IERJQUdOT1NUSUNTID09PQ0KQXZnIEREQSBzdGVwcy9yYXk6IDguMw0KRWFybHktb3V0czogMTIN
CkZvZyBzd2l0Y2hlczogNw0KV2FsbCBjb2x1bW5zOiA0ODANCkZsb29yIHJvd3M6IDEzNQ0KU3By
aXRlIGNvbHVtbnM6IDE1Ng0KRlBTOiA1OA0KQ1BVOiA0MiUNCmBgYA0KDQoqKkxldmVsIExvYWQg
U3VtbWFyeSoqOg0KYGBgDQo9PT0gTEVWRUwgTE9BRCBESUFHTk9TVElDUyA9PT0NCkZsb29yOiAz
DQpEaWZmaWN1bHR5OiAzDQpSb29tczogMTINCk9iamVjdHM6IDQ3DQpTZWVkOiAxMjM0NQ0KYGBg
DQoNCiMjIyBEZWJ1ZyBNb2Rlcw0KDQoqKlRlc3QgRG9vciBNb2RlKiogKGNvbmZpZy5sdWEpOg0K
YGBgbHVhDQp0ZXN0X2Rvb3Jfb3BlbiA9IDAuNSAgLS0gRm9yY2UgYWxsIGRvb3JzIHRvIDUwJSBv
cGVuDQp0ZXN0X2Rvb3JfeCA9IDEwICAgICAgLS0gT25seSBhZmZlY3QgZG9vciBhdCAoMTAsIHkp
DQp0ZXN0X2Rvb3JfeSA9IDE1ICAgICAgLS0gT25seSBhZmZlY3QgZG9vciBhdCAoeCwgMTUpDQpg
YGANCg0KKipNaW5pbWFwKio6DQotICoqWCoqOiBUb2dnbGUgZnVsbCAyRCBtaW5pbWFwICh3aGVu
IGRlYnVnX21vZGUgZW5hYmxlZCkNCi0gU2hvd3Mgd2FsbHMsIGZsb29ycywgZG9vcnMsIG9iamVj
dHMsIHBsYXllcg0KDQoqKkRlYnVnIFJheWNhc3QgT3V0cHV0Kio6DQotIFByaW50cyByYXkgaGl0
IGRhdGEgd2hlbiBgZGVidWdfbW9kZT10cnVlYA0KLSBTaG93cyB0aWxlIElEcywgZGVwdGhzLCB0
ZXh0dXJlIGNvb3JkaW5hdGVzDQoNCiMjIyBQZXJmb3JtYW5jZSBQcm9maWxpbmcNCg0KKipJZGVu
dGlmeSBCb3R0bGVuZWNrcyoqOg0KMS4gRW5hYmxlIGRpYWdub3N0aWNzIChHKQ0KMi4gTW9uaXRv
ciBjb3VudGVycyBhY3Jvc3MgZGlmZmVyZW50IHNjZW5lczoNCiAgIC0gQ29ycmlkb3JzOiBIaWdo
IHdhbGwgY29sdW1ucywgbG93IHNwcml0ZSBjb2x1bW5zDQogICAtIFJvb21zOiBMb3cgd2FsbCBj
b2x1bW5zLCBoaWdoIHNwcml0ZSBjb2x1bW5zDQogICAtIE9wZW4gYXJlYXM6IEhpZ2ggZWFybHkt
b3V0cywgbG93IHdhbGwgY29sdW1ucw0KDQoqKlR1bmUgQ29uZmlndXJhdGlvbioqOg0KMS4gSWYg
RlBTIDwgNTA6DQogICAtIFJlZHVjZSBgcmF5X2NvdW50YCAoMTI4IOKGkiA5NiDihpIgODApDQog
ICAtIExvd2VyIGB3YWxsX2xvZF9yYXRpb2AgKDAuNCDihpIgMC4zKQ0KICAgLSBEaXNhYmxlIGBw
ZXJfY2VsbF9mbG9vcnNfZW5hYmxlZGANCg0KMi4gSWYgRlBTID4gNjA6DQogICAtIEluY3JlYXNl
IGByYXlfY291bnRgICgxMjgg4oaSIDE2MCDihpIgMTkyKQ0KICAgLSBSYWlzZSBgd2FsbF9sb2Rf
cmF0aW9gICgwLjQg4oaSIDAuNikNCg0KKipXYXRjaCBmb3IgUmVncmVzc2lvbnMqKjoNCi0gRm9n
IHN3aXRjaGVzID4gMjAvZnJhbWU6IEluY3JlYXNlIGBmb2dfaHlzdGVyZXNpc2ANCi0gRERBIHN0
ZXBzL3JheSA_IDE1OiBDaGVjayBmb3IgbWlzc2luZyBlYXJseS1vdXRzDQotIFdhbGwgY29sdW1u
cyA_IDYwMDogQ2hlY2sgTE9EIHRocmVzaG9sZA0KLSBTcHJpdGUgY29sdW1ucyA_IDMwMDogQ2hl
Y2sgZnJ1c3R1bSBjdWxsaW5nDQoNCiMjIyBDb21tb24gSXNzdWVzDQoNCioqQmxhbmsgQ29sdW1u
cyoqOg0KLSBDYXVzZTogYHJheV9jb3VudGAgbm90IGRpdmlkaW5nIGBzY3JlZW5fd2lkdGhgIGV2
ZW5seQ0KLSBGaXg6IFNwYW4gY29tcHV0YXRpb24gaGFuZGxlcyB0aGlzIGF1dG9tYXRpY2FsbHkN
Cg0KKipTcHJpdGUgUG9wcGluZyoqOg0KLSBDYXVzZTogYGZhcl9wbGFuZSA8IGZvZ19mYXJgDQot
IEZpeDogRW5zdXJlIGBmYXJfcGxhbmUgPj0gZm9nX2ZhciArIDIuMGANCg0KKipUZXh0dXJlIFNl
YW1zKio6DQotIENhdXNlOiBVLWludGVycG9sYXRpb24gYWNyb3NzIGRpZmZlcmVudCB0aWxlcw0K
LSBGaXg6IE9ubHkgaW50ZXJwb2xhdGUgd2hlbiBjb25zZWN1dGl2ZSByYXlzIGhpdCBzYW1lIHRp
bGUNCg0KKipEZWdlbmVyYXRlIEJvdW5kcyoqOg0KLSBDYXVzZTogTm8gd2FsbCBoaXRzIGluIG9w
ZW4gc2NlbmVzDQotIEZpeDogRnJ1c3R1bSBBQUJCIHByb3ZpZGVzIGluZGVwZW5kZW50IHNwcml0
ZSBjdWxsaW5nDQoNCioqUGFsZXR0ZSBUaHJhc2hpbmcqKjoNCi0gQ2F1c2U6IEZyZXF1ZW50IGZv
ZyBsZXZlbCBjaGFuZ2VzDQotIEZpeDogSW5jcmVhc2UgYGZvZ19oeXN0ZXJlc2lzYCBvciByZWR1
Y2UgZm9nIGxldmVscw0KDQotLS0NCg0KIyMgQXNzZXQgU3BlY2lmaWNhdGlvbnMNCg0KLSAqKldh
bGwgdGV4dHVyZXMqKjogMzLDlzMyIHNwcml0ZXMgcmVmZXJlbmNlZCBieSBgdGV4c2V0c2AgKGUu
Zy4sIGBnZngvMF93YWxscy5nZnhgIGluZGljZXMpLiAgDQogIC0gT3BhcXVlOyByZW5kZXJlZCB2
aWEgYHRsaW5lM2RgIG9yIHNvbGlkLWNvbG9yIExPRCBiZXlvbmQgYHdhbGxfbG9kX2Rpc3RhbmNl
YCAoYGZvZ19mYXIgKiB3YWxsX2xvZF9yYXRpb2ApLiAgDQogIC0gQ29uZmlndXJlIHNldHMgYW5k
IHZhcmlhbnRzIGluIGBzcmMvY29uZmlnLmx1YTogdGV4c2V0c2AuDQoNCi0gKipDZWlsaW5nIHRl
eHR1cmVzKio6IDMyw5czMiBzcHJpdGVzIHJlZmVyZW5jZWQgYnkgYHBsYW5ldHlwc2AgKHR5cGlj
YWxseSBpbmRpY2VzIDM04oCTMzYpLiAgDQogIC0gT3B0aW9uYWwgc2Nyb2xsaW5nIHZpYSBgeHZl
bC95dmVsYDsgZm9nIGFwcGxpZWQgcGVyIHNjYW5saW5lLiAgDQogIC0gQ29uZmlndXJlIGluIGBz
cmMvY29uZmlnLmx1YTogcGxhbmV0eXBzYC4NCg0KLSAqKkZsb29yIHRleHR1cmVzKio6IDMyw5cz
MiBzcHJpdGVzIHJlZmVyZW5jZWQgYnkgYHBsYW5ldHlwc2AgKHR5cGljYWxseSBpbmRpY2VzIDMy
4oCTMzMpLiAgDQogIC0gU3VwcG9ydHMgcGVyLWNlbGwgZmxvb3IgdHlwaW5nIHZpYSBgbWFwLmZs
b29yc2AgaWYgYHBlcl9jZWxsX2Zsb29yc19lbmFibGVkPXRydWVgLiAgDQogIC0gQ29uZmlndXJl
IGluIGBzcmMvY29uZmlnLmx1YTogcGxhbmV0eXBzYC4NCg0KLSAqKkRvb3IgdGV4dHVyZXMqKjog
MzLDlzMyIHNwcml0ZXMgKGBkb29yX25vcm1hbGAsIGBkb29yX2xvY2tlZGAsIGBkb29yX3N0YXlf
b3BlbmApLiAgDQogIC0gQmVoYXZpb3IgZGV0ZXJtaW5lZCBieSB0eXBlOyBsb2NrZWQgZG9vcnMg
bWF5IGNhcnJ5IGBrZXludW1gLiAgDQogIC0gQ29uZmlndXJlIElEcyBpbiBgc3JjL2NvbmZpZy5s
dWFgIGFuZCBjcmVhdGUgYXQgZ2VuZXJhdGlvbiB3aXRoIGBjcmVhdGVfZG9vcmAuDQoNCi0gKipT
cGF3bmFibGUgb2JqZWN0cyAoaXRlbXMsIGRlY29yYXRpb25zKSoqOiAzMsOXMzIgc3ByaXRlcy4g
IA0KICAtIERlZmluaXRpb25zIGluIGBvYmpfdHlwZXNgIGFuZCBgZGVjb3JhdGlvbl90eXBlc2A7
IGFuaW1hdGVkIG9iamVjdHMgdXNlIHNlcXVlbnRpYWwgaW5kaWNlcyB3aXRoIGBmcmFtZWN0L2Fu
aW1zcGRgLiAgDQogIC0gUGxhY2UgdmlhIGdlbmVyYXRvciAoYGdlbmVyYXRlX2l0ZW1zYCwgYGdl
bmVyYXRlX2RlY29yYXRpb25zYCkuDQoNCi0gKipOUENzL2VuZW1pZXMqKjogMzLDlzMyIHNwcml0
ZXMuICANCiAgLSBFbnRyaWVzIGluIGBlbmVteV90eXBlc2AgKHNwcml0ZSBpbmRpY2VzIDY04oCT
NzIgYnkgZGVmYXVsdCkuIEFuaW1hdGlvbiB1c2VzIHNlcXVlbnRpYWwgaW5kaWNlcyB3aGVuIGBm
cmFtZWN0PjFgLg0KDQojIyMgRm9ybWF0cywgUGFsZXR0ZXMsIGFuZCBUcmFuc3BhcmVuY3kNCi0g
QXNzZXRzIGFyZSByZXNvbHZlZCBieSBzcHJpdGUgaW5kZXggdmlhIGBnZXRfc3ByKClgLiBBdXRo
b3IgdGhlbSBpbiBQaWNvdHJvbiBHRlggYmFua3MuICANCi0gVHJhbnNwYXJlbmN5OiBjb2xvciAx
NCBpcyB0cmVhdGVkIHRyYW5zcGFyZW50IGZvciBzcHJpdGVzIChgcGFsdCgxNCx0cnVlKWAgZHVy
aW5nIHNwcml0ZSByZW5kZXJpbmcpLiBXYWxscy9mbG9vcnMvY2VpbGluZ3MgcmVuZGVyIG9wYXF1
ZS4gIA0KLSBEaXN0YW5jZSBmb2cgdXNlcyA2NC1jb2xvciBwYWxldHRlIHJlbWFwcyAoYHBhbHNg
IHdpdGggMTYgZm9nIGxldmVscykuDQoNCiMjIyBDb25maWd1cmF0aW9uIFRvdWNocG9pbnRzIChg
c3JjL2NvbmZpZy5sdWFgKQ0KLSBgc3ByaXRlX3NpemVgIChkZWZhdWx0IDMyKTogZ2xvYmFsIHNw
cml0ZSBzYW1wbGluZyBzaXplLiAgDQotIGB0ZXhzZXRzYCwgYHBsYW5ldHlwc2A6IHdhbGwvZmxv
b3IvY2VpbGluZyB0ZXh0dXJlIGluZGljZXMgYW5kIHByb3BlcnRpZXMuICANCi0gYGVuZW15X3R5
cGVzYCwgYGRlY29yYXRpb25fdHlwZXNgLCBgb2JqX3R5cGVzYDogc3ByaXRlIGluZGljZXMgYW5k
IGJlaGF2aW9yIGZvciBzcGF3bmVkIGNvbnRlbnQuICANCi0gYHBhbHNgLCBgZm9nX25lYXJgLCBg
Zm9nX2ZhcmAsIGBmb2dfaHlzdGVyZXNpc2A6IGZvZyBiZWhhdmlvciBhbmQgcGFsZXR0ZSB0YWJs
ZXMuICANCi0gYHdhbGxfbG9kX3JhdGlvYCwgYHNwcml0ZV9sb2RfcmF0aW9gLCBgcm93X3N0cmlk
ZWAgKGtlcHQgYXQgMSksIGBwZXJfY2VsbF9mbG9vcnNfZW5hYmxlZGA6IHBlcmZvcm1hbmNlL3F1
YWxpdHkgY29udHJvbHMuDQoNCi0tLQ0KDQojIyBDcmVkaXRzICYgTGljZW5zZQ0KDQoqKkVuZ2lu
ZSoqOiBQaWNvdHJvbiBSYXljYXN0IEVuZ2luZSAgDQoqKlBsYXRmb3JtKio6IFBpY290cm9uIChM
ZXhhbG9mZmxlIEdhbWVzKSAgDQoqKkxhbmd1YWdlKio6IEx1YSA1LjQgIA0KKipBcmNoaXRlY3R1
cmUqKjogUmF5Y2FzdGluZyB3aXRoIG1vZGVybiBvcHRpbWl6YXRpb25zICANCg0KKipLZXkgSW5u
b3ZhdGlvbnMqKjoNCi0gRGVjb3VwbGVkIHJheV9jb3VudCBhcmNoaXRlY3R1cmUNCi0gVW5pZmll
ZCBmb2cgc3lzdGVtIHdpdGggaHlzdGVyZXNpcw0KLSBGcnVzdHVtLWJhc2VkIHNwcml0ZSBjdWxs
aW5nDQotIERlcHRoLWJ1Y2tldCBzb3J0aW5nDQotIFBlci1jZWxsIGZsb29yIHJlbmRlcmluZw0K
LSBDb21wcmVoZW5zaXZlIGRpYWdub3N0aWNzDQoNCioqUmVmZXJlbmNlcyoqOg0KLSBMb2RlJ3Mg
Q29tcHV0ZXIgR3JhcGhpY3MgVHV0b3JpYWwgKHJheWNhc3RpbmcgZnVuZGFtZW50YWxzKQ0KLSBX
b2xmZW5zdGVpbiAzRCAob3JpZ2luYWwgcmF5Y2FzdGluZyBnYW1lKQ0KLSBEb29tIChkZXB0aC1i
dWNrZXQgc29ydGluZyBpbnNwaXJhdGlvbikNCg0KLS0tDQoNCiMjIEFwcGVuZGl4OiBQZXJmb3Jt
YW5jZSBCdWRnZXQgQnJlYWtkb3duDQoNCiMjIyBGcmFtZSBCdWRnZXQgKDYwIEZQUyA9IDE2LjY3
bXMpDQoNCnwgU3lzdGVtIHwgQnVkZ2V0IHwgQWN0dWFsIHwgTm90ZXMgfA0KfC0tLS0tLS0tfC0t
LS0tLS0tfC0tLS0tLS0tfC0tLS0tLS18DQp8IFJheWNhc3RpbmcgfCA2bXMgfCA0LTVtcyB8IERE
QSBndWFyZHMgcHJldmVudCBzcGlrZXMgfA0KfCBGbG9vcnMgfCA0bXMgfCAzLTRtcyB8IFN0cmlk
ZT0yIGhhbHZlcyBjb3N0IHwNCnwgV2FsbHMgfCA1bXMgfCA0LTVtcyB8IExPRCByZWR1Y2VzIGRp
c3RhbnQgd2FsbHMgfA0KfCBTcHJpdGVzIHwgM21zIHwgMi0zbXMgfCBGcnVzdHVtIGN1bGxpbmcs
IGRlcHRoIGJ1Y2tldHMgfA0KfCBIVUQgfCAxbXMgfCAxbXMgfCBNaW5pbWFsIG92ZXJoZWFkIHwN
CnwgKipUb3RhbCoqIHwgKioxOW1zKiogfCAqKjE0LTE4bXMqKiB8ICoqfjItM21zIG1hcmdpbioq
IHwNCg0KIyMjIE9wdGltaXphdGlvbiBJbXBhY3QNCg0KfCBPcHRpbWl6YXRpb24gfCBFZmZlY3Qg
fA0KfC0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tfA0KfCBEREEgZ3VhcmRzIHwgQm91bmRzIHdvcnN0
LWNhc2UgdHJhdmVyc2FsOyByZWR1Y2VzIHN0ZXAgc3Bpa2VzIHwNCnwgRm9nIGh5c3RlcmVzaXMg
fCBEcmFtYXRpY2FsbHkgbG93ZXJzIHBhbGV0dGUgb3BzL2ZyYW1lIHwNCnwgRmxvb3Igc3RyaWRl
IHwgSGFsdmVzIHNjYW5saW5lIGB0bGluZTNkYCB3b3JrIGF0IHN0cmlkZT0yIHwNCnwgV2FsbCBM
T0QgfCBSZWR1Y2VzIGRpc3RhbnQgd2FsbCBgdGxpbmUzZGAgd29yayB8DQp8IFNwcml0ZSBMT0Qg
fCBSZWR1Y2VzIGRpc3RhbnQgc3ByaXRlIGRyYXcgY29zdCB8DQp8IERlcHRoIGJ1Y2tldHMgfCBB
dm9pZHMgTyhuwrIpIHNvcnRzIGF0IGhpZ2hlciBzcHJpdGUgY291bnRzIHwNCg0KLS0t
:: src/docs/RenderPipeline.md
b64$IyMgR3VpZGluZyBDb25zdHJhaW50cw0KDQotICoqUmVuZGVyZXItZmlyc3QgcmV3cml0ZSoq
OiBgbWFpbi5sdWFgIGFuZCB0aGUgZ2VuZXJhdG9yIGRlbGl2ZXIgYSBzaW5nbGUgZGF0YSBsYXlv
dXQ7IHJlbmRlcmVyIG1vZHVsZXMgY29uc3VtZSBpdCBkaXJlY3RseSBhbmQgZXhwb3NlIGEgbmFy
cm93IEFQSSBiYWNrLg0KLSAqKlplcm8tY29zdCBkaWFnbm9zdGljcyoqOiB3aGVuIGBkZWJ1Z19t
b2RlPWZhbHNlYCBubyBjb3VudGVycywgdGFibGVzLCBvciBzdHJpbmdzIGFyZSB0b3VjaGVkOyBg
cl9kaWFnYCBpcyB0aGUgb25seSBtb2R1bGUgYWxsb3dlZCB0byBhc3NlbWJsZSBkaWFnbm9zdGlj
cyBhbmQgb25seSB3aGVuIHRvZ2dsZWQgb24uDQotICoqRGVkaWNhdGVkIG1lbW9yeSBtYW5hZ2Vt
ZW50Kio6IGFsbCBsYXJnZSBhcnJheXMgYXJlIGFsbG9jYXRlZCBvbmNlIGluIGByX3N0YXRlYCB1
c2luZyBgdXNlcmRhdGEoLi4uKWAgYW5kIGtlcHQgc3RhYmxlIGFjcm9zcyBmcmFtZXM7IHRlYXJk
b3duIGNsZWFycyByZWZlcmVuY2VzIHRvIGFsbG93IEdDIG9uIHJlbG9hZC4NCi0gKipVbmlmaWVk
IGJhdGNoaW5nKio6IGByX2JhdGNoYCBvd25zIGV2ZXJ5IGB0bGluZTNkYC9gcmVjdGZpbGxgIGJ1
ZmZlcjsgbm8gb3RoZXIgbW9kdWxlIGJ1aWxkcyBhZC1ob2MgYmF0Y2hlcyBvciBtdXRhdGVzIGRy
YXcgc3RhdGUgZGlyZWN0bHkuDQotICoqRGV0ZXJtaW5pc3RpYyBmcmFtZSBvcmRlcioqOiBjbGVh
ciDihpIgZmxvb3IvY2VpbGluZyDihpIgd2FsbHMg4oaSIHNwcml0ZXMg4oaSIGRpYWdub3N0aWNz
IHdpdGggYSBzaW5nbGUgY2xpcC9wYWxldHRlIGNvbmZpZ3VyYXRpb24gcGVyIHBhc3MgdG8gbWlu
aW1pc2Ugc3RhdGUgY2h1cm4uDQoNCi0tLQ0KDQojIyBGaW5hbCBSZW5kZXJlciBCbHVlcHJpbnQg
KHYyKQ0KDQojIyMgTW9kdWxlcw0KDQp8IE1vZHVsZSB8IFB1cnBvc2UgfCBOb3RlcyB8DQp8LS0t
LS0tLS18LS0tLS0tLS0tfC0tLS0tLS18DQp8IGByX3N0YXRlLmx1YWAgfCBPd25zIHJlbmRlcmVy
IGNvbmZpZywgbWFwcyBhbGwgdXNlcmRhdGEgYnVmZmVycywgdHJhY2tzIG9jY3VwYW5jeSBjb3Vu
dGVycywgZXhwb3NlcyBhY2Nlc3NvciBoZWxwZXJzLiB8IE9uZS10aW1lIHNldHVwIGluIGBfaW5p
dCgpYDsgcHJvdmlkZXMgYHByZXBhcmVfZnJhbWUoKWAgdG8gemVybyBjb3VudGVycyB3aXRoIGB1
c2VyZGF0YTpmaWxsYC4gfA0KfCBgcl9iYXRjaC5sdWFgIHwgQ2VudHJhbCBiYXRjaGluZyBmb3Ig
YHRsaW5lM2RgIGFuZCBgcmVjdGZpbGxgLCBhcHBsaWVzIGNsaXAvcGFsZXR0ZSBwb2xpY3kgcGVy
IHBhc3MuIHwgRW5zdXJlcyBkcmF3cyBhcmUgZmx1c2hlZCBvbmx5IHdoZW4gY2FwYWNpdHkgcmVh
Y2hlZCBvciBvbiBleHBsaWNpdCBzdWJtaXQuIHwNCnwgYHJfdmlldy5sdWFgIHwgQ29tcHV0ZXMg
Y2FtZXJhIGJhc2lzIGFuZCByYXkgZGlyZWN0aW9uIExVVHMuIHwgUmVidWlsZHMgbG9va3VwIHRh
YmxlcyBvbmx5IHdoZW4gcmF5IGNvdW50IGNoYW5nZXM7IHJldXNlcyBjYWNoZWQgdHJpZyAoR3Vp
ZGVsaW5lIMKnOSkuIHwNCnwgYHJfY2FzdC5sdWFgIHwgRERBIHJheWNhc3RlciB3cml0aW5nIGhp
dCBkYXRhIChgcmF5X3RpbGVgLCBgcmF5X3pgLCBgcmF5X3R4YCwgYHJheV9oaXR4YCwgYHJheV9o
aXR5YCkuIHwgQ29uc3VtZXMgbWFwL2Rvb3IgZGF0YSBhcy1pczsgbm8gdGFibGUgYWxsb2NhdGlv
bnMgaW4gdGhlIGhvdCBwYXRoLiB8DQp8IGByX2Zsb29yLmx1YWAgfCBIeWJyaWQgZmxvb3IvY2Vp
bGluZyByZW5kZXJlciB3aXRoIG5lYXIvbWlkL2ZhciByb3cgc2NoZWR1bGluZyBhbmQgYGJsaXQo
KWAgZHVwbGljYXRpb24uIHwgRGVsZWdhdGVzIGV2ZXJ5IGRyYXcgdG8gYHJfYmF0Y2hgOyBkdXBs
aWNhdGlvbiBzY2hlZHVsZSB0dW5lZCB0byBoaXQgcm93LWNvdW50IGJ1ZGdldC4gfA0KfCBgcl93
YWxscy5sdWFgIHwgU3BhbiBiYXRjaGVyIG1lcmdpbmcgcmF5cyBieSB0aWxlLCBjaG9vc2luZyB0
ZXh0dXJlZCB2cyBMT0QgcGF0aC4gfCBSZXNvbHZlcyB0ZXh0dXJlcyB2aWEgY2FjaGUsIHB1c2hl
cyBzcGFucyB0byBgcl9iYXRjaGAsIHVwZGF0ZXMgei1idWZmZXIgdXNlcmRhdGEuIHwNCnwgYHJf
c3ByaXRlcy5sdWFgIHwgRGVwdGgtYnVja2V0ZWQgc3ByaXRlIHJlbmRlcmVyIHdpdGggaW1wb3N0
b3IgZmFsbGJhY2suIHwgQnVja2V0cyBzdG9yZWQgaW4gdXNlcmRhdGEgc2xhYnMgcGVyIE9wdGlt
aXphdGlvbkd1aWRlbGluZXMgwqc1OyBvbmx5IGByX2RpYWdgIHRvdWNoZXMgc3RhdHMuIHwNCnwg
YHJfZGlhZy5sdWFgIHwgRGlhZ25vc3RpY3Mgb3ZlcmxheSBnYXRlZCBieSBgZGVidWdfbW9kZWAu
IHwgUHVsbHMgcGVyLWZyYW1lIHN0YXRzIHNuYXBzaG90IGZyb20gYHJfc3RhdGVgIGFuZCByZW5k
ZXJzIG92ZXJsYXkgd2l0aG91dCBhZmZlY3RpbmcgbWFpbiBwYXNzZXMuIHwNCg0KIyMjIEZyYW1l
IEZsb3cNCg0KMS4gYHJfc3RhdGUucHJlcGFyZV9mcmFtZSgpYCBjbGVhcnMgb2NjdXBhbmN5IGNv
dW50ZXJzIGFuZCBzdGFtcHMgdGhlIHotYnVmZmVyLg0KMi4gYHJfdmlldy51cGRhdGUoY2FtZXJh
KWAgcmVmcmVzaGVzIGNhbWVyYSBiYXNpcyBhbmQgcmF5IGRpcmVjdGlvbnMgaWYgcmF5IGNvdW50
IGNoYW5nZWQuDQozLiBgcl9jYXN0LmNhc3Rfc2NlbmUoKWAgcnVucyBEREEgb25jZSwgcG9wdWxh
dGluZyByYXkgYnVmZmVycyBhbmQgb3B0aW9uYWwgc3RhdHMuDQo0LiBgcl9mbG9vci5kcmF3X2Zs
b29yX2NlaWxpbmcoKWAgcmVuZGVycyBuZWFyL21pZC9mYXIgYmFuZHMgdXNpbmcgYHJfYmF0Y2hg
ICsgYGJsaXQoKWAgZHVwbGljYXRpb24gc2NoZWR1bGUuDQo1LiBgcl93YWxscy5kcmF3X3NwYW5z
KClgIG1lcmdlcyByYXlzIGludG8gc3BhbnMsIHNlbGVjdHMgTE9EL3RleHR1cmVkIHBhdGgsIHVw
ZGF0ZXMgei1idWZmZXIuDQo2LiBgcl9zcHJpdGVzLmRyYXcoKWAgdHJhbnNmb3JtcyBlbnRpdGll
cywgZmlsbHMgdXNlcmRhdGEgYnVja2V0cywgcmVuZGVycyBmYXLihpJuZWFyIHdpdGggaW1wb3N0
b3IgZmFsbGJhY2suDQo3LiBgcl9kaWFnLmRyYXcoc3RhdHMpYCByZW5kZXJzIG92ZXJsYXkgb25s
eSB3aGVuIGBkZWJ1Z19tb2RlPXRydWVgLCByZXN0b3JpbmcgcGFsZXR0ZS9jbGlwIGFmdGVyd2Fy
ZHMuDQoNCiMjIyBEYXRhIFN0cnVjdHVyZXMgKG1lbW1hcC1vd25lZCkNCg0KfCBCdWZmZXIgfCBU
eXBlIHwgU2l6ZSB8DQp8LS0tLS0tLS18LS0tLS0tfC0tLS0tLXwNCnwgYHJheV9kaXJfeGAsIGBy
YXlfZGlyX3lgLCBgcmF5X3pgLCBgcmF5X3R4YCwgYHJheV9oaXR4YCwgYHJheV9oaXR5YCB8IGBm
NjRgIHwgYHJheV9jb3VudGAgfA0KfCBgcmF5X3RpbGVgIHwgYGkxNmAgfCBgcmF5X2NvdW50YCB8
DQp8IGB3YWxsX3NwYW5fc3RhcnRgLCBgd2FsbF9zcGFuX2VuZGAsIGB3YWxsX3NwYW5fdGlsZWAg
fCBgaTE2YCB8IGByYXlfY291bnRgIHdvcnN0LWNhc2UgfA0KfCBgd2FsbF9zcGFuX3V2YCwgYHdh
bGxfc3Bhbl9kZXB0aGAgfCBgZjMyYCB8IGByYXlfY291bnRgIHwNCnwgYHNwcml0ZV9idWNrZXRf
aW5kaWNlc2AsIGBzcHJpdGVfYnVja2V0X2RlcHRoc2AgfCBgaTE2YCwgYGYzMmAgfCBgYnVja2V0
X2NvdW50IMOXIGJ1Y2tldF9jYXBhY2l0eWAgfA0KfCBgdGxpbmVfYXJnc2AsIGByZWN0X2FyZ3Ng
IHwgYGY2NGAgfCBNYW5hZ2VkIGV4Y2x1c2l2ZWx5IGJ5IGByX2JhdGNoYCB8DQp8IGB6YnVmYCwg
YHpzdGFtcGAgfCBgZjMyYCwgYGkzMmAgfCBgc2NyZWVuX3dpZHRoYCB8DQp8IGBzdGF0c191ZGAg
fCBgZjMyYCB8IFNtYWxsIGZpeGVkIGJsb2NrIGZvciBkaWFnbm9zdGljcyBzbmFwc2hvdCB8DQoN
CiMjIyBEaWFnbm9zdGljcw0KDQotIFJlbmRlcmluZyBtb2R1bGVzIHB1c2ggaW50byBgc3RhdHNf
dWRgIG9ubHkgd2hlbiBgZGVidWdfbW9kZWAgaXMgZW5hYmxlZDsgb3RoZXJ3aXNlIHRoZXkgZXhp
dCBlYXJseSB3aXRob3V0IGluY3JlbWVudGluZyBjb3VudGVycy4NCi0gYHJfZGlhZ2Agb3ducyBh
bGwgc3RyaW5nIGZvcm1hdHRpbmcsIHVzaW5nIGNhY2hlZCBsYWJlbCB1c2VyZGF0YSB0byBhdm9p
ZCBwZXItZnJhbWUgY29uY2F0ZW5hdGlvbi4NCi0gT3ZlcmxheSBjb2xsZWN0cyBmcmFtZSB0aW1l
LCBDUFUgJSwgYWN0aXZlIHJheXMsIGZsb29yIHJvd3MsIHdhbGwgc3BhbnMsIHRleHR1cmVkIHZz
IExPRCBjb2x1bW5zLCBzcHJpdGUgdGV4dHVyZWQgdnMgaW1wb3N0b3IgY29sdW1ucywgbWF0Y2hp
bmcgT3B0aW1pemF0aW9uR3VpZGVsaW5lcyDCpzMgYW5kIMKnOS4NCg0KLS0tDQoNCiMjIEltcGxl
bWVudGF0aW9uIFNlcXVlbmNlDQoNCjEuIFN0YW5kIHVwIGByX3N0YXRlYCArIGByX2JhdGNoYDsg
dmFsaWRhdGUgYG1lbW1hcGAvYHVubWFwYCBsaWZlY3ljbGUgYW5kIGJ1ZmZlciBzaXplcy4NCjIu
IEJ1aWxkIGByX3ZpZXdgIHdpdGggTFVUIHJlYnVpbGRzIHRpZWQgdG8gcmF5LWNvdW50IGNoYW5n
ZXM7IGNvbmZpcm0gdHJpZyBjYWNoZXMgcGVyc2lzdC4NCjMuIEltcGxlbWVudCBgcl9jYXN0YDsg
dmVyaWZ5IEREQSBvdXRwdXQgdmlhIGR1bmdlb24gaGFybmVzcyB3aXRoIHdhbGwgcmVuZGVyaW5n
IGRpc2FibGVkLg0KNC4gSW50ZWdyYXRlIGByX3dhbGxzYCBzcGFuIGJhdGNoaW5nOyB0dW5lIExP
RCB0aHJlc2hvbGRzIGFuZCBlbnN1cmUgYHRsaW5lM2RgIGZsYWcgdXNhZ2UgbWF0Y2hlcyBwZXJm
b3JtYW5jZSBndWlkZWxpbmVzLg0KNS4gQWRkIGByX2Zsb29yYCBoeWJyaWQgcGFzczsgYmVuY2ht
YXJrIHJvdyBjb3VudHMgYW5kIGFkanVzdCBkdXBsaWNhdGlvbiBzY2hlZHVsZSB0byBzdGF5IG5l
YXIgdGhlIDEzNS1yb3cgdGFyZ2V0Lg0KNi4gSW1wbGVtZW50IGByX3Nwcml0ZXNgIHVzaW5nIHVz
ZXJkYXRhIGJ1Y2tldHM7IGNvbmZpcm0gaW1wb3N0b3IvdGV4dHVyZWQgcmF0aW9zIG1lZXQgc3By
aXRlIExPRCBnb2Fscy4NCjcuIEhvb2sgbW9kdWxlcyBpbnRvIGBtYWluLmx1YWAgKGB2aWV3X3Vw
ZGF0ZWAsIGBjYXN0X3JheXNgLCBgZHJhd19mbG9vcmAsIGBkcmF3X3dhbGxzYCwgYGRyYXdfc3By
aXRlc2AsIGBkcmF3X2RpYWdgKSBhbmQgcmVtb3ZlIGxlZ2FjeSBjYWxscy4NCjguIEltcGxlbWVu
dCBgcl9kaWFnYCBvdmVybGF5OyBnYXRlIHN0YXQgY29sbGVjdGlvbiBhbmQgZW5zdXJlIHBhbGV0
dGUvY2xpcCBzdGF0ZSByZXN0b3JlcyBjbGVhbmx5Lg0KOS4gUnVuIGR1bmdlb24gaGFybmVzczsg
bWVhc3VyZSBgc3RhdCgxKWAgPCAwLjksIGZsb29yIHJvd3Mg4omIMTM1LCB3YWxsIHNwYW5zIOKJ
iDEwMCwgZnJhbWUgdGltZSA8MzPigK9tczsgaXRlcmF0ZSB0aHJlc2hvbGRzIGFzIG5lZWRlZC4N
CjEwLiBVcGRhdGUgZG9jcywgcmVtb3ZlIGxlZ2FjeSByZW5kZXJlciBtb2R1bGVzIChgcmVuZGVy
Lmx1YWAsIGByZW5kZXJfc3ByaXRlLmx1YWAsIGByYXljYXN0Lmx1YWApIG9uY2UgYmVuY2htYXJr
cyBwYXNzLg0KDQojIyBNb2R1bGUgU3VjY2Vzc2lvbg0KDQotIGBzcmMvcmVuZGVyLmx1YWAgKGZs
b29ycywgd2FsbHMpIOKGkiByZXBsYWNlZCBieSBgcl9mbG9vci5sdWFgLCBgcl93YWxscy5sdWFg
LCBhbmQgc2hhcmVkIGByX2JhdGNoLmx1YWAuDQotIGBzcmMvcmF5Y2FzdC5sdWFgIChEREEgY29y
ZSkg4oaSIHN1cGVyc2VkZWQgYnkgYHJfY2FzdC5sdWFgIHdpdGggbWVtbWFwcGVkIGJ1ZmZlcnMu
DQotIGBzcmMvcmVuZGVyX3Nwcml0ZS5sdWFgIOKGkiBzdXBlcnNlZGVkIGJ5IGByX3Nwcml0ZXMu
bHVhYCB3aXRoIHVzZXJkYXRhIGJ1Y2tldHMuDQotIERpYWdub3N0aWNzIGluIGBtYWluLmx1YWAg
4oaSIHJlcGxhY2VkIGJ5IGByX2RpYWcubHVhYDsgYG1haW4ubHVhYCBub3cganVzdCB0b2dnbGVz
IGBkZWJ1Z19tb2RlYCBhbmQgZm9yd2FyZHMgc3RhdHMuDQoNCkFsbCBvdGhlciBzdWJzeXN0ZW1z
IChkdW5nZW9uIGdlbmVyYXRpb24sIGRvb3JzLCBjb25maWcgdGFibGVzKSByZW1haW4gdW50b3Vj
aGVkOyBvbmx5IHJlbmRlcmVyIG1vZHVsZXMgYW5kIHRoZSB3aXJpbmcgaW4gYG1haW4ubHVhYCBj
aGFuZ2UuDQoNCiMjIE1haW50ZW5hbmNlIEd1YXJkcmFpbHMNCg0KLSBgcl9zdGF0ZS5kdW1wX3Vz
YWdlKClgIGxvZ3MgYnVmZmVyIHNpemVzIGFuZCBvY2N1cGFuY3kgYmVoaW5kIGBkZWJ1Z19tb2Rl
YCwgYWlkaW5nIGNhY2hlIHR1bmluZyB3aXRob3V0IHRvdWNoaW5nIGhvdCBwYXRocy4NCi0gSG90
LXBhdGggYXNzZXJ0aW9ucyBsaXZlIGJlaGluZCBgZGVidWdfbW9kZWAgdG8gY2F0Y2ggYWNjaWRl
bnRhbCB0YWJsZSBhbGxvY2F0aW9ucyBvciBzdGF0ZSBkcmlmdC4NCi0gR2FyYmFnZSBjb2xsZWN0
aW9uIChgc3RhdCgwKWApIHRyaWdnZXJlZCBvbmx5IGR1cmluZyBsZXZlbCBsb2FkcyBvciBtZW51
IHRyYW5zaXRpb25zLCBuZXZlciB3aXRoaW4gdGhlIGRyYXcgcGlwZWxpbmUsIGtlZXBpbmcgd2l0
aGluIE9wdGltaXphdGlvbkd1aWRlbGluZXMgwqczLg0KDQotLS0NCg0KIyMgUmVuZGVyZXIgTW9k
dWxlIENvbnRyYWN0cw0KDQojIyMgQ29udHJhY3QgVmVyaWZpY2F0aW9uDQoNCkNvbnRyYWN0cyBh
cmUgdmVyaWZpZWQgYnkgdW5pdCB0ZXN0cyB1bmRlciBgdGVzdC9yZW5kZXIvYCwgZS5nLiBgdGVz
dC9yZW5kZXIvdGVzdF9waXBlbGluZV9jb250cmFjdHMubHVhYC4gVGhlc2UgdGVzdHMgZHJpdmUg
dGhlIHJlbmRlcmVyIG1vZHVsZXMgb25jZSBwZXIgdGVzdCBjYXNlIChub3QgcGVyIGZyYW1lKSBh
bmQgYXNzZXJ0IGludGVyZmFjZSBndWFyYW50ZWVzLiBUaGVyZSBpcyBubyBwZXItZnJhbWUgdmVy
aWZpZXIgY291cGxlZCB0byB0aGUgZ2FtZSBsb29wLg0KDQojIyMgcl9zdGF0ZS5sdWENCg0KKipD
b250cmFjdDoqKiBPd25zIGFsbCByZW5kZXJlciBidWZmZXJzIGFuZCBjb25maWc7IGd1YXJhbnRl
ZXMgc3RhYmxlIGNhcGFjaXR5IGFjcm9zcyBmcmFtZXMuDQoNCioqUHJlY29uZGl0aW9uczoqKg0K
LSBgY29uZmlnLnNjcmVlbl93aWR0aC9oZWlnaHRgLCBgcmF5X2NvdW50YCwgYHNwcml0ZV9idWNr
ZXRfKmAgbXVzdCBiZSBwcm92aWRlZCBhdCBpbml0DQotIGBwcmVwYXJlX2ZyYW1lKClgIGNhbGxl
ZCBleGFjdGx5IG9uY2UgcGVyIGZyYW1lIGJlZm9yZSBhbnkgcmVuZGVyaW5nDQoNCioqUG9zdGNv
bmRpdGlvbnM6KioNCi0gQWxsIGJ1ZmZlcnMgYWxsb2NhdGVkIGFuZCBhY2Nlc3NpYmxlIHZpYSBg
cl9zdGF0ZS5idWZmZXJzYA0KLSBgb2NjdXBhbmN5YCBjb3VudGVycyByZXNldCB0byAwIGVhY2gg
ZnJhbWUNCi0gYHpyZWFkL3p3cml0ZWAgb25seSBhY2Nlc3MgdmFsaWQgc2NyZWVuIGNvb3JkaW5h
dGVzICgwIOKJpCB4IDwgc2NyZWVuX3dpZHRoKQ0KDQoqKlZlcmlmaWNhdGlvbjoqKiBgcl9zdGF0
ZWAgaGFzIG5vIGhhcm5lc3M7IG90aGVyIG1vZHVsZXMgdmVyaWZ5IGl0cyBpbnZhcmlhbnRzIGlu
ZGlyZWN0bHkuDQoNCiMjIyByX3ZpZXcubHVhDQoNCioqQ29udHJhY3Q6KiogUHJvZHVjZXMgbm9y
bWFsaXplZCB1bml0IHZlY3RvcnMgZm9yIHJheSBkaXJlY3Rpb25zOyBjYW1lcmEgYmFzaXMgdmVj
dG9ycyBhcmUgb3J0aG9ub3JtYWwuDQoNCioqUHJlY29uZGl0aW9uczoqKg0KLSBgY2FtZXJhID0g
e3gsIHksIGF9YCB3aXRoIG51bWVyaWMgcG9zaXRpb24vYW5nbGUNCi0gYHJfc3RhdGVgIGluaXRp
YWxpemVkIHdpdGggdmFsaWQgYnVmZmVycw0KLSBgZm92YCBpbiByYWRpYW5zIChoYWxmLWFuZ2xl
KQ0KLSBgYWN0aXZlX3JheV9jb3VudCDiiaQgcl9zdGF0ZS5jb25maWcucmF5X2NvdW50YA0KDQoq
KlBvc3Rjb25kaXRpb25zOioqDQotIGByX3ZpZXcuZm9yd2FyZF94L2ZvcndhcmRfeWAgYW5kIGBy
X3ZpZXcucmlnaHRfeC9yaWdodF95YCBmb3JtIG9ydGhvbm9ybWFsIGJhc2lzDQotIEFsbCBgcl9z
dGF0ZS5idWZmZXJzLnJheV9kaXJfeC95W2ldYCBhcmUgdW5pdCB2ZWN0b3JzIChtYWduaXR1ZGUg
PSAxLjAgwrEgMWUtNikNCi0gYHJfc3RhdGUub2NjdXBhbmN5LnJheXNfYWN0aXZlYCBzZXQgdG8g
YGFjdGl2ZV9yYXlfY291bnRgDQoNCioqVmVyaWZpY2F0aW9uOioqIENoZWNrcyBmaXJzdCA1IHJh
eSBtYWduaXR1ZGVzOyBhc3NlcnRzIHVuaXQgdmVjdG9yIHByb3BlcnR5Lg0KDQojIyMgcl9jYXN0
Lmx1YQ0KDQoqKkNvbnRyYWN0OioqIFBvcHVsYXRlcyByYXkgaGl0IGJ1ZmZlcnMgdXNpbmcgRERB
OyBleHBlY3RzIG5vcm1hbGl6ZWQgcmF5IGRpcmVjdGlvbnMuDQoNCioqUHJlY29uZGl0aW9uczoq
Kg0KLSBgcl9zdGF0ZS5vY2N1cGFuY3kucmF5c19hY3RpdmUgPiAwYA0KLSBSYXkgZGlyZWN0aW9u
cyBhcmUgbm9ybWFsaXplZCB1bml0IHZlY3RvcnMNCi0gYGdhbWVfc3RhdGVgIHByb3ZpZGVzOiBg
Z2V0X3dhbGxgIChmdW5jdGlvbiksIGBpc19kb29yYCAoZnVuY3Rpb24pLCBgZG9vcmdyaWRgICh0
YWJsZSksIGBmYXJfcGxhbmVgLCBgbWFwX3NpemVgDQoNCioqUG9zdGNvbmRpdGlvbnM6KioNCi0g
YHJheV96W2ldYCwgYHJheV9oaXR4L3lbaV1gLCBgcmF5X3RpbGVbaV1gLCBgcmF5X3R4W2ldYCBw
b3B1bGF0ZWQgZm9yIGFsbCBhY3RpdmUgcmF5cw0KLSBSYXlzIGhpdHRpbmcgbm90aGluZyBoYXZl
IGByYXlfeltpXSA9IDk5OWAsIGByYXlfdGlsZVtpXSA9IDBgDQotIFZhbGlkIGhpdHMgaGF2ZSBg
MCA8IHJheV96W2ldIDwgZmFyX3BsYW5lYA0KDQoqKlZlcmlmaWNhdGlvbjoqKiBDaGVja3MgZm9y
IGhpdHMgYW5kIHZhbGlkIGRlcHRocyBpbiBmaXJzdCAxMCByYXlzLg0KDQojIyMgcl9mbG9vci5s
dWENCg0KKipDb250cmFjdDoqKiBSZW5kZXJzIGZsb29yL2NlaWxpbmcgcm93cyB1c2luZyBiYXRj
aGluZzsgdXBkYXRlcyBvY2N1cGFuY3kgY291bnRlcnMuDQoNCioqUHJlY29uZGl0aW9uczoqKg0K
LSBgcl9iYXRjaGAgaW5pdGlhbGl6ZWQNCi0gYGdhbWVfc3RhdGVgIHByb3ZpZGVzOiBgZmxvb3Iv
cm9vZmAgKHRhYmxlcyksIGBnZXRfc3ByYCAoZnVuY3Rpb24pLCBgcGxhbmV0eXBzYCAodGFibGUp
LCBgRVJST1JfSURYYCAodGFibGUpDQotIElmIGBwZXJfY2VsbF9mbG9vcnNfZW5hYmxlZGA6IGBn
ZXRfZmxvb3JgIChmdW5jdGlvbikgcmVxdWlyZWQNCg0KKipQb3N0Y29uZGl0aW9uczoqKg0KLSBG
bG9vci9jZWlsaW5nIHJlbmRlcmVkIHZpYSBgcl9iYXRjaGANCi0gYHJfc3RhdGUub2NjdXBhbmN5
LmZsb29yX3Jvd3MgPiAwYCBmb3IgdmFsaWQgc2NlbmVzDQoNCioqVmVyaWZpY2F0aW9uOioqIENv
bmZpcm1zIGBmbG9vcl9yb3dzID4gMGAuDQoNCiMjIyByX3dhbGxzLmx1YQ0KDQoqKkNvbnRyYWN0
OioqIE1lcmdlcyByYXlzIGludG8gc3BhbnMsIHJlbmRlcnMgd2FsbHMgd2l0aCBMT0Q7IHVwZGF0
ZXMgei1idWZmZXIuDQoNCioqUHJlY29uZGl0aW9uczoqKg0KLSBSYXkgYnVmZmVycyBwb3B1bGF0
ZWQgYnkgYHJfY2FzdGANCi0gYGdhbWVfc3RhdGVgIHByb3ZpZGVzOiBgZ2V0X3NwcmAgKGZ1bmN0
aW9uKSwgYGVycm9yX3RleHR1cmVzYCAodGFibGUpLCBgRVJST1JfSURYYCAodGFibGUpDQotIGBy
X3N0YXRlLm9jY3VwYW5jeS5yYXlzX2FjdGl2ZSA_IDBgDQoNCioqUG9zdGNvbmRpdGlvbnM6KioN
Ci0gV2FsbCBzcGFucyByZW5kZXJlZCB2aWEgYHJfYmF0Y2hgDQotIFotYnVmZmVyIHVwZGF0ZWQg
Zm9yIGFsbCByZW5kZXJlZCBwaXhlbHMNCi0gYHJfc3RhdGUub2NjdXBhbmN5LndhbGxfc3BhbnMg
4omlIDBgIChtYXkgYmUgMCBmb3IgZW1wdHkgc2NlbmVzKQ0KDQoqKlZlcmlmaWNhdGlvbjoqKiBD
b25maXJtcyBgd2FsbF9zcGFucyDiiaUgMGAuDQoNCiMjIyByX3Nwcml0ZXMubHVhDQoNCioqQ29u
dHJhY3Q6KiogUmVuZGVycyBzcHJpdGVzIHVzaW5nIGRlcHRoIGJ1Y2tldGluZzsgaGFuZGxlcyBp
bXBvc3RvciBMT0QuDQoNCioqUHJlY29uZGl0aW9uczoqKg0KLSBgZ2FtZV9zdGF0ZWAgcHJvdmlk
ZXM6IGBvYmplY3RzYCAodGFibGUpLCBgZmFyX3BsYW5lYCwgYHNwcml0ZV9sb2RfcmF0aW9gLCBg
Zm9nX2ZhcmAsIGBnZXRfc3ByYCAoZnVuY3Rpb24pLCBgZXJyb3JfdGV4dHVyZXNgICh0YWJsZSkN
Ci0gYG9iamVjdHNgIGlzIGEgZGVuc2UgYXJyYXkgKDEuLk4pDQoNCioqUG9zdGNvbmRpdGlvbnM6
KioNCi0gU3ByaXRlcyByZW5kZXJlZCB2aWEgYHJfYmF0Y2hgDQotIGByX3N0YXRlLm9jY3VwYW5j
eS5zcHJpdGVfY291bnQgPT0gI2dhbWVfc3RhdGUub2JqZWN0c2ANCi0gQnVja2V0IG92ZXJmbG93
cyBsb2dnZWQgYXMgd2FybmluZ3MNCg0KKipWZXJpZmljYXRpb246KiogQ29uZmlybXMgc3ByaXRl
IGNvdW50IG1hdGNoZXMgaW5wdXQ7IGNoZWNrcyBidWNrZXQgdXNhZ2UuDQoNCiMjIyByX2RpYWcu
bHVhDQoNCioqQ29udHJhY3Q6KiogUmVuZGVycyBkaWFnbm9zdGljcyBvdmVybGF5IHdoZW4gZW5h
YmxlZDsgcHJlc2VydmVzIHJlbmRlciBzdGF0ZS4NCg0KKipQcmVjb25kaXRpb25zOioqDQotIGBy
X3N0YXRlLmNvbmZpZy5kZWJ1Z19tb2RlID09IHRydWVgIHRvIHJlbmRlcg0KDQoqKlBvc3Rjb25k
aXRpb25zOioqDQotIE92ZXJsYXkgZHJhd24gd2l0aCBjdXJyZW50IGZyYW1lIG1ldHJpY3MNCi0g
Q2xpcC9wYWxldHRlIHN0YXRlIHJlc3RvcmVkIHRvIGRlZmF1bHRzDQoNCioqVmVyaWZpY2F0aW9u
OioqIE5vIGhhcm5lc3MgKHB1cmUgb3V0cHV0IG1vZHVsZSkuDQoNCiMjIyBJbnRlZ3JhdGlvbiBD
b250cmFjdCAobWFpbi5sdWEpDQoNCioqQ29udHJhY3Q6KiogT3JjaGVzdHJhdGVzIHJlbmRlcmVy
IHBpcGVsaW5lIGluIGNvcnJlY3Qgb3JkZXIgd2l0aCB2YWxpZCBnYW1lIHN0YXRlLg0KDQoqKlBy
ZWNvbmRpdGlvbnM6KioNCi0gQWxsIHJlbmRlcmVyIG1vZHVsZXMgaW5pdGlhbGl6ZWQNCi0gR2Ft
ZSBzdGF0ZSB0YWJsZXMgcG9wdWxhdGVkIHdpdGggcmVxdWlyZWQgZmllbGRzDQoNCioqUG9zdGNv
bmRpdGlvbnM6KioNCi0gUGlwZWxpbmUgcnVuczogYHByZXBhcmVfZnJhbWUg4oaSIHJfdmlldy51
cGRhdGUg4oaSIHJfY2FzdC5jYXN0X3NjZW5lIOKGkiByX2Zsb29yIOKGkiByX3dhbGxzIOKGkiBy
X3Nwcml0ZXMg4oaSIHJfZGlhZ2ANCi0gTm8gZXhjZXB0aW9ucyB0aHJvd24gZHVyaW5nIG5vcm1h
bCByZW5kZXJpbmcNCg0KKipWZXJpZmljYXRpb246KiogQ292ZXJlZCBieSB1bml0IHRlc3RzIGlu
IGB0ZXN0L3JlbmRlci9gIHRoYXQgaW52b2tlIGEgc2luZ2xlLWZyYW1lIHBpcGVsaW5lIHBhc3Mg
d2l0aCBjb250cm9sbGVkIHN0YXRlLg==
:: src/docs/TemplateSummary.md
b64$IyMgT3ZlcnZpZXc6IEhvdyBUaGlzIFRlbXBsYXRlIEltcHJvdmVzIFBpY290cm9uIERldmVs
b3BtZW50DQoNCiMjIyAxLiAqKk1vZHVsYXIgQ29kZSBPcmdhbml6YXRpb24qKg0KLSBDdXN0b20g
YHJlcXVpcmUoKWAgc3lzdGVtIGNvbXBhdGlibGUgd2l0aCBMdWEgNS40IGZvciBtb2R1bGUgbG9h
ZGluZyBhbmQgY2FjaGluZw0KLSBTdXBwb3J0cyBtdWx0aXBsZSBzZWFyY2ggcGF0aHMgYW5kIG1v
ZHVsZSBhbGlhc2luZyBmb3IgdGVzdGluZw0KLSBSZWR1Y2VzIGNvZGUgZHVwbGljYXRpb24gYW5k
IGltcHJvdmVzIG1haW50YWluYWJpbGl0eQ0KDQojIyMgMi4gKipTdHJ1Y3R1cmVkIExvZ2dpbmcg
U3lzdGVtKioNCi0gTG9nIGxldmVscyAoVFJBQ0UsIERFQlVHLCBJTkZPLCBXQVJOLCBFUlJPUikg
Zm9yIGZpbHRlcmluZyBvdXRwdXQNCi0gTXVsdGlwbGUgdGFyZ2V0czogY29uc29sZSBvciBleHRl
cm5hbCBwcm9jZXNzIChlLmcuLCBgbG9ndmlldy5sdWFgKQ0KLSBUaW1lc3RhbXBlZCBlbnRyaWVz
IGZvciBkZWJ1Z2dpbmcNCi0gRnVuY3Rpb24gdHJhY2luZyB3aXRoIGB0cmFjZV9mdW5jdGlvbigp
YA0KLSBFbmFibGVzIHJlYWwtdGltZSBtb25pdG9yaW5nIGFuZCBlYXNpZXIgZGVidWdnaW5nDQoN
CiMjIyAzLiAqKlVuaXQgVGVzdGluZyBGcmFtZXdvcmsqKg0KLSBMaWZlY3ljbGUgaG9va3M6IGBi
ZWZvcmVfYWxsKClgLCBgYmVmb3JlX2VhY2goKWAsIGBhZnRlcl9lYWNoKClgLCBgYWZ0ZXJfYWxs
KClgDQotIEF1dG9tYXRpYyB0ZXN0IGRpc2NvdmVyeSBpbiB0aGUgYHRlc3QvYCBkaXJlY3RvcnkN
Ci0gRGV0YWlsZWQgZXJyb3IgcmVwb3J0aW5nIHdpdGggbGluZSBudW1iZXJzDQotIEludGVncmF0
aW9uIHdpdGggdGhlIGxvZ2dpbmcgc3lzdGVtDQotIFN1cHBvcnRzIHJ1bm5pbmcgYWxsIHRlc3Rz
IG9yIHNwZWNpZmljIHRlc3QgZmlsZXMNCi0gSGVscHMgY2F0Y2ggYnVncyBlYXJseSBhbmQgbWFp
bnRhaW4gY29kZSBxdWFsaXR5DQoNCiMjIyA0LiAqKkFzc2VydGlvbiBMaWJyYXJ5KioNCi0gQ29t
cGFyaXNvbiBhc3NlcnRpb25zIChgYXJlX2VxdWFsYCwgYGFyZV9ub3RfZXF1YWxgLCBgYXJlX2Vx
dWFsX3RhYmxlc2ApDQotIFR5cGUgY2hlY2tpbmcgKGBpc19uaWxgLCBgaXNfdHlwZWAsIGBpc190
cnVlYCwgYGlzX2ZhbHNlYCkNCi0gTnVtYmVyIGNvbXBhcmlzb25zIChgaXNfZ3JlYXRlcl90aGFu
YCwgYGlzX2xlc3NfdGhhbmApDQotIFRhYmxlIG9wZXJhdGlvbnMgKGBjb250YWluc2AsIGBoYXNf
a2V5YCwgYGhhc19sZW5ndGhgKQ0KLSBQYXR0ZXJuIG1hdGNoaW5nIGZvciBzdHJpbmdzDQotIFBy
b3ZpZGVzIGNsZWFyLCBkZXNjcmlwdGl2ZSBlcnJvciBtZXNzYWdlcyB3aGVuIHRlc3RzIGZhaWwN
Cg0KIyMjIDUuICoqUHJvamVjdCBTdHJ1Y3R1cmUgJiBDb25maWd1cmF0aW9uKioNCi0gQ2VudHJh
bGl6ZWQgY29uZmlndXJhdGlvbiBpbiBgY29uZmlndXJhdGlvbi5sdWFgDQotIEdsb2JhbCB1dGls
aXRpZXMgaW4gYGdsb2JhbHMubHVhYA0KLSBDbGVhciBzZXBhcmF0aW9uIGJldHdlZW4gc291cmNl
IGNvZGUgKGBzcmMvYCksIHRlc3RzIChgdGVzdC9gKSwgYW5kIGxpYnJhcmllcyAoYGxpYi9gKQ0K
LSBTdGFuZGFyZGl6ZWQgZW50cnkgcG9pbnQgKGBtYWluLmx1YWApDQoNCiMjIyA2LiAqKkRldmVs
b3BtZW50IFdvcmtmbG93IEJlbmVmaXRzKioNCi0gRmFzdGVyIGRlYnVnZ2luZyB3aXRoIHN0cnVj
dHVyZWQgbG9nZ2luZyBhbmQgcmVhbC10aW1lIGxvZyB2aWV3aW5nDQotIFNhZmVyIHJlZmFjdG9y
aW5nIHdpdGggdW5pdCB0ZXN0cw0KLSBCZXR0ZXIgY29kZSBvcmdhbml6YXRpb24gdGhyb3VnaCBt
b2R1bGFyIGRlc2lnbg0KLSBFYXNpZXIgY29sbGFib3JhdGlvbiB3aXRoIHN0YW5kYXJkaXplZCBz
dHJ1Y3R1cmUgYW5kIHRlc3RpbmcgcHJhY3RpY2VzDQotIEVhcmx5IGJ1ZyBkZXRlY3Rpb24gdGhy
b3VnaCBhdXRvbWF0ZWQgdGVzdGluZw0KDQojIyMgNy4gKipQcmFjdGljYWwgRGV2ZWxvcG1lbnQg
U2NlbmFyaW9zKioNCi0gRGVidWdnaW5nOiBVc2UgbG9nIGxldmVscyB0byB0cmFjZSBleGVjdXRp
b24gZmxvdyBhbmQgaWRlbnRpZnkgaXNzdWVzDQotIFRlc3Rpbmc6IFdyaXRlIGZpeHR1cmVzIGZv
ciBlYWNoIG1vZHVsZSB0byB2ZXJpZnkgYmVoYXZpb3INCi0gUmVmYWN0b3Jpbmc6IFJ1biB0ZXN0
cyBhZnRlciBjaGFuZ2VzIHRvIGVuc3VyZSBub3RoaW5nIGJyZWFrcw0KLSBDb2xsYWJvcmF0aW9u
OiBTdGFuZGFyZCBzdHJ1Y3R1cmUgbWFrZXMgb25ib2FyZGluZyBlYXNpZXINCi0gTWFpbnRlbmFu
Y2U6IE1vZHVsYXIgY29kZSBpcyBlYXNpZXIgdG8gdXBkYXRlIGFuZCBleHRlbmQNCg0KVGhpcyB0
ZW1wbGF0ZSBwcm92aWRlcyBhIGZvdW5kYXRpb24gZm9yIHNjYWxhYmxlLCBtYWludGFpbmFibGUg
UGljb3Ryb24gcHJvamVjdHMgd2l0aCBwcm9mZXNzaW9uYWwgZGV2ZWxvcG1lbnQgcHJhY3RpY2Vz
IGJ1aWx0IGluLg==
:: src/procgen/.info.pod
--[[pod,created="2025-11-12 15:40:09",modified="2025-11-12 15:40:09"]]
:: src/render/.info.pod
--[[pod,created="2025-11-12 15:40:09",modified="2025-11-12 15:40:09"]]
:: test/.info.pod
--[[pod,created="2025-11-12 15:40:09",modified="2025-11-12 15:40:09"]]
:: test/render/.info.pod
--[[pod,created="2025-11-12 15:40:09",modified="2025-11-12 15:40:09"]]
:: [eoc]
