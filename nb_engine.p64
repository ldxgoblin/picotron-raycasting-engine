picotron cartridge // www.picotron.net
version 2

:: src/
:: tests/
:: src/config.lua
--[[pod_format="raw",created="2025-11-07 21:17:14",modified="2025-11-07 21:48:05",revision=1]]
-- engine configuration

-- screen constants
screen_width=480
screen_height=270
screen_center_x=screen_width/2
screen_center_y=screen_height/2
-- default ray budget: tuned for 480px wide viewport; adaptive governor in main.lua can lower this
ray_count=128
-- CRITICAL: screen_center_x must equal screen_width/2, screen_center_y must equal screen_height/2
-- ray_count is decoupled from screen_width and can be configured independently for performance tuning
sdist=200 -- default; computed dynamically in raycast_scene() based on fov
map_size=128
objgrid_size=5
objgrid_array_size=26
fov=0.5

-- sprite configuration
sprite_size=32

-- fog configuration (unified linear fog system)
fog_near=5.0 -- near fog distance where fog begins
fog_far=20.0 -- far fog distance where fog is maximum
fog_hysteresis=0.5 -- minimum z change required to update fog level (reduces palette thrashing)
screenbright=1.0 -- screen brightness multiplier (1.0=normal, <1.0=darker for atmosphere)

-- lod configuration (ratios of fog_far)
wall_lod_ratio=0.4 -- ratio of fog_far for wall LOD transition
sprite_lod_ratio=0.5 -- ratio of fog_far for sprite LOD transition
wall_lod_distance=fog_far*wall_lod_ratio -- computed: walls beyond this z use simplified rendering
wall_tiny_screen_px=6 -- walls shorter than this many pixels use LOD solid fill

-- rendering configuration
row_stride=1 -- floor/ceiling stride; keep at 1 for correct perspective (governor can relax if needed)
per_cell_floors_enabled=false -- enable per-cell floor type detection (false=render entire scanline with single texture)
-- tline quality flag (0x400) is expensive; keep off unless visual artifacts demand it
tline_high_quality_near=false

-- raycast configuration
far_plane=25.0 -- maximum raycast distance; must be >= fog_far + 2.0 to prevent geometry popping

-- ai and interaction constants
ai_update_rate=2 -- frames between AI updates
interaction_range=0.5 -- proximity for triggers
combat_trigger_range=0.3 -- distance to trigger combat

-- player movement constants
player_rotation_speed=0.008 -- radians per frame when turning (slower, smoother)
player_move_speed=0.04 -- units per frame when moving (reduced)

-- door animation constants
door_anim_speed=0.06 -- door open/close speed per frame
door_close_delay=90 -- frames before door auto-closes

-- floor/ceiling types (tex indexes from gfx/1_surfaces.gfx, offset 32)
planetyps={
 -- stone_tile
 {tex=32,scale=1,height=0.5,lit=true,xvel=0,yvel=0},
 -- dirt
 {tex=33,scale=1,height=0.5,lit=true,xvel=0,yvel=0},
 -- stone_ceiling
 {tex=34,scale=1,height=0.5,lit=false,xvel=0,yvel=0},
 -- sky
 {tex=35,scale=2,height=1,lit=false,xvel=0.01,yvel=0},
 -- night_sky
 {tex=36,scale=2,height=1,lit=false,xvel=0.005,yvel=0}
}

-- wall texture sets (sprite indexes from gfx/0_walls.gfx)
texsets={
 -- none (removed to avoid collision with brick variant 0)
 -- brick
 {base=0,variants={0,1,2,3}},
 -- cobblestone
 {base=4,variants={4,5,6,7}},
 -- wood_plank
 {base=8,variants={8,9,10,11}},
 -- stone
 {base=12,variants={12,13,14,15}},
 -- grass (outdoor)
 {base=16,variants={16,17,18,19}},
 -- earth (outdoor)
 {base=20,variants={20,21,22,23}}
}

-- door types (sprite indexes from gfx/0_walls.gfx)
door_normal=24
door_locked=25
door_stay_open=26

-- helper: check if tile is a door
function is_door(val)
 return val>=door_normal and val<=door_stay_open
end

-- exit types (tile IDs)
exit_start=67
exit_end=68

-- wall fill constant
wall_fill_tile=1

-- generation parameters
gen_params={
 min_rooms=5,
 max_rooms=15,
 min_size=4,
 max_size=12,
 spacing=2,
 corridor_texture=0,
 room_door_prob=0.3,
 erode_amount=50,
 difficulty=1,
 max_difficulty=9,
 max_enemies_per_room=8,
 max_decorations_per_room=12,
 npc_hostile_ratio=0.7,
 items_per_room=2,
 pickup_density=0.1
}

gen_observability={
 enable_console=false,
 capture_history=true,
 history_limit=400,
 log_seed=true,
 log_room_attempts=true,
 log_corridors=true,
 log_progression=true,
 log_repairs=true
}

gen_adaptive_settings={
 spacing_relax_threshold=4,
 spacing_relax_step=1,
 spacing_max_relax=4,
 spacing_restore_delay=2,
 spacing_restore_step=1,
 max_room_failures=24,
 offcenter_bias=0.65,
 bias_radius=12,
 junction_retry_limit=6,
 corridor_jog_chance=0.25
}

-- helper constants
max_spawn_attempts=50
max_room_attempts=100

-- door testing parameters
test_door_open=nil -- if set to a value 0.0-1.0, forces all doors to this open state for testing
test_door_x=nil -- if set, only affects door at this position
test_door_y=nil -- if set, only affects door at this position

-- object type definitions (mx=sprite index from gfx files, my deprecated, mw/mh use sprite_size)
-- NOTE: my=0 is deprecated and maintained for backward compatibility only; will be removed once rendering code migrates
obj_types={
 player={solid=true,w=0.4,mx=0,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.8,flat=false,lit=nil,framect=nil,animspd=nil,yoffs=nil,kind="player"},
 enemy={solid=true,w=0.4,mx=64,my=0,mw=sprite_size,mh=sprite_size,y=0.1,h=0.8,flat=false,lit=nil,framect=4,animspd=0.25,yoffs={0,-0.01,0,-0.01},kind="hostile_npc",ai_type="follow",follow_speed=0.05,follow_range=20,patrol_speed=0.03},
 item={solid=false,w=0.3,mx=128,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.2,flat=false,lit=nil,framect=nil,animspd=nil,yoffs=nil,kind="direct_pickup",subtype="generic"},
 key={solid=false,w=0.3,mx=129,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.2,flat=false,lit=nil,framect=nil,animspd=nil,yoffs=nil,kind="direct_pickup",subtype="key"},
 heart={solid=false,w=0.3,mx=130,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.2,flat=false,lit=nil,framect=2,animspd=0.1,yoffs={0,0.05},kind="direct_pickup",subtype="heart"},
 decoration={solid=false,w=0.3,mx=148,my=0,mw=sprite_size,mh=sprite_size,y=0.3,h=0.4,flat=false,lit=0,framect=4,animspd=0.25,yoffs=nil,kind="decorative"},
 hostile_npc={solid=true,w=0.4,mx=64,my=0,mw=sprite_size,mh=sprite_size,y=0.1,h=0.8,flat=false,lit=nil,framect=4,animspd=0.25,yoffs={0,-0.01,0,-0.01},kind="hostile_npc",ai_type="follow",follow_speed=0.05,follow_range=20,patrol_speed=0.03},
 non_hostile_npc={solid=false,w=0.4,mx=73,my=0,mw=sprite_size,mh=sprite_size,y=0.1,h=0.8,flat=false,lit=nil,framect=1,animspd=0,yoffs=nil,kind="non_hostile_npc"},
 direct_pickup={solid=false,w=0.2,mx=128,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.2,flat=false,lit=nil,framect=2,animspd=0.1,yoffs={0,0.05},kind="direct_pickup"},
 interactable_chest={solid=false,w=0.3,mx=131,my=0,mw=sprite_size,mh=sprite_size,y=0.3,h=0.3,flat=false,lit=nil,framect=1,animspd=0,yoffs=nil,kind="interactable",subtype="chest"},
 interactable_shrine={solid=false,w=0.4,mx=132,my=0,mw=sprite_size,mh=sprite_size,y=0.3,h=0.5,flat=false,lit=nil,framect=1,animspd=0,yoffs=nil,kind="interactable",subtype="shrine"},
 interactable_trap={solid=false,w=0.2,mx=133,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.1,flat=true,lit=nil,framect=1,animspd=0,yoffs=nil,kind="interactable",subtype="trap"},
 interactable_note={solid=false,w=0.3,mx=134,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.2,flat=true,lit=nil,framect=1,animspd=0,yoffs=nil,kind="interactable",subtype="note"},
 interactable_exit={solid=false,w=0.3,mx=135,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.2,flat=false,lit=nil,framect=1,animspd=0,yoffs=nil,kind="interactable",subtype="exit"}
}

-- enemy type definitions (sprite indexes from gfx/2_characters.gfx, offset 64)
enemy_types={
 {name="rat",difficulty=1,min_count=1,max_count=3,obj_type=obj_types.hostile_npc,sprite=64,hp=1},
 {name="bat",difficulty=2,min_count=1,max_count=4,obj_type=obj_types.hostile_npc,sprite=65,hp=1},
 {name="slime",difficulty=3,min_count=2,max_count=5,obj_type=obj_types.hostile_npc,sprite=66,hp=2},
 {name="skeleton",difficulty=4,min_count=1,max_count=3,obj_type=obj_types.hostile_npc,sprite=67,hp=3},
 {name="goblin",difficulty=5,min_count=2,max_count=4,obj_type=obj_types.hostile_npc,sprite=68,hp=3},
 {name="orc",difficulty=6,min_count=1,max_count=3,obj_type=obj_types.hostile_npc,sprite=69,hp=4},
 {name="troll",difficulty=7,min_count=1,max_count=2,obj_type=obj_types.hostile_npc,sprite=70,hp=5},
 {name="demon",difficulty=8,min_count=1,max_count=2,obj_type=obj_types.hostile_npc,sprite=71,hp=6},
 {name="dragon",difficulty=9,min_count=1,max_count=1,obj_type=obj_types.hostile_npc,sprite=72,hp=10}
}

-- decoration type definitions (sprite indexes from gfx/3_props.gfx, offset 148)
decoration_types={
 {name="torch",difficulty=1,obj_type=obj_types.decoration,gen_tags={"lit","uni"},theme_tags={"dng","lit"},sprite=148},
 {name="barrel",difficulty=1,obj_type=obj_types.decoration,gen_tags={"uni"},theme_tags={"dng","house"},sprite=149},
 {name="crate",difficulty=1,obj_type=obj_types.decoration,gen_tags={"uni2"},theme_tags={"dng","house"},sprite=150},
 {name="pillar",difficulty=2,obj_type=obj_types.decoration,gen_tags={"big"},theme_tags={"dng","dem"},sprite=151},
 {name="statue",difficulty=3,obj_type=obj_types.decoration,gen_tags={"rare"},theme_tags={"dng","dem"},sprite=152},
 {name="chest",difficulty=2,obj_type=obj_types.decoration,gen_tags={"scatter"},theme_tags={"dng","house"},sprite=153},
 {name="tree",difficulty=1,obj_type=obj_types.decoration,gen_tags={"scatter"},theme_tags={"out"},sprite=154},
 {name="rock",difficulty=1,obj_type=obj_types.decoration,gen_tags={"uni"},theme_tags={"out"},sprite=155}
}

-- theme definitions
themes={
 dng={
  floor="stone_tile",
  roof="stone_ceiling",
  decor_prob=0.8,
  rules={
   room_shape_weights={square=0.5,hall_horizontal=0.25,hall_vertical=0.2,grand=0.1},
   room_extra_size=1,
   bias_radius=10,
   center_bias=0.55,
   corridor_jog_chance=0.2,
   erosion_intensity=1.0
  }
 },
 out={
  floor="dirt",
  roof="sky",
  decor_prob=0.5,
  rules={
   room_shape_weights={hall_horizontal=0.45,square=0.35,grand=0.05,hall_vertical=0.15},
   room_extra_size=0,
   bias_radius=14,
   center_bias=0.7,
   corridor_jog_chance=0.35,
   erosion_intensity=1.2
  }
 },
 dem={
  floor="stone_tile",
  roof="night_sky",
  decor_prob=0.9,
  rules={
   room_shape_weights={square=0.4,hall_vertical=0.3,hall_horizontal=0.2,grand=0.15},
   room_extra_size=2,
   bias_radius=8,
   center_bias=0.5,
   corridor_jog_chance=0.15,
   erosion_intensity=0.8
  }
 },
 house={
  floor="stone_tile",
  roof="stone_ceiling",
  decor_prob=0.7,
  rules={
   room_shape_weights={square=0.6,hall_horizontal=0.2,hall_vertical=0.2},
   room_extra_size=0,
   bias_radius=9,
   center_bias=0.6,
   corridor_jog_chance=0.1,
   erosion_intensity=0.5
  }
 },
 dark={
  floor="stone_tile",
  roof="night_sky",
  decor_prob=0.6,
  rules={
   room_shape_weights={square=0.35,hall_vertical=0.35,hall_horizontal=0.2,grand=0.1},
   room_extra_size=1,
   bias_radius=8,
   center_bias=0.5,
   corridor_jog_chance=0.25,
   erosion_intensity=0.9
  }
 }
}

-- fog palettes (distance-based)
-- extended to support all 64 colors in Picotron
-- base colors 0-15 are remapped per fog level; colors 16-63 map to their fogged equivalents
pals={
 -- level 0: no fog
 {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63},
 -- level 1
 {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,5,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,5,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,5,48,49,50,51,52,53,54,5,56,57,58,59,60,61,62,5},
 -- level 2
 {0,1,2,3,4,5,6,7,8,9,10,11,12,13,5,5,16,17,18,19,20,21,22,23,24,25,26,27,28,29,5,5,32,33,34,35,36,37,38,39,40,41,42,43,44,45,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,61,5,5},
 -- level 3
 {0,1,2,3,4,5,6,7,8,9,10,11,12,5,5,5,16,17,18,19,20,21,22,23,24,25,26,27,28,5,5,5,32,33,34,35,36,37,38,39,40,41,42,43,44,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 4
 {0,1,2,3,4,5,6,7,8,9,10,11,5,5,5,5,16,17,18,19,20,21,22,23,24,25,26,27,5,5,5,5,32,33,34,35,36,37,38,39,40,41,42,43,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 5
 {0,1,2,3,4,5,6,7,8,9,10,5,5,5,5,5,16,17,18,19,20,21,22,23,24,25,26,5,5,5,5,5,32,33,34,35,36,37,38,39,40,41,42,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 6
 {0,1,2,3,4,5,6,7,8,9,5,5,5,5,5,5,16,17,18,19,20,21,22,23,24,25,5,5,5,5,5,5,32,33,34,35,36,37,38,39,40,41,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 7
 {0,1,2,3,4,5,6,7,8,5,5,5,5,5,5,5,16,17,18,19,20,21,22,23,24,5,5,5,5,5,5,5,32,33,34,35,36,37,38,39,40,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 8
 {0,1,2,3,4,5,6,7,5,5,5,5,5,5,5,5,16,17,18,19,20,21,22,23,5,5,5,5,5,5,5,5,32,33,34,35,36,37,38,39,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 9
 {0,1,2,3,4,5,6,5,5,5,5,5,5,5,5,5,16,17,18,19,20,21,5,5,5,5,5,5,5,5,5,5,32,33,34,35,36,37,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 10
 {0,1,2,3,4,5,5,5,5,5,5,5,5,5,5,5,16,17,18,19,20,21,5,5,5,5,5,5,5,5,5,5,32,33,34,35,36,37,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 11
 {0,1,2,3,4,5,5,5,5,5,5,5,5,5,5,5,16,17,18,19,20,21,5,5,5,5,5,5,5,5,5,5,32,33,34,35,36,37,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 12
 {0,1,2,3,5,5,5,5,5,5,5,5,5,5,5,5,16,17,18,19,5,5,5,5,5,5,5,5,5,5,5,5,32,33,34,35,5,5,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 13
 {0,1,2,5,5,5,5,5,5,5,5,5,5,5,5,5,16,17,18,5,5,5,5,5,5,5,5,5,5,5,5,5,32,33,34,5,5,5,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 14
 {0,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,16,17,5,5,5,5,5,5,5,5,5,5,5,5,5,5,32,33,5,5,5,5,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 15: maximum fog
 {0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,16,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,32,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5}
}

:: src/door_system.lua
--[[pod_format="raw",created="2025-11-07 21:17:14",modified="2025-11-07 21:48:06",revision=1]]
-- door animation system
-- test mode state (to avoid permanent mutation)
test_mode_prev=false
test_mode_saved_state={}

-- create a door
function create_door(x,y,dtype,key_id)
 local door={
  x=x,
  y=y,
  open=0, -- 0=closed, 1=fully open
  opening=false, -- animation state
  timer=0,
  dtype=dtype or door_normal,
  keynum=key_id, -- nil if unlocked, key id if locked
  stayopen=(dtype==door_stay_open) -- doors with door_stay_open dtype stay open
 }
 
 -- prevent duplicates at same grid cell
 local existing = doorgrid[x] and doorgrid[x][y] or nil
 if existing then
  printh("warning: duplicate door at ("..x..","..y..") - replacing")
  del(doors, existing)
 end
 add(doors,door)
 doorgrid[x][y]=door
	-- walls layer already set by generation to door tile ID (authoritative)
 
 return door
end

-- update all doors
function update_doors()
 -- handle test mode transitions to avoid permanent state mutation
 if test_door_mode and not test_mode_prev then
  -- entering test mode: save states
  test_mode_saved_state={}
  for door in all(doors) do
   test_mode_saved_state[door]={open=door.open,opening=door.opening,timer=door.timer}
  end
 elseif (not test_door_mode) and test_mode_prev then
  -- exiting test mode: restore states
  for door in all(doors) do
   local st=test_mode_saved_state[door]
   if st~=nil then
    door.open=st.open
    door.opening=st.opening
    door.timer=st.timer
   end
  end
  test_mode_saved_state={}
 end
 
 -- in test mode, temporarily override open values (restored on exit)
 if test_door_mode then
  for door in all(doors) do
   door.open=test_door_open or 0
  end
  -- keep early return to skip normal animation while testing
  test_mode_prev=true
  return
 end
 
 test_mode_prev=false
 
 for door in all(doors) do
  if door.opening then
   -- play sound on start
   if door.open==0 then
    -- sfx(10) -- door open sound
   end
   -- animate opening
   door.open+=door_anim_speed
   if door.open>1 then
    door.open=1
    door.opening=false
    door.timer=door_close_delay
   end
  else
   -- not opening
   if door.timer>0 then
    door.timer-=1
   elseif not door.stayopen then
    -- close door
    door.open=max(door.open-door_anim_speed,0)
   end
  end
 end
end



-- remove a door
function remove_door(x,y)
 local door=doorgrid[x][y]
 if door then
  del(doors,door)
  doorgrid[x][y]=nil
		set_wall(x,y,0)
 end
end

:: src/dungeon_gen.lua
--[[pod_format="raw",created="2025-11-07 21:17:13",modified="2025-11-07 21:48:06",revision=1]]
-- procedural dungeon generation

-- generation state
gen_rects={}
gen_nodes={}
gen_edges={}
gen_inventory={}
gen_objects={}
gen_locked_edges={}

-- theme-specific floor id used during carving/eroding; initialized to stone_tile (1)
local gen_floor_id=1

-- observability + diagnostics configuration (defaults if config.lua did not define them)
local observability = rawget(_G,"gen_observability") or {
 enable_console=false,
 capture_history=true,
 history_limit=400,
 log_seed=true,
 log_room_attempts=true,
 log_corridors=true,
 log_progression=true,
 log_repairs=true
}

local gen_history={}
local protected_tiles={}
local dynamic_spacing=0
local base_spacing=0
local spacing_restore_timer=0
local spacing_relaxations=0
local active_theme_rules=nil
local adaptive_settings=rawget(_G,"gen_adaptive_settings") or {
 spacing_relax_threshold=4,
 spacing_relax_step=1,
 spacing_max_relax=4,
 spacing_restore_delay=2,
 spacing_restore_step=1,
 max_room_failures=20,
 offcenter_bias=0.65,
 bias_radius=12,
 junction_retry_limit=4,
 corridor_jog_chance=0.25
}

local room_failure_streak=0
local total_room_failures=0

local tick_spacing -- forward declaration
local gen_log -- forward declaration
local relax_spacing -- forward declaration

local function hist_push(entry)
 if not observability.capture_history then return end
 add(gen_history,entry)
 if #gen_history>(observability.history_limit or 400) then
  deli(gen_history,1)
 end
end

local function register_room_failure(reason)
 room_failure_streak+=1
 total_room_failures+=1
 tick_spacing(false)
 if observability.log_room_attempts then
  gen_log("room_fail",reason.." (streak="..room_failure_streak..")")
 end
 if room_failure_streak>=(adaptive_settings.spacing_relax_threshold or 4) then
  relax_spacing()
  room_failure_streak=0
 end
end

local function register_room_success()
 room_failure_streak=0
 tick_spacing(true)
end

gen_log=function(tag,msg)
 local line="["..tag.."] "..msg
 hist_push(line)
 if observability.enable_console then printh(line) end
end

local function clear_protected()
 protected_tiles={}
end

local function protect_tile(x,y)
 if not x or not y then return end
 protected_tiles[x]=protected_tiles[x] or {}
 protected_tiles[x][y]=true
end

local function is_tile_protected(x,y)
 return protected_tiles[x] and protected_tiles[x][y] or false
end

local function reset_adaptive_spacing()
 base_spacing=gen_params.spacing or 0
 dynamic_spacing=base_spacing
 spacing_restore_timer=0
 spacing_relaxations=0
 room_failure_streak=0
 total_room_failures=0
end

relax_spacing=function()
 if spacing_relaxations>=(adaptive_settings.spacing_max_relax or 4) then return end
 dynamic_spacing=max(0,dynamic_spacing-(adaptive_settings.spacing_relax_step or 1))
 spacing_relaxations+=1
 spacing_restore_timer=adaptive_settings.spacing_restore_delay or 2
 gen_log("spacing","relaxed spacing to "..dynamic_spacing)
end

tick_spacing=function(success)
 if success then
  if spacing_restore_timer>0 then
   spacing_restore_timer-=1
  elseif dynamic_spacing<base_spacing then
   dynamic_spacing=min(base_spacing,dynamic_spacing+(adaptive_settings.spacing_restore_step or 1))
   if dynamic_spacing==base_spacing then
    spacing_relaxations=0
   end
   gen_log("spacing","restored spacing to "..dynamic_spacing)
  end
 else
  if spacing_restore_timer>0 then
   spacing_restore_timer-=1
  end
 end
end

local function rect_area(rect)
 return (rect[3]-rect[1]+1)*(rect[4]-rect[2]+1)
end

local function classify_room_style(rect)
 local w=rect[3]-rect[1]+1
 local h=rect[4]-rect[2]+1
 local ratio=w/h
 if ratio>=1.8 then
  return "hall_horizontal"
 elseif ratio<=0.55 then
  return "hall_vertical"
 elseif w*h>=120 then
  return "grand"
 elseif w<=6 and h<=6 then
  return "compact"
 else
  return "square"
 end
end

local function choose_weighted(weights,default_key)
 if not weights then return default_key end
 local total=0
 for _,v in pairs(weights) do
  total+=v
 end
 if total<=0 then return default_key end
 local roll=rnd(total)
 local acc=0
 for key,v in pairs(weights) do
  acc+=v
  if roll<=acc then return key end
 end
 return default_key
end

local function get_edge_between(a,b)
 for e in all(gen_edges) do
  if (e.n1==a and e.n2==b) or (e.n1==b and e.n2==a) then
   return e
  end
 end
 return nil
end

local function locate_room_for_position(x,y)
 for node in all(gen_nodes) do
  local r=node.rect
  if x>=r[1] and x<=r[3] and y>=r[2] and y<=r[4] then
   return node
  end
 end
 return nil
end

local function relocate_key_to_room(keynum,target_node)
 if not target_node then return false end
 local sx,sy=find_spawn_point(target_node.rect)
 if not sx then
  sx=target_node.midx+0.5
  sy=target_node.midy+0.5
 end
 for ob in all(gen_objects) do
  if ob.typ==obj_types.key and ob.keynum==keynum then
   ob.pos={sx,sy}
   ob.room_index=target_node.index
   if observability.log_progression then
    gen_log("progression","relocated key#"..keynum.." to room "..target_node.index)
   end
   return true
  end
 end
 return false
end

local function validate_and_repair_progression(start_node,locked_edges)
 if not locked_edges or #locked_edges==0 then return end
 local key_rooms={}
 for ob in all(gen_objects) do
  if ob.typ==obj_types.key and ob.keynum then
   if not ob.room_index then
    local node=locate_room_for_position(ob.pos[1],ob.pos[2])
    ob.room_index=node and node.index or nil
   end
   key_rooms[ob.keynum]=ob.room_index
  end
 end

 local acquired={}
 local visited={}
 local queue={start_node}
 visited[start_node]=true
 local function collect_keys(node)
  for ob in all(gen_objects) do
   if ob.typ==obj_types.key and ob.keynum and ob.room_index==node.index then
    acquired[ob.keynum]=true
   end
  end
 end
 collect_keys(start_node)
 local progressed=true
 while progressed do
  progressed=false
  for edge in all(gen_edges) do
   local a,b=edge.n1,edge.n2
   local a_vis=visited[a]
   local b_vis=visited[b]
   if a_vis and not b_vis then
    local can_traverse=true
    if edge.locked and edge.keynum and not acquired[edge.keynum] then
     can_traverse=false
    end
    if can_traverse then
     visited[b]=true
     collect_keys(b)
     progressed=true
    end
   elseif b_vis and not a_vis then
    local can_traverse=true
    if edge.locked and edge.keynum and not acquired[edge.keynum] then
     can_traverse=false
    end
    if can_traverse then
     visited[a]=true
     collect_keys(a)
     progressed=true
    end
   end
  end
 end

 local relocated=false
 for edge in all(locked_edges) do
  if edge.locked and edge.keynum then
   local n1_vis=visited[edge.n1]
   local n2_vis=visited[edge.n2]
   if not (n1_vis and n2_vis) then
    if relocate_key_to_room(edge.keynum,start_node) then
     relocated=true
     acquired[edge.keynum]=true
     visited[edge.n1]=true
     visited[edge.n2]=true
    end
   end
  end
 end
 if relocated then
  validate_and_repair_progression(start_node,locked_edges)
 end
end

local function ensure_theme_rules(theme)
 local rules=(themes[theme] and themes[theme].rules) or nil
 active_theme_rules=rules or {
  room_aspect_bias=0.35,
  room_extra_size=0,
  spacing_floor=0,
  corridor_width=1,
  corridor_jog_chance=adaptive_settings.corridor_jog_chance or 0.25
 }
end

-- helper: check if tile is a wall
function is_wall(val)
 return val>0 and val<door_normal
end

-- helper: check if tile is a door
function is_door(val)
 return val>=door_normal and val<=door_stay_open
end

-- helper: check if tile is an exit
function is_exit(val)
 return val>=exit_start and val<=exit_end
end

-- helper: boundary cell is reserved if it has a door/exit in either layer
function is_reserved_boundary(x,y)
 local w=get_wall(x,y)
 if is_door(w) or is_exit(w) then return true end
 -- defensive: should always be 0 if walls layer is authoritative
 if get_door(x,y)>0 then return true end
 if doorgrid[x] and doorgrid[x][y] then return true end
 return false
end

-- helper: check if rectangles overlap
function rect_overlaps(rect)
 -- reject out-of-bounds rectangles upfront (map is 0..127)
 if rect[1]<0 or rect[3]>=128 or rect[2]<0 or rect[4]>=128 then
  return true
 end
 for r in all(gen_rects) do
  local spacing=dynamic_spacing or 0
  if not (rect[3]+spacing<r[1] or rect[1]>r[3]+spacing or
          rect[4]+spacing<r[2] or rect[2]>r[4]+spacing) then
   return true
  end
 end
 return false
end

local function rect_conflicts(rect,ignore_nodes,spacing_override)
 if rect[1]<0 or rect[3]>=map_size or rect[2]<0 or rect[4]>=map_size then
  return true
 end
 local ignore={}
 if ignore_nodes then
  for n in all(ignore_nodes) do
   if n and n.index then
    ignore[n.index]=true
   end
  end
 end
 local spacing=(spacing_override~=nil) and spacing_override or (dynamic_spacing or 0)
 for idx=1,#gen_rects do
  if not ignore[idx] then
   local r=gen_rects[idx]
   if r and not (rect[3]+spacing<r[1] or rect[1]>r[3]+spacing or rect[4]+spacing<r[2] or rect[2]>r[4]+spacing) then
    return true
   end
  end
 end
 return false
end

-- helper: fill rectangle using set_wall
-- Note: Uses Lua loops with userdata:set() calls; potential optimization:
-- batch userdata operations or memset() if available per Picotron guidelines
function fill_rect(rect,val)
 local x0=max(0,rect[1])
 local x1=min(127,rect[3])
 local y0=max(0,rect[2])
 local y1=min(127,rect[4])
 local fill_val=(val or 0)
 for x=x0,x1 do
  for y=y0,y1 do
   set_wall(x,y,fill_val)
  end
 end
end

-- helper: try place door with fallback positions
function try_place_door_with_fallback(x,y,dtype)
 dtype=dtype or door_normal
 local attempts={{0,0},{-1,0},{1,0},{0,-1},{0,1},{-2,0},{2,0},{0,-2},{0,2}}
 local should_place=rnd(1)<gen_params.room_door_prob
 if not should_place then
  gen_log("door","skipped optional door at "..x..","..y)
  return false
 end
 for i=1,#attempts do
  local off=attempts[i]
  local ax,ay=x+off[1],y+off[2]
  if ax>=0 and ax<map_size and ay>=0 and ay<map_size then
   local existing=get_wall(ax,ay)
   if is_wall(existing) then
    set_wall(ax,ay,dtype)
    create_door(ax,ay,dtype)
    protect_tile(ax,ay)
    if observability.log_corridors then
     gen_log("door","placed door at "..ax..","..ay.." after "..i.." attempts")
    end
    return true
   end
  end
 end
 if observability.log_repairs then
  gen_log("door","failed to place door near "..x..","..y)
 end
 return false
end

-- helper: generate random room
function random_room(base_node,is_special)
 local min_size=gen_params.min_size or 4
 local max_size=gen_params.max_size or 12
 if active_theme_rules and active_theme_rules.room_extra_size then
  max_size+=active_theme_rules.room_extra_size
 end
 if max_size<min_size then max_size=min_size end
 local shape_weights=active_theme_rules and active_theme_rules.room_shape_weights
 local shape=choose_weighted(shape_weights,"square")
 local w,h
 if is_special then
  w,h=12,12
 else
  if shape=="hall_horizontal" then
   w=flr(rnd(max_size-min_size+1))+min_size
   h=max(min_size,flr(w*0.5))
  elseif shape=="hall_vertical" then
   h=flr(rnd(max_size-min_size+1))+min_size
   w=max(min_size,flr(h*0.5))
  elseif shape=="grand" then
   w=max_size
   h=max(min_size,max_size-2)
  else
   w=flr(rnd(max_size-min_size+1))+min_size
   h=flr(rnd(max_size-min_size+1))+min_size
  end
 end
 w=min(w, max_size)
 h=min(h, max_size)
 w=max(w,min_size)
 h=max(h,min_size)

 local function sample_offset(range)
  local bias=(active_theme_rules and active_theme_rules.center_bias) or adaptive_settings.offcenter_bias or 0.65
  local magnitude=flr(range*(rnd()^bias))
  if rnd(1)<0.5 then magnitude=-magnitude end
  return magnitude
 end

 local x,y
 if base_node then
  local radius=(active_theme_rules and active_theme_rules.bias_radius) or adaptive_settings.bias_radius or 12
  local dx=sample_offset(radius)
  local dy=sample_offset(radius)
  x=base_node.midx+dx-flr(w/2)
  y=base_node.midy+dy-flr(h/2)
 else
  local margin=4
  x=flr(rnd(map_size-w-margin*2))+margin
  y=flr(rnd(map_size-h-margin*2))+margin
 end

 x=max(1,min(map_size-w-2,x))
 y=max(1,min(map_size-h-2,y))

 return {x,y,x+w-1,y+h-1}
end

-- helper: add room to generation state
function add_room(rect,is_junction)
 local index=#gen_nodes+1
 gen_rects[index]=rect
 local style=classify_room_style(rect)
 local node={
  rect=rect,
  midx=flr((rect[1]+rect[3])/2),
  midy=flr((rect[2]+rect[4])/2),
  edges={},
  is_junction=is_junction or false,
  style=style,
  area=rect_area(rect),
  theme=gen_params.theme,
  metadata={},
  index=index
 }
 if observability.log_room_attempts then
  gen_log("room","added room "..(#gen_nodes+1).." style="..style.." rect=("..rect[1]..","..rect[2]..")-("..rect[3]..","..rect[4]..")")
 end
 add(gen_nodes,node)
 return node
end

-- helper: determine corridor type between two rooms
function get_corridor_type(r1,r2)
 local ox=not (r1[3]<r2[1] or r1[1]>r2[3])
 local oy=not (r1[4]<r2[2] or r1[2]>r2[4])
 if ox and not oy then return "vert" end
 if oy and not ox then return "horiz" end
 return "l_shape"
end

-- helper: place door at exact boundary wall tile with retry
function place_boundary_door_with_retry(bx,by,dtype,max_attempts)
 dtype=dtype or door_normal
 local offsets={{0,0},{-1,0},{1,0},{0,-1},{0,1},{-2,0},{2,0},{0,-2},{0,2}}
 local attempts=max_attempts or #offsets
 for i=1,attempts do
  local off=offsets[i] or offsets[#offsets]
  local ax,ay=bx+off[1],by+off[2]
  if ax>=0 and ax<map_size and ay>=0 and ay<map_size then
   local tile=get_wall(ax,ay)
   if is_wall(tile) then
    set_wall(ax,ay,dtype)
    create_door(ax,ay,dtype)
    protect_tile(ax,ay)
    if observability.log_corridors then
     gen_log("door","boundary door placed at "..ax..","..ay.." (from "..bx..","..by..")")
    end
    return true
   end
  end
 end
 return false
end

-- helper: place door at exact boundary wall tile
function place_boundary_door(bx,by,dtype)
 -- bx,by = boundary wall tile (between corridor and room)
 if bx>=0 and bx<128 and by>=0 and by<128 then
  if is_wall(get_wall(bx,by)) then
   set_wall(bx,by,dtype or door_normal)
   create_door(bx,by,dtype)
   protect_tile(bx,by)
   return true
  end
 end
 return false
end

-- helper: ensure boundary passage (fallback for failed door placement)
function ensure_boundary_passage(bx,by)
 if bx>=0 and bx<128 and by>=0 and by<128 then
  local tile=get_wall(bx,by)
  -- if wall is still blocking and not a door, clear it
  if tile>0 and not is_door(tile) and not is_exit(tile) then
   set_wall(bx,by,0)
   set_floor(bx,by,gen_floor_id)
   protect_tile(bx,by)
   if observability.log_repairs then
    gen_log("door","fallback cleared wall at ("..bx..","..by..")")
   end
   return true
  end
 end
 return false
end

local function verify_boundary_door(bx,by,dtype)
 if not bx or not by then return end
 dtype=dtype or door_normal
 if bx<0 or bx>=map_size or by<0 or by>=map_size then return end
 local tile=get_wall(bx,by)
 if is_door(tile) then
  protect_tile(bx,by)
  return
 end
 if tile==0 then
  set_wall(bx,by,dtype)
  create_door(bx,by,dtype)
  protect_tile(bx,by)
  if observability.log_repairs then
   gen_log("door","repaired missing door at "..bx..","..by)
  end
 else
  local ok=place_boundary_door_with_retry(bx,by,dtype,6)
  if not ok then
   ensure_boundary_passage(bx,by)
  end
 end
end

local function carve_horizontal_span(y,x_start,x_end,floor_id)
 if not floor_id then floor_id=gen_floor_id end
 if y<0 or y>=map_size then return end
 local a=min(x_start,x_end)
 local b=max(x_start,x_end)
 a=max(0,a)
 b=min(map_size-1,b)
 for x=a,b do
  set_wall(x,y,0)
  set_floor(x,y,floor_id)
 end
end

local function carve_vertical_span(x,y_start,y_end,floor_id)
 if not floor_id then floor_id=gen_floor_id end
 if x<0 or x>=map_size then return end
 local a=min(y_start,y_end)
 local b=max(y_start,y_end)
 a=max(0,a)
 b=min(map_size-1,b)
 for y=a,b do
  set_wall(x,y,0)
  set_floor(x,y,floor_id)
 end
end

local function create_horizontal_corridor(n1,n2,edge)
 local left,right=n1,n2
 if n1.midx>n2.midx then left,right=n2,n1 end
 local r_left,r_right=left.rect,right.rect
 local y_start=max(r_left[2],r_right[2])
 local y_end=min(r_left[4],r_right[4])
 local y
 if y_start<=y_end then
  y=flr((y_start+y_end)/2)
 else
  y=flr((n1.midy+n2.midy)/2)
 end
 local jog_offset=0
 local jog_chance=(active_theme_rules and active_theme_rules.corridor_jog_chance) or adaptive_settings.corridor_jog_chance or 0.25
 if rnd(1)<jog_chance then
  local offset=(rnd(1)<0.5) and -1 or 1
  local candidate=y+offset
  if candidate>1 and candidate<map_size-2 then
   y=candidate
   jog_offset=offset
  end
 end
 local bx_left=r_left[3]+1
 local bx_right=r_right[1]-1
 local success=true
 if not place_boundary_door_with_retry(bx_left,y,door_normal,5) then
  success=false
  ensure_boundary_passage(bx_left,y)
 end
 if not place_boundary_door_with_retry(bx_right,y,door_normal,5) then
  success=false
  ensure_boundary_passage(bx_right,y)
 end
 carve_horizontal_span(y,bx_left+1,bx_right-1,gen_floor_id)
 verify_boundary_door(bx_left,y,door_normal)
 verify_boundary_door(bx_right,y,door_normal)
 edge.b1={x=bx_left,y=y}
 edge.b2={x=bx_right,y=y}
 edge.shape=jog_offset~=0 and "jog" or "straight"
 edge.metadata.corridor_y=y
 edge.metadata.jog_offset=jog_offset
 return success
end

local function create_vertical_corridor(n1,n2,edge)
 local top,bottom=n1,n2
 if n1.midy>n2.midy then top,bottom=n2,n1 end
 local r_top,r_bottom=top.rect,bottom.rect
 local x_start=max(r_top[1],r_bottom[1])
 local x_end=min(r_top[3],r_bottom[3])
 local x
 if x_start<=x_end then
  x=flr((x_start+x_end)/2)
 else
  x=flr((n1.midx+n2.midx)/2)
 end
 local jog_offset=0
 local jog_chance=(active_theme_rules and active_theme_rules.corridor_jog_chance) or adaptive_settings.corridor_jog_chance or 0.25
 if rnd(1)<jog_chance then
  local offset=(rnd(1)<0.5) and -1 or 1
  local candidate=x+offset
  if candidate>1 and candidate<map_size-2 then
   x=candidate
   jog_offset=offset
  end
 end
 local by_top=r_top[4]+1
 local by_bottom=r_bottom[2]-1
 local success=true
 if not place_boundary_door_with_retry(x,by_top,door_normal,5) then
  success=false
  ensure_boundary_passage(x,by_top)
 end
 if not place_boundary_door_with_retry(x,by_bottom,door_normal,5) then
  success=false
  ensure_boundary_passage(x,by_bottom)
 end
 carve_vertical_span(x,by_top+1,by_bottom-1,gen_floor_id)
 verify_boundary_door(x,by_top,door_normal)
 verify_boundary_door(x,by_bottom,door_normal)
 edge.b1={x=x,y=by_top}
 edge.b2={x=x,y=by_bottom}
 edge.shape=jog_offset~=0 and "jog" or "straight"
 edge.metadata.corridor_x=x
 edge.metadata.jog_offset=jog_offset
 return success
end

local function create_l_shaped_corridor(n1,n2,edge)
local orient_horizontal_first=rnd(1)<0.5
local anchor_x=orient_horizontal_first and n2.midx or n1.midx
local anchor_y=orient_horizontal_first and n1.midy or n2.midy
local jrect
local offsets={{0,0},{1,0},{-1,0},{0,1},{0,-1},{2,0},{-2,0},{0,2},{0,-2}}
local attempt_limit=adaptive_settings.junction_retry_limit or 4
for i=1,#offsets do
 local off=offsets[i]
 local cx=max(1,min(map_size-2,anchor_x+off[1]))
 local cy=max(1,min(map_size-2,anchor_y+off[2]))
 local candidate={cx-1,cy-1,cx+1,cy+1}
 if not rect_conflicts(candidate,{n1,n2},0) then
  jrect=candidate
  anchor_x=cx
  anchor_y=cy
  break
 end
 if i>=attempt_limit then break end
end
 local success=true
 if not jrect then
  -- fallback: carve direct manhattan path without junction
  orient_horizontal_first=true
  anchor_x=n2.midx
  anchor_y=n1.midy
  jrect=nil
  success=false
  if observability.log_corridors then
   gen_log("corridor","fallback L-shape without junction between rooms")
  end
 else
  fill_rect(jrect,0)
  for x=jrect[1],jrect[3] do
   for y=jrect[2],jrect[4] do
    set_floor(x,y,gen_floor_id)
   end
  end
  local jnode=add_room(jrect,true)
  edge.metadata.junction_node=jnode
 end

 local function connect_horizontal(from_node, target_x, y)
  local rect=from_node.rect
  local side=target_x>from_node.midx and 1 or -1
  local boundary_from=(side==1) and rect[3]+1 or rect[1]-1
  local boundary_to=side==1 and target_x-1 or target_x+1
  local door_pos=boundary_from
  if not place_boundary_door_with_retry(door_pos, y, door_normal,5) then
   success=false
   ensure_boundary_passage(door_pos,y)
  end
  carve_horizontal_span(y, boundary_from+side, boundary_to, gen_floor_id)
  verify_boundary_door(door_pos,y,door_normal)
  return {x=door_pos,y=y}
 end

 local function connect_vertical(from_node, x, target_y)
  local rect=from_node.rect
  local side=target_y>from_node.midy and 1 or -1
  local boundary_from=(side==1) and rect[4]+1 or rect[2]-1
  local boundary_to=side==1 and target_y-1 or target_y+1
  local door_pos=boundary_from
  if not place_boundary_door_with_retry(x,door_pos,door_normal,5) then
   success=false
   ensure_boundary_passage(x,door_pos)
  end
  carve_vertical_span(x, boundary_from+side, boundary_to, gen_floor_id)
  verify_boundary_door(x,door_pos,door_normal)
  return {x=x,y=door_pos}
 end

 local b1,b2
 if orient_horizontal_first then
  local horizontal_y=n1.midy
  b1=connect_horizontal(n1, anchor_x, horizontal_y)
  local vertical_x=jrect and anchor_x or b1.x+(anchor_x>b1.x and 1 or -1)
  b2=connect_vertical(n2, vertical_x, anchor_y)
 else
  local vertical_x=n1.midx
  b1=connect_vertical(n1, vertical_x, anchor_y)
  local horizontal_y=jrect and anchor_y or b1.y+(anchor_y>b1.y and 1 or -1)
  b2=connect_horizontal(n2, anchor_x, horizontal_y)
 end

 edge.b1=b1
 edge.b2=b2
 edge.shape="l_shape"
 edge.metadata.anchor={x=anchor_x,y=anchor_y}
 edge.metadata.orientation=orient_horizontal_first and "hv" or "vh"
 return success
end

function create_corridor(n1,n2)
 local edge={n1=n1,n2=n2,metadata={}}
 local ctype=get_corridor_type(n1.rect,n2.rect)
 local success=true
 if ctype=="horiz" then
  success=create_horizontal_corridor(n1,n2,edge)
 elseif ctype=="vert" then
  success=create_vertical_corridor(n1,n2,edge)
 else
  success=create_l_shaped_corridor(n1,n2,edge)
 end
 edge.success=success
 add(gen_edges,edge)
 add(n1.edges,n2)
 add(n2.edges,n1)
 if observability.log_corridors then
  local status=success and "ok" or "fallback"
  gen_log("corridor","linked nodes "..n1.index.." <-> "..n2.index.." ("..ctype..","..status..")")
 end
 return success
end

-- helper: try to generate and connect a room
function try_generate_room()
 if #gen_nodes==0 then return false end
 local base=gen_nodes[flr(rnd(#gen_nodes))+1]
 if not base then return false end
 local rect=random_room(base,false)
 
 if rect[1]<2 or rect[3]>map_size-3 or rect[2]<2 or rect[4]>map_size-3 then
  register_room_failure("bounds")
  return false
 end
 
 if rect_overlaps(rect) then
  register_room_failure("overlap")
  return false
 end
 
 local node=add_room(rect)
 fill_rect(rect,0)
 for x=max(0,rect[1]),min(map_size-1,rect[3]) do
  for y=max(0,rect[2]),min(map_size-1,rect[4]) do
   set_floor(x, y, gen_floor_id)
  end
 end
 local corridor_ok=create_corridor(base,node)
 if not corridor_ok and observability.log_corridors then
  gen_log("corridor","degenerate corridor between nodes "..base.index.." and "..node.index)
 end
 register_room_success()
 return true
end

-- helper: apply wall textures to room perimeter
function apply_room_walls(rect,tex)
 -- ensure tex is never 0
 if tex==0 then tex=1 end
 
 for x=rect[1],rect[3] do
  if rect[2]-1>=0 and rect[2]-1<128 and x>=0 and x<128 then
   -- skip reserved cells (doors/exits in any layer)
		if not is_reserved_boundary(x,rect[2]-1) then
     set_wall(x,rect[2]-1,tex)
   end
  end
  if rect[4]+1>=0 and rect[4]+1<128 and x>=0 and x<128 then
   -- skip reserved cells (doors/exits in any layer)
		if not is_reserved_boundary(x,rect[4]+1) then
     set_wall(x,rect[4]+1,tex)
   end
  end
 end
 for y=rect[2],rect[4] do
  if rect[1]-1>=0 and rect[1]-1<128 and y>=0 and y<128 then
   -- skip reserved cells (doors/exits in any layer)
		if not is_reserved_boundary(rect[1]-1,y) then
     set_wall(rect[1]-1,y,tex)
   end
  end
  if rect[3]+1>=0 and rect[3]+1<128 and y>=0 and y<128 then
   -- skip reserved cells (doors/exits in any layer)
		if not is_reserved_boundary(rect[3]+1,y) then
     set_wall(rect[3]+1,y,tex)
   end
  end
 end
end

-- repair step: ensure door tiles exist on walls layer for all logical doors
function enforce_door_tiles()
 for door in all(doors) do
  if not is_door(get_wall(door.x,door.y)) then
   set_wall(door.x,door.y,door.dtype or door_normal)
  end
 end
 
 -- also check doorgrid consistency
 for x=0,map_size-1 do
  if doorgrid[x] then
   for y=0,map_size-1 do
    if doorgrid[x][y] then
     local tile=get_wall(x,y)
     if not is_door(tile) then
      -- restore door tile from doorgrid or use default
      local correct_tile=doorgrid[x][y].tile or door_normal
      set_wall(x,y,correct_tile)
      if observability.log_repairs then
       gen_log("door","restored door tile at ("..x..","..y..")")
      end
     end
    end
   end
  end
 end
end

-- border ring enforcement: set outermost ring to walls while preserving doors/exits
function enforce_border_ring()
 -- top and bottom edges (y=0 and y=map_size-1)
 for x=0,map_size-1 do
  -- top edge
  local top_tile=get_wall(x,0)
  if not is_door(top_tile) and not is_exit(top_tile) then
  set_wall(x,0,wall_fill_tile)
  end
  
  -- bottom edge
  local bottom_tile=get_wall(x,map_size-1)
  if not is_door(bottom_tile) and not is_exit(bottom_tile) then
  set_wall(x,map_size-1,wall_fill_tile)
  end
 end
 
 -- left and right edges (x=0 and x=map_size-1)
 for y=0,map_size-1 do
  -- left edge
  local left_tile=get_wall(0,y)
  if not is_door(left_tile) and not is_exit(left_tile) then
  set_wall(0,y,wall_fill_tile)
  end
  
  -- right edge
  local right_tile=get_wall(map_size-1,y)
  if not is_door(right_tile) and not is_exit(right_tile) then
  set_wall(map_size-1,y,wall_fill_tile)
  end
 end
end

-- helper: random wall texture (never returns 0)
function random_wall_texture()
 local set=texsets[flr(rnd(#texsets-1))+2] -- skip texsets[1] which is floor
 return set.variants[flr(rnd(#set.variants))+1]
end

-- helper: get theme-appropriate wall texture set
function theme_wall_texture(theme)
 if theme=="out" then
  -- outdoor: grass or earth variants
  -- indices in texsets: 5=grass, 6=earth
  local idx=rnd(1)<0.5 and 5 or 6
  return texsets[idx] or texsets[1]
 elseif theme=="dem" then
  -- demon: stone or cobblestone
  -- indices: 4=stone, 2=cobblestone
  local idx=rnd(1)<0.5 and 4 or 2
  return texsets[idx] or texsets[1]
 elseif theme=="house" then
  -- house: wood plank
  -- index: 3=wood_plank
  return texsets[3] or texsets[1]
 else
  -- default dungeon: brick or cobblestone
  -- indices: 1=brick, 2=cobblestone
  local idx=rnd(1)<0.5 and 1 or 2
  return texsets[idx] or texsets[1]
 end
end

-- helper: find accessible rooms from start via edges
function find_accessible_rooms(start_node,locked_edges)
 local accessible={}
 local queue={start_node}
 local visited={}
 visited[start_node]=true
 
 while #queue>0 do
  local node=queue[1]
  deli(queue,1)
  add(accessible,node)
  
  for edge_node in all(node.edges) do
   if not visited[edge_node] then
    local is_locked=false
    if locked_edges then
     for le in all(locked_edges) do
					if (le.n1==node and le.n2==edge_node) or (le.n1==edge_node and le.n2==node) then
       is_locked=true
       break
      end
     end
    end
    
    if not is_locked then
     visited[edge_node]=true
     add(queue,edge_node)
    end
   end
  end
 end
 
 return accessible
end

-- helper: find spawn point in room
function find_spawn_point(rect)
 for attempt=1,max_spawn_attempts do
  local x=rect[1]+1+flr(rnd(rect[3]-rect[1]-1))
  local y=rect[2]+1+flr(rnd(rect[4]-rect[2]-1))
  
  if x>=0 and x<128 and y>=0 and y<128 and get_wall(x,y)==0 then
   local valid=true
   for obj in all(gen_objects) do
    local ox=obj.pos and obj.pos[1] or obj.x
    local oy=obj.pos and obj.pos[2] or obj.y
    if ox and oy then
     local dx,dy=abs(ox-x),abs(oy-y)
     if dx<1 and dy<1 then
      valid=false
      break
     end
    end
   end
   
   if valid then
    return x+0.5,y+0.5
   end
  end
 end
 return nil,nil
end

-- helper: erode map for organic feel (generalized for all wall types)
function erode_map(amount)
 local intensity=(active_theme_rules and active_theme_rules.erosion_intensity) or 1
 local target=flr(amount*intensity)
 local removed=0
 for i=1,target do
  local x,y=flr(rnd(map_size)),flr(rnd(map_size))
  if is_tile_protected(x,y) then goto continue end
  if is_wall(get_wall(x,y)) then
   local neighbors=0
   local near_protected=false
   for dx=-1,1 do
    for dy=-1,1 do
     local nx,ny=x+dx,y+dy
     if nx>=0 and nx<map_size and ny>=0 and ny<map_size then
      if is_tile_protected(nx,ny) then
       near_protected=true
      end
      if get_wall(nx,ny)==0 then
       neighbors+=1
      end
     end
    end
   end
   if not near_protected and neighbors>=3 then
    set_wall(x,y,0)
    set_floor(x,y,gen_floor_id)
    removed+=1
   end
  end
 ::continue::
 end
 if observability.log_corridors and removed>target*0.7 then
  gen_log("erosion","high erosion count "..removed.."/"..target)
 end
end

-- helper: generate exit portal on wall
function generate_exit(rect,exit_type)
 local walls={}
 for x=rect[1],rect[3] do
		if rect[2]-1>=0 and is_wall(get_wall(x,rect[2]-1)) then
   add(walls,{x,rect[2]})
  end
		if rect[4]+1<128 and is_wall(get_wall(x,rect[4]+1)) then
   add(walls,{x,rect[4]})
  end
 end
 for y=rect[2],rect[4] do
		if rect[1]-1>=0 and is_wall(get_wall(rect[1]-1,y)) then
   add(walls,{rect[1],y})
  end
		if rect[3]+1<128 and is_wall(get_wall(rect[3]+1,y)) then
   add(walls,{rect[3],y})
  end
 end
 
 if #walls>0 then
  local pos=walls[flr(rnd(#walls))+1]
  -- write exit tile to map
  local exit_tile=exit_type==3 and exit_start or exit_end
  set_wall(pos[1],pos[2],exit_tile or 0)
  -- also add interactable exit object
  local ob={
   pos={pos[1]+0.5,pos[2]+0.5},
   typ=obj_types.interactable_exit,
   rel={0,0},
   frame=0,
   animloop=true,
   autoanim=false,
   exit_type=exit_type
  }
  add(gen_objects,ob)
 end
end

-- gameplay generation: enemies, items, decorations, npcs
function generate_gameplay()
 -- guard against empty gen_nodes to avoid nil dereference
 if not gen_nodes or #gen_nodes==0 then
  gen_log("error","generate_gameplay() called with no rooms")
  printh("error: generate_gameplay() called with no rooms")
  return
 end
 local start_node=gen_nodes[1]
 local exit_node=gen_nodes[#gen_nodes]
 
 -- place start/exit portals
 generate_exit(start_node.rect,3)
 generate_exit(exit_node.rect,4)
 
 -- erode map
 erode_map(gen_params.erode_amount)
 
 -- populate inventory with health items
 for i=1,3 do
  add(gen_inventory,{type="heart"})
 end
 
 -- generate progression loop (simplified - no locking yet)
 generate_progression_loop(start_node)
 
 -- generate npcs (includes hostile and non-hostile)
 generate_npcs()
 
 -- generate items
 generate_items()
 
 -- generate decorations
 generate_decorations()
end

-- generate progression: items and locked doors
function generate_progression_loop(start_node)
 local locked_edges={}
 local key_counter=1
 
 -- cache accessible rooms for current locked_edges; recompute only after a successful lock
 local full_accessible=find_accessible_rooms(start_node,locked_edges)
 
 -- prepare shuffled edge order to avoid duplicate selection and ensure coverage
 local edges_shuffled={}
 for e in all(gen_edges) do add(edges_shuffled,e) end
 -- fisher-yates shuffle
 for i=#edges_shuffled,2,-1 do
  local j=flr(rnd(i))+1
  edges_shuffled[i],edges_shuffled[j]=edges_shuffled[j],edges_shuffled[i]
 end
 
 -- attempt to create progression gates
 for gate_idx=1,#edges_shuffled do
  if key_counter>3 then break end
  
  -- try to lock an edge
  local edge=edges_shuffled[gate_idx]
  local n1,n2=edge.n1,edge.n2
  
  -- check if this edge would gate content
  local combined_locked={}
  for le in all(locked_edges) do add(combined_locked,le) end
  add(combined_locked,edge)
  local test_accessible=find_accessible_rooms(start_node,combined_locked)
  
  -- if locking this edge hides new rooms, add it as a gate
  if #test_accessible<#full_accessible then
   local candidates={edge.b1,edge.b2}
   local chosen=nil
   for c in all(candidates) do
    if c and c.x and c.y then
     local wt=get_wall(c.x,c.y)
     if is_door(wt) then
      chosen=c
      break
     end
    end
   end
   if chosen then
    local x,y=chosen.x,chosen.y
    local door=doorgrid[x] and doorgrid[x][y] or nil
    if door then
     set_wall(x,y,door_locked)
     door.dtype=door_locked
     door.keynum=key_counter
     door.locked=true
    else
     set_wall(x,y,door_locked)
     create_door(x,y,door_locked,key_counter)
    end
    protect_tile(x,y)
    edge.locked=true
    edge.keynum=key_counter
    edge.lock_tile={x=x,y=y}
    add(locked_edges,edge)
    full_accessible=find_accessible_rooms(start_node,locked_edges)
    add(gen_inventory,{type="key",keynum=key_counter})
    if observability.log_progression then
     gen_log("progression","locked edge "..n1.index.." <-> "..n2.index.." key#"..key_counter)
    end
    key_counter+=1
   else
    if observability.log_progression then
     gen_log("progression","edge "..n1.index.." <-> "..n2.index.." missing door; skipped")
    end
   end
  end
 end
 
 -- place inventory items in accessible rooms
 local failed_placements=0
 -- compute accessible rooms once (does not change during item placement)
 local accessible=find_accessible_rooms(start_node,locked_edges)
 while #gen_inventory>0 do
  
  if #accessible>0 then
   local room=accessible[flr(rnd(#accessible))+1]
   local item=gen_inventory[1]
   deli(gen_inventory,1)
   
   local x,y=find_spawn_point(room.rect)
   if x then
    failed_placements=0
    if item.type=="key" then
     local ob={pos={x,y},typ=obj_types.key,rel={0,0},frame=0,animloop=true,autoanim=true,keynum=item.keynum,room_index=room.index}
     add(gen_objects,ob)
    else
     local ob={pos={x,y},typ=obj_types[item.type],rel={0,0},frame=0,animloop=true,autoanim=true}
     add(gen_objects,ob)
    end
   else
    -- handle failed placement
    if item.type=="key" then
     -- retry a limited number of times across different rooms
     local attempts=0
     local placed=false
     while attempts<15 and not placed do
      local rr=accessible[flr(rnd(#accessible))+1]
      local kx,ky=find_spawn_point(rr.rect)
      if kx then
       local ob={pos={kx,ky},typ=obj_types.key,rel={0,0},frame=0,animloop=true,autoanim=true,keynum=item.keynum,room_index=rr.index}
       add(gen_objects,ob)
       placed=true
       break
      end
      attempts+=1
     end
     if not placed then
      -- fallback: force place in start room (center if needed)
      local sx,sy=find_spawn_point(start_node.rect)
      if not sx then
       sx=start_node.midx+0.5
       sy=start_node.midy+0.5
      end
      local ob={pos={sx,sy},typ=obj_types.key,rel={0,0},frame=0,animloop=true,autoanim=true,keynum=item.keynum,room_index=start_node.index}
      add(gen_objects,ob)
     end
    else
     failed_placements+=1
     if failed_placements>10 then
      gen_log("items","failed to place items after multiple attempts; stopping")
      break
     end
    end
   end
  else
   break
  end
 end

validate_and_repair_progression(start_node,locked_edges)
gen_locked_edges=locked_edges
end

-- generate npcs (hostile and non-hostile) in rooms
function generate_npcs()
 for node in all(gen_nodes) do
  local rect=node.rect
  local num_npcs=flr(rnd(3))+1
  
  for i=1,num_npcs do
   local x,y=find_spawn_point(rect)
   if x then
    -- 70% hostile, 30% non-hostile
    if rnd(1)<gen_params.npc_hostile_ratio then
     -- select enemy type based on current difficulty level
     local available_enemies = {}
     for enemy in all(enemy_types) do
      if enemy.difficulty <= gen_params.difficulty then
       add(available_enemies, enemy)
      end
     end
     -- fallback to rat if no enemies available
     if #available_enemies == 0 then
      available_enemies = {enemy_types[1]}
     end
     local enemy_type = available_enemies[flr(rnd(#available_enemies))+1]
     
     -- hostile npc with patrol or follow behavior
     local ai_type=rnd(1)<0.5 and "patrol" or "follow"
     -- sprite_index from enemy_types configuration (64-72 range)
     local ob={
      pos={x,y},
      typ=obj_types.hostile_npc,
      rel={0,0},
      frame=0,
      animloop=true,
      autoanim=true,
      ai_type=ai_type,
      patrol_index=0,
      patrol_points={},
      sprite_index=enemy_type.sprite
     }
     -- generate patrol points if patrol mode
     if ai_type=="patrol" then
      for j=1,4 do
       local px,py=find_spawn_point(rect)
       if px then
        add(ob.patrol_points,{x=px,y=py})
       end
      end
      if #ob.patrol_points==0 then
       add(ob.patrol_points,{x=x,y=y})
      end
     end
     add(gen_objects,ob)
    else
     -- non-hostile NPCs use sprite 73
     local ob={
      pos={x,y},
      typ=obj_types.non_hostile_npc,
      rel={0,0},
      frame=0,
      animloop=true,
      autoanim=false,
      sprite_index=obj_types.non_hostile_npc.mx
     }
     add(gen_objects,ob)
    end
   end
  end
 end
end

-- generate items (pickups and interactables) in rooms
function generate_items()
 for node in all(gen_nodes) do
  local rect=node.rect
  local num_items=flr(rnd(gen_params.items_per_room))+1
  
  for i=1,num_items do
   local x,y=find_spawn_point(rect)
   if x then
    -- choose item type: 60% pickup, 40% interactable
    if rnd(1)<0.6 then
     -- direct pickup (heart or generic item)
     local pickup_type=rnd(1)<0.5 and "heart" or "direct_pickup"
     local obj_type=pickup_type=="heart" and obj_types.heart or obj_types.direct_pickup
     local ob={
      pos={x,y},
      typ=obj_type,
      rel={0,0},
      frame=0,
      animloop=true,
      autoanim=true
     }
     add(gen_objects,ob)
    else
     -- interactable (chest, shrine, trap, note)
     local subtypes={"chest","shrine","trap","note"}
     local subtype=subtypes[flr(rnd(#subtypes))+1]
     local obj_type
     if subtype=="chest" then
      obj_type=obj_types.interactable_chest
     elseif subtype=="shrine" then
      obj_type=obj_types.interactable_shrine
     elseif subtype=="trap" then
      obj_type=obj_types.interactable_trap
     else
      obj_type=obj_types.interactable_note
     end
     local ob={
      pos={x,y},
      typ=obj_type,
      rel={0,0},
      frame=0,
      animloop=true,
      autoanim=false,
      subtype=subtype
     }
     add(gen_objects,ob)
    end
   end
  end
 end
end

-- generate decorations in rooms
function generate_decorations()
 local current_theme=gen_params.theme or "dng"
 local theme_config=themes[current_theme] or themes.dng
 local decor_prob=theme_config.decor_prob or 0.8
 
 for node in all(gen_nodes) do
  local rect=node.rect
  local w,h=rect[3]-rect[1]+1,rect[4]-rect[2]+1
  local room_decor_count=0
  local max_decor=gen_params.max_decorations_per_room or 12
  
  -- uniform grid pattern
  for dec in all(decoration_types) do
   if room_decor_count>=max_decor then break end
   
   -- filter by theme: check if any theme_tags match current_theme
   local theme_match=false
   if dec.theme_tags then
    for tag in all(dec.theme_tags) do
     if tag==current_theme then
      theme_match=true
      break
     end
    end
   else
    theme_match=true -- no theme_tags means always match
   end
   
   if theme_match and dec.gen_tags then
    for tag in all(dec.gen_tags) do
     if room_decor_count>=max_decor then break end
     
     if tag=="uni" and rnd(1)<0.3*decor_prob then
      for dx=2,w-2,3 do
       for dy=2,h-2,3 do
        if room_decor_count>=max_decor then break end
        if rnd(1)<0.5 then
         local x,y=rect[1]+dx+0.5,rect[2]+dy+0.5
         -- sprite_index from decoration_types configuration (148-155 range)
         local ob={pos={x,y},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,sprite_index=dec.sprite}
         add(gen_objects,ob)
         room_decor_count+=1
        end
       end
       if room_decor_count>=max_decor then break end
      end
      
     elseif tag=="uni2" and rnd(1)<0.4*decor_prob then
      -- denser uniform grid
      for dx=1,w-1,2 do
       for dy=1,h-1,2 do
        if room_decor_count>=max_decor then break end
        if rnd(1)<0.6 then
         local x,y=rect[1]+dx+0.5,rect[2]+dy+0.5
         local ob={pos={x,y},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,sprite_index=dec.sprite}
         add(gen_objects,ob)
         room_decor_count+=1
        end
       end
       if room_decor_count>=max_decor then break end
      end
      
     elseif tag=="scatter" and rnd(1)<0.2*decor_prob then
      local count=flr(rnd(3))+1
      for i=1,count do
       if room_decor_count>=max_decor then break end
       local x,y=find_spawn_point(rect)
       if x then
        local ob={pos={x,y},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,sprite_index=dec.sprite}
        add(gen_objects,ob)
        room_decor_count+=1
       end
      end
      
     elseif tag=="big" and rnd(1)<0.15*decor_prob then
      if room_decor_count>=max_decor then break end
      -- large object: place at room center or corner
      local cx,cy=flr((rect[1]+rect[3])/2)+0.5,flr((rect[2]+rect[4])/2)+0.5
      if rnd(1)<0.5 then
       -- center
       local ob={pos={cx,cy},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,sprite_index=dec.sprite}
       add(gen_objects,ob)
       room_decor_count+=1
      else
       -- random corner
       local corners={{rect[1]+1.5,rect[2]+1.5},{rect[3]-0.5,rect[2]+1.5},{rect[1]+1.5,rect[4]-0.5},{rect[3]-0.5,rect[4]-0.5}}
       local corner=corners[flr(rnd(#corners))+1]
       local ob={pos={corner[1],corner[2]},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,sprite_index=dec.sprite}
       add(gen_objects,ob)
       room_decor_count+=1
      end
      
     elseif tag=="rare" and rnd(1)<0.05*decor_prob then
      if room_decor_count>=max_decor then break end
      -- rare: single spawn
      local x,y=find_spawn_point(rect)
      if x then
       local ob={pos={x,y},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,sprite_index=dec.sprite}
       add(gen_objects,ob)
       room_decor_count+=1
      end
      
     elseif tag=="lit" and rnd(1)<0.25*decor_prob then
      if room_decor_count>=max_decor then break end
      -- lit: bias toward walls or doorways
      local walls={}
      -- collect wall-adjacent floor tiles
      for x=rect[1]+1,rect[3]-1 do
       if get_wall(x,rect[2])>0 then add(walls,{x+0.5,rect[2]+1.5}) end
       if get_wall(x,rect[4])>0 then add(walls,{x+0.5,rect[4]-0.5}) end
      end
      for y=rect[2]+1,rect[4]-1 do
       if get_wall(rect[1],y)>0 then add(walls,{rect[1]+1.5,y+0.5}) end
       if get_wall(rect[3],y)>0 then add(walls,{rect[3]-0.5,y+0.5}) end
      end
      if #walls>0 then
       local pos=walls[flr(rnd(#walls))+1]
       local ob={pos={pos[1],pos[2]},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,sprite_index=dec.sprite}
       add(gen_objects,ob)
       room_decor_count+=1
      end
     end
    end
   end
  end
 end
end

-- generate a complete dungeon
function generate_dungeon(opts)
 opts=opts or {}
 local seed=opts.seed or flr(rnd(1000000))
 srand(seed)
 gen_history={}
 clear_protected()
 reset_adaptive_spacing()
 if gen_params.spacing==nil then gen_params.spacing=0 end
 if observability.log_seed then
  gen_log("seed","generation seed "..seed)
 end
 
 -- initialize state
 gen_rects={}
 gen_nodes={}
 gen_edges={}
 gen_inventory={}
 gen_objects={}
 doors={}
 animated_objects={}
 -- clear doorgrid
 for x=0,map_size-1 do
  if doorgrid[x] then
   for y=0,map_size-1 do
    doorgrid[x][y]=nil
   end
  end
 end
 
 -- fill with walls (non-zero tile)
 fill_rect({0,0,map_size-1,map_size-1},wall_fill_tile)
 
 -- assign global theme before carving (ensures theme floor id is available)
 local selected_theme=opts.theme or "dng"
 if not opts.theme then
  local theme_roll=rnd(1)
  if theme_roll<0.7 then
   selected_theme="dng"
  elseif theme_roll<0.9 then
   selected_theme="out"
  else
   selected_theme="dem"
  end
 end
 gen_params.theme=selected_theme
 ensure_theme_rules(selected_theme)
 local theme_config=themes[selected_theme] or themes.dng
 
 -- set floor and ceiling types based on theme
 local floor_idx=1
 local roof_idx=3
 if theme_config.floor=="stone_tile" then floor_idx=1
 elseif theme_config.floor=="dirt" then floor_idx=2
 end
 if theme_config.roof=="stone_ceiling" then roof_idx=3
 elseif theme_config.roof=="sky" then roof_idx=4
 elseif theme_config.roof=="night_sky" then roof_idx=5
 end
 floor.typ=planetyps[floor_idx]
 roof.typ=planetyps[roof_idx]
 floor.x,floor.y=0,0
 roof.x,roof.y=0,0
 -- theme-specific floor id used by generator when carving/eroding
 gen_floor_id=floor_idx
 
 -- generate first room
 local first_rect=random_room(nil,false)
 local first_node=add_room(first_rect)
 fill_rect(first_rect,0)
 for x=max(0,first_rect[1]),min(map_size-1,first_rect[3]) do
  for y=max(0,first_rect[2]),min(map_size-1,first_rect[4]) do
   set_floor(x, y, gen_floor_id)
  end
 end
 register_room_success()
 
 -- generate additional rooms
 local target_rooms=flr(rnd(gen_params.max_rooms-gen_params.min_rooms+1))+gen_params.min_rooms
 for i=2,target_rooms do
  local placed=false
  for attempt=1,max_room_attempts do
   if try_generate_room() then
    placed=true
    break
   end
  end
  if not placed and observability.log_room_attempts then
   gen_log("room","failed to place room "..i.." after "..max_room_attempts.." attempts")
  end
 end
 
 -- apply wall textures based on theme
 for node in all(gen_nodes) do
  if not node.is_junction then
   local texset=theme_wall_texture(selected_theme)
   local tex=texset.variants[flr(rnd(#texset.variants))+1]
   apply_room_walls(node.rect,tex)
  end
 end
 
 -- ensure any doors placed earlier remain doors on the walls layer
 enforce_door_tiles()
 
 -- generate gameplay content (now aware of theme)
 generate_gameplay()
 -- gameplay may lock doors; re-assert tiles
 enforce_door_tiles()
 
 -- enforce border ring while preserving doors/exits
 enforce_border_ring()
 -- re-assert door tiles after border enforcement
 enforce_door_tiles()
 if observability.enable_console then
  gen_log("summary","border ring enforced")
 end
 
 -- export objects to global arrays (flat iteration, no spatial grid)
 objects=gen_objects
 
 -- populate animated_objects list for frame updates
 animated_objects={}
 for ob in all(objects) do
  if ob.autoanim then
   add(animated_objects, ob)
  end
 end
 
 -- set player start
 player.x=first_node.midx+0.5
 player.y=first_node.midy+0.5
 
 if observability.enable_console then
  gen_log("summary","rooms="..#gen_nodes.." objects="..#gen_objects)
 end
 
 return {x=player.x,y=player.y},{rooms=#gen_nodes,objects=#gen_objects,seed=seed,history=gen_history}
end


:: src/r_batch.lua
--[[pod_format="raw",created="2025-11-12 00:00:00",modified="2025-11-12 00:00:00",revision=1]]
-- r_batch.lua
-- Central batching for tline3d and rectfill operations

local r_batch = {}

-- Batch configuration
local TLINE_COLS = 13  -- sprite_index, x0,y0,x1,y1, u0,v0,u1,v1, w0,w1, flags
local RECT_COLS = 5    -- x0,y0,x1,y1, color

-- Buffer capacities
local tline_capacity = 480 * 2  -- 2x screen width
local rect_capacity = 480 * 4   -- 4x screen width

-- Batch buffers
local tline_args = nil
local rect_args = nil
local tline_count = 0
local rect_count = 0

-- Current clip/palette state (for pass isolation)
local current_clip = nil
local current_palette = nil

-- Initialize batch buffers
function r_batch.init()
  tline_args = userdata("f64", TLINE_COLS, tline_capacity)
  rect_args = userdata("f64", RECT_COLS, rect_capacity)
  tline_count = 0
  rect_count = 0
  printh("[r_batch] initialized: tline=" .. tline_capacity .. ", rect=" .. rect_capacity)
end

-- Reset tline batch
function r_batch.tline_reset()
  tline_count = 0
end

-- Push a tline3d call to batch
function r_batch.tline_push(idx, x0, y0, x1, y1, u0, v0, u1, v1, w0, w1, flags)
  if tline_count >= tline_capacity then
    r_batch.tline_submit()
  end
  
  tline_args:set(0, tline_count, 
    idx, x0, y0, x1, y1, 
    u0, v0, u1, v1, 
    w0 or 1, w1 or 1, 
    flags or 0)
  tline_count = tline_count + 1
end

-- Submit tline batch
function r_batch.tline_submit()
  if tline_count > 0 then
    tline3d(tline_args, 0, tline_count, TLINE_COLS)
    tline_count = 0
  end
end

-- Reset rect batch
function r_batch.rect_reset()
  rect_count = 0
end

-- Push a rectfill call to batch
function r_batch.rect_push(x0, y0, x1, y1, c)
  if rect_count >= rect_capacity then
    r_batch.rect_submit()
  end
  
  rect_args:set(0, rect_count, x0, y0, x1, y1, c)
  rect_count = rect_count + 1
end

-- Submit rect batch
function r_batch.rect_submit()
  if rect_count > 0 then
    rectfill(rect_args, 0, rect_count, RECT_COLS)
    rect_count = 0
  end
end

-- Set clip region for current pass
function r_batch.set_clip(x, y, w, h)
  -- Flush any pending batches before changing state
  r_batch.tline_submit()
  r_batch.rect_submit()
  
  if x == nil then
    clip()
    current_clip = nil
  else
    clip(x, y, w, h)
    current_clip = {x, y, w, h}
  end
end

-- Set palette for current pass
function r_batch.set_palette(pal_table)
  -- Flush any pending batches before changing state
  r_batch.tline_submit()
  r_batch.rect_submit()
  
  if pal_table == nil then
    pal()
    current_palette = nil
  else
    pal(pal_table)
    current_palette = pal_table
  end
end

-- Restore default state (called at pass boundaries)
function r_batch.restore_defaults()
  r_batch.tline_submit()
  r_batch.rect_submit()
  clip()
  pal()
  palt()
  current_clip = nil
  current_palette = nil
end

return r_batch


:: src/r_cast.lua
--[[pod_format="raw",created="2025-11-12 00:00:00",modified="2025-11-12 00:00:00",revision=1]]
-- r_cast.lua
-- DDA raycaster writing hit data to userdata buffers

local r_cast = {}

-- Sign helper
local function sgn(n)
  if n < 0 then return -1 end
  if n > 0 then return 1 end
  return 0
end

-- DDA raycast with depth tracking
-- Returns: z, hit_x, hit_y, tile, tx
local function raycast_dda(x, y, dx, dy, fx, fy, far_plane, map_size, get_wall_fn, is_door_fn, doorgrid, test_door_mode, test_door_open)
  -- Clamp near-zero components
  if abs(dx) < 0.01 then dx = 0.01 end
  if abs(dy) < 0.01 then dy = 0.01 end
  
  -- Horizontal ray initialization
  local hx, hy, hdx, hdy = x, y, sgn(dx), dy / abs(dx)
  local hdz = hdx * fx + hdy * fy
  local hz = 0
  
  -- Step to grid boundary
  local fracx = hx % 1
  local hstep = (hdx > 0) and (1 - fracx) or fracx
  hx = hx + hdx * hstep
  hy = hy + hdy * hstep
  hz = hz + hdz * hstep
  
  -- Vertical ray initialization
  local vx, vy, vdx, vdy = x, y, dx / abs(dy), sgn(dy)
  local vdz = vdx * fx + vdy * fy
  local vz = 0
  
  -- Step to grid boundary
  local fracy = vy % 1
  local vstep = (vdy > 0) and (1 - fracy) or fracy
  vx = vx + vdx * vstep
  vy = vy + vdy * vstep
  vz = vz + vdz * vstep
  
  -- Compute iteration limit
  local horizontal_crossings = (hdx > 0) and (map_size - math.floor(hx)) or (math.floor(hx) + 1)
  local vertical_crossings = (vdy > 0) and (map_size - math.floor(vy)) or (math.floor(vy) + 1)
  local iteration_limit = min(256, horizontal_crossings + vertical_crossings + 10)
  
  -- Ray marching
  for iter = 1, iteration_limit do
    -- Far-plane check
    if min(hz, vz) > far_plane then
      return 999, hx, hy, 0, 0
    end
    
    if hz < vz then
      -- Horizontal crossing (vertical gridline)
      local gx = math.floor(hx) + ((hdx < 0) and -1 or 0)
      local gy = math.floor(hy)
      
      -- OOB check
      if (gx < 0 and hdx < 0) or (gx >= map_size and hdx > 0) or 
         (gy < 0 and hdy < 0) or (gy >= map_size and hdy > 0) then
        return 999, hx, hy, 0, 0
      end
      
      if gx >= 0 and gx < map_size and gy >= 0 and gy < map_size then
        local m = get_wall_fn(gx, gy)
        if m > 0 then
          -- Check if door
          if is_door_fn(m) and doorgrid[gx] and doorgrid[gx][gy] then
            local dz = ((hx + hdx / 2 - x) * fx + (hy + hdy / 2 - y) * fy)
            if dz <= vz then
              local open = test_door_mode and (test_door_open or 0) or doorgrid[gx][gy].open
              local dy_off = (hy + hdy / 2) % 1 - open
              if dy_off >= 0 then
                return dz, hx, hy, m, dy_off
              end
            end
          else
            -- Wall hit
            local z = ((hx - x) * fx + (hy - y) * fy)
            local frac = hy - math.floor(hy)
            local tx = (hdx > 0) and (1 - frac) or frac
            return z, hx, hy, m, tx
          end
        end
      end
      
      hx = hx + hdx
      hy = hy + hdy
      hz = hz + hdz
    else
      -- Vertical crossing (horizontal gridline)
      local gx = math.floor(vx)
      local gy = math.floor(vy) + ((vdy < 0) and -1 or 0)
      
      -- OOB check
      if (gx < 0 and vdx < 0) or (gx >= map_size and vdx > 0) or 
         (gy < 0 and vdy < 0) or (gy >= map_size and vdy > 0) then
        return 999, vx, vy, 0, 0
      end
      
      if gx >= 0 and gx < map_size and gy >= 0 and gy < map_size then
        local m = get_wall_fn(gx, gy)
        if m > 0 then
          -- Check if door
          if is_door_fn(m) and doorgrid[gx] and doorgrid[gx][gy] then
            local dz = ((vx + vdx / 2 - x) * fx + (vy + vdy / 2 - y) * fy)
            if dz <= hz then
              local open = test_door_mode and (test_door_open or 0) or doorgrid[gx][gy].open
              local dx_off = (vx + vdx / 2) % 1 - open
              if dx_off >= 0 then
                return dz, vx, vy, m, dx_off
              end
            end
          else
            -- Wall hit
            local z = ((vx - x) * fx + (vy - y) * fy)
            local frac = vx - math.floor(vx)
            local tx = (vdy < 0) and (1 - frac) or frac
            return z, vx, vy, m, tx
          end
        end
      end
      
      vx = vx + vdx
      vy = vy + vdy
      vz = vz + vdz
    end
  end
  
  -- Fallback
  return 999, hx, hy, 0, 0
end

-- Cast scene: populate ray hit buffers
-- camera: {x, y} position table
-- r_view: view module with forward/right vectors
-- r_state: renderer state with buffers
-- game_state: {get_wall, is_door, doorgrid, test_door_mode, test_door_open, far_plane, map_size}
function r_cast.cast_scene(camera, r_view, r_state, game_state)
  local bufs = r_state.buffers
  local ray_cnt = r_state.occupancy.rays_active
  local fx, fy = r_view.forward_x, r_view.forward_y
  
  for i = 0, ray_cnt - 1 do
    local dx = bufs.ray_dir_x:get(i)
    local dy = bufs.ray_dir_y:get(i)
    
    local z, hx, hy, tile, tx = raycast_dda(
      camera.x, camera.y, dx, dy, fx, fy,
      game_state.far_plane, game_state.map_size,
      game_state.get_wall, game_state.is_door,
      game_state.doorgrid, game_state.test_door_mode, game_state.test_door_open
    )
    
    bufs.ray_z:set(i, z)
    bufs.ray_hitx:set(i, hx)
    bufs.ray_hity:set(i, hy)
    bufs.ray_tile:set(i, tile)
    bufs.ray_tx:set(i, tx)
  end
end

return r_cast


:: src/r_diag.lua
--[[pod_format="raw",created="2025-11-12 00:00:00",modified="2025-11-12 00:00:00",revision=1]]
-- r_diag.lua
-- Diagnostics overlay gated by debug_mode

local r_diag = {}

-- Draw diagnostics panel
-- r_state: renderer state with occupancy counters
-- frame_ms: frame time in milliseconds
-- cpu_sample: CPU usage from stat(1)
function r_diag.draw(r_state, frame_ms, cpu_sample)
  if not r_state.config.debug_mode then
    return
  end
  
  local cfg = r_state.config
  local occ = r_state.occupancy
  
  -- Format metrics
  frame_ms = frame_ms or 0
  cpu_sample = cpu_sample or 0
  local cpu_pct = math.floor(cpu_sample * 1000 + 0.5) / 10
  local frame_ms_fmt = math.floor(frame_ms * 10 + 0.5) / 10
  local rays_text = occ.rays_active .. "/" .. cfg.ray_count
  
  local lines = {
    {text = "r_diag: metrics", color = 11},
    {text = "frame_ms: " .. frame_ms_fmt, color = 11},
    {text = "cpu%: " .. cpu_pct, color = (cpu_pct > 90) and 8 or ((cpu_pct > 70) and 10 or 11)},
    {text = "rays: " .. rays_text, color = 7},
    {text = "floor rows: " .. occ.floor_rows, color = 7},
    {text = "wall spans: " .. occ.wall_spans, color = 7},
    {text = "sprite count: " .. occ.sprite_count, color = 7}
  }
  
  -- Compute panel dimensions
  local max_len = 0
  for entry in all(lines) do
    if #entry.text > max_len then
      max_len = #entry.text
    end
  end
  
  local panel_x = 4
  local panel_y = 80
  local panel_w = max_len * 4 + 6
  local panel_h = #lines * 8 + 6
  
  -- Save clip/palette state
  local prev_clip = peek(0x5f20, 4)
  
  -- Draw panel background and border
  clip()
  rectfill(panel_x - 2, panel_y - 2, panel_x + panel_w, panel_y + panel_h, 1)
  rect(panel_x - 3, panel_y - 3, panel_x + panel_w + 1, panel_y + panel_h + 1, 7)
  
  -- Draw text
  for i = 1, #lines do
    local entry = lines[i]
    print(entry.text, panel_x, panel_y + (i - 1) * 8, entry.color)
  end
  
  -- Restore clip state
  clip()
end

return r_diag


:: src/r_floor.lua
--[[pod_format="raw",created="2025-11-12 00:00:00",modified="2025-11-12 00:00:00",revision=1]]
-- r_floor.lua
-- Hybrid floor/ceiling renderer with near/mid/far row scheduling

local r_floor = {}

-- Preallocated buffers for per-cell floor runs (avoid per-frame allocations)
local RUN_CAP = 1024
local runs_x0 = userdata("i16", RUN_CAP)
local runs_x1 = userdata("i16", RUN_CAP)
local runs_id = userdata("i16", RUN_CAP)
local merged_x0 = userdata("i16", RUN_CAP)
local merged_x1 = userdata("i16", RUN_CAP)
local merged_id = userdata("i16", RUN_CAP)

-- Clamped blit helper
local function clamped_blit(src_row, dst_row, screen_center_y, screen_height, y1_limit, r_state)
  if dst_row > y1_limit then return end
  local dst_y = screen_center_y + dst_row
  if dst_y < 0 or dst_y >= screen_height then return end
  local src_y = screen_center_y + src_row
  if src_y < 0 or src_y >= screen_height then return end
  blit(get_draw_target(), get_draw_target(), 0, src_y, 0, dst_y, screen_width, 1)
  r_state.occupancy.floor_rows = r_state.occupancy.floor_rows + 1
end

-- Resolve sprite index with fallback
local function resolve_sprite_index(idx, kind, error_idx_table, get_spr_fn)
  if idx and get_spr_fn(idx) then
    return idx
  end
  if error_idx_table then
    if kind == "floor" then return error_idx_table.floor
    elseif kind == "ceiling" then return error_idx_table.ceiling
    else return error_idx_table.default end
  end
  return 0
end

-- Draw single row with optional per-cell floor sampling
local function draw_single_row(row, src, tex, tilesize, height, cx, cy, sa, ca, sdist, screen_center_y, screen_width, sprite_size, r_batch, r_state, per_cell_floors, get_floor_fn, planetyps, error_idx_table, get_spr_fn)
  local y = row
  local y_offset = (y >= 0) and (y + 0.5) or abs(y - 0.5)
  local g = y_offset / sdist
  if g < 0.0001 then g = 0.0001 end
  local z = (height or 0.5) / g
  local mx = (cx + z * sa) / tilesize
  local my = (cy + z * ca) / tilesize
  local s = sdist / z * tilesize
  local mdx = -ca / s
  local mdy = sa / s
  mx = mx - screen_center_x * mdx
  my = my - screen_center_x * mdy
  
  if per_cell_floors then
    -- Per-cell floor sampling
    local sample_interval = 12
    local rcount = 0
    local cur_id = -1
    local cur_x0 = 0
    
    for x = 0, screen_width - 1, sample_interval do
      local wx = mx + x * mdx
      local wy = my + x * mdy
      local gx = math.floor(wx)
      local gy = math.floor(wy)
      local fid = get_floor_fn(gx, gy)
      
      if cur_id < 0 then
        cur_id = fid
        cur_x0 = x
      elseif fid ~= cur_id then
        if rcount < RUN_CAP then
          runs_x0:set(rcount, cur_x0)
          runs_x1:set(rcount, x - 1)
          runs_id:set(rcount, cur_id)
          rcount = rcount + 1
        end
        cur_id = fid
        cur_x0 = x
      end
    end
    
    if rcount < RUN_CAP then
      runs_x0:set(rcount, cur_x0)
      runs_x1:set(rcount, screen_width - 1)
      runs_id:set(rcount, cur_id)
      rcount = rcount + 1
    end
    
    -- Merge tiny runs
    local mcount = 0
    for i = 0, rcount - 1 do
      local x0i = runs_x0:get(i)
      local x1i = runs_x1:get(i)
      local fidi = runs_id:get(i)
      local width = x1i - x0i + 1
      if width < 4 and mcount > 0 then
        local prev_x1 = merged_x1:get(mcount - 1)
        if x1i > prev_x1 then merged_x1:set(mcount - 1, x1i) end
      else
        if mcount < RUN_CAP then
          merged_x0:set(mcount, x0i)
          merged_x1:set(mcount, x1i)
          merged_id:set(mcount, fidi)
          mcount = mcount + 1
        end
      end
    end
    
    -- Draw merged runs
    for i = 0, mcount - 1 do
      local rx0 = merged_x0:get(i)
      local rx1 = merged_x1:get(i)
      local fid = merged_id:get(i)
      local run_tex = tex
      if fid > 0 and fid <= #planetyps then
        run_tex = planetyps[fid].tex
      end
      local idx = resolve_sprite_index(run_tex, "floor", error_idx_table, get_spr_fn)
      local u0 = ((mx + rx0 * mdx) % 1) * sprite_size
      local v0 = ((my + rx0 * mdy) % 1) * sprite_size
      u0 = math.max(0, math.min(sprite_size - 0.001, u0))
      v0 = math.max(0, math.min(sprite_size - 0.001, v0))
      local u1 = u0 + (rx1 - rx0) * mdx * sprite_size
      local v1 = v0 + (rx1 - rx0) * mdy * sprite_size
      r_batch.tline_push(idx, rx0, screen_center_y + y, rx1, screen_center_y + y, u0, v0, u1, v1, 1, 1)
    end
  else
    -- Single texture for entire row
    local idx = resolve_sprite_index(tex, "floor", error_idx_table, get_spr_fn)
    local u0 = (mx % 1) * sprite_size
    local v0 = (my % 1) * sprite_size
    u0 = math.max(0, math.min(sprite_size - 0.001, u0))
    v0 = math.max(0, math.min(sprite_size - 0.001, v0))
    local u1 = u0 + (screen_width - 1) * mdx * sprite_size
    local v1 = v0 + (screen_width - 1) * mdy * sprite_size
    r_batch.tline_push(idx, 0, screen_center_y + y, screen_width - 1, screen_center_y + y, u0, v0, u1, v1, 1, 1)
  end
  
  r_state.occupancy.floor_rows = r_state.occupancy.floor_rows + 1
end

-- Draw floor and ceiling with hybrid duplication schedule
-- camera: {x, y} position
-- r_view: view module with forward/right vectors and sdist
-- r_state: renderer state
-- r_batch: batch module
-- game_state: {floor, roof, sprite_size, per_cell_floors_enabled, get_floor, planetyps, error_textures, ERROR_IDX, get_spr}
function r_floor.draw_floor_ceiling(camera, r_view, r_state, r_batch, game_state)
  local cfg = r_state.config
  local screen_center_y = cfg.screen_height / 2
  local screen_width = cfg.screen_width
  local screen_height = cfg.screen_height
  local fwdy = r_view.forward_y
  local fwdx = r_view.forward_x
  local sdist = r_view.sdist
  local sprite_size = game_state.sprite_size or 32
  
  palt(0, false)
  
  r_batch.tline_reset()
  
  -- Draw ceiling
  local roof_typ = game_state.roof.typ
  local roof_src = game_state.get_spr(roof_typ.tex)
  local y0_ceil = -screen_center_y
  local y1_ceil = -1
  
  -- Near ceiling rows (every row)
  local near_end = math.min(y1_ceil, -16)
  for y = y0_ceil, near_end do
    draw_single_row(y, roof_src, roof_typ.tex, roof_typ.scale, roof_typ.height, 
      camera.x - game_state.roof.x, camera.y - game_state.roof.y, 
      fwdy, fwdx, sdist, screen_center_y, screen_width, sprite_size, 
      r_batch, r_state, false, nil, nil, game_state.ERROR_IDX, game_state.get_spr)
  end
  
  -- Mid ceiling rows (2x duplication)
  local mid_end = math.min(y1_ceil, 32)
  local y = near_end + 1
  while y <= mid_end do
    draw_single_row(y, roof_src, roof_typ.tex, roof_typ.scale, roof_typ.height,
      camera.x - game_state.roof.x, camera.y - game_state.roof.y,
      fwdy, fwdx, sdist, screen_center_y, screen_width, sprite_size,
      r_batch, r_state, false, nil, nil, game_state.ERROR_IDX, game_state.get_spr)
    clamped_blit(y, y + 1, screen_center_y, screen_height, y1_ceil, r_state)
    y = y + 2
  end
  
  -- Far ceiling rows (4x duplication)
  while y <= y1_ceil do
    draw_single_row(y, roof_src, roof_typ.tex, roof_typ.scale, roof_typ.height,
      camera.x - game_state.roof.x, camera.y - game_state.roof.y,
      fwdy, fwdx, sdist, screen_center_y, screen_width, sprite_size,
      r_batch, r_state, false, nil, nil, game_state.ERROR_IDX, game_state.get_spr)
    clamped_blit(y, y + 1, screen_center_y, screen_height, y1_ceil, r_state)
    clamped_blit(y, y + 2, screen_center_y, screen_height, y1_ceil, r_state)
    clamped_blit(y, y + 3, screen_center_y, screen_height, y1_ceil, r_state)
    y = y + 4
  end
  
  -- Draw floor
  local floor_typ = game_state.floor.typ
  local floor_src = game_state.get_spr(floor_typ.tex)
  local y0_floor = 0
  local y1_floor = screen_center_y - 1
  
  -- Near floor rows (every row) - POSITIVE threshold for floor space
  near_end = math.min(y1_floor, 16)
  for y = y0_floor, near_end do
    draw_single_row(y, floor_src, floor_typ.tex, floor_typ.scale, floor_typ.height,
      camera.x - game_state.floor.x, camera.y - game_state.floor.y,
      fwdy, fwdx, sdist, screen_center_y, screen_width, sprite_size,
      r_batch, r_state, game_state.per_cell_floors_enabled, game_state.get_floor, game_state.planetyps, game_state.ERROR_IDX, game_state.get_spr)
  end
  
  -- Mid floor rows (2x duplication) - POSITIVE threshold
  mid_end = math.min(y1_floor, 48)
  y = near_end + 1
  while y <= mid_end do
    draw_single_row(y, floor_src, floor_typ.tex, floor_typ.scale, floor_typ.height,
      camera.x - game_state.floor.x, camera.y - game_state.floor.y,
      fwdy, fwdx, sdist, screen_center_y, screen_width, sprite_size,
      r_batch, r_state, game_state.per_cell_floors_enabled, game_state.get_floor, game_state.planetyps, game_state.ERROR_IDX, game_state.get_spr)
    clamped_blit(y, y + 1, screen_center_y, screen_height, y1_floor, r_state)
    y = y + 2
  end
  
  -- Far floor rows (4x duplication)
  while y <= y1_floor do
    draw_single_row(y, floor_src, floor_typ.tex, floor_typ.scale, floor_typ.height,
      camera.x - game_state.floor.x, camera.y - game_state.floor.y,
      fwdy, fwdx, sdist, screen_center_y, screen_width, sprite_size,
      r_batch, r_state, game_state.per_cell_floors_enabled, game_state.get_floor, game_state.planetyps, game_state.ERROR_IDX, game_state.get_spr)
    clamped_blit(y, y + 1, screen_center_y, screen_height, y1_floor, r_state)
    clamped_blit(y, y + 2, screen_center_y, screen_height, y1_floor, r_state)
    clamped_blit(y, y + 3, screen_center_y, screen_height, y1_floor, r_state)
    y = y + 4
  end
  
  r_batch.tline_submit()
  palt()
end

return r_floor


:: src/r_sprites.lua
--[[pod_format="raw",created="2025-11-12 00:00:00",modified="2025-11-12 00:00:00",revision=1]]
-- r_sprites.lua
-- Depth-bucketed sprite renderer with impostor fallback

local r_sprites = {}

-- Note: Sprite buckets now use userdata buffers from r_state
-- Each bucket stores object indices (not object references) to avoid GC pressure
-- Buckets are stored as flat arrays: [bucket0_obj1, bucket0_obj2, ..., bucket1_obj1, ...]
-- bucket_counts tracks how many objects in each bucket

local function clear_buckets(r_state)
  -- Zero out bucket counts (userdata stays allocated)
  for i = 0, r_state.config.sprite_bucket_count - 1 do
    r_state.buffers.sprite_bucket_counts:set(i, 0)
  end
end

-- Draw single sprite with z-buffer occlusion
local function draw_sprite(ob, camera, r_view, r_state, r_batch, game_state)
  if not ob or not ob.typ or not ob.rel then
    return
  end
  
  local t = ob.typ
  local x = ob.rel[1]  -- camera-space x
  local z = ob.rel[2]  -- camera-space z (depth)
  local sdist = r_view.sdist
  local cfg = r_state.config
  local screen_center_x = cfg.screen_width / 2
  local screen_center_y = cfg.screen_height / 2
  local sprite_size = game_state.sprite_size or 32
  
  -- Fetch sprite index
  local base_sprite_index = ob.sprite_index or t.mx
  local sprite_index = base_sprite_index
  
  -- Handle animation
  if t.framect then
    local fr = math.floor(ob.frame or 0)
    if ob.animloop then
      fr = fr % t.framect
    else
      fr = math.min(fr, t.framect - 1)
    end
    sprite_index = base_sprite_index + fr
  end
  
  -- Validate sprite exists
  local src = game_state.get_spr(sprite_index)
  if not src then
    if sprite_index ~= base_sprite_index then
      sprite_index = base_sprite_index
    end
    src = game_state.get_spr(sprite_index)
  end
  
  if not src then
    src = game_state.error_textures.sprite or game_state.error_textures.default
  end
  
  -- Get vertical offset
  local y = ob.y or t.y
  if t.yoffs then
    local frame = ob.frame or 0
    local frame_idx = math.floor(frame % #t.yoffs) + 1
    if frame_idx > 0 and frame_idx <= #t.yoffs then
      y = y + t.yoffs[frame_idx]
    end
  end
  
  -- LOD: impostor rendering for distant sprites
  local sprite_lod_distance = game_state.fog_far * game_state.sprite_lod_ratio
  if z > sprite_lod_distance then
    -- Sample average color from sprite center
    local avg_color = 5
    if src and src.get then
      avg_color = src:get(16, 16) or 5
    end
    
    -- Project to screen space
    local f_lod = sdist / z
    local sx_lod = x * f_lod + screen_center_x
    local w_lod = t.w * f_lod
    
    -- Compute vertical span
    local y0_lod, y1_lod
    if t.flat then
      local z0 = z + t.w / 2
      local z1 = z - t.w / 2
      y0_lod = y * sdist / z0 + screen_center_y
      y1_lod = y * sdist / z1 + screen_center_y
    else
      local sy_lod = y * f_lod + screen_center_y
      local h_lod = t.h * f_lod
      y0_lod = sy_lod - h_lod / 2
      y1_lod = sy_lod + h_lod / 2
    end
    
    -- Clamp to screen bounds
    local x0 = math.max(0, math.ceil(sx_lod - w_lod / 2))
    local x1 = math.min(cfg.screen_width - 1, math.floor(sx_lod + w_lod / 2))
    y0_lod = math.max(0, math.ceil(y0_lod))
    y1_lod = math.min(cfg.screen_height - 1, math.floor(y1_lod))
    
    -- Draw impostor columns with z-test
    if y1_lod > y0_lod and x1 >= x0 then
      r_batch.rect_reset()
      for px = x0, x1 do
        local zb = r_state.zread(px)
        if z < zb then
          r_batch.rect_push(px, y0_lod, px, y1_lod, avg_color)
          r_state.zwrite(px, z)
        end
      end
      r_batch.rect_submit()
    end
    
    return
  end
  
  -- Full texture rendering
  local f = sdist / z
  local sx = x * f + screen_center_x
  local w = t.w * f
  
  -- Calculate y coordinates
  local y0, y1
  if t.flat then
    local z0 = z + t.w / 2
    local z1 = z - t.w / 2
    y0 = y * sdist / z0 + screen_center_y
    y1 = y * sdist / z1 + screen_center_y
  else
    local sy = y * f + screen_center_y
    local h = t.h * f
    y0 = sy - h / 2
    y1 = sy + h / 2
  end
  
  -- Map to UV space
  local sxd = sprite_size / w
  local syd = sprite_size / (y1 - y0 + 0.01)
  local u0 = 0
  local v0 = 0
  
  -- Clamp to screen bounds
  local lx = sx - w / 2
  local fy0 = y0
  local x0 = math.max(0, math.ceil(lx))
  local x1 = math.min(cfg.screen_width - 1, math.floor(sx + w / 2))
  
  if x0 > lx then
    u0 = u0 + (x0 - lx) * sxd
  end
  
  y0 = math.max(0, math.ceil(fy0))
  y1 = math.min(cfg.screen_height - 1, math.floor(y1))
  
  if y0 > fy0 then
    v0 = v0 + (y0 - fy0) * syd
  end
  
  -- Guard against degenerate span
  if y1 <= y0 or x1 < x0 then
    return
  end
  
  -- Draw sprite column-by-column with z-buffer
  local spr_idx = sprite_index
  r_batch.tline_reset()
  for px = x0, x1 do
    local zb = r_state.zread(px)
    if z < zb then
      local u = u0 + (px - x0) * sxd
      r_batch.tline_push(spr_idx, px, y0, px, y1, u, v0, u, v0 + sprite_size, 1, 1)
      r_state.zwrite(px, z)
    end
  end
  r_batch.tline_submit()
end

-- Render all sprites with depth bucketing
-- camera: {x, y} position
-- r_view: view module with forward/right vectors
-- r_state: renderer state
-- r_batch: batch module
-- game_state: {objects, far_plane, sprite_lod_ratio, fog_far, sprite_size, get_spr, error_textures}
function r_sprites.draw(camera, r_view, r_state, r_batch, game_state)
  local cfg = r_state.config
  local sa, ca = sin(camera.a), cos(camera.a)
  local bucket_size = game_state.far_plane / 8
  local bufs = r_state.buffers
  local bucket_count = cfg.sprite_bucket_count
  local bucket_capacity = cfg.sprite_bucket_capacity
  
  clear_buckets(r_state)
  
  -- Build object index list (for stable bucket storage)
  local obj_list = game_state.objects
  local obj_count = #obj_list
  
  -- Transform sprites to camera space and bucket by depth
  for obj_idx = 1, obj_count do
    local ob = obj_list[obj_idx]
    if ob and ob.pos and ob.typ then
      -- Transform to view space
      local rx = ob.pos[1] - camera.x
      local ry = ob.pos[2] - camera.y
      
      -- Simple distance culling
      if abs(rx) >= game_state.far_plane or abs(ry) >= game_state.far_plane then
        goto skip_sprite
      end
      
      -- Rotate to camera space
      local x_cam = -sa * rx + ca * ry
      local z_cam = ca * rx + sa * ry
      ob.rel = ob.rel or {}
      ob.rel[1] = x_cam
      ob.rel[2] = z_cam
      
      -- Far-plane culling
      if ob.rel[2] > game_state.far_plane then
        goto skip_sprite
      end
      
      -- Frustum culling
      local t = ob.typ
      local pass_frustum = false
      if ob.rel[2] > 0.1 then
        if t.flat then
          if ob.rel[2] >= t.w / 2 then
            pass_frustum = true
          end
        else
          if abs(ob.rel[1]) - (t.w / 2) < ob.rel[2] * (cfg.screen_width / 2 / r_view.sdist) then
            pass_frustum = true
          end
        end
      end
      
      if pass_frustum then
        local bucket_idx = math.min(bucket_count - 1, math.floor(ob.rel[2] / bucket_size))
        local count = bufs.sprite_bucket_counts:get(bucket_idx)
        
        -- Check capacity
        if count < bucket_capacity then
          local base = bucket_idx * bucket_capacity
          bufs.sprite_bucket_indices:set(base + count, obj_idx)
          bufs.sprite_bucket_depths:set(base + count, ob.rel[2])
          bufs.sprite_bucket_counts:set(bucket_idx, count + 1)
        end
      end
      
      ::skip_sprite::
    end
  end
  
  -- Draw sprites back-to-front
  palt(0, false)
  palt(14, true)
  
  for bucket_idx = bucket_count - 1, 0, -1 do
    local count = bufs.sprite_bucket_counts:get(bucket_idx)
    
    -- Sort bucket by z descending (far to near) using insertion sort
    if count > 4 then
      local base = bucket_idx * bucket_capacity
      for i = 1, count - 1 do
        local idx_i = bufs.sprite_bucket_indices:get(base + i)
        local z_i = bufs.sprite_bucket_depths:get(base + i)
        local j = i - 1
        while j >= 0 and bufs.sprite_bucket_depths:get(base + j) < z_i do
          bufs.sprite_bucket_indices:set(base + j + 1, bufs.sprite_bucket_indices:get(base + j))
          bufs.sprite_bucket_depths:set(base + j + 1, bufs.sprite_bucket_depths:get(base + j))
          j = j - 1
        end
        bufs.sprite_bucket_indices:set(base + j + 1, idx_i)
        bufs.sprite_bucket_depths:set(base + j + 1, z_i)
      end
    end
    
    -- Draw all sprites in bucket
    local base = bucket_idx * bucket_capacity
    for i = 0, count - 1 do
      local obj_idx = bufs.sprite_bucket_indices:get(base + i)
      local ob = obj_list[obj_idx]
      draw_sprite(ob, camera, r_view, r_state, r_batch, game_state)
    end
  end
  
  palt()
  r_state.occupancy.sprite_count = r_state.occupancy.sprite_count + #game_state.objects
end

return r_sprites


:: src/r_state.lua
--[[pod_format="raw",created="2025-11-12 00:00:00",modified="2025-11-12 00:00:00",revision=1]]
-- r_state.lua
-- Renderer state: owns all userdata buffers, config, and occupancy counters

local r_state = {}

-- Memory base address for renderer buffers (safe range per optimization guidelines)
local MEM_BASE = 0x080000

-- Configuration
r_state.config = {
  screen_width = 480,
  screen_height = 270,
  ray_count = 128,
  sprite_bucket_count = 8,
  sprite_bucket_capacity = 64,
  debug_mode = false
}

-- Buffer handles (will be populated by init)
r_state.buffers = {}

-- Occupancy counters (reset per frame)
r_state.occupancy = {
  rays_active = 0,
  wall_spans = 0,
  floor_rows = 0,
  sprite_count = 0
}

-- Frame counter for z-buffer stamping
r_state.frame_id = 0

-- Initialize all renderer buffers using memmap
function r_state.init(config)
  -- Merge user config
  if config then
    for k, v in pairs(config) do
      r_state.config[k] = v
    end
  end
  
  local cfg = r_state.config
  local ray_cnt = cfg.ray_count
  local sw = cfg.screen_width
  local sh = cfg.screen_height
  
  -- Ray direction and hit data buffers
  r_state.buffers.ray_dir_x = userdata("f64", ray_cnt)
  r_state.buffers.ray_dir_y = userdata("f64", ray_cnt)
  r_state.buffers.ray_z = userdata("f64", ray_cnt)
  r_state.buffers.ray_tx = userdata("f64", ray_cnt)
  r_state.buffers.ray_hitx = userdata("f64", ray_cnt)
  r_state.buffers.ray_hity = userdata("f64", ray_cnt)
  r_state.buffers.ray_tile = userdata("i16", ray_cnt)
  
  -- Screen span mapping (which pixels each ray covers)
  r_state.buffers.ray_x0 = userdata("i16", ray_cnt)
  r_state.buffers.ray_x1 = userdata("i16", ray_cnt)
  r_state.buffers.ray_px_center = userdata("f64", ray_cnt)
  
  -- Wall span buffers (worst case: one span per ray)
  r_state.buffers.wall_span_start = userdata("i16", ray_cnt)
  r_state.buffers.wall_span_end = userdata("i16", ray_cnt)
  r_state.buffers.wall_span_tile = userdata("i16", ray_cnt)
  r_state.buffers.wall_span_uv0 = userdata("f32", ray_cnt)
  r_state.buffers.wall_span_uv1 = userdata("f32", ray_cnt)
  r_state.buffers.wall_span_depth = userdata("f32", ray_cnt)
  
  -- Sprite buckets (depth-sorted bins)
  local bucket_size = cfg.sprite_bucket_count * cfg.sprite_bucket_capacity
  r_state.buffers.sprite_bucket_indices = userdata("i16", bucket_size)
  r_state.buffers.sprite_bucket_depths = userdata("f32", bucket_size)
  r_state.buffers.sprite_bucket_counts = userdata("i16", cfg.sprite_bucket_count)
  
  -- Z-buffer and frame stamp
  r_state.buffers.zbuf = userdata("f32", sw)
  r_state.buffers.zstamp = userdata("i32", sw)
  
  -- Initialize zstamp to 0
  for i = 0, sw - 1 do
    r_state.buffers.zstamp:set(i, 0)
  end
  
  -- Diagnostics snapshot buffer (only used when debug_mode enabled)
  r_state.buffers.stats_ud = userdata("f32", 32)
  
  printh("[r_state] initialized: " .. ray_cnt .. " rays, " .. sw .. "x" .. sh .. " screen")
end

-- Prepare frame: clear occupancy counters and stamp z-buffer
function r_state.prepare_frame()
  r_state.frame_id = r_state.frame_id + 1
  r_state.occupancy.rays_active = 0
  r_state.occupancy.wall_spans = 0
  r_state.occupancy.floor_rows = 0
  r_state.occupancy.sprite_count = 0
  
  -- Z-buffer is invalidated by frame stamp, no need to clear values
end

-- Z-buffer helpers using frame stamping
function r_state.zread(x)
  if x < 0 or x >= r_state.config.screen_width then return 999 end
  local stamp = r_state.buffers.zstamp:get(x) or 0
  if stamp == r_state.frame_id then
    return r_state.buffers.zbuf:get(x) or 999
  end
  return 999
end

function r_state.zwrite(x, z)
  if x < 0 or x >= r_state.config.screen_width then return end
  r_state.buffers.zbuf:set(x, z)
  r_state.buffers.zstamp:set(x, r_state.frame_id)
end

-- Dump buffer usage (debug mode only)
function r_state.dump_usage()
  if not r_state.config.debug_mode then return end
  
  printh("[r_state] buffer usage:")
  printh("  rays_active: " .. r_state.occupancy.rays_active .. " / " .. r_state.config.ray_count)
  printh("  wall_spans: " .. r_state.occupancy.wall_spans .. " / " .. r_state.config.ray_count)
  printh("  floor_rows: " .. r_state.occupancy.floor_rows)
  printh("  sprite_count: " .. r_state.occupancy.sprite_count)
end

-- Teardown: unmap all userdata (allows GC)
function r_state.teardown()
  -- Picotron doesn't require explicit unmap, but we clear references
  for k, v in pairs(r_state.buffers) do
    r_state.buffers[k] = nil
  end
  printh("[r_state] teardown complete")
end

return r_state


:: src/r_view.lua
--[[pod_format="raw",created="2025-11-12 00:00:00",modified="2025-11-12 00:00:00",revision=1]]
-- r_view.lua
-- Camera basis and ray direction LUT computation

local r_view = {}

-- Cached state to detect changes
local last_ray_count = 0
local last_fov = 0

-- Camera basis vectors (cached per frame)
r_view.forward_x = 0
r_view.forward_y = 0
r_view.right_x = 0
r_view.right_y = 0

-- Projection distance (cached, recomputed when FOV changes)
r_view.sdist = 200

-- Update camera basis and ray direction LUTs
-- camera: {x, y, a} table with position and angle
-- r_state: renderer state with buffers
-- fov: field of view (half-angle in radians)
-- active_ray_count: current ray budget (can be < r_state.config.ray_count)
function r_view.update(camera, r_state, fov, active_ray_count)
  local cfg = r_state.config
  local ray_cnt = active_ray_count or cfg.ray_count
  local screen_center_x = cfg.screen_width / 2
  
  -- Recompute projection distance if FOV changed
  if fov ~= last_fov then
    r_view.sdist = screen_center_x / math.tan(fov)
    last_fov = fov
  end
  
  -- Update camera basis (cached sin/cos)
  local sa = sin(camera.a)
  local ca = cos(camera.a)
  
  r_view.forward_x = ca
  r_view.forward_y = sa
  r_view.right_x = -sa
  r_view.right_y = ca
  
  -- Rebuild ray direction LUTs only if ray count changed
  if ray_cnt ~= last_ray_count then
    local bufs = r_state.buffers
    
    for i = 0, ray_cnt - 1 do
      -- Compute screen span for this ray
      local x0 = math.floor(i * cfg.screen_width / ray_cnt)
      local x1 = math.max(x0, math.floor((i + 1) * cfg.screen_width / ray_cnt) - 1)
      local pixel_x = (x0 + x1) / 2 + 0.5
      
      bufs.ray_x0:set(i, x0)
      bufs.ray_x1:set(i, x1)
      bufs.ray_px_center:set(i, pixel_x)
    end
    
    last_ray_count = ray_cnt
    printh("[r_view] rebuilt LUTs for " .. ray_cnt .. " rays")
  end
  
  -- Compute ray directions in world space
  local bufs = r_state.buffers
  for i = 0, ray_cnt - 1 do
    local pixel_x = bufs.ray_px_center:get(i)
    local dx = pixel_x - screen_center_x
    local dy = r_view.sdist
    
    -- Transform camera-space direction to world-space
    -- ray_dir = right * dx + forward * dy
    local world_dx = r_view.right_x * dx + r_view.forward_x * dy
    local world_dy = r_view.right_y * dx + r_view.forward_y * dy
    
    bufs.ray_dir_x:set(i, world_dx)
    bufs.ray_dir_y:set(i, world_dy)
  end
  
  r_state.occupancy.rays_active = ray_cnt
end

return r_view


:: src/r_walls.lua
--[[pod_format="raw",created="2025-11-12 00:00:00",modified="2025-11-12 00:00:00",revision=1]]
-- r_walls.lua
-- Span batcher for wall rendering with LOD

local r_walls = {}

-- Texture cache (sprite index -> {src, is_fallback})
local tex_cache = {}
local avg_color_cache = {}

-- Resolve sprite index with fallback to error textures
local function resolve_sprite_index(idx, kind, error_idx_table, get_spr_fn)
  if idx and get_spr_fn(idx) then
    return idx
  end
  if error_idx_table then
    if kind == "door" then return error_idx_table.door
    else return error_idx_table.wall end
  end
  return 0
end

-- Get texture source with caching
local function get_texture_source(sprite_index, obj_type, get_spr_fn, error_textures)
  sprite_index = sprite_index or 0
  obj_type = obj_type or "default"
  
  -- Check cache
  local cached = tex_cache[sprite_index]
  if cached then
    return cached.src, cached.is_fallback
  end
  
  -- Try to fetch sprite
  local src = get_spr_fn(sprite_index)
  if not src then
    -- Use error texture
    local err_tex = error_textures[obj_type] or error_textures.default
    tex_cache[sprite_index] = {src = err_tex, is_fallback = true}
    return err_tex, true
  end
  
  tex_cache[sprite_index] = {src = src, is_fallback = false}
  return src, false
end

-- Get average color with caching
local function get_avg_color(tile, get_spr_fn, error_textures, is_door_fn)
  local avg = avg_color_cache[tile]
  if avg then return avg end
  
  local obj_type = is_door_fn and is_door_fn(tile) and "door" or "wall"
  local src, is_fallback = get_texture_source(tile, obj_type, get_spr_fn, error_textures)
  
  avg = 5  -- default fog color
  if src and src.get then
    avg = src:get(16, 16) or 5
  end
  
  avg_color_cache[tile] = avg
  return avg
end

-- Draw wall spans with LOD and batching
-- camera: {x, y} position
-- r_view: view module with forward vectors and sdist
-- r_state: renderer state with buffers
-- r_batch: batch module
-- game_state: {wall_lod_distance, wall_tiny_screen_px, sprite_size, is_door, get_spr, error_textures, ERROR_IDX}
function r_walls.draw_spans(camera, r_view, r_state, r_batch, game_state)
  local bufs = r_state.buffers
  local ray_cnt = r_state.occupancy.rays_active
  local cfg = r_state.config
  local screen_center_y = cfg.screen_height / 2
  local fwdx, fwdy = r_view.forward_x, r_view.forward_y
  local sdist = r_view.sdist
  local tex_size = game_state.sprite_size or 32
  
  r_batch.rect_reset()
  r_batch.tline_reset()
  
  -- Span merging state
  local span_start = nil
  local span_tile = nil
  local span_spr = nil
  local span_avg = nil
  local span_tx0, span_tx1 = nil, nil
  local span_hitx0, span_hity0 = nil, nil
  local span_hitx1, span_hity1 = nil, nil
  
  local function flush_span(span_end)
    if not span_start then return end
    
    local x0 = bufs.ray_x0:get(span_start)
    local x1 = bufs.ray_x1:get(span_end)
    if x0 > x1 then span_start = nil return end
    
    local span_width = x1 - x0
    
    -- Handle single-column span
    if span_width <= 0 then
      local rel_x = span_hitx0 - camera.x
      local rel_y = span_hity0 - camera.y
      local z = rel_x * fwdx + rel_y * fwdy
      if z <= 0.0001 then z = 0.0001 end
      
      local h = sdist / z
      local y0 = screen_center_y - h / 2
      local y1 = screen_center_y + h / 2
      local tdy0 = math.ceil(y0)
      local tdy1 = math.min(math.floor(y1), cfg.screen_height - 1)
      
      if tdy0 <= tdy1 then
        local wall_height = tdy1 - tdy0
        if z > game_state.wall_lod_distance or wall_height < game_state.wall_tiny_screen_px then
          r_batch.rect_push(x0, tdy0, x1, tdy1, span_avg)
        else
          local u0 = span_tx0 * tex_size
          local v0 = 0
          local full_h = y1 - y0
          if full_h > 0 and tdy0 < y1 then
            v0 = ((tdy0 - y0) / full_h) * tex_size
          end
          local w0 = 1 / z
          r_batch.tline_push(span_spr, x0, tdy0, x1, tdy1, u0, v0, u0, v0 + tex_size, w0, w0, 0)
        end
        r_state.zwrite(x0, z)
      end
      
      span_start = nil
      return
    end
    
    -- Multi-column span
    local rel_x0 = span_hitx0 - camera.x
    local rel_y0 = span_hity0 - camera.y
    local z0 = rel_x0 * fwdx + rel_y0 * fwdy
    if z0 <= 0.0001 then z0 = 0.0001 end
    
    local rel_x1 = span_hitx1 - camera.x
    local rel_y1 = span_hity1 - camera.y
    local z1 = rel_x1 * fwdx + rel_y1 * fwdy
    if z1 <= 0.0001 then z1 = 0.0001 end
    
    local h0 = sdist / z0
    local base_y0 = screen_center_y - h0 / 2
    local base_y1 = screen_center_y + h0 / 2
    local tdy0 = math.ceil(base_y0)
    local tdy1 = math.min(math.floor(base_y1), cfg.screen_height - 1)
    
    if tdy0 > tdy1 then
      span_start = nil
      return
    end
    
    local h1 = sdist / z1
    local y1_top = screen_center_y - h1 / 2
    local y1_bot = screen_center_y + h1 / 2
    tdy0 = math.min(tdy0, math.ceil(y1_top))
    tdy1 = math.max(tdy1, math.min(math.floor(y1_bot), cfg.screen_height - 1))
    tdy0 = math.max(tdy0, 0)
    tdy1 = math.min(tdy1, cfg.screen_height - 1)
    
    if tdy0 > tdy1 then
      span_start = nil
      return
    end
    
    local column_count = x1 - x0 + 1
    
    -- LOD check
    if z0 > game_state.wall_lod_distance and z1 > game_state.wall_lod_distance then
      r_batch.rect_push(x0, tdy0, x1, tdy1, span_avg)
    else
      local u0 = span_tx0 * tex_size
      local u1 = span_tx1 * tex_size
      local v0 = ((tdy0 - base_y0) / (base_y1 - base_y0)) * tex_size
      if base_y1 - base_y0 <= 0 then v0 = 0 end
      v0 = math.max(0, math.min(tex_size, v0))
      local v1 = v0 + tex_size
      r_batch.tline_push(span_spr, x0, tdy0, x1, tdy1, u0, v0, u1, v1, 1 / z0, 1 / z1, 0)
    end
    
    -- Update z-buffer for all columns in span
    for col = x0, x1 do
      local t = (span_width > 0) and ((col - x0) / span_width) or 0
      local world_x = span_hitx0 + (span_hitx1 - span_hitx0) * t
      local world_y = span_hity0 + (span_hity1 - span_hity0) * t
      local rel_x = world_x - camera.x
      local rel_y = world_y - camera.y
      local z = rel_x * fwdx + rel_y * fwdy
      if z <= 0.0001 then z = 0.0001 end
      r_state.zwrite(col, z)
    end
    
    r_state.occupancy.wall_spans = r_state.occupancy.wall_spans + 1
    span_start = nil
  end
  
  -- Iterate rays and merge into spans
  for ray_idx = 0, ray_cnt - 1 do
    local tile = bufs.ray_tile:get(ray_idx)
    
    if tile and tile > 0 then
      if span_start and tile == span_tile then
        -- Continue span
        span_tx1 = bufs.ray_tx:get(ray_idx)
        span_hitx1 = bufs.ray_hitx:get(ray_idx)
        span_hity1 = bufs.ray_hity:get(ray_idx)
      else
        -- Flush previous span
        if span_start then flush_span(ray_idx - 1) end
        
        -- Start new span
        span_start = ray_idx
        span_tile = tile
        span_spr = resolve_sprite_index(tile, (game_state.is_door and game_state.is_door(tile)) and "door" or "wall", game_state.ERROR_IDX, game_state.get_spr)
        span_avg = get_avg_color(tile, game_state.get_spr, game_state.error_textures, game_state.is_door)
        span_tx0 = bufs.ray_tx:get(ray_idx)
        span_tx1 = span_tx0
        span_hitx0 = bufs.ray_hitx:get(ray_idx)
        span_hity0 = bufs.ray_hity:get(ray_idx)
        span_hitx1 = span_hitx0
        span_hity1 = span_hity0
      end
    else
      -- Empty tile: flush span
      if span_start then flush_span(ray_idx - 1) end
    end
  end
  
  -- Flush final span
  if span_start then flush_span(ray_cnt - 1) end
  
  r_batch.tline_submit()
  r_batch.rect_submit()
end

-- Clear texture caches (call on level load)
function r_walls.clear_caches()
  tex_cache = {}
  avg_color_cache = {}
end

return r_walls


:: tests/dungeon_harness.lua
-- deterministic dungeon generation harness
local harness={}

harness.default_seeds={1111,2222,3333,4444,5555}

local function validate_locked_edges(issues)
 if not gen_locked_edges then return end
 for edge in all(gen_locked_edges) do
  if edge.locked and edge.keynum then
   local lt=edge.lock_tile
   if not lt then
    add(issues,"edge "..edge.n1.index.."->"..edge.n2.index.." missing lock tile")
   else
    local tile=get_wall(lt.x,lt.y)
    if tile~=door_locked then
     add(issues,"door at "..lt.x..","..lt.y.." not locked")
    end
   end
   local key_found=false
   for ob in all(gen_objects) do
    if ob.typ==obj_types.key and ob.keynum==edge.keynum then
     key_found=true
     break
    end
   end
   if not key_found then
    add(issues,"missing key#"..edge.keynum.." for edge "..edge.n1.index.."->"..edge.n2.index)
   end
  end
 end
end

function harness.run(seeds)
 seeds=seeds or harness.default_seeds
 local summary={
  total=#seeds,
  failures=0,
  results={}
 }
 local original_seed=nil
 for _,seed in ipairs(seeds) do
  local ok,meta=pcall(function()
   local _,stats=generate_dungeon({seed=seed})
   return stats
  end)
  local record={seed=seed,issues={},rooms=0,objects=0}
  if not ok then
   record.error=meta
   summary.failures+=1
  else
   record.rooms=meta.rooms or 0
   record.objects=meta.objects or 0
   if record.rooms<(gen_params.min_rooms or 0) then
    add(record.issues,"room count "..record.rooms.." below min "..gen_params.min_rooms)
   end
   validate_locked_edges(record.issues)
   if #record.issues>0 then
    summary.failures+=1
   end
  end
  add(summary.results,record)
 end
 return summary
end

dungeon_harness=harness
return harness


:: .info.pod
--[[pod,created="2025-11-07 22:14:20",modified="2025-11-10 12:35:37",runtime=21,workspaces={{location="main.lua#828",workspace_index=1}}]]
:: main.lua
b64$LS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNS0xMS0wNyAyMTowNDowNiIsbW9k
aWZpZWQ9IjIwMjUtMTEtMDcgMjI6MTg6NTEiLHJldmlzaW9uPTVdXQotLSBub25ib3kgcmF5Y2Fz
dCBlbmdpbmUgdjEuMAotLSBtYWluIGVudHJ5IHBvaW50CgppbmNsdWRlInNyYy9jb25maWcubHVh
IgotLSBOZXcgcmVuZGVyZXIgbW9kdWxlcwppbmNsdWRlInNyYy9yX3N0YXRlLmx1YSIKaW5jbHVk
ZSJzcmMvcl9iYXRjaC5sdWEiCmluY2x1ZGUic3JjL3Jfdmlldy5sdWEiCmluY2x1ZGUic3JjL3Jf
Y2FzdC5sdWEiCmluY2x1ZGUic3JjL3JfZmxvb3IubHVhIgppbmNsdWRlInNyYy9yX3dhbGxzLmx1
YSIKaW5jbHVkZSJzcmMvcl9zcHJpdGVzLmx1YSIKaW5jbHVkZSJzcmMvcl9kaWFnLmx1YSIKLS0g
R2FtZSBzeXN0ZW1zCmluY2x1ZGUic3JjL2Rvb3Jfc3lzdGVtLmx1YSIKaW5jbHVkZSJzcmMvZHVu
Z2Vvbl9nZW4ubHVhIgppbmNsdWRlInRlc3RzL2R1bmdlb25faGFybmVzcy5sdWEiCgotLSBJbml0
aWFsaXplIHJlbmRlcmVyIG1vZHVsZXMKbG9jYWwgcl9zdGF0ZSA9IGluY2x1ZGUic3JjL3Jfc3Rh
dGUubHVhIgpsb2NhbCByX2JhdGNoID0gaW5jbHVkZSJzcmMvcl9iYXRjaC5sdWEiCmxvY2FsIHJf
dmlldyA9IGluY2x1ZGUic3JjL3Jfdmlldy5sdWEiCmxvY2FsIHJfY2FzdCA9IGluY2x1ZGUic3Jj
L3JfY2FzdC5sdWEiCmxvY2FsIHJfZmxvb3IgPSBpbmNsdWRlInNyYy9yX2Zsb29yLmx1YSIKbG9j
YWwgcl93YWxscyA9IGluY2x1ZGUic3JjL3Jfd2FsbHMubHVhIgpsb2NhbCByX3Nwcml0ZXMgPSBp
bmNsdWRlInNyYy9yX3Nwcml0ZXMubHVhIgpsb2NhbCByX2RpYWcgPSBpbmNsdWRlInNyYy9yX2Rp
YWcubHVhIgoKbG9jYWwgc2NlbmVzPXt9CmxvY2FsIHNjZW5lX3N0YXRlPXt9CmxvY2FsIGN1cnJl
bnRfc2NlbmU9bmlsCgpsb2NhbCBmdW5jdGlvbiBnZXRfc2NlbmVfc3RhdGUobmFtZSkKIHNjZW5l
X3N0YXRlW25hbWVdPXNjZW5lX3N0YXRlW25hbWVdIG9yIHt9CiByZXR1cm4gc2NlbmVfc3RhdGVb
bmFtZV0KZW5kCgpsb2NhbCBmdW5jdGlvbiBzd2l0Y2hfc2NlbmUobmFtZSxwYXJhbXMpCiBsb2Nh
bCBzY2VuZT1zY2VuZXNbbmFtZV0KIGlmIG5vdCBzY2VuZSB0aGVuCiAgcHJpbnRoKCJ3YXJuaW5n
OiB1bmtub3duIHNjZW5lICIuLnRvc3RyaW5nKG5hbWUpKQogIHJldHVybgogZW5kCiBpZiBjdXJy
ZW50X3NjZW5lIGFuZCBzY2VuZXNbY3VycmVudF9zY2VuZV0gYW5kIHNjZW5lc1tjdXJyZW50X3Nj
ZW5lXS5sZWF2ZSB0aGVuCiAgc2NlbmVzW2N1cnJlbnRfc2NlbmVdLmxlYXZlKGdldF9zY2VuZV9z
dGF0ZShjdXJyZW50X3NjZW5lKSkKIGVuZAogY3VycmVudF9zY2VuZT1uYW1lCiBsb2NhbCBzdGF0
ZT1nZXRfc2NlbmVfc3RhdGUobmFtZSkKIGlmIHNjZW5lLmVudGVyIHRoZW4KICBzY2VuZS5lbnRl
cihzdGF0ZSxwYXJhbXMgb3Ige30pCiBlbmQKZW5kCgpsb2NhbCBmdW5jdGlvbiBzY2VuZV91cGRh
dGUoKQogaWYgY3VycmVudF9zY2VuZSBhbmQgc2NlbmVzW2N1cnJlbnRfc2NlbmVdIGFuZCBzY2Vu
ZXNbY3VycmVudF9zY2VuZV0udXBkYXRlIHRoZW4KICBzY2VuZXNbY3VycmVudF9zY2VuZV0udXBk
YXRlKGdldF9zY2VuZV9zdGF0ZShjdXJyZW50X3NjZW5lKSkKIGVuZAplbmQKCmxvY2FsIGZ1bmN0
aW9uIHNjZW5lX2RyYXcoKQogaWYgY3VycmVudF9zY2VuZSBhbmQgc2NlbmVzW2N1cnJlbnRfc2Nl
bmVdIGFuZCBzY2VuZXNbY3VycmVudF9zY2VuZV0uZHJhdyB0aGVuCiAgc2NlbmVzW2N1cnJlbnRf
c2NlbmVdLmRyYXcoZ2V0X3NjZW5lX3N0YXRlKGN1cnJlbnRfc2NlbmUpKQogZWxzZQogIGNscygw
KQogZW5kCmVuZAoKLS0gY29uc3RhbnRzCnBsYXllcl9jb2xsaXNpb25fcmFkaXVzPTAuMTUKCmZ1
bmN0aW9uIF9pbml0KCkKIHdpbmRvdyhzY3JlZW5fd2lkdGgsc2NyZWVuX2hlaWdodCkKIAogLS0g
cGluIG1hc2tzIHRvIGRlZmF1bHRzIGZvciBzaW5nbGUgY29sb3VyLXRhYmxlIGZhc3QgcGF0aAog
cG9rZSgweDU1MDgsMHgzZikgcG9rZSgweDU1MDksMHgzZikgcG9rZSgweDU1MGEsMHgzZikgcG9r
ZSgweDU1MGIsMHgwMCkKIAogLS0gdGlsZSAwIGRyYXdpbmcgc3RhdGU6IHZlcmlmaWVkIG5vdCBy
ZXF1aXJlZDsgbGVhdmUgMHg1ZjM2IGF0IGRlZmF1bHQgKG5vIGV4cGxpY2l0IHBva2UpCiAtLSBz
c3ByKCkgdXNhZ2UgdmVyaWZpZWQ6IE5vbmUgaW4gcHJvZHVjdGlvbiBjb2RlIChvbmx5IGluIHNh
bXBsZSBmaWxlcykKIC0tIFBlciBQaWNvdHJvbiBndWlkZWxpbmVzOiBibGl0KCkgaXMgZmFzdGVy
OyBIVUQvbWluaW1hcCB1c2UgZGlyZWN0IGRyYXdpbmcKIC0tIGNvbmZpZ3VyYXRpb24gZ3VhcmQ6
IHByZXZlbnQgZm9nIHBvcHBpbmcgYmV5b25kIGZhci1wbGFuZQogYXNzZXJ0KGZhcl9wbGFuZT49
Zm9nX2ZhcisxLCJjb25maWcgZXJyb3I6IGZhcl9wbGFuZSBtdXN0IGJlID49IGZvZ19mYXIgKyAx
IikKIAogLS0gZGVmZW5zaXZlIGRlZmF1bHRzIGlmIGNvbmZpZyBpbmNsdWRlIGZhaWxlZCB0byBz
ZXQgdGhlbSBmb3IgYW55IHJlYXNvbgogaWYgbm90IG9iamdyaWRfc2l6ZSB0aGVuIG9iamdyaWRf
c2l6ZT01IGVuZAogaWYgbm90IG9iamdyaWRfYXJyYXlfc2l6ZSB0aGVuIG9iamdyaWRfYXJyYXlf
c2l6ZT0yNiBlbmQKIAogLS0gZnJhbWUgY291bnRlciBmb3IgYWkgdGltaW5nCiBmcmFtZV9jdD0w
CiAKIC0tIEluaXRpYWxpemUgbmV3IHJlbmRlcmVyCiByX3N0YXRlLmluaXQoewogIHNjcmVlbl93
aWR0aCA9IHNjcmVlbl93aWR0aCwKICBzY3JlZW5faGVpZ2h0ID0gc2NyZWVuX2hlaWdodCwKICBy
YXlfY291bnQgPSByYXlfY291bnQsCiAgc3ByaXRlX2J1Y2tldF9jb3VudCA9IDgsCiAgc3ByaXRl
X2J1Y2tldF9jYXBhY2l0eSA9IDY0LAogIGRlYnVnX21vZGUgPSBmYWxzZQogfSkKIHJfYmF0Y2gu
aW5pdCgpCiBwcmludGgoIlttYWluXSBuZXcgcmVuZGVyZXIgaW5pdGlhbGl6ZWQiKQogCiAtLSBD
b21wYXRpYmlsaXR5IGhlbHBlcnMgZm9yIG1pbmltYXAgZHJhd2luZyAodXNlcyByX2JhdGNoKQog
ZnVuY3Rpb24gcmJhdGNoX3Jlc2V0KCkKICByX2JhdGNoLnJlY3RfcmVzZXQoKQogZW5kCiBmdW5j
dGlvbiByYmF0Y2hfcHVzaCh4MCwgeTAsIHgxLCB5MSwgYykKICByX2JhdGNoLnJlY3RfcHVzaCh4
MCwgeTAsIHgxLCB5MSwgYykKIGVuZAogZnVuY3Rpb24gcmJhdGNoX3N1Ym1pdCgpCiAgcl9iYXRj
aC5yZWN0X3N1Ym1pdCgpCiBlbmQKIAogLS0gcGxheWVyIHN0YXRlCiBwbGF5ZXI9ewogIHg9NjQs
eT02NCwKICBhPTAsCiAgc3BkPXBsYXllcl9tb3ZlX3NwZWVkLAogIGtleXM9e30sCiAgaHA9MTAw
CiB9CiAKIC0tIGludGVyYWN0aW9uIHN0YXRlCiBpbnRlcmFjdGlvbl9hY3RpdmU9ZmFsc2UKIGN1
cnJlbnRfaW50ZXJhY3Q9bmlsCiAKIC0tIGNvbWJhdCBzdGF0ZQogaW5fY29tYmF0PWZhbHNlCiBj
dXJyZW50X3RhcmdldD1uaWwKIAogLS0gdHJhcCBtZXNzYWdlIHRpbWVyCiB0cmFwX21zZ190aW1l
cj0wCiAKIC0tIGNhbWVyYQogY2FtPXtwbGF5ZXIueCxwbGF5ZXIueX0KIAogLS0gbWFwIGFic3Ry
YWN0aW9uIHdpdGggdXNlcmRhdGEgbGF5ZXJzCiBtYXA9e30KIG1hcC53YWxscz11c2VyZGF0YSgi
aTE2IiwxMjgsMTI4KQogbWFwLmRvb3JzPXVzZXJkYXRhKCJpMTYiLDEyOCwxMjgpCiBtYXAuZmxv
b3JzPXVzZXJkYXRhKCJpMTYiLDEyOCwxMjgpCiAKIC0tIGhlbHBlcjogZ2V0IHdhbGwgdGlsZQot
LSBQdXJwb3NlOiBSZXRyaWV2ZSB3YWxsIHRpbGUgSUQgYXQgZ3JpZCBwb3NpdGlvbgogLS0gUGFy
YW1ldGVyczogeCwgeSAoZ3JpZCBjb29yZGluYXRlcyAwLTEyNykKIC0tIFJldHVybnM6IHRpbGUg
SUQgKDA9ZW1wdHksID4wPXdhbGwvZG9vci9leGl0KQogZnVuY3Rpb24gZ2V0X3dhbGwoeCx5KQog
aWYgeD49MCBhbmQgeDwxMjggYW5kIHk_PTAgYW5kIHk8MTI4IHRoZW4KICByZXR1cm4gbWFwLndh
bGxzOmdldCh4LHkpIG9yIDAKIGVuZAogcmV0dXJuIDAKIGVuZAogCiAtLSBoZWxwZXI6IHNldCB3
YWxsIHRpbGUKIGZ1bmN0aW9uIHNldF93YWxsKHgseSx2YWwpCiAgaWYgeD49MCBhbmQgeDwxMjgg
YW5kIHk_PTAgYW5kIHk8MTI4IHRoZW4KCQltYXAud2FsbHM6c2V0KHgseSx2YWwgb3IgMCkKICBl
bmQKIGVuZAogCiAtLSBoZWxwZXI6IGdldCBkb29yIHRpbGUKIGZ1bmN0aW9uIGdldF9kb29yKHgs
eSkKICBpZiB4Pj0wIGFuZCB4PDEyOCBhbmQgeT49MCBhbmQgeTwxMjggdGhlbgogICByZXR1cm4g
bWFwLmRvb3JzOmdldCh4LHkpIG9yIDAKICBlbmQKICByZXR1cm4gMAogZW5kCiAKIC0tIGhlbHBl
cjogc2V0IGRvb3IgdGlsZQogZnVuY3Rpb24gc2V0X2Rvb3IoeCx5LHZhbCkKICBpZiB4Pj0wIGFu
ZCB4PDEyOCBhbmQgeT49MCBhbmQgeTwxMjggdGhlbgogICBtYXAuZG9vcnM6c2V0KHgseSx2YWwg
b3IgMCkKICBlbmQKIGVuZAoKIC0tIGhlbHBlcjogZ2V0IGZsb29yIHRpbGUKIC0tIFB1cnBvc2U6
IFJldHJpZXZlIGZsb29yIHR5cGUgSUQgYXQgZ3JpZCBwb3NpdGlvbgogLS0gUGFyYW1ldGVyczog
eCwgeSAoZ3JpZCBjb29yZGluYXRlcyAwLTEyNykKIC0tIFJldHVybnM6IGZsb29yIHR5cGUgSUQg
KDA9dXNlIGdsb2JhbCBkZWZhdWx0LCAxLTg9c3BlY2lmaWMgZmxvb3IgdHlwZSBmcm9tIHBsYW5l
dHlwcykKIC0tIE5vdGVzOiBGbG9vciB0eXBlIElEcyBtYXAgdG8gaW5kaWNlcyBpbiB0aGUgcGxh
bmV0eXBzIHRhYmxlIGRlZmluZWQgaW4gY29uZmlnLmx1YQogZnVuY3Rpb24gZ2V0X2Zsb29yKHgs
eSkKICBpZiB4Pj0wIGFuZCB4PDEyOCBhbmQgeT49MCBhbmQgeTwxMjggdGhlbgogICByZXR1cm4g
bWFwLmZsb29yczpnZXQoeCx5KSBvciAwCiAgZW5kCiAgcmV0dXJuIDAKIGVuZAoKIC0tIGhlbHBl
cjogc2V0IGZsb29yIHRpbGUKIC0tIFB1cnBvc2U6IFN0b3JlIHBlci1jZWxsIGZsb29yIHR5cGUg
SURzIGZvciB2YXJpZWQgZmxvb3IgdGV4dHVyZXMKIC0tIFBhcmFtZXRlcnM6IHgsIHkgKGdyaWQg
Y29vcmRpbmF0ZXMgMC0xMjcpLCB2YWwgKGZsb29yIHR5cGUgSUQgMC04KQogLS0gTm90ZXM6IDA9
dXNlIGdsb2JhbCBkZWZhdWx0IGZsb29yIHR5cGUsIDEtOD1zcGVjaWZpYyBmbG9vciB0eXBlIGZy
b20gcGxhbmV0eXBzCiBmdW5jdGlvbiBzZXRfZmxvb3IoeCx5LHZhbCkKICBpZiB4Pj0wIGFuZCB4
PDEyOCBhbmQgeT49MCBhbmQgeTwxMjggdGhlbgogICAtLSBub3JtYWxpemUgdmFsIHRvIHZhbGlk
IHJhbmdlIDAtOAogICBpZiB0eXBlKHZhbCl_PSJudW1iZXIiIG9yIHZhbD09bmlsIHRoZW4KICAg
IHZhbD0wCiAgIGVsc2VpZiB2YWw8MCB0aGVuCiAgICB2YWw9MAogICBlbHNlaWYgdmFsPjggdGhl
bgogICAgdmFsPTgKICAgZW5kCiAgIG1hcC5mbG9vcnM6c2V0KHgseSx2YWwpCiAgZW5kCiBlbmQK
IAogZG9vcmdyaWQ9e30KIGZvciBpPTAsMTI3IGRvCiAgZG9vcmdyaWRbaV09e30KICBmb3Igaj0w
LDEyNyBkbwogICBkb29yZ3JpZFtpXVtqXT1uaWwKICBlbmQKIGVuZAogCiAtLSBpbml0aWFsaXpl
IGZsb29yIGRhdGEKIGZvciBpPTAsMTI3IGRvCiAgZm9yIGo9MCwxMjcgZG8KICAgc2V0X2Zsb29y
KGksaiwwKQogIGVuZAogZW5kCiAgCiBkb29ycz17fQogb2JqZWN0cz17fQogYW5pbWF0ZWRfb2Jq
ZWN0cz17fQogCi0tIExlZ2FjeSBidWZmZXJzIHJlbW92ZWQgKG5vdyBtYW5hZ2VkIGJ5IHJfc3Rh
dGUpCiAtLSBkeW5hbWljIGJ1ZGdldHMKIGFjdGl2ZV9yYXlfY291bnQ9cmF5X2NvdW50CiByb3df
c3RyaWRlX2R5bmFtaWM9cm93X3N0cmlkZQogCiAtLSBmb2cgc3RhdGUgZm9yIGh5c3RlcmVzaXMK
IGxhc3RfZm9nX3o9MAogCiAtLSBwcm9qZWN0aW9uIGNvbnN0YW50IGRlZmluZWQgaW4gY29uZmln
Lmx1YQogCiAtLSBmbG9vciBhbmQgcm9vZiBzdGF0ZQogZmxvb3I9e3R5cD1wbGFuZXR5cHNbMV0s
eD0wLHk9MH0KIHJvb2Y9e3R5cD1wbGFuZXR5cHNbM10seD0wLHk9MH0KIAogZ2VuX3N0YXRzPXty
b29tcz0wLG9iamVjdHM9MCxzZWVkPTAsaGlzdG9yeT17fX0KIHN0YXJ0X3Bvcz17eD1wbGF5ZXIu
eCx5PXBsYXllci55fQogLS0gbW9kZTogM2Qgb3IgMmQgbWFwCiB2aWV3X21vZGU9IjNkIgogCiAt
LSBkZWJ1ZyBtb2RlIGZvciByYXkgY2FzdGluZwogZGVidWdfbW9kZT1mYWxzZQpzaG93X2RpYWdu
b3N0aWNzPWZhbHNlCmVuYWJsZV9kaWFnbm9zdGljc19sb2dnaW5nPWZhbHNlICAtLSBQZXJtYW5l
bnRseSBkaXNhYmxlZCBmb3IgcHJvZHVjdGlvbiBwZXJmb3JtYW5jZQotLSBPcHRpb25hbDogcmUt
ZW5hYmxlIGEgbm9uLXJlbmRlciBDUFUgZ292ZXJub3IgKHNhbXBsZXMgQ1BVIG91dHNpZGUgX2Ry
YXcoKSkKZW5hYmxlX25vbnJlbmRlcl9nb3Zlcm5vcj1mYWxzZQpyZWNlbnRfY3B1PTAKIAogLS0g
cGVyZm9ybWFuY2UgdmFsaWRhdGlvbiBtb2RlOiBkaXNhYmxlcyBDUFUgZ292ZXJub3IgdG8gc3Rh
YmlsaXplIG1lYXN1cmVtZW50cwogcGVyZl92YWxpZGF0aW9uPWZhbHNlCiAKIC0tIGRpYWdub3N0
aWMgY291bnRlcnMgZm9yIHBlcmZvcm1hbmNlIHRyYWNraW5nIChyZWZyZXNoZWQgZWFjaCBmcmFt
ZSkKIGRpYWdfZnJhbWVfY291bnQ9MAogZGlhZ193YWxsX2NvbHVtbnM9MAogZGlhZ193YWxsX2xv
ZF9jb2x1bW5zPTAKIGRpYWdfZmxvb3Jfcm93cz0wCiBkaWFnX2Zsb29yX2JhdGNoZXM9MAogZGlh
Z19zcHJpdGVfY29sdW1ucz0wCiBkaWFnX3Nwcml0ZV9pbXBvc3Rvcl9jb2x1bW5zPTAKIGRpYWdf
YWN0aXZlX3JheXM9cmF5X2NvdW50CiBsYXN0X2NwdV9zYW1wbGU9MAogCiAtLSB0ZXN0IGRvb3Ig
bW9kZQogdGVzdF9kb29yX21vZGU9ZmFsc2UKCiAtLSBjcmVhdGUgdGludGVkIGVycm9yIHRleHR1
cmVzIGZvciBkaWZmZXJlbnQgb2JqZWN0IHR5cGVzIChjaGVja2VyYm9hcmQgcGF0dGVybikKIC0t
IHdhbGxzOiBtYWdlbnRhL3BpbmsgKDgvMTQpLCBmbG9vcjogYmx1ZS9jeWFuICgxMi8xMyksIGNl
aWxpbmc6IGdyZWVuL2RhcmsgZ3JlZW4gKDExLzMpCiAtLSBzcHJpdGVzOiB5ZWxsb3cvb3Jhbmdl
ICgxMC85KSwgcHJvcHM6IHJlZC9icm93biAoOC80KQogZXJyb3JfdGV4dHVyZXMgPSB7CiAgd2Fs
bCA9IHVzZXJkYXRhKCJ1OCIsIDMyLCAzMiksCiBkb29yID0gdXNlcmRhdGEoInU4IiwgMzIsIDMy
KSwKICBmbG9vciA9IHVzZXJkYXRhKCJ1OCIsIDMyLCAzMiksCiAgY2VpbGluZyA9IHVzZXJkYXRh
KCJ1OCIsIDMyLCAzMiksCiAgc3ByaXRlID0gdXNlcmRhdGEoInU4IiwgMzIsIDMyKSwKICBkZWZh
dWx0ID0gdXNlcmRhdGEoInU4IiwgMzIsIDMyKQogfQogCiAtLSBnZW5lcmF0ZSB0aW50ZWQgY2hl
Y2tlcmJvYXJkcyBmb3IgZWFjaCB0eXBlCiBsb2NhbCB0aW50cyA9IHsKICB3YWxsID0gezgsIDE0
fSwgICAgICAtLSBtYWdlbnRhL3BpbmsKIGRvb3IgPSB7MiwgNn0sICAgICAgIC0tIHB1cnBsZS9i
bHVlIChkaXN0aW5jdCBmcm9tIHdhbGxzKQogIGZsb29yID0gezEyLCAxM30sICAgIC0tIGJsdWUv
Y3lhbgogIGNlaWxpbmcgPSB7MTEsIDN9LCAgIC0tIGdyZWVuL2RhcmsgZ3JlZW4KICBzcHJpdGUg
PSB7MTAsIDl9LCAgICAtLSB5ZWxsb3cvb3JhbmdlCiAgZGVmYXVsdCA9IHs4LCAxNH0gICAgLS0g
bWFnZW50YS9waW5rIChmYWxsYmFjaykKIH0KIAogZm9yIHR5cGVfbmFtZSwgY29sb3JzIGluIHBh
aXJzKHRpbnRzKSBkbwogIGZvciB5PTAsMzEgZG8KICAgZm9yIHg9MCwzMSBkbwogICAgbG9jYWwg
Y29sb3IgPSAoKGZscih4LzQpICsgZmxyKHkvNCkpICUgMiA9PSAwKSBhbmQgY29sb3JzWzFdIG9y
IGNvbG9yc1syXQogICAgZXJyb3JfdGV4dHVyZXNbdHlwZV9uYW1lXTpzZXQoeCwgeSwgY29sb3Ip
CiAgIGVuZAogIGVuZAogZW5kCiAKIC0tIG1haW50YWluIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkg
d2l0aCBzaW5nbGUgZXJyb3JfdGV4dHVyZQogZXJyb3JfdGV4dHVyZSA9IGVycm9yX3RleHR1cmVz
LmRlZmF1bHQKCiAtLSByZXNlcnZlIHNwcml0ZSBpbmRleGVzIGZvciBlcnJvciB0ZXh0dXJlcyAo
YmF0Y2hpbmcgcHJlZmVycyBzcHJpdGUgaW5kZXhlcykKIEVSUk9SX0lEWCA9IHsgd2FsbD04MDAw
LCBkb29yPTgwMDEsIGZsb29yPTgwMDIsIGNlaWxpbmc9ODAwMywgc3ByaXRlPTgwMDQsIGRlZmF1
bHQ9ODAwNSB9CiBmb3IgbmFtZSwgdWQgaW4gcGFpcnMoZXJyb3JfdGV4dHVyZXMpIGRvCiAgbG9j
YWwgaWR4ID0gRVJST1JfSURYW25hbWVdIG9yIEVSUk9SX0lEWC5kZWZhdWx0CiAgc2V0X3Nwcihp
ZHgsIHVkKQogZW5kCiAKIC0tIFByZWxvYWQgdGV4dHVyZSBjYWNoZSBmb3IgY29tbW9ubHktdXNl
ZCBzcHJpdGVzICgwLTIwMCkKIC0tIFBvcHVsYXRlIHRleF9jYWNoZSBkaXJlY3RseSB1c2luZyBn
ZXRfc3ByKCkgdG8gYXZvaWQgd2FybmluZ3MKIHByaW50aCgicHJlbG9hZGluZyB0ZXh0dXJlIGNh
Y2hlLi4uIikKIGxvY2FsIHByZWxvYWRfc3RhcnQgPSB0aW1lKCkKIGZvciBpPTAsMjAwIGRvCiAg
bG9jYWwgc3JjPWdldF9zcHIgYW5kIGdldF9zcHIoaSkKICBpZiBzcmMgYW5kIGNhY2hlX3RleCB0
aGVuCiAgIGNhY2hlX3RleChpLCBzcmMsIGZhbHNlKQogIGVuZAogZW5kCiBsb2NhbCBwcmVsb2Fk
X3RpbWUgPSAodGltZSgpIC0gcHJlbG9hZF9zdGFydCkgKiAxMDAwCiBwcmludGgoInRleHR1cmUg
Y2FjaGUgcHJlbG9hZGVkOiAiLi5wcmVsb2FkX3RpbWUuLiJtcyIpCiAtLSBUcmlnZ2VyIEdDIGFm
dGVyIHByZWxvYWRpbmcgKFBpY290cm9uIGd1aWRlbGluZTogc3RhdCgwKSBkdXJpbmcgcGF1c2Vz
IG9ubHkpCiBzdGF0KDApCiAKIC0tIGxvZ2dpbmcgaGVscGVyOiBjb25zb2xlICsgcmluZyBidWZm
ZXIgZm9yIG9wdGlvbmFsIG9uLXNjcmVlbiBlY2hvCiBsb2dfbGluZXMgPSB7fQogZnVuY3Rpb24g
bG9nKHN0cikKICBwcmludGgoc3RyKQogIGFkZChsb2dfbGluZXMsIHN0cikKICBpZiAjbG9nX2xp
bmVzID4gMjAwIHRoZW4gZGVsaShsb2dfbGluZXMsIDEpIGVuZAogZW5kCgogLS0gdmFsaWRhdGUg
YWxsIGNvbmZpZ3VyZWQgc3ByaXRlcyBleGlzdCAoY29tbWVudCBvdXQgZm9yIHByb2R1Y3Rpb24p
CiB2YWxpZGF0ZV9zcHJpdGVfY29uZmlndXJhdGlvbigpCgogcHJpbnRoKCJwaWNvdHJvbiByYXlj
YXN0IGVuZ2luZSB2MS4wIikKIHN3aXRjaF9zY2VuZSgibWVudSIpCmVuZAoKLS0gdmFsaWRhdGUg
c3ByaXRlIGNvbmZpZ3VyYXRpb24gYXQgc3RhcnR1cCAob3B0aW9uYWwsIGNhbiBiZSBkaXNhYmxl
ZCBmb3IgcGVyZm9ybWFuY2UpCmZ1bmN0aW9uIHZhbGlkYXRlX3Nwcml0ZV9jb25maWd1cmF0aW9u
KCkKIC0tIGNoZWNrIGVuZW15IHNwcml0ZXMKIGZvciBlbmVteSBpbiBhbGwoZW5lbXlfdHlwZXMp
IGRvCiAgaWYgbm90IGdldF9zcHIoZW5lbXkuc3ByaXRlKSB0aGVuCiAgIHByaW50aCgiV0FSTklO
RzogZW5lbXkgc3ByaXRlICIuLmVuZW15LnNwcml0ZS4uIiAoIi4uZW5lbXkubmFtZS4uIikgbm90
IGZvdW5kIGluIEdGWCBmaWxlcyIpCiAgZW5kCiBlbmQKIAogLS0gY2hlY2sgZGVjb3JhdGlvbiBz
cHJpdGVzCiBmb3IgZGVjIGluIGFsbChkZWNvcmF0aW9uX3R5cGVzKSBkbwogIGlmIG5vdCBnZXRf
c3ByKGRlYy5zcHJpdGUpIHRoZW4KICAgcHJpbnRoKCJXQVJOSU5HOiBkZWNvcmF0aW9uIHNwcml0
ZSAiLi5kZWMuc3ByaXRlLi4iICgiLi5kZWMubmFtZS4uIikgbm90IGZvdW5kIGluIEdGWCBmaWxl
cyIpCiAgZW5kCiBlbmQKIAogLS0gY2hlY2sgd2FsbCB0ZXh0dXJlIHNwcml0ZXMKIGZvciB0ZXhz
ZXQgaW4gYWxsKHRleHNldHMpIGRvCiAgZm9yIHZhcmlhbnQgaW4gYWxsKHRleHNldC52YXJpYW50
cykgZG8KICAgaWYgbm90IGdldF9zcHIodmFyaWFudCkgdGhlbgogICAgcHJpbnRoKCJXQVJOSU5H
OiB3YWxsIHRleHR1cmUgc3ByaXRlICIuLnZhcmlhbnQuLiIgbm90IGZvdW5kIGluIEdGWCBmaWxl
cyIpCiAgIGVuZAogIGVuZAogZW5kCiAKIC0tIGNoZWNrIGZsb29yL2NlaWxpbmcgc3ByaXRlcwog
Zm9yIHR5cCBpbiBhbGwocGxhbmV0eXBzKSBkbwogIGlmIG5vdCBnZXRfc3ByKHR5cC50ZXgpIHRo
ZW4KICAgcHJpbnRoKCJXQVJOSU5HOiBmbG9vci9jZWlsaW5nIHNwcml0ZSAiLi50eXAudGV4Li4i
IG5vdCBmb3VuZCBpbiBHRlggZmlsZXMiKQogIGVuZAogZW5kCmVuZAoKZnVuY3Rpb24gdXBkYXRl
X2dhbWVwbGF5KCkKIC0tIGluY3JlbWVudCBmcmFtZSBjb3VudGVyCiBmcmFtZV9jdCs9MQogCiAt
LSBvcHRpb25hbDogc2FtcGxlIENQVSBvdXRzaWRlIHJlbmRlciBmcmFtZSAoZXZlcnkgMzAgZnJh
bWVzKSBmb3Igbm9uLXJlbmRlciBnb3Zlcm5vcgogaWYgZW5hYmxlX25vbnJlbmRlcl9nb3Zlcm5v
ciBhbmQgKGZyYW1lX2N0JTMwPT0wKSB0aGVuCiAgcmVjZW50X2NwdT1zdGF0KDEpIG9yIDAKIGVu
ZAogCiAtLSBjb21iYXQgZ2F0aW5nOiBza2lwIG5vcm1hbCB1cGRhdGVzIHdoZW4gaW4gY29tYmF0
CiBpZiBpbl9jb21iYXQgdGhlbgogIHVwZGF0ZV9jb21iYXQoKQogIHJldHVybgogZW5kCiAKIHVw
ZGF0ZV9pbnB1dCgpCiB1cGRhdGVfZG9vcnMoKQogCiAtLSB1cGRhdGUgbnBjIGFpIChyYXRlIGxp
bWl0ZWQsIGRldGVybWluaXN0aWMgZnJhbWUgY2hlY2spCiBpZiBmcmFtZV9jdCVhaV91cGRhdGVf
cmF0ZT09MCB0aGVuCiAgdXBkYXRlX25wY19haSgpCiBlbmQKIAogY2FtPXtwbGF5ZXIueCxwbGF5
ZXIueX0KIAogLS0gdXBkYXRlIGZsb29yL2NlaWxpbmcgc2Nyb2xsaW5nCiBmbG9vci54Kz1mbG9v
ci50eXAueHZlbCBvciAwCiBmbG9vci55Kz1mbG9vci50eXAueXZlbCBvciAwCiByb29mLngrPXJv
b2YudHlwLnh2ZWwgb3IgMAogcm9vZi55Kz1yb29mLnR5cC55dmVsIG9yIDAKIAogLS0gdXBkYXRl
IG9iamVjdCBhbmltYXRpb25zCiBmb3Igb2IgaW4gYWxsKGFuaW1hdGVkX29iamVjdHMpIGRvCiAg
aWYgb2IudHlwIGFuZCBvYi50eXAuZnJhbWVjdCB0aGVuCiAgIG9iLmZyYW1lKz1vYi50eXAuYW5p
bXNwZAogICBpZiBvYi5hbmltbG9vcCB0aGVuCiAgICBvYi5mcmFtZT1vYi5mcmFtZSVvYi50eXAu
ZnJhbWVjdAogICBlbHNlCiAgICBvYi5mcmFtZT1taW4ob2IuZnJhbWUsb2IudHlwLmZyYW1lY3Qt
MSkKICAgZW5kCiAgZW5kCiBlbmQKIAogLS0gdG9nZ2xlIHZpZXcgbW9kZSAoZGVidWcgb25seSkK
IGlmIGRlYnVnX21vZGUgYW5kIChrZXlwKCJ4Iikgb3IgYnRucCg1KSkgdGhlbgogIHZpZXdfbW9k
ZT12aWV3X21vZGU9PSIzZCIgYW5kICIyZCIgb3IgIjNkIgogZW5kCiAKIC0tIGRlYnVnIG1vZGUg
dG9nZ2xlIChtb3ZlZCBmcm9tIGJ0bnAoNCkgdG8gYXZvaWQgY29uZmxpY3QpCiBpZiBrZXlwKCJ0
YWIiKSB0aGVuCiAgZGVidWdfbW9kZT1ub3QgZGVidWdfbW9kZQogZW5kCiAKIC0tIGRpYWdub3N0
aWNzIG92ZXJsYXkgcmVtb3ZlZDsgbWVyZ2VkIGludG8gZGVidWcgcGFuZWwgKFRhYikKIAogLS0g
dG9nZ2xlIGRpYWdub3N0aWNzIGxvZ2dpbmcgKGNvbnRyb2xsZXIgYnV0dG9uIDEyKQogaWYgYnRu
cCgxMikgdGhlbgogIGVuYWJsZV9kaWFnbm9zdGljc19sb2dnaW5nPW5vdCBlbmFibGVfZGlhZ25v
c3RpY3NfbG9nZ2luZwogIHByaW50aCgiRGlhZ25vc3RpY3MgbG9nZ2luZzogIi4udG9zdHJpbmco
ZW5hYmxlX2RpYWdub3N0aWNzX2xvZ2dpbmcpKQogZW5kCiAKIC0tIGRlY3JlbWVudCB0cmFwIG1l
c3NhZ2UgdGltZXIKIGlmIHRyYXBfbXNnX3RpbWVyPjAgdGhlbgogIHRyYXBfbXNnX3RpbWVyLT0x
CiBlbmQKIAogLS0gdG9nZ2xlIHRlc3QgZG9vciBtb2RlICh3aGVuIG5vdCBpbiAyZCBtYXAgdmll
dykKIGlmIHZpZXdfbW9kZT09IjNkIiBhbmQgKGtleXAoInYiKSBvciBidG5wKDE1KSkgdGhlbgog
IHRlc3RfZG9vcl9tb2RlPW5vdCB0ZXN0X2Rvb3JfbW9kZQogZW5kCiAKIC0tIGN5Y2xlIHRlc3Qg
ZG9vciBvcGVuIHZhbHVlICgwLjAgdG8gMS4wKQogaWYgdGVzdF9kb29yX21vZGUgdGhlbgogIGlm
IGtleXAoImMiKSB0aGVuCiAgIHRlc3RfZG9vcl9vcGVuPSh0ZXN0X2Rvb3Jfb3BlbiBvciAwKSsw
LjEKICAgaWYgdGVzdF9kb29yX29wZW4_MSB0aGVuIHRlc3RfZG9vcl9vcGVuPTAgZW5kCiAgZW5k
CiAgaWYga2V5cCgiZCIpIHRoZW4KICAgdGVzdF9kb29yX29wZW49KHRlc3RfZG9vcl9vcGVuIG9y
IDApLTAuMQogICBpZiB0ZXN0X2Rvb3Jfb3BlbjwwIHRoZW4gdGVzdF9kb29yX29wZW49MSBlbmQK
ICBlbmQKIGVuZAogCiAtLSBjeWNsZSBmbG9vciB0eXBlIChmb3IgdGVzdGluZykgd2hlbiBub3Qg
aW4gZG9vciB0ZXN0IG1vZGUKIGlmIG5vdCB0ZXN0X2Rvb3JfbW9kZSBhbmQga2V5cCgiYyIpIHRo
ZW4KICBsb2NhbCBjdXJyZW50X2lkeD0xCiAgZm9yIGk9MSwjcGxhbmV0eXBzIGRvCiAgIGlmIHBs
YW5ldHlwc1tpXS50ZXg9PWZsb29yLnR5cC50ZXggdGhlbgogICAgY3VycmVudF9pZHg9aQogICAg
YnJlYWsKICAgZW5kCiAgZW5kCiAgZmxvb3IudHlwPXBsYW5ldHlwc1soY3VycmVudF9pZHggJSAj
cGxhbmV0eXBzKSsxXQogIGZsb29yLngsZmxvb3IueT0wLDAKICAtLSBUZXN0IG1vZGU6IGNsZWFy
IGNhY2hlIHdoZW4gY3ljbGluZyBmbG9vciB0eXBlcyAoY2FuIGJlIGRpc2FibGVkIGluIHByb2R1
Y3Rpb24pCiAgaWYgY2xlYXJfdGV4dHVyZV9jYWNoZXMgdGhlbiBjbGVhcl90ZXh0dXJlX2NhY2hl
cygpIGVuZAogZW5kCiAKIC0tIGN5Y2xlIHJvb2YgdHlwZSAoZm9yIHRlc3RpbmcpIHdoZW4gbm90
IGluIGRvb3IgdGVzdCBtb2RlCiBpZiBub3QgdGVzdF9kb29yX21vZGUgYW5kIGtleXAoImQiKSB0
aGVuCiAgbG9jYWwgY3VycmVudF9pZHg9MQogIGZvciBpPTEsI3BsYW5ldHlwcyBkbwogICBpZiBw
bGFuZXR5cHNbaV0udGV4PT1yb29mLnR5cC50ZXggdGhlbgogICAgY3VycmVudF9pZHg9aQogICAg
YnJlYWsKICAgZW5kCiAgZW5kCiAgcm9vZi50eXA9cGxhbmV0eXBzWyhjdXJyZW50X2lkeCAlICNw
bGFuZXR5cHMpKzFdCiAgcm9vZi54LHJvb2YueT0wLDAKICAtLSBUZXN0IG1vZGU6IGNsZWFyIGNh
Y2hlIHdoZW4gY3ljbGluZyByb29mIHR5cGVzIChjYW4gYmUgZGlzYWJsZWQgaW4gcHJvZHVjdGlv
bikKICBpZiBjbGVhcl90ZXh0dXJlX2NhY2hlcyB0aGVuIGNsZWFyX3RleHR1cmVfY2FjaGVzKCkg
ZW5kCiBlbmQKIAogLS0gZGVidWcgcmF5IGNhc3RpbmcgKHJlbW92ZWQgLSB1c2UgZGlhZ25vc3Rp
Y3Mgb3ZlcmxheSBpbnN0ZWFkIHdpdGggVGFiIGtleSkKIC0tIExlZ2FjeSByYXljYXN0KCkvaGl0
c2NhbigpIGZ1bmN0aW9ucyBubyBsb25nZXIgYXZhaWxhYmxlIGFmdGVyIHJlbmRlcmVyIHJlZmFj
dG9yCiAtLSBVc2Ugcl9kaWFnIGRpYWdub3N0aWNzIG92ZXJsYXkgKFRhYiBrZXkpIGZvciBwZXJm
b3JtYW5jZSBtZXRyaWNzCmVuZAoKZnVuY3Rpb24gZHJhd19nYW1lcGxheSgpCiBjbGlwKDAsMCxz
Y3JlZW5fd2lkdGgsc2NyZWVuX2hlaWdodCkKIGNscygwKQogCiBsb2NhbCBmcmFtZV9zdGFydD10
aW1lKCkKIAogZGlhZ19mcmFtZV9jb3VudCs9MQogCi0tIHJlc2V0IHBlci1mcmFtZSBkaWFnbm9z
dGljcwpkaWFnX3dhbGxfY29sdW1ucz0wCmRpYWdfd2FsbF9sb2RfY29sdW1ucz0wCmRpYWdfZmxv
b3Jfcm93cz0wCmRpYWdfZmxvb3JfYmF0Y2hlcz0wCmRpYWdfc3ByaXRlX2NvbHVtbnM9MApkaWFn
X3Nwcml0ZV9pbXBvc3Rvcl9jb2x1bW5zPTAKCi0tIEVuc3VyZSBhZGFwdGl2ZSBjb250cm9scyBh
cmUgaW5pdGlhbGl6ZWQgb25jZQppZiBub3QgYWN0aXZlX3JheV9jb3VudCB0aGVuIGFjdGl2ZV9y
YXlfY291bnQ9cmF5X2NvdW50IGVuZAppZiBub3Qgcm93X3N0cmlkZV9keW5hbWljIHRoZW4gcm93
X3N0cmlkZV9keW5hbWljPXJvd19zdHJpZGUgZW5kCgpsb2NhbCBmdW5jdGlvbiBhZGp1c3RfcmF5
X2J1ZGdldChjcHVfc2FtcGxlKQogbG9jYWwgbWluX3JheXM9bWF4KDQ4LCBmbHIocmF5X2NvdW50
KjAuMjUpKQogaWYgY3B1X3NhbXBsZT4wLjkwIHRoZW4KICBhY3RpdmVfcmF5X2NvdW50PW1heCht
aW5fcmF5cywgYWN0aXZlX3JheV9jb3VudC0xNikKIGVsc2VpZiBjcHVfc2FtcGxlPDAuNzAgdGhl
bgogIGFjdGl2ZV9yYXlfY291bnQ9bWluKHJheV9jb3VudCwgYWN0aXZlX3JheV9jb3VudCs4KQog
ZW5kCmVuZAoKLS0gQ29udGludW91cyBDUFUgc2FtcGxpbmcgZm9yIGFkYXB0aXZlIGJ1ZGdldAps
b2NhbCBjcHVfc2FtcGxlID0gc3RhdCgxKSBvciBsYXN0X2NwdV9zYW1wbGUgb3IgMAppZiBub3Qg
cGVyZl92YWxpZGF0aW9uIGFuZCBub3QgZW5hYmxlX25vbnJlbmRlcl9nb3Zlcm5vciB0aGVuCiBh
ZGp1c3RfcmF5X2J1ZGdldChjcHVfc2FtcGxlKQplbmQKCi0tIE9wdGlvbmFsIG5vbi1yZW5kZXIg
Z292ZXJub3I6IHVzZXMgQ1BVIHNhbXBsZWQgaW4gX3VwZGF0ZSgpCmlmIGVuYWJsZV9ub25yZW5k
ZXJfZ292ZXJub3IgdGhlbgogYWRqdXN0X3JheV9idWRnZXQocmVjZW50X2NwdSBvciBjcHVfc2Ft
cGxlKQplbmQKbGFzdF9jcHVfc2FtcGxlPWNwdV9zYW1wbGUKZGlhZ19hY3RpdmVfcmF5cz1hY3Rp
dmVfcmF5X2NvdW50CiAKIC0tIFByZXBhcmUgZnJhbWUgaW4gbmV3IHJlbmRlcmVyCiByX3N0YXRl
LnByZXBhcmVfZnJhbWUoKQogcl9zdGF0ZS5jb25maWcuZGVidWdfbW9kZSA9IGRlYnVnX21vZGUK
IAogLS0gVXBkYXRlIGRlYnVnIG1vZGUKIHJfc3RhdGUuY29uZmlnLmRlYnVnX21vZGUgPSBkZWJ1
Z19tb2RlCiAKIGlmIHZpZXdfbW9kZT09IjNkIiB0aGVuCiAgLS0gQnVpbGQgY2FtZXJhIHRhYmxl
CiAgbG9jYWwgY2FtZXJhID0ge3ggPSBwbGF5ZXIueCwgeSA9IHBsYXllci55LCBhID0gcGxheWVy
LmF9CiAgCiAgLS0gVXBkYXRlIHZpZXcgKGNhbWVyYSBiYXNpcyBhbmQgcmF5IExVVHMpCiAgcl92
aWV3LnVwZGF0ZShjYW1lcmEsIHJfc3RhdGUsIGZvdiwgYWN0aXZlX3JheV9jb3VudCkKICBsb2Nh
bCB0X3ZpZXcgPSB0aW1lKCkKICAKICAtLSBDYXN0IHJheXMKICBsb2NhbCBnYW1lX3N0YXRlX2Nh
c3QgPSB7CiAgICBnZXRfd2FsbCA9IGdldF93YWxsLAogICAgaXNfZG9vciA9IGlzX2Rvb3IsCiAg
ICBkb29yZ3JpZCA9IGRvb3JncmlkLAogICAgdGVzdF9kb29yX21vZGUgPSB0ZXN0X2Rvb3JfbW9k
ZSwKICAgIHRlc3RfZG9vcl9vcGVuID0gdGVzdF9kb29yX29wZW4sCiAgICBmYXJfcGxhbmUgPSBm
YXJfcGxhbmUsCiAgICBtYXBfc2l6ZSA9IG1hcF9zaXplCiAgfQogIHJfY2FzdC5jYXN0X3NjZW5l
KGNhbWVyYSwgcl92aWV3LCByX3N0YXRlLCBnYW1lX3N0YXRlX2Nhc3QpCiAgbG9jYWwgdF9yYXlj
YXN0ID0gdGltZSgpCiAgCiAgLS0gRHJhdyBmbG9vciBhbmQgY2VpbGluZwogIGxvY2FsIGdhbWVf
c3RhdGVfZmxvb3IgPSB7CiAgICBmbG9vciA9IGZsb29yLAogICAgcm9vZiA9IHJvb2YsCiAgICBz
cHJpdGVfc2l6ZSA9IHNwcml0ZV9zaXplLAogICAgcGVyX2NlbGxfZmxvb3JzX2VuYWJsZWQgPSBw
ZXJfY2VsbF9mbG9vcnNfZW5hYmxlZCwKICAgIGdldF9mbG9vciA9IGdldF9mbG9vciwKICAgIHBs
YW5ldHlwcyA9IHBsYW5ldHlwcywKICAgIEVSUk9SX0lEWCA9IEVSUk9SX0lEWCwKICAgIGdldF9z
cHIgPSBnZXRfc3ByLAogICAgZXJyb3JfdGV4dHVyZXMgPSBlcnJvcl90ZXh0dXJlcwogIH0KICBy
X2Zsb29yLmRyYXdfZmxvb3JfY2VpbGluZyhjYW1lcmEsIHJfdmlldywgcl9zdGF0ZSwgcl9iYXRj
aCwgZ2FtZV9zdGF0ZV9mbG9vcikKICBsb2NhbCB0X2Zsb29yID0gdGltZSgpCiAgCiAgLS0gRHJh
dyB3YWxscwogIGxvY2FsIGdhbWVfc3RhdGVfd2FsbHMgPSB7CiAgICB3YWxsX2xvZF9kaXN0YW5j
ZSA9IHdhbGxfbG9kX2Rpc3RhbmNlLAogICAgd2FsbF90aW55X3NjcmVlbl9weCA9IHdhbGxfdGlu
eV9zY3JlZW5fcHgsCiAgICBzcHJpdGVfc2l6ZSA9IHNwcml0ZV9zaXplLAogICAgaXNfZG9vciA9
IGlzX2Rvb3IsCiAgICBnZXRfc3ByID0gZ2V0X3NwciwKICAgIGVycm9yX3RleHR1cmVzID0gZXJy
b3JfdGV4dHVyZXMsCiAgICBFUlJPUl9JRFggPSBFUlJPUl9JRFgKICB9CiAgcl93YWxscy5kcmF3
X3NwYW5zKGNhbWVyYSwgcl92aWV3LCByX3N0YXRlLCByX2JhdGNoLCBnYW1lX3N0YXRlX3dhbGxz
KQogIGxvY2FsIHRfd2FsbHMgPSB0aW1lKCkKICAKICAtLSBEcmF3IHNwcml0ZXMKICBsb2NhbCBn
YW1lX3N0YXRlX3Nwcml0ZXMgPSB7CiAgICBvYmplY3RzID0gb2JqZWN0cywKICAgIGZhcl9wbGFu
ZSA9IGZhcl9wbGFuZSwKICAgIHNwcml0ZV9sb2RfcmF0aW8gPSBzcHJpdGVfbG9kX3JhdGlvLAog
ICAgZm9nX2ZhciA9IGZvZ19mYXIsCiAgICBzcHJpdGVfc2l6ZSA9IHNwcml0ZV9zaXplLAogICAg
Z2V0X3NwciA9IGdldF9zcHIsCiAgICBlcnJvcl90ZXh0dXJlcyA9IGVycm9yX3RleHR1cmVzCiAg
fQogIHJfc3ByaXRlcy5kcmF3KGNhbWVyYSwgcl92aWV3LCByX3N0YXRlLCByX2JhdGNoLCBnYW1l
X3N0YXRlX3Nwcml0ZXMpCiAgbG9jYWwgdF9zcHJpdGVzID0gdGltZSgpCiAgCiAgbG9jYWwgbXNf
dmlldyA9ICh0X3ZpZXcgLSBmcmFtZV9zdGFydCkgKiAxMDAwCiAgbG9jYWwgbXNfcmF5Y2FzdCA9
ICh0X3JheWNhc3QgLSB0X3ZpZXcpICogMTAwMAogIGxvY2FsIG1zX2Zsb29yID0gKHRfZmxvb3Ig
LSB0X3JheWNhc3QpICogMTAwMAogIGxvY2FsIG1zX3dhbGxzID0gKHRfd2FsbHMgLSB0X2Zsb29y
KSAqIDEwMDAKICBsb2NhbCBtc19zcHJpdGVzID0gKHRfc3ByaXRlcyAtIHRfd2FsbHMpICogMTAw
MAogIGxvY2FsIGZyYW1lX21zID0gKHRfc3ByaXRlcyAtIGZyYW1lX3N0YXJ0KSAqIDEwMDAKICAK
ICAtLSBodWQgKG1pbmltYWwpCiAgcHJpbnQoInBvczoiLi5mbHIocGxheWVyLngpLi4iLCIuLmZs
cihwbGF5ZXIueSksMiwyLDcpCiAgcHJpbnQoImFuZzoiLi4oZmxyKHBsYXllci5hKjEwMCkvMTAw
KSwyLDEwLDcpCiAgcHJpbnQoImZwczoiLi5zdGF0KDcpLDIsMTgsNykKICBwcmludCgiaHA6Ii4u
cGxheWVyLmhwLDIsMjYsNykKICAKICAtLSBpbnRlcmFjdGlvbiBwcm9tcHQKICBpZiBpbnRlcmFj
dGlvbl9hY3RpdmUgYW5kIGN1cnJlbnRfaW50ZXJhY3QgdGhlbgogICBwcmludCgiW0VdL1o6IGlu
dGVyYWN0IixzY3JlZW5fY2VudGVyX3gtNDAsc2NyZWVuX2hlaWdodC0yMCwxMSkKICBlbmQKICAK
ICAtLSB0cmFwIG1lc3NhZ2UKICBpZiB0cmFwX21zZ190aW1lcj4wIHRoZW4KICAgcHJpbnQoInRy
YXAgc3BydW5nISIsc2NyZWVuX2NlbnRlcl94LTMwLHNjcmVlbl9jZW50ZXJfeSw4KQogIGVuZAog
IAogLS1bWyBERUJVRyBQQU5FTCBSRU1PVkVEIEZPUiBQUk9EVUNUSU9OIFBFUkZPUk1BTkNFCiBp
ZiBkZWJ1Z19tb2RlIHRoZW4KICAtLSByZW1vdmVkCiBlbmQKIF1dCiAgCiAtLVtbIFBFUklPRElD
IExPR0dJTkcgUkVNT1ZFRCBGT1IgUFJPRFVDVElPTiBQRVJGT1JNQU5DRQogaWYgZW5hYmxlX2Rp
YWdub3N0aWNzX2xvZ2dpbmcgYW5kIGRpYWdfZnJhbWVfY291bnQlNjA9PTAgdGhlbgogIC0tIHJl
bW92ZWQKIGVuZAogXV0KICAKICAtLSBtaW5pbWFwIEhVRCBvdmVybGF5CiAgZHJhd19taW5pbWFw
X2h1ZCgpCiBlbHNlCiAgZHJhd19taW5pbWFwKCkKIGVuZAogCiAtLSBjb21iYXQgb3ZlcmxheQog
aWYgaW5fY29tYmF0IHRoZW4KICByZWN0ZmlsbCgwLHNjcmVlbl9oZWlnaHQtNDAsc2NyZWVuX3dp
ZHRoLHNjcmVlbl9oZWlnaHQsMCkKICBwcmludCgiZW50ZXJpbmcgY29tYmF0Li4uIixzY3JlZW5f
Y2VudGVyX3gtNDAsc2NyZWVuX2NlbnRlcl95LDgpCiAgcHJpbnQoIltlbnRlcl0gZXhpdCAodGVt
cCkiLHNjcmVlbl9jZW50ZXJfeC00MCxzY3JlZW5fY2VudGVyX3krMTAsNykKIGVuZAogCiAtLSBy
ZXN0b3JlIHBhbGV0dGUgZnJvbSBmb2cgcmVtYXBwaW5nIChzaW5nbGUgcmVzdG9yZSBwZXIgZnJh
bWUpCiBwYWwoKQogLS0gcmVzZXQgZm9nIHN0YXRlIHNvIGZpcnN0IHNldF9mb2cgYXBwbGllcyBt
YXBwaW5nIG5leHQgZnJhbWUKIGxhc3RfZm9nX2xldmVsPS0xCiBwcmV2X3BhbD17fQoKIC0tIERy
YXcgZGlhZ25vc3RpY3Mgb3ZlcmxheSAobmV3IHJlbmRlcmVyKQogcl9kaWFnLmRyYXcocl9zdGF0
ZSwgZnJhbWVfbXMsIGNwdV9zYW1wbGUpCmVuZAoKbG9jYWwgZnVuY3Rpb24gZ2VuZXJhdGVfbGFi
X2R1bmdlb24oc3RhdGUsc2VlZCkKIGxvY2FsIHRhcmdldF9zZWVkPXNlZWQgb3IgKDErZmxyKHJu
ZCg5OTk5OTkpKSkKIGlmIHRhcmdldF9zZWVkPDEgdGhlbiB0YXJnZXRfc2VlZD0xIGVuZAogc3Rh
cnRfcG9zLGdlbl9zdGF0cz1nZW5lcmF0ZV9kdW5nZW9uKHtzZWVkPXRhcmdldF9zZWVkfSkKIHN0
YXRlLnNlZWQ9Z2VuX3N0YXRzLnNlZWQKIHN0YXRlLmdlbl9zdGF0cz1nZW5fc3RhdHMKIHN0YXRl
Lmhpc3Rvcnk9Z2VuX3N0YXRzLmhpc3Rvcnkgb3Ige30KIHN0YXRlLmhpc3RvcnlfY3Vyc29yPW1h
eCgwLCNzdGF0ZS5oaXN0b3J5LTIwKQogc3RhdGUuaGFybmVzc19yZXN1bHQ9c3RhdGUuaGFybmVz
c19yZXN1bHQgb3IgbmlsCiB2aWV3X21vZGU9IjJkIgplbmQKCmxvY2FsIGZ1bmN0aW9uIGRyYXdf
bGFiX21hcChzdGF0ZSkKIGxvY2FsIHNjYWxlPTMKIGxvY2FsIG94PTgKIGxvY2FsIG95PTgKIGxv
Y2FsIG1hcF9weD1tYXBfc2l6ZSpzY2FsZQogcmVjdGZpbGwoMCwwLHNjcmVlbl93aWR0aC0xLHNj
cmVlbl9oZWlnaHQtMSwwKQogcmVjdGZpbGwob3gtMixveS0yLG94K21hcF9weCsxLG95K21hcF9w
eCsxLDEpCiBmb3IgeD0wLG1hcF9zaXplLTEgZG8KICBmb3IgeT0wLG1hcF9zaXplLTEgZG8KICAg
bG9jYWwgd2FsbD1nZXRfd2FsbCh4LHkpCiAgIGxvY2FsIGZsb29yX3ZhbD1nZXRfZmxvb3IoeCx5
KQogICBsb2NhbCBjb2xvcgogICBpZiB3YWxsPjAgdGhlbgogICAgY29sb3I9NQogICBlbHNlaWYg
Zmxvb3JfdmFsPjAgdGhlbgogICAgY29sb3I9NgogICBlbHNlCiAgICBjb2xvcj0wCiAgIGVuZAog
ICByZWN0ZmlsbChveCt4KnNjYWxlLG95K3kqc2NhbGUsb3greCpzY2FsZStzY2FsZS0xLG95K3kq
c2NhbGUrc2NhbGUtMSxjb2xvcikKICBlbmQKIGVuZAogZm9yIG5vZGUgaW4gYWxsKGdlbl9ub2Rl
cykgZG8KICBsb2NhbCByPW5vZGUucmVjdAogIHJlY3Qob3grclsxXSpzY2FsZSxveStyWzJdKnNj
YWxlLG94K3JbM10qc2NhbGUsb3krcls0XSpzY2FsZSwxMSkKIGVuZAogZm9yIGVkZ2UgaW4gYWxs
KGdlbl9lZGdlcykgZG8KICBsb2NhbCBjPWVkZ2UubG9ja2VkIGFuZCA4IG9yIDEyCiAgbG9jYWwg
eDE9b3grZWRnZS5uMS5taWR4KnNjYWxlCiAgbG9jYWwgeTE9b3krZWRnZS5uMS5taWR5KnNjYWxl
CiAgbG9jYWwgeDI9b3grZWRnZS5uMi5taWR4KnNjYWxlCiAgbG9jYWwgeTI9b3krZWRnZS5uMi5t
aWR5KnNjYWxlCiAgbGluZSh4MSx5MSx4Mix5MixjKQogIGlmIGVkZ2UuYjEgdGhlbgogICByZWN0
ZmlsbChveCtlZGdlLmIxLngqc2NhbGUsb3krZWRnZS5iMS55KnNjYWxlLG94K2VkZ2UuYjEueCpz
Y2FsZStzY2FsZS0xLG95K2VkZ2UuYjEueSpzY2FsZStzY2FsZS0xLGMpCiAgZW5kCiAgaWYgZWRn
ZS5iMiB0aGVuCiAgIHJlY3RmaWxsKG94K2VkZ2UuYjIueCpzY2FsZSxveStlZGdlLmIyLnkqc2Nh
bGUsb3grZWRnZS5iMi54KnNjYWxlK3NjYWxlLTEsb3krZWRnZS5iMi55KnNjYWxlK3NjYWxlLTEs
YykKICBlbmQKIGVuZAogZm9yIGRvb3IgaW4gYWxsKGRvb3JzKSBkbwogIGxvY2FsIGM9ZG9vci5k
dHlwZT09ZG9vcl9sb2NrZWQgYW5kIDggb3IgMTAKICByZWN0ZmlsbChveCtkb29yLngqc2NhbGUs
b3krZG9vci55KnNjYWxlLG94K2Rvb3IueCpzY2FsZStzY2FsZS0xLG95K2Rvb3IueSpzY2FsZStz
Y2FsZS0xLGMpCiBlbmQKIGZvciBvYiBpbiBhbGwob2JqZWN0cykgZG8KICBpZiBvYi5wb3MgdGhl
bgogICBsb2NhbCBjeD1veCtvYi5wb3NbMV0qc2NhbGUKICAgbG9jYWwgY3k9b3krb2IucG9zWzJd
KnNjYWxlCiAgIGxvY2FsIGNvbG9yPTcKICAgaWYgb2IudHlwPT1vYmpfdHlwZXMua2V5IHRoZW4g
Y29sb3I9OQogICBlbHNlaWYgb2IudHlwPT1vYmpfdHlwZXMuaG9zdGlsZV9ucGMgdGhlbiBjb2xv
cj04CiAgIGVsc2VpZiBvYi50eXA9PW9ial90eXBlcy5ub25faG9zdGlsZV9ucGMgdGhlbiBjb2xv
cj0xMwogICBlbHNlaWYgb2IudHlwIGFuZCBvYi50eXAua2luZD09ImludGVyYWN0YWJsZSIgdGhl
biBjb2xvcj0xMgogICBlbmQKICAgY2lyY2ZpbGwoY3gsY3ksMSxjb2xvcikKICBlbmQKIGVuZAog
cHJpbnQoImNvbnRyb2xzOiBaPXJhbmRvbSAgWD1yZXBsYXkgIOKGkC-ihpIgc2VlZCAgRj1oYXJu
ZXNzIiw4LHNjcmVlbl9oZWlnaHQtMjAsNykKIHByaW50KCJzY3JvbGwgbG9nOiDihpEv4oaTICAg
IG1lbnU6IEcgb3IgTUVOVSIsOCxzY3JlZW5faGVpZ2h0LTEyLDcpCmVuZAoKbG9jYWwgZnVuY3Rp
b24gZHJhd19sYWJfaGlzdG9yeShzdGF0ZSkKIGxvY2FsIHBhbmVsX3g9c2NyZWVuX3dpZHRoLTE1
NAogbG9jYWwgcGFuZWxfdz0xNDAKIGxvY2FsIHBhbmVsX3RvcD0xMgogbG9jYWwgcGFuZWxfYm90
dG9tPXNjcmVlbl9oZWlnaHQtMTIKIGxvY2FsIHBhbmVsX2g9cGFuZWxfYm90dG9tLXBhbmVsX3Rv
cAoKIHJlY3RmaWxsKHBhbmVsX3gtNCxwYW5lbF90b3AtNCxwYW5lbF94K3BhbmVsX3crMixwYW5l
bF9ib3R0b20sMCkKIHJlY3QocGFuZWxfeC01LHBhbmVsX3RvcC01LHBhbmVsX3grcGFuZWxfdysz
LHBhbmVsX2JvdHRvbSsxLDEpCgogbG9jYWwgeT1wYW5lbF90b3AKIGxvY2FsIHNlZWRfdGV4dD0i
c2VlZDogIi4uKHN0YXRlLnNlZWQgb3IgIj8iKQogbG9jYWwgcm9vbXNfdGV4dD0icm9vbXM6ICIu
LigjZ2VuX25vZGVzIG9yIDApCiBsb2NhbCBsb2NrZWRfY291bnQ9MAogaWYgZ2VuX2xvY2tlZF9l
ZGdlcyB0aGVuCiAgZm9yIGUgaW4gYWxsKGdlbl9sb2NrZWRfZWRnZXMpIGRvCiAgIGlmIGUubG9j
a2VkIHRoZW4gbG9ja2VkX2NvdW50Kz0xIGVuZAogIGVuZAogZW5kCiBsb2NhbCBsb2NrZWRfdGV4
dD0ibG9ja2VkIGVkZ2VzOiAiLi5sb2NrZWRfY291bnQKIHByaW50KHNlZWRfdGV4dCxwYW5lbF94
LHksNykgeSs9OAogcHJpbnQocm9vbXNfdGV4dCxwYW5lbF94LHksNykgeSs9OAogcHJpbnQobG9j
a2VkX3RleHQscGFuZWxfeCx5LDcpIHkrPTEyCgogbG9jYWwgaGlzdG9yeT1zdGF0ZS5oaXN0b3J5
IG9yIHt9CiBsb2NhbCBhdmFpbGFibGVfc3BhY2U9cGFuZWxfaC0oeS1wYW5lbF90b3ApLTI0CiBs
b2NhbCBsaW5lX2g9OAogbG9jYWwgbWF4X2xpbmVzPW1heCgwLGZscihhdmFpbGFibGVfc3BhY2Uv
bGluZV9oKSkKCiBwcmludCgiZ2VuZXJhdGlvbiBsb2ciLHBhbmVsX3gseSwxMSkKIHkrPWxpbmVf
aAoKIGlmIG1heF9saW5lczw9MCB0aGVuCiAgcHJpbnQoIihwYW5lbCB0b28gc21hbGwpIixwYW5l
bF94LHksOCkKIGVsc2UKICBsb2NhbCBjdXJzb3I9c3RhdGUuaGlzdG9yeV9jdXJzb3Igb3IgMAog
IGxvY2FsIG1heF9jdXJzb3I9bWF4KDAsbWF4KCNoaXN0b3J5LW1heF9saW5lcywwKSkKICBpZiBj
dXJzb3I_bWF4X2N1cnNvciB0aGVuIGN1cnNvcj1tYXhfY3Vyc29yIGVuZAogIGlmIGN1cnNvcjww
IHRoZW4gY3Vyc29yPTAgZW5kCiAgc3RhdGUuaGlzdG9yeV9jdXJzb3I9Y3Vyc29yCiAgaWYgI2hp
c3Rvcnk9PTAgdGhlbgogICBwcmludCgiKG5vIGV2ZW50cykiLHBhbmVsX3gseSw1KQogIGVsc2UK
ICAgZm9yIGk9MSxtYXhfbGluZXMgZG8KICAgIGxvY2FsIGlkeD1jdXJzb3IraQogICAgaWYgaWR4
PiNoaXN0b3J5IHRoZW4gYnJlYWsgZW5kCiAgICBsb2NhbCBlbnRyeT1oaXN0b3J5W2lkeF0KICAg
IGlmIGVudHJ5IHRoZW4KICAgICBwcmludChzdHJpbmcuc3ViKGVudHJ5LDEsMzIpLHBhbmVsX3gs
eSw3KQogICAgIHkrPWxpbmVfaAogICAgZW5kCiAgIGVuZAogIGVuZAogZW5kCgogeT1wYW5lbF9i
b3R0b20tMTYKIGlmIHN0YXRlLmhhcm5lc3NfcmVzdWx0IHRoZW4KICBsb2NhbCByZXM9c3RhdGUu
aGFybmVzc19yZXN1bHQKICBsb2NhbCBmYWlsdXJlcz1yZXMuZmFpbHVyZXMgb3IgMAogIGxvY2Fs
IGNvbG9yPWZhaWx1cmVzPjAgYW5kIDggb3IgMTEKICBwcmludCgiaGFybmVzczogIi4uKHJlcy50
b3RhbCBvciAwKSxwYW5lbF94LHksY29sb3IpCiAgeSs9bGluZV9oCiAgcHJpbnQoImZhaWx1cmVz
OiAiLi5mYWlsdXJlcyxwYW5lbF94LHksY29sb3IpCiAgeSs9bGluZV9oCiBlbmQKIHByaW50KCJz
Y3JvbGw6IOKGkS-ihpMgICBtZW51OiBHL01FTlUiLHBhbmVsX3gseSw2KQplbmQKCnNjZW5lcy5t
ZW51PXsKIGVudGVyPWZ1bmN0aW9uKHN0YXRlKQogIHN0YXRlLm9wdGlvbnM9eyJTdGFydCBHYW1l
cGxheSIsIkR1bmdlb24gTGFiIn0KICBzdGF0ZS5pbmRleD1zdGF0ZS5pbmRleCBvciAxCiAgc3Rh
dGUubWVzc2FnZT0iIgogZW5kLAogdXBkYXRlPWZ1bmN0aW9uKHN0YXRlKQogIGxvY2FsIG1vdmVf
dXA9YnRucCgyKSBvciBrZXlwKCJ1cCIpIG9yIGtleXAoInciKQogIGxvY2FsIG1vdmVfZG93bj1i
dG5wKDMpIG9yIGtleXAoImRvd24iKSBvciBrZXlwKCJzIikKICBpZiBtb3ZlX3VwIHRoZW4KICAg
c3RhdGUuaW5kZXg9bWF4KDEsc3RhdGUuaW5kZXgtMSkKICBlbHNlaWYgbW92ZV9kb3duIHRoZW4K
ICAgc3RhdGUuaW5kZXg9bWluKCNzdGF0ZS5vcHRpb25zLHN0YXRlLmluZGV4KzEpCiAgZW5kCgog
IGxvY2FsIGNvbmZpcm09YnRucCg0KSBvciBidG5wKDUpIG9yIGtleXAoInoiKSBvciBrZXlwKCJ4
Iikgb3Iga2V5cCgiZW50ZXIiKSBvciBrZXlwKCJyZXR1cm4iKQogIGlmIGNvbmZpcm0gdGhlbgog
ICBsb2NhbCBjaG9pY2U9c3RhdGUub3B0aW9uc1tzdGF0ZS5pbmRleF0KICAgaWYgY2hvaWNlPT0i
U3RhcnQgR2FtZXBsYXkiIHRoZW4KICAgIHN3aXRjaF9zY2VuZSgiZ2FtZXBsYXkiLHt9KQogICBl
bHNlaWYgY2hvaWNlPT0iRHVuZ2VvbiBMYWIiIHRoZW4KICAgIHN3aXRjaF9zY2VuZSgiZHVuZ2Vv
bl9sYWIiLHt9KQogICBlbmQKICBlbmQKIGVuZCwKIGRyYXc9ZnVuY3Rpb24oc3RhdGUpCiAgY2xz
KDApCiAgcHJpbnQoIlJheWNhc3QgRW5naW5lIixzY3JlZW5fY2VudGVyX3gtNDgsNDAsMTEpCiAg
cHJpbnQoIk1haW4gTWVudSIsc2NyZWVuX2NlbnRlcl94LTMyLDU2LDcpCiAgZm9yIGlkeCxvcHQg
aW4gaXBhaXJzKHN0YXRlLm9wdGlvbnMpIGRvCiAgIGxvY2FsIHk9ODArKGlkeC0xKSoxMgogICBs
b2NhbCBjb2xvcj0oaWR4PT1zdGF0ZS5pbmRleCkgYW5kIDEwIG9yIDcKICAgcHJpbnQoKGlkeD09
c3RhdGUuaW5kZXggYW5kICI_IiBvciAiICIpLi4iICIuLm9wdCxzY3JlZW5fY2VudGVyX3gtNDAs
eSxjb2xvcikKICBlbmQKICBwcmludCgiW1pdIGNvbmZpcm0gIFtVUC9ET1dOXSBuYXZpZ2F0ZSIs
c2NyZWVuX2NlbnRlcl94LTY0LHNjcmVlbl9oZWlnaHQtMzIsNykKIGVuZAp9CgpzY2VuZXMuZ2Ft
ZXBsYXk9ewogZW50ZXI9ZnVuY3Rpb24oc3RhdGUscGFyYW1zKQogIGxvY2FsIHNlZWQ9cGFyYW1z
IGFuZCBwYXJhbXMuc2VlZAogIHN0YXJ0X3BvcyxnZW5fc3RhdHM9Z2VuZXJhdGVfZHVuZ2Vvbih7
c2VlZD1zZWVkfSkKICBwbGF5ZXIueD1zdGFydF9wb3MueAogIHBsYXllci55PXN0YXJ0X3Bvcy55
CiAgdmlld19tb2RlPSIzZCIKICBzdGF0ZS5zZWVkPWdlbl9zdGF0cy5zZWVkCiBlbmQsCiB1cGRh
dGU9ZnVuY3Rpb24oc3RhdGUpCiAgaWYgYnRucCg2KSBvciBrZXlwKCJnIikgdGhlbgogICBzd2l0
Y2hfc2NlbmUoIm1lbnUiKQogICByZXR1cm4KICBlbmQKICB1cGRhdGVfZ2FtZXBsYXkoKQogZW5k
LAogZHJhdz1mdW5jdGlvbihzdGF0ZSkKICBkcmF3X2dhbWVwbGF5KCkKICBwcmludCgiW01FTlVd
L0cgdG8gcmV0dXJuIixzY3JlZW5fd2lkdGgtMTIwLHNjcmVlbl9oZWlnaHQtMTAsNykKIGVuZAp9
CgpzY2VuZXMuZHVuZ2Vvbl9sYWI9ewogZW50ZXI9ZnVuY3Rpb24oc3RhdGUscGFyYW1zKQogIHN0
YXRlLnNlZWQ9cGFyYW1zIGFuZCBwYXJhbXMuc2VlZAogIGdlbmVyYXRlX2xhYl9kdW5nZW9uKHN0
YXRlLHN0YXRlLnNlZWQpCiBlbmQsCiB1cGRhdGU9ZnVuY3Rpb24oc3RhdGUpCiAgaWYgYnRucCg2
KSBvciBrZXlwKCJnIikgdGhlbgogICBzd2l0Y2hfc2NlbmUoIm1lbnUiKQogICByZXR1cm4KICBl
bmQKICBpZiBrZXlwKCJ6IikgdGhlbgogICBnZW5lcmF0ZV9sYWJfZHVuZ2VvbihzdGF0ZSxuaWwp
CiAgZWxzZWlmIGtleXAoIngiKSB0aGVuCiAgIGdlbmVyYXRlX2xhYl9kdW5nZW9uKHN0YXRlLHN0
YXRlLnNlZWQpCiAgZWxzZWlmIGtleXAoImxlZnQiKSBvciBidG5wKDApIHRoZW4KICAgbG9jYWwg
c2VlZD0oc3RhdGUuc2VlZCBvciAxKS0xCiAgIGlmIHNlZWQ8MSB0aGVuIHNlZWQ9MSBlbmQKICAg
Z2VuZXJhdGVfbGFiX2R1bmdlb24oc3RhdGUsc2VlZCkKICBlbHNlaWYga2V5cCgicmlnaHQiKSBv
ciBidG5wKDEpIHRoZW4KICAgbG9jYWwgc2VlZD0oc3RhdGUuc2VlZCBvciAxKSsxCiAgIGdlbmVy
YXRlX2xhYl9kdW5nZW9uKHN0YXRlLHNlZWQpCiAgZWxzZWlmIGtleXAoImYiKSB0aGVuCiAgIGxv
Y2FsIHByZXZpb3VzX3NlZWQ9c3RhdGUuc2VlZAogICBzdGF0ZS5oYXJuZXNzX3Jlc3VsdD1kdW5n
ZW9uX2hhcm5lc3MucnVuKCkKICAgZ2VuZXJhdGVfbGFiX2R1bmdlb24oc3RhdGUscHJldmlvdXNf
c2VlZCkKICBlbHNlaWYgYnRucCgyKSBvciBrZXlwKCJ1cCIpIG9yIGtleXAoInBhZ2V1cCIpIHRo
ZW4KICAgc3RhdGUuaGlzdG9yeV9jdXJzb3I9bWF4KDAsKHN0YXRlLmhpc3RvcnlfY3Vyc29yIG9y
IDApLTEpCiAgZWxzZWlmIGJ0bnAoMykgb3Iga2V5cCgiZG93biIpIG9yIGtleXAoInBhZ2Vkb3du
IikgdGhlbgogICBsb2NhbCBoaXN0b3J5PXN0YXRlLmhpc3Rvcnkgb3Ige30KICAgbG9jYWwgbWF4
X2N1cnNvcj1tYXgoMCwjaGlzdG9yeS0xKQogICBzdGF0ZS5oaXN0b3J5X2N1cnNvcj1taW4obWF4
X2N1cnNvciwoc3RhdGUuaGlzdG9yeV9jdXJzb3Igb3IgMCkrMSkKICBlbmQKIGVuZCwKIGRyYXc9
ZnVuY3Rpb24oc3RhdGUpCiAgZHJhd19sYWJfbWFwKHN0YXRlKQogIGRyYXdfbGFiX2hpc3Rvcnko
c3RhdGUpCiBlbmQKfQoKZnVuY3Rpb24gX3VwZGF0ZSgpCiBzY2VuZV91cGRhdGUoKQplbmQKCmZ1
bmN0aW9uIF9kcmF3KCkKIHNjZW5lX2RyYXcoKQplbmQKCi0tIGRyYXcgMmQgbWluaW1hcCBmb3Ig
dGVzdGluZwotLSBQdXJwb3NlOiBSZW5kZXIgMkQgdG9wLWRvd24gZGVidWcgdmlldyBvZiBkdW5n
ZW9uCi0tIEFsZ29yaXRobTogU2NhbGUgMTI4w5cxMjggbWFwIHRvIDI1NsOXMjU2IHBpeGVscyAo
c2NhbGU9MikKLS0gRGlzcGxheXM6IFdhbGxzLCByb29tcywgZG9vcnMsIG9iamVjdHMsIHBsYXll
ciBwb3NpdGlvbiBhbmQgZmFjaW5nCi0tIE5vdGVzOiBUb2dnbGVkIHdpdGggWCBidXR0b24sIHVz
ZWZ1bCBmb3IgZGVidWdnaW5nIGdlbmVyYXRpb24KZnVuY3Rpb24gZHJhd19taW5pbWFwKCkKIGxv
Y2FsIHNjYWxlPTIKIGxvY2FsIG94LG95PTEwLDEwCiAKIC0tIGJhdGNoIGFsbCB0aWxlIGRyYXdp
bmcgdG8gcmVkdWNlIGRyYXcgY2FsbCBjb3VudAogcmJhdGNoX3Jlc2V0KCkKIAogLS0gZHJhdyB3
YWxscyBmcm9tIG1hcC53YWxscyB1c2VyZGF0YSB3aXRoIGZsb29yIGRhdGEgdG8gZGlzdGluZ3Vp
c2ggY29ycmlkb3JzIGZyb20gdm9pZAogZm9yIHg9MCwxMjcgZG8KICBmb3IgeT0wLDEyNyBkbwog
ICBsb2NhbCB3YWxsPWdldF93YWxsKHgseSkKICAgbG9jYWwgZmxvb3JfdmFsPWdldF9mbG9vcih4
LHkpCiAgIGxvY2FsIGNvbG9yCiAgIGlmIHdhbGw_MCB0aGVuCiAgICAtLSB3YWxsIHRpbGUKICAg
IGNvbG9yPTUKICAgZWxzZWlmIGZsb29yX3ZhbD4wIHRoZW4KICAgIC0tIGNhcnZlZCBjb3JyaWRv
ci9yb29tIGZsb29yIChmbG9vciB0eXBlIHNldCBkdXJpbmcgZ2VuZXJhdGlvbikKICAgIGNvbG9y
PTYKICAgZWxzZQogICAgLS0gdW5jYXJ2ZWQgdm9pZCAod2FsbD0wLCBmbG9vcj0wKQogICAgY29s
b3I9MQogICBlbmQKICAgcmJhdGNoX3B1c2gob3greCpzY2FsZSxveSt5KnNjYWxlLG94K3gqc2Nh
bGUrc2NhbGUtMSxveSt5KnNjYWxlK3NjYWxlLTEsY29sb3IpCiAgZW5kCiBlbmQKIAogcmJhdGNo
X3N1Ym1pdCgpCiAKIC0tIGRyYXcgcm9vbXMKIGZvciBub2RlIGluIGFsbChnZW5fbm9kZXMpIGRv
CiAgbG9jYWwgcj1ub2RlLnJlY3QKICByZWN0KG94K3JbMV0qc2NhbGUsb3krclsyXSpzY2FsZSxv
eCtyWzNdKnNjYWxlLG95K3JbNF0qc2NhbGUsMTEpCiBlbmQKIAogLS0gYmF0Y2ggZG9vciBkcmF3
aW5nCiByYmF0Y2hfcmVzZXQoKQogZm9yIGRvb3IgaW4gYWxsKGRvb3JzKSBkbwogIGxvY2FsIGM9
ZG9vci5kdHlwZT09ZG9vcl9sb2NrZWQgYW5kIDggb3IgMTIKICByYmF0Y2hfcHVzaChveCtkb29y
Lngqc2NhbGUsb3krZG9vci55KnNjYWxlLG94K2Rvb3IueCpzY2FsZStzY2FsZS0xLG95K2Rvb3Iu
eSpzY2FsZStzY2FsZS0xLGMpCiBlbmQKIHJiYXRjaF9zdWJtaXQoKQogCiAtLSBkcmF3IG9iamVj
dHMKIGZvciBvYiBpbiBhbGwob2JqZWN0cykgZG8KICBsb2NhbCBjPTcKICBpZiBvYi50eXAgYW5k
IG9iLnR5cC5raW5kPT0iaG9zdGlsZV9ucGMiIHRoZW4gYz04CiAgZWxzZWlmIG9iLnR5cCBhbmQg
b2IudHlwLmtpbmQ9PSJkaXJlY3RfcGlja3VwIiB0aGVuCiAgIGlmIG9iLnR5cC5zdWJ0eXBlPT0i
aGVhcnQiIHRoZW4gYz0xNAogICBlbHNlaWYgb2IudHlwLnN1YnR5cGU9PSJrZXkiIHRoZW4gYz05
CiAgIGVuZAogIGVsc2VpZiBvYi50eXAgYW5kIG9iLnR5cC5raW5kPT0iaW50ZXJhY3RhYmxlIiB0
aGVuCiAgIGlmIG9iLnR5cC5zdWJ0eXBlPT0iZXhpdCIgdGhlbiBjPTEyIGVuZAogIGVsc2VpZiBv
Yi50eXAgYW5kIG9iLnR5cC5raW5kPT0iZGVjb3JhdGl2ZSIgdGhlbiBjPTEzCiAgZW5kCiAgbG9j
YWwgeD1vYi5wb3NbMV0KICBsb2NhbCB5PW9iLnBvc1syXQogIGNpcmNmaWxsKG94K3gqc2NhbGUs
b3kreSpzY2FsZSwxLGMpCiBlbmQKIAogLS0gZHJhdyBwbGF5ZXIKIGxvY2FsIHB4LHB5PW94K3Bs
YXllci54KnNjYWxlLG95K3BsYXllci55KnNjYWxlCiBjaXJjZmlsbChweCxweSwyLDEwKQogbG9j
YWwgc2EsY2E9c2luKHBsYXllci5hKSxjb3MocGxheWVyLmEpCiBsaW5lKHB4LHB5LHB4K2NhKjYs
cHkrc2EqNiwxMCkKIAogLS0gc3RhdHMKIHByaW50KCIyZCBtYXAgdmlldyIsMTAsMiw3KQogcHJp
bnQoInJvb21zOiAiLi5nZW5fc3RhdHMucm9vbXMsMTAsMTAsNykKIHByaW50KCJvYmplY3RzOiAi
Li5nZW5fc3RhdHMub2JqZWN0cywxMCwxOCw3KQogcHJpbnQoInNlZWQ6ICIuLmdlbl9zdGF0cy5z
ZWVkLDEwLDI2LDcpCiBpZiBkZWJ1Z19tb2RlIHRoZW4KICBwcmludCgiW3hdIHRvZ2dsZSAzZCIs
MTAsMzQsNykKIGVuZAplbmQKCi0tIGRyYXcgaHVkIG1pbmltYXAgb3ZlcmxheQotLSBQdXJwb3Nl
OiBSZW5kZXIgc2Nyb2xsaW5nIHZpZXdwb3J0IG1pbmltYXAgaW4gdG9wLXJpZ2h0IGNvcm5lciBk
dXJpbmcgM0QgdmlldwotLSBBbGdvcml0aG06IFBsYXllci1jZW50ZXJlZCBjYW1lcmEgd2l0aCBj
bGlwcGVkIGRyYXdpbmcgb2YgdmlzaWJsZSB0aWxlcyBvbmx5Ci0tIERpc3BsYXlzOiBXYWxscywg
Zmxvb3JzLCBkb29ycywgb2JqZWN0cywgcGxheWVyIChhdXRvLXNjcm9sbHMgYXMgcGxheWVyIG1v
dmVzKQotLSBOb3RlczogRml4ZWQgMTIww5c2OHB4IHZpZXdwb3J0IGF0IHRvcC1yaWdodCwgc2Nh
bGU9Miwgb25seSBkcmF3cyB2aXNpYmxlIHRpbGUgcmFuZ2UKZnVuY3Rpb24gZHJhd19taW5pbWFw
X2h1ZCgpCiBsb2NhbCBodWRfdz1jZWlsKHNjcmVlbl93aWR0aCowLjI1KQogbG9jYWwgaHVkX2g9
Y2VpbChzY3JlZW5faGVpZ2h0KjAuMjUpCiBsb2NhbCBodWRfeD1zY3JlZW5fd2lkdGgtaHVkX3ct
OAogbG9jYWwgaHVkX3k9OAogbG9jYWwgc2NhbGU9MgogCiAtLSBjYW1lcmEgb2Zmc2V0IHRvIGNl
bnRlciBwbGF5ZXIgaW4gdmlld3BvcnQKIGxvY2FsIGNhbV94PXBsYXllci54KnNjYWxlLWh1ZF93
LzIKIGxvY2FsIGNhbV95PXBsYXllci55KnNjYWxlLWh1ZF9oLzIKIAogLS0gY2FsY3VsYXRlIHZp
c2libGUgdGlsZSByYW5nZQogbG9jYWwgeF9taW49bWF4KDAsZmxyKGNhbV94L3NjYWxlKSkKIGxv
Y2FsIHhfbWF4PW1pbigxMjcsZmxyKChjYW1feCtodWRfdykvc2NhbGUpKQogbG9jYWwgeV9taW49
bWF4KDAsZmxyKGNhbV95L3NjYWxlKSkKIGxvY2FsIHlfbWF4PW1pbigxMjcsZmxyKChjYW1feSto
dWRfaCkvc2NhbGUpKQogCiAtLSBzZXQgY2xpcCByZWdpb24KIGNsaXAoaHVkX3gsaHVkX3ksaHVk
X3csaHVkX2gpCiAKIC0tIGRyYXcgYmFja2dyb3VuZAogcmVjdGZpbGwoaHVkX3gsaHVkX3ksaHVk
X3graHVkX3ctMSxodWRfeStodWRfaC0xLDApCiAKIC0tIGJhdGNoIG1hcCB0aWxlcyAob25seSB2
aXNpYmxlIHJhbmdlKQogcmJhdGNoX3Jlc2V0KCkKIGZvciB4PXhfbWluLHhfbWF4IGRvCiAgZm9y
IHk9eV9taW4seV9tYXggZG8KICAgbG9jYWwgc3g9aHVkX3grKHgqc2NhbGUtY2FtX3gpCiAgIGxv
Y2FsIHN5PWh1ZF95Kyh5KnNjYWxlLWNhbV95KQogICAKICAgLS0gYWRkaXRpb25hbCBib3VuZHMg
Y2hlY2sKICAgaWYgc3g_PWh1ZF94IGFuZCBzeDxodWRfeCtodWRfdyBhbmQgc3k_PWh1ZF95IGFu
ZCBzeTxodWRfeStodWRfaCB0aGVuCiAgICBsb2NhbCB3YWxsPWdldF93YWxsKHgseSkKICAgIGxv
Y2FsIGZsb29yX3ZhbD1nZXRfZmxvb3IoeCx5KQogICAgbG9jYWwgY29sb3IKICAgIAogICAgaWYg
d2FsbD4wIHRoZW4KICAgICBjb2xvcj01CiAgICBlbHNlaWYgZmxvb3JfdmFsPjAgdGhlbgogICAg
IGNvbG9yPTYKICAgIGVsc2UKICAgICBjb2xvcj0xCiAgICBlbmQKICAgIAogICAgcmJhdGNoX3B1
c2goc3gsc3ksc3grc2NhbGUtMSxzeStzY2FsZS0xLGNvbG9yKQogICBlbmQKICBlbmQKIGVuZAog
cmJhdGNoX3N1Ym1pdCgpCiAKIC0tIGJhdGNoIGRvb3IgZHJhd2luZyB2aWEgc3BhdGlhbCBxdWVy
eSBvdmVyIHZpc2libGUgdGlsZXMKIHJiYXRjaF9yZXNldCgpCiBmb3IgeD14X21pbix4X21heCBk
bwogIGZvciB5PXlfbWluLHlfbWF4IGRvCiAgIGxvY2FsIGRvb3I9ZG9vcmdyaWRbeF0gYW5kIGRv
b3JncmlkW3hdW3ldIG9yIG5pbAogICBpZiBkb29yIHRoZW4KICAgIGxvY2FsIHN4PWh1ZF94Kyh4
KnNjYWxlLWNhbV94KQogICAgbG9jYWwgc3k9aHVkX3krKHkqc2NhbGUtY2FtX3kpCiAgICBpZiBz
eD49aHVkX3ggYW5kIHN4PGh1ZF94K2h1ZF93IGFuZCBzeT49aHVkX3kgYW5kIHN5PGh1ZF95K2h1
ZF9oIHRoZW4KICAgICBsb2NhbCBjPWRvb3IuZHR5cGU9PWRvb3JfbG9ja2VkIGFuZCA4IG9yIDEy
CiAgICAgcmJhdGNoX3B1c2goc3gsc3ksc3grc2NhbGUtMSxzeStzY2FsZS0xLGMpCiAgICBlbmQK
ICAgZW5kCiAgZW5kCiBlbmQKIHJiYXRjaF9zdWJtaXQoKQogCiAtLSBkcmF3IG9iamVjdHMgdmlh
IGZsYXQgYXJyYXkgaXRlcmF0aW9uIHdpdGhpbiB2aWV3cG9ydCBib3VuZHMKIGZvciBvYiBpbiBh
bGwob2JqZWN0cykgZG8KICBpZiBvYi5wb3MgdGhlbgogICBsb2NhbCBzeD1odWRfeCsob2IucG9z
WzFdKnNjYWxlLWNhbV94KQogICBsb2NhbCBzeT1odWRfeSsob2IucG9zWzJdKnNjYWxlLWNhbV95
KQogICBpZiBzeD49aHVkX3ggYW5kIHN4PGh1ZF94K2h1ZF93IGFuZCBzeT49aHVkX3kgYW5kIHN5
PGh1ZF95K2h1ZF9oIHRoZW4KICAgIGxvY2FsIGM9NwogICAgaWYgb2IudHlwIGFuZCBvYi50eXAu
a2luZD09Imhvc3RpbGVfbnBjIiB0aGVuIGM9OAogICAgZWxzZWlmIG9iLnR5cCBhbmQgb2IudHlw
LmtpbmQ9PSJkaXJlY3RfcGlja3VwIiB0aGVuCiAgICAgaWYgb2IudHlwLnN1YnR5cGU9PSJoZWFy
dCIgdGhlbiBjPTE0CiAgICAgZWxzZWlmIG9iLnR5cC5zdWJ0eXBlPT0ia2V5IiB0aGVuIGM9OQog
ICAgIGVuZAogICAgZWxzZWlmIG9iLnR5cCBhbmQgb2IudHlwLmtpbmQ9PSJpbnRlcmFjdGFibGUi
IHRoZW4KICAgICBpZiBvYi50eXAuc3VidHlwZT09ImV4aXQiIHRoZW4gYz0xMiBlbmQKICAgIGVs
c2VpZiBvYi50eXAgYW5kIG9iLnR5cC5raW5kPT0iZGVjb3JhdGl2ZSIgdGhlbiBjPTEzCiAgICBl
bmQKICAgIGNpcmNmaWxsKHN4LHN5LDEsYykKICAgZW5kCiAgZW5kCiBlbmQKIAogLS0gZHJhdyBw
bGF5ZXIgKGFsd2F5cyBjZW50ZXJlZCBieSBjYW1lcmEgZGVzaWduKQogbG9jYWwgcHg9aHVkX3gr
KHBsYXllci54KnNjYWxlLWNhbV94KQogbG9jYWwgcHk9aHVkX3krKHBsYXllci55KnNjYWxlLWNh
bV95KQogY2lyY2ZpbGwocHgscHksMiwxMCkKIGxpbmUocHgscHkscHgrY2FfY2FjaGVkKjYscHkr
c2FfY2FjaGVkKjYsMTApCiAKIC0tIG9wdGlvbmFsIGZyYW1lCiByZWN0KGh1ZF94LGh1ZF95LGh1
ZF94K2h1ZF93LTEsaHVkX3kraHVkX2gtMSw3KQogCiAtLSByZXNldCBjbGlwCiBjbGlwKCkKZW5k
CgotLSB1bmlmaWVkIGNvbGxpc2lvbiBjaGVjayBmb3Igd2FsbHMsIGRvb3JzLCBhbmQgb2JqZWN0
cwotLSBQdXJwb3NlOiBVbmlmaWVkIGNvbGxpc2lvbiBkZXRlY3Rpb24gZm9yIHdhbGxzLCBkb29y
cywgYW5kIG9iamVjdHMKLS0gUGFyYW1ldGVyczogcHgsIHB5ICh3b3JsZCBwb3NpdGlvbiksIHJh
ZGl1cyAoY29sbGlzaW9uIHJhZGl1cyksIG9wZW5kb29ycyAoYXV0by1vcGVuIGRvb3JzKSwgaXNw
bGF5ZXIgKGVuYWJsZSBrZXkgY2hlY2tpbmcpCi0tIFJldHVybnM6IGJvb2xlYW4gKHRydWUgaWYg
Y29sbGlzaW9uIGRldGVjdGVkKQotLSBBbGdvcml0aG06IEdyaWQtYmFzZWQgd2FsbCBjaGVjayAr
IHNwYXRpYWwgcGFydGl0aW9uaW5nIGZvciBvYmplY3RzCi0tIFNpZGUgZWZmZWN0czogT3BlbnMg
ZG9vcnMsIHByZXZlbnRzIGRvb3IgY2xvc2luZyB3aGVuIHBsYXllciBpbnNpZGUKZnVuY3Rpb24g
aXNjb2wocHgscHkscmFkaXVzLG9wZW5kb29ycyxpc3BsYXllcikKIGxvY2FsIGNvbD1mYWxzZQog
b3BlbmRvb3JzPW9wZW5kb29ycyBvciBmYWxzZQogaXNwbGF5ZXI9aXNwbGF5ZXIgb3IgZmFsc2UK
IAogLS0gY2hlY2sgZ3JpZCBjZWxscyBhcm91bmQgcG9zaXRpb24KIGZvciB4PWZscihweC1yYWRp
dXMpLGZscihweCtyYWRpdXMpIGRvCiAgZm9yIHk9ZmxyKHB5LXJhZGl1cyksZmxyKHB5K3JhZGl1
cykgZG8KICAgLS0gYm91bmRzIGNoZWNrCiAgIGlmIHg8MCBvciB4Pj0xMjggb3IgeTwwIG9yIHk_
PTEyOCB0aGVuCiAgICBjb2w9dHJ1ZQogICAgYnJlYWsKICAgZWxzZQogICAgbG9jYWwgdGlsZT1n
ZXRfd2FsbCh4LHkpCiAgICAKICAgIC0tIGNoZWNrIGlmIGRvb3IgdGlsZQogICAgaWYgdGlsZT09
ZG9vcl9ub3JtYWwgb3IgdGlsZT09ZG9vcl9sb2NrZWQgb3IgdGlsZT09ZG9vcl9zdGF5X29wZW4g
dGhlbgogICAgIGxvY2FsIGRvb3I9ZG9vcmdyaWRbeF1beV0KICAgICBpZiBkb29yIHRoZW4KICAg
ICAgaWYgZG9vci5vcGVuPT0xIHRoZW4KICAgICAgIC0tIGZ1bGx5IG9wZW46IHByZXZlbnQgY2xv
c2luZwogICAgICAgZG9vci5vcGVuaW5nPXRydWUKICAgICAgZWxzZQogICAgICAgLS0gZG9vciBw
YXJ0aWFsbHkgb3BlbiBvciBjbG9zZWQ6IGNvbGxpc2lvbiBkZXRlY3RlZAogICAgICAgY29sPXRy
dWUKICAgICAgIC0tIGhhbmRsZSB1bmxvY2tpbmcvb3BlbmluZyBiZWZvcmUgZXhpdGluZyBpbm5l
ciBsb29wCiAgICAgICBpZiBvcGVuZG9vcnMgdGhlbgogICAgICAgIGlmIGRvb3Iua2V5bnVtIHRo
ZW4KICAgICAgICAgLS0gY2hlY2sgaW52ZW50b3J5IGZvciBrZXkKICAgICAgICAgaWYgaXNwbGF5
ZXIgdGhlbgogICAgICAgICAgZm9yIGksaXRlbSBpbiBpcGFpcnMocGxheWVyLmtleXMpIGRvCiAg
ICAgICAgICAgaWYgaXRlbS5rZXludW09PWRvb3Iua2V5bnVtIHRoZW4KICAgICAgICAgICAgLS0g
cmVtb3ZlIGtleQogICAgICAgICAgICBkZWxpKHBsYXllci5rZXlzLGkpCiAgICAgICAgICAgIGRv
b3Iua2V5bnVtPW5pbAogICAgICAgICAgICBkb29yLm9wZW5pbmc9dHJ1ZQogICAgICAgICAgICAt
LSBrZWVwIGNvbD10cnVlLCBkb24ndCBjbGVhciBpbW1lZGlhdGVseQogICAgICAgICAgICBicmVh
awogICAgICAgICAgIGVuZAogICAgICAgICAgZW5kCiAgICAgICAgIGVuZAogICAgICAgIGVsc2UK
ICAgICAgICAgLS0gdW5sb2NrZWQKICAgICAgICAgZG9vci5vcGVuaW5nPXRydWUKICAgICAgICAg
LS0ga2VlcCBjb2w9dHJ1ZSwgZG9uJ3QgY2xlYXIgaW1tZWRpYXRlbHkKICAgICAgICBlbmQKICAg
ICAgIGVuZAogICAgICAgLS0gZWFybHkgZXhpdCBmcm9tIGlubmVyIGxvb3Agb24gY29sbGlzaW9u
IChhZnRlciBvcGVuZG9vcnMgaGFuZGxpbmcpCiAgICAgICBicmVhawogICAgICBlbmQKICAgICBl
bmQKICAgIC0tIGNoZWNrIGlmIGV4aXQgcG9ydGFsCiAgICBlbHNlaWYgKHRpbGU9PWV4aXRfc3Rh
cnQgb3IgdGlsZT09ZXhpdF9lbmQpIGFuZCBpc3BsYXllciB0aGVuCiAgICAgLS0gcGxhY2Vob2xk
ZXIgZm9yIGxldmVsIGNvbXBsZXRpb24KICAgIC0tIGNoZWNrIGlmIHdhbGwKICAgIGVsc2VpZiB0
aWxlPjAgdGhlbgogICAgIGNvbD10cnVlCiAgICAgYnJlYWsKICAgIGVuZAogICBlbmQKICBlbmQK
ICBpZiBjb2wgdGhlbiBicmVhayBlbmQKIGVuZAogCiAtLSBjaGVjayBzb2xpZCBvYmplY3RzIGFy
b3VuZCBwb3NpdGlvbiB2aWEgZmxhdCBhcnJheSB3aXRoIGVhcmx5IGRpc3RhbmNlIGN1bGwKIGZv
ciBvYiBpbiBhbGwob2JqZWN0cykgZG8KICBpZiBvYi50eXAgYW5kIG9iLnR5cC5zb2xpZCBhbmQg
b2IucG9zIHRoZW4KICAgbG9jYWwgb3g9b2IucG9zWzFdLXB4CiAgIGxvY2FsIG95PW9iLnBvc1sy
XS1weQogICAtLSBlYXJseSBheGlzLWFsaWduZWQgY3VsbAogICBpZiBhYnMob3gpPChyYWRpdXMr
KG9iLnR5cC53IG9yIDApKSBhbmQgYWJzKG95KTwocmFkaXVzKyhvYi50eXAudyBvciAwKSkgdGhl
bgogICAgaWYgbWF4KGFicyhveCksYWJzKG95KSk8KG9iLnR5cC53IG9yIDApIHRoZW4KICAgICBj
b2w9dHJ1ZQogICAgIC0tIHRyaWdnZXIgaW50ZXJhY3Rpb24gb24gc29saWQgY29udGFjdCBpZiBw
bGF5ZXIKICAgICBpZiBpc3BsYXllciB0aGVuCiAgICAgIGNoZWNrX2ludGVyYWN0aW9uc19hdChw
eCxweSkKICAgICBlbmQKICAgICBicmVhawogICAgZW5kCiAgIGVuZAogIGVuZAogZW5kCiAKIHJl
dHVybiBjb2wKZW5kCgotLSBtb3ZlbWVudCB3cmFwcGVyIHdpdGggc2xpZGluZyBjb2xsaXNpb24K
LS0gUHVycG9zZTogTW92ZW1lbnQgd2l0aCBzbGlkaW5nIGNvbGxpc2lvbiAodHJ5IGRpYWdvbmFs
LCB0aGVuIFgsIHRoZW4gWSkKLS0gUGFyYW1ldGVyczogcG9zICh0YWJsZSB3aXRoIHgseSksIHRh
cmdldF94LCB0YXJnZXRfeSwgcmFkaXVzLCBvcGVuZG9vcnMsIGlzcGxheWVyCi0tIFJldHVybnM6
IGJvb2xlYW4gKHRydWUgaWYgYW55IG1vdmVtZW50IHN1Y2NlZWRlZCkKLS0gQWxnb3JpdGhtOiBU
aHJlZS1waGFzZSBjb2xsaXNpb24gY2hlY2sgZm9yIHNtb290aCB3YWxsIHNsaWRpbmcKZnVuY3Rp
b24gdHJ5bW92ZXRvKHBvcyx0YXJnZXRfeCx0YXJnZXRfeSxyYWRpdXMsb3BlbmRvb3JzLGlzcGxh
eWVyKQogcmFkaXVzPXJhZGl1cyBvciBwbGF5ZXJfY29sbGlzaW9uX3JhZGl1cwogb3BlbmRvb3Jz
PW9wZW5kb29ycyBvciBmYWxzZQogaXNwbGF5ZXI9aXNwbGF5ZXIgb3IgZmFsc2UKIAogLS0gdHJ5
IGRpcmVjdCBtb3ZlbWVudAogaWYgbm90IHJhZGl1cyBvciBub3QgaXNjb2wodGFyZ2V0X3gsdGFy
Z2V0X3kscmFkaXVzLG9wZW5kb29ycyxpc3BsYXllcikgdGhlbgogIHBvcy54LHBvcy55PXRhcmdl
dF94LHRhcmdldF95CiAgcmV0dXJuIHRydWUKIGVuZAogCiAtLSB0cnkgeC1vbmx5IG1vdmVtZW50
CiBpZiBhYnMocG9zLngtdGFyZ2V0X3gpPjAuMDEgYW5kIG5vdCBpc2NvbCh0YXJnZXRfeCxwb3Mu
eSxyYWRpdXMsb3BlbmRvb3JzLGlzcGxheWVyKSB0aGVuCiAgcG9zLng9dGFyZ2V0X3gKICByZXR1
cm4gdHJ1ZQogZW5kCiAKIC0tIHRyeSB5LW9ubHkgbW92ZW1lbnQKIGlmIGFicyhwb3MueS10YXJn
ZXRfeSk_MC4wMSBhbmQgbm90IGlzY29sKHBvcy54LHRhcmdldF95LHJhZGl1cyxvcGVuZG9vcnMs
aXNwbGF5ZXIpIHRoZW4KICBwb3MueT10YXJnZXRfeQogIHJldHVybiB0cnVlCiBlbmQKIAogcmV0
dXJuIGZhbHNlCmVuZAoKLS0gbW92ZW1lbnQgd3JhcHBlciBmb3IgcG9zWzFdL3Bvc1syXSBhcnJh
eSBwb3NpdGlvbnMKZnVuY3Rpb24gdHJ5bW92ZXRvX3Bvcyhwb3NfYXJyYXksdGFyZ2V0X3gsdGFy
Z2V0X3kscmFkaXVzLG9wZW5kb29ycyxpc3BsYXllcikKIHJhZGl1cz1yYWRpdXMgb3IgcGxheWVy
X2NvbGxpc2lvbl9yYWRpdXMKIG9wZW5kb29ycz1vcGVuZG9vcnMgb3IgZmFsc2UKIGlzcGxheWVy
PWlzcGxheWVyIG9yIGZhbHNlCiAKIC0tIHRyeSBkaXJlY3QgbW92ZW1lbnQKIGlmIG5vdCByYWRp
dXMgb3Igbm90IGlzY29sKHRhcmdldF94LHRhcmdldF95LHJhZGl1cyxvcGVuZG9vcnMsaXNwbGF5
ZXIpIHRoZW4KICBwb3NfYXJyYXlbMV0scG9zX2FycmF5WzJdPXRhcmdldF94LHRhcmdldF95CiAg
cmV0dXJuIHRydWUKIGVuZAogCiAtLSB0cnkgeC1vbmx5IG1vdmVtZW50CiBpZiBhYnMocG9zX2Fy
cmF5WzFdLXRhcmdldF94KT4wLjAxIGFuZCBub3QgaXNjb2wodGFyZ2V0X3gscG9zX2FycmF5WzJd
LHJhZGl1cyxvcGVuZG9vcnMsaXNwbGF5ZXIpIHRoZW4KICBwb3NfYXJyYXlbMV09dGFyZ2V0X3gK
ICByZXR1cm4gdHJ1ZQogZW5kCiAKIC0tIHRyeSB5LW9ubHkgbW92ZW1lbnQKIGlmIGFicyhwb3Nf
YXJyYXlbMl0tdGFyZ2V0X3kpPjAuMDEgYW5kIG5vdCBpc2NvbChwb3NfYXJyYXlbMV0sdGFyZ2V0
X3kscmFkaXVzLG9wZW5kb29ycyxpc3BsYXllcikgdGhlbgogIHBvc19hcnJheVsyXT10YXJnZXRf
eQogIHJldHVybiB0cnVlCiBlbmQKIAogcmV0dXJuIGZhbHNlCmVuZAoKZnVuY3Rpb24gdXBkYXRl
X2lucHV0KCkKIGxvY2FsIHNhLGNhPXNpbihwbGF5ZXIuYSksY29zKHBsYXllci5hKQogCiAtLSBt
b3ZlbWVudAogLS0gY29tYmluZSBrZXlzIHRvIGF2b2lkIGRvdWJsZS1wcm9jZXNzaW5nIGFuZCBm
aXggZGlyZWN0aW9uOgogLS0gcG9zaXRpdmUgdHVybiA9IGxlZnQsIG5lZ2F0aXZlIHR1cm4gPSBy
aWdodAogbG9jYWwgdHVybj0oYnRuKDApIGFuZCAxIG9yIDApLShidG4oMSkgYW5kIDEgb3IgMCkK
IGlmIHR1cm5_PTAgdGhlbgogIHBsYXllci5hKz10dXJuKnBsYXllcl9yb3RhdGlvbl9zcGVlZAog
ZW5kCiBpZiBidG4oMikgdGhlbiAtLSB1cAogIGxvY2FsIG54PXBsYXllci54K2NhKnBsYXllci5z
cGQKICBsb2NhbCBueT1wbGF5ZXIueStzYSpwbGF5ZXIuc3BkCiAgdHJ5bW92ZXRvKHBsYXllcixu
eCxueSxwbGF5ZXJfY29sbGlzaW9uX3JhZGl1cyx0cnVlLHRydWUpCiBlbmQKIGlmIGJ0bigzKSB0
aGVuIC0tIGRvd24KICBsb2NhbCBueD1wbGF5ZXIueC1jYSpwbGF5ZXIuc3BkCiAgbG9jYWwgbnk9
cGxheWVyLnktc2EqcGxheWVyLnNwZAogIHRyeW1vdmV0byhwbGF5ZXIsbngsbnkscGxheWVyX2Nv
bGxpc2lvbl9yYWRpdXMsdHJ1ZSx0cnVlKQogZW5kCiAKIC0tIGNoZWNrIGZvciBpbnRlcmFjdGlv
bnMgZXZlcnkgZnJhbWUKIGNoZWNrX2ludGVyYWN0aW9ucygpCiAKIC0tIGludGVyYWN0aW9uIGlu
cHV0OiBFIGtleSBvciBaIGJ1dHRvbgogaWYga2V5cCgiZSIpIG9yIGJ0bnAoNCkgdGhlbgogIGhh
bmRsZV9pbnRlcmFjdCgpCiBlbmQKZW5kCgogCgotLSBjaGVjayBpbnRlcmFjdGlvbnMgYXJvdW5k
IHBsYXllciBwb3NpdGlvbgotLSBQdXJwb3NlOiBTY2FuIG5lYXJieSBvYmplY3RzIGZvciBwcm94
aW1pdHktYmFzZWQgaW50ZXJhY3Rpb25zCi0tIEFsZ29yaXRobTogM8OXMyBvYmpncmlkIGNlbGwg
c2NhbiBhcm91bmQgcGxheWVyCi0tIFNpZGUgZWZmZWN0czogQXV0by1jb2xsZWN0cyBwaWNrdXBz
LCB0cmlnZ2VycyBjb21iYXQsIHNldHMgaW50ZXJhY3Rpb24gZmxhZ3MKLS0gTm90ZXM6IENhbGxl
ZCBldmVyeSBmcmFtZSBpbiBfdXBkYXRlKCkKZnVuY3Rpb24gY2hlY2tfaW50ZXJhY3Rpb25zKCkK
IGNoZWNrX2ludGVyYWN0aW9uc19hdChwbGF5ZXIueCxwbGF5ZXIueSkKZW5kCgotLSBjaGVjayBp
bnRlcmFjdGlvbnMgYXQgc3BlY2lmaWMgcG9zaXRpb24gKGF2b2lkcyByZWN1cnNpb24pCmZ1bmN0
aW9uIGNoZWNrX2ludGVyYWN0aW9uc19hdChweCxweSkKIC0tIHNjYW4gYWxsIG9iamVjdHMgd2l0
aCBkaXN0YW5jZSBjdWxsaW5nCiBsb2NhbCBjbG9zZXN0X2ludGVyYWN0PW5pbAogbG9jYWwgY2xv
c2VzdF9kaXN0PTk5OQogCiBmb3Igb2IgaW4gYWxsKG9iamVjdHMpIGRvCiAgaWYgb2IucG9zIGFu
ZCBvYi50eXAgdGhlbgogICBsb2NhbCBkeD1vYi5wb3NbMV0tcHgKICAgbG9jYWwgZHk9b2IucG9z
WzJdLXB5CiAgIGxvY2FsIGRpc3Q9YWJzKGR4KSthYnMoZHkpCiAgIAogICAtLSBkaXJlY3QgcGlj
a3VwOiBhdXRvLWNvbGxlY3QKICAgaWYgb2IudHlwLmtpbmQ9PSJkaXJlY3RfcGlja3VwIiBhbmQg
ZGlzdDxpbnRlcmFjdGlvbl9yYW5nZSB0aGVuCiAgICBjb2xsZWN0X2l0ZW0ob2IpCiAgICBkZWwo
b2JqZWN0cyxvYikKICAgIGlmIG9iLmF1dG9hbmltIHRoZW4gZGVsKGFuaW1hdGVkX29iamVjdHMs
b2IpIGVuZAogICAKICAgLS0gaG9zdGlsZSBucGM6IHRyaWdnZXIgY29tYmF0CiAgIGVsc2VpZiBv
Yi50eXAua2luZD09Imhvc3RpbGVfbnBjIiBhbmQgZGlzdDxjb21iYXRfdHJpZ2dlcl9yYW5nZSB0
aGVuCiAgICBpbl9jb21iYXQ9dHJ1ZQogICAgY3VycmVudF90YXJnZXQ9b2IKICAgCiAgIC0tIGlu
dGVyYWN0YWJsZTogc2V0IGZsYWcgZm9yIGNsb3Nlc3QKICAgZWxzZWlmIG9iLnR5cC5raW5kPT0i
aW50ZXJhY3RhYmxlIiBhbmQgZGlzdDxpbnRlcmFjdGlvbl9yYW5nZSB0aGVuCiAgICAtLSB0cmFw
OiBpbW1lZGlhdGUgZWZmZWN0CiAgICBpZiBvYi50eXAuc3VidHlwZT09InRyYXAiIHRoZW4KICAg
ICBwbGF5ZXIuaHA9bWF4KDAscGxheWVyLmhwLTEwKQogICAgIHRyYXBfbXNnX3RpbWVyPTYwCiAg
ICAgZGVsKG9iamVjdHMsb2IpCiAgICAgaWYgb2IuYXV0b2FuaW0gdGhlbiBkZWwoYW5pbWF0ZWRf
b2JqZWN0cyxvYikgZW5kCiAgICBlbHNlaWYgZGlzdDxjbG9zZXN0X2Rpc3QgdGhlbgogICAgIGNs
b3Nlc3RfaW50ZXJhY3Q9b2IKICAgICBjbG9zZXN0X2Rpc3Q9ZGlzdAogICAgZW5kCiAgIGVuZAog
IGVuZAogZW5kCiAKIC0tIHVwZGF0ZSBpbnRlcmFjdGlvbiBzdGF0ZQogaWYgY2xvc2VzdF9pbnRl
cmFjdCB0aGVuCiAgaW50ZXJhY3Rpb25fYWN0aXZlPXRydWUKICBjdXJyZW50X2ludGVyYWN0PWNs
b3Nlc3RfaW50ZXJhY3QKIGVsc2UKICBpbnRlcmFjdGlvbl9hY3RpdmU9ZmFsc2UKICBjdXJyZW50
X2ludGVyYWN0PW5pbAogZW5kCmVuZAoKLS0gY29sbGVjdCBpdGVtIChwaWNrdXApCi0tIFB1cnBv
c2U6IEhhbmRsZSBwaWNrdXAgY29sbGVjdGlvbiBhbmQgaW52ZW50b3J5IHVwZGF0ZXMKLS0gUGFy
YW1ldGVyczogb2IgKG9iamVjdCB3aXRoIHR5cC5zdWJ0eXBlKQotLSBTaWRlIGVmZmVjdHM6IEFk
ZHMgdG8gcGxheWVyLmtleXMsIGluY3JlYXNlcyBwbGF5ZXIuaHAKLS0gTm90ZXM6IENhbGxlZCBi
eSBjaGVja19pbnRlcmFjdGlvbnNfYXQoKSBmb3IgZGlyZWN0X3BpY2t1cCBvYmplY3RzCmZ1bmN0
aW9uIGNvbGxlY3RfaXRlbShvYikKIGlmIG9iLnR5cC5zdWJ0eXBlPT0ia2V5IiBhbmQgb2Iua2V5
bnVtIHRoZW4KICBhZGQocGxheWVyLmtleXMse2tleW51bT1vYi5rZXludW19KQogIHByaW50aCgi
Y29sbGVjdGVkIGtleSAiLi5vYi5rZXludW0pCiBlbHNlaWYgb2IudHlwLnN1YnR5cGU9PSJoZWFy
dCIgdGhlbgogIHBsYXllci5ocD1taW4oMTAwLHBsYXllci5ocCsyMCkKICBwcmludGgoImNvbGxl
Y3RlZCBoZWFydCIpCiBlbHNlCiAgcHJpbnRoKCJjb2xsZWN0ZWQgaXRlbSIpCiBlbmQKZW5kCgot
LSBoYW5kbGUgaW50ZXJhY3Rpb24gd2hlbiBwbGF5ZXIgcHJlc3NlcyBFL1oKLS0gUHVycG9zZTog
UHJvY2VzcyBwbGF5ZXItaW5pdGlhdGVkIGludGVyYWN0aW9ucyAoRSBrZXkgLyBaIGJ1dHRvbikK
LS0gQWxnb3JpdGhtOiBTd2l0Y2ggb24gY3VycmVudF9pbnRlcmFjdC50eXAuc3VidHlwZQotLSBT
aWRlIGVmZmVjdHM6IE9wZW5zIGNoZXN0cywgYWN0aXZhdGVzIHNocmluZXMsIHJlYWRzIG5vdGVz
LCB0cmlnZ2VycyBmbG9vciB0cmFuc2l0aW9uCi0tIE5vdGVzOiBPbmx5IHJ1bnMgd2hlbiBpbnRl
cmFjdGlvbl9hY3RpdmUgZmxhZyBpcyB0cnVlCmZ1bmN0aW9uIGhhbmRsZV9pbnRlcmFjdCgpCiBp
ZiBub3QgaW50ZXJhY3Rpb25fYWN0aXZlIG9yIG5vdCBjdXJyZW50X2ludGVyYWN0IHRoZW4gcmV0
dXJuIGVuZAogCiBsb2NhbCBzdWJ0eXBlPWN1cnJlbnRfaW50ZXJhY3QudHlwIGFuZCBjdXJyZW50
X2ludGVyYWN0LnR5cC5zdWJ0eXBlIG9yICJ1bmtub3duIgogCiBpZiBzdWJ0eXBlPT0iY2hlc3Qi
IHRoZW4KICAtLSBvcGVuIGNoZXN0IChwbGFjZWhvbGRlcikKICBwbGF5ZXIuaHA9bWluKDEwMCxw
bGF5ZXIuaHArMTApCiAgcHJpbnRoKCJvcGVuZWQgY2hlc3QiKQogIGRlbChvYmplY3RzLGN1cnJl
bnRfaW50ZXJhY3QpCiAgaWYgY3VycmVudF9pbnRlcmFjdC5hdXRvYW5pbSB0aGVuIGRlbChhbmlt
YXRlZF9vYmplY3RzLGN1cnJlbnRfaW50ZXJhY3QpIGVuZAogIAogZWxzZWlmIHN1YnR5cGU9PSJz
aHJpbmUiIHRoZW4KICAtLSBhY3RpdmF0ZSBzaHJpbmUgKHBsYWNlaG9sZGVyKQogIHBsYXllci5o
cD0xMDAKICBwcmludGgoImFjdGl2YXRlZCBzaHJpbmUiKQogIAogZWxzZWlmIHN1YnR5cGU9PSJu
b3RlIiB0aGVuCiAgLS0gcmVhZCBub3RlIChwbGFjZWhvbGRlcikKICBwcmludGgoInJlYWQgbm90
ZSIpCiAgZGVsKG9iamVjdHMsY3VycmVudF9pbnRlcmFjdCkKICBpZiBjdXJyZW50X2ludGVyYWN0
LmF1dG9hbmltIHRoZW4gZGVsKGFuaW1hdGVkX29iamVjdHMsY3VycmVudF9pbnRlcmFjdCkgZW5k
CiAgCiBlbHNlaWYgc3VidHlwZT09ImV4aXQiIHRoZW4KICAtLSB0cmlnZ2VyIG5leHQgZmxvb3IK
ICBwcmludGgoInVzaW5nIGV4aXQgcG9ydGFsIikKICBnZW5lcmF0ZV9uZXdfZmxvb3IoKQogIAog
ZW5kCiAKIC0tIGNsZWFyIGludGVyYWN0aW9uIHN0YXRlIGFmdGVyIGhhbmRsaW5nCiBpbnRlcmFj
dGlvbl9hY3RpdmU9ZmFsc2UKIGN1cnJlbnRfaW50ZXJhY3Q9bmlsCmVuZAoKLS0gZ2VuZXJhdGUg
bmV3IGZsb29yIChyZWdlbmVyYXRlIGR1bmdlb24pCmZ1bmN0aW9uIGdlbmVyYXRlX25ld19mbG9v
cigpCiAtLSBpbmNyZW1lbnQgZGlmZmljdWx0eQogZ2VuX3BhcmFtcy5kaWZmaWN1bHR5PW1pbihn
ZW5fcGFyYW1zLm1heF9kaWZmaWN1bHR5LGdlbl9wYXJhbXMuZGlmZmljdWx0eSsxKQogCiAtLSBj
bGVhciBleGlzdGluZyBvYmplY3RzCiBvYmplY3RzPXt9CiBhbmltYXRlZF9vYmplY3RzPXt9CiBk
b29ycz17fQogLS0gYWxzbyBjbGVhciBkb29yZ3JpZCB0byBwcmV2ZW50IHN0YWxlIHJlZmVyZW5j
ZXMKIGZvciBpPTAsMTI3IGRvCiAgaWYgZG9vcmdyaWRbaV0gdGhlbgogICBmb3Igaj0wLDEyNyBk
bwogICAgZG9vcmdyaWRbaV1bal09bmlsCiAgIGVuZAogIGVuZAogZW5kCiAKIC0tIHJlZ2VuZXJh
dGUgZHVuZ2Vvbgogc3RhcnRfcG9zLGdlbl9zdGF0cz1nZW5lcmF0ZV9kdW5nZW9uKCkKLS0gVHJp
Z2dlciBHQyBhZnRlciBkdW5nZW9uIGdlbmVyYXRpb24gKFBpY290cm9uIGd1aWRlbGluZTogYXZv
aWQgbWlkLWdhbWVwbGF5IHN0dXR0ZXIpCnN0YXQoMCkKIC0tIGludmFsaWRhdGUgcGVyc2lzdGVu
dCByZW5kZXIgY2FjaGVzIGZvciBuZXcgZmxvb3IKLS0gUHJvZHVjdGlvbjogY2xlYXIgY2FjaGUg
b24gbGV2ZWwgbG9hZCB0byBwcmV2ZW50IHN0YWxlIHRleHR1cmUgcmVmZXJlbmNlcwppZiBjbGVh
cl90ZXh0dXJlX2NhY2hlcyB0aGVuIGNsZWFyX3RleHR1cmVfY2FjaGVzKCkgZW5kCiAKIHByaW50
aCgiZmxvb3IgY29tcGxldGUhIGRpZmZpY3VsdHk6ICIuLmdlbl9wYXJhbXMuZGlmZmljdWx0eSkK
IAogLS0gbGV2ZWwgbG9hZCBkaWFnbm9zdGljIHN1bW1hcnkKIHByaW50aCgiPT09IExFVkVMIExP
QUQgRElBR05PU1RJQ1MgPT09IikKIHByaW50aCgiRmxvb3I6ICIuLihjdXJyZW50X2Zsb29yIG9y
ICJ1bmtub3duIikpCiBwcmludGgoIkRpZmZpY3VsdHk6ICIuLmdlbl9wYXJhbXMuZGlmZmljdWx0
eSkKIHByaW50aCgiUm9vbXM6ICIuLmdlbl9zdGF0cy5yb29tcykKIHByaW50aCgiT2JqZWN0czog
Ii4uZ2VuX3N0YXRzLm9iamVjdHMpCiBwcmludGgoIlNlZWQ6ICIuLmdlbl9zdGF0cy5zZWVkKQpl
bmQKCi0tIHVwZGF0ZSBjb21iYXQgKHBsYWNlaG9sZGVyKQpmdW5jdGlvbiB1cGRhdGVfY29tYmF0
KCkKIC0tIHRlbXAgZXhpdDogcHJlc3MgUSBvciBFbnRlcgogaWYga2V5cCgicSIpIG9yIGtleXAo
ImVudGVyIikgdGhlbgogIGluX2NvbWJhdD1mYWxzZQogIGN1cnJlbnRfdGFyZ2V0PW5pbAogIHBy
aW50aCgiZXhpdGVkIGNvbWJhdCIpCiBlbmQKZW5kCgotLSB1cGRhdGUgbnBjIGFpIChiYXNpYyBw
YXRyb2wgYW5kIGZvbGxvdykKZnVuY3Rpb24gdXBkYXRlX25wY19haSgpCiBmb3Igb2IgaW4gYWxs
KG9iamVjdHMpIGRvCiAgaWYgb2IudHlwIGFuZCBvYi50eXAua2luZD09Imhvc3RpbGVfbnBjIiBh
bmQgb2IuYWlfdHlwZSB0aGVuCiAgIGxvY2FsIG9sZF94LG9sZF95PW9iLnBvc1sxXSxvYi5wb3Nb
Ml0KICAgCiAgIGlmIG9iLmFpX3R5cGU9PSJwYXRyb2wiIHRoZW4KICAgIC0tIHBhdHJvbDogY3lj
bGUgdGhyb3VnaCBwYXRyb2xfcG9pbnRzCiAgICBpZiBvYi5wYXRyb2xfcG9pbnRzIGFuZCAjb2Iu
cGF0cm9sX3BvaW50cz4wIHRoZW4KICAgICAtLSBpbml0aWFsaXplIHBhdHJvbF9pbmRleCBpZiBu
aWwgb3IgMAogICAgIGlmIG5vdCBvYi5wYXRyb2xfaW5kZXggb3Igb2IucGF0cm9sX2luZGV4PT0w
IHRoZW4KICAgICAgb2IucGF0cm9sX2luZGV4PTEKICAgICBlbmQKICAgICAKICAgICBsb2NhbCB0
YXJnZXQ9b2IucGF0cm9sX3BvaW50c1tvYi5wYXRyb2xfaW5kZXhdCiAgICAgaWYgdGFyZ2V0IHRo
ZW4KICAgICAgbG9jYWwgZHg9dGFyZ2V0Lngtb2IucG9zWzFdCiAgICAgIGxvY2FsIGR5PXRhcmdl
dC55LW9iLnBvc1syXQogICAgICBsb2NhbCBkaXN0PXNxcnQoZHgqZHgrZHkqZHkpCiAgICAgIAog
ICAgICAtLSByZWFjaGVkIHdheXBvaW50OiBhZHZhbmNlIHRvIG5leHQKICAgICAgaWYgZGlzdDww
LjEgdGhlbgogICAgICAgb2IucGF0cm9sX2luZGV4PShvYi5wYXRyb2xfaW5kZXglI29iLnBhdHJv
bF9wb2ludHMpKzEKICAgICAgZWxzZQogICAgICAgLS0gbW92ZSB0b3dhcmQgY3VycmVudCB3YXlw
b2ludAogICAgICAgaWYgZGlzdD4wIHRoZW4KICAgICAgICBsb2NhbCBzcGQ9b2IudHlwLnBhdHJv
bF9zcGVlZCBvciAwLjAzCiAgICAgICAgbG9jYWwgbng9b2IucG9zWzFdK2R4L2Rpc3Qqc3BkCiAg
ICAgICAgbG9jYWwgbnk9b2IucG9zWzJdK2R5L2Rpc3Qqc3BkCiAgICAgICAgdHJ5bW92ZXRvX3Bv
cyhvYi5wb3Msbngsbnksb2IudHlwLncgb3IgMC40LGZhbHNlLGZhbHNlKQogICAgICAgZW5kCiAg
ICAgIGVuZAogICAgIGVuZAogICAgZW5kCiAgICAKICAgZWxzZWlmIG9iLmFpX3R5cGU9PSJmb2xs
b3ciIHRoZW4KICAgIC0tIGZvbGxvdzogbW92ZSB0b3dhcmQgcGxheWVyIGlmIGluIHJhbmdlCiAg
ICBsb2NhbCBkeD1wbGF5ZXIueC1vYi5wb3NbMV0KICAgIGxvY2FsIGR5PXBsYXllci55LW9iLnBv
c1syXQogICAgbG9jYWwgZGlzdD1zcXJ0KGR4KmR4K2R5KmR5KQogICAgbG9jYWwgZm9sbG93X3Jh
bmdlPW9iLnR5cC5mb2xsb3dfcmFuZ2Ugb3IgMjAKICAgIGlmIGRpc3Q8Zm9sbG93X3JhbmdlIGFu
ZCBkaXN0PjAuMSB0aGVuCiAgICAgbG9jYWwgc3BkPW9iLnR5cC5mb2xsb3dfc3BlZWQgb3IgMC4w
NQogICAgIGxvY2FsIG54PW9iLnBvc1sxXStkeC9kaXN0KnNwZAogICAgIGxvY2FsIG55PW9iLnBv
c1syXStkeS9kaXN0KnNwZAogICAgIHRyeW1vdmV0b19wb3Mob2IucG9zLG54LG55LG9iLnR5cC53
IG9yIDAuNCxmYWxzZSxmYWxzZSkKICAgIGVuZAogICBlbmQKICBlbmQKIGVuZAplbmQ=
:: src/.info.pod
--[[pod,created="2025-11-07 22:14:13",modified="2025-11-12 09:54:32"]]
:: tests/.info.pod
--[[pod,created="2025-11-12 09:54:32",modified="2025-11-12 09:54:32"]]
:: [eoc]
