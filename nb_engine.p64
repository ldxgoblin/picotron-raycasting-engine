picotron cartridge // www.picotron.net
version 2

:: src/
:: src/config.lua
--[[pod_format="raw",created="2025-11-07 21:17:14",modified="2025-11-07 21:48:05",revision=1]]
-- engine configuration

-- screen constants
screen_width=480
screen_height=270
screen_center_x=screen_width/2
screen_center_y=screen_height/2
-- default ray budget: tuned for 480px wide viewport; adaptive governor in main.lua can lower this
ray_count=128
-- CRITICAL: screen_center_x must equal screen_width/2, screen_center_y must equal screen_height/2
-- ray_count is decoupled from screen_width and can be configured independently for performance tuning
sdist=200 -- default; computed dynamically in raycast_scene() based on fov
map_size=128
objgrid_size=5
objgrid_array_size=26
fov=0.5

-- sprite configuration
sprite_size=32

-- fog configuration (unified linear fog system)
fog_near=5.0 -- near fog distance where fog begins
fog_far=20.0 -- far fog distance where fog is maximum
fog_hysteresis=0.5 -- minimum z change required to update fog level (reduces palette thrashing)
screenbright=1.0 -- screen brightness multiplier (1.0=normal, <1.0=darker for atmosphere)

-- lod configuration (ratios of fog_far)
wall_lod_ratio=0.4 -- ratio of fog_far for wall LOD transition
sprite_lod_ratio=0.5 -- ratio of fog_far for sprite LOD transition
wall_lod_distance=fog_far*wall_lod_ratio -- computed: walls beyond this z use simplified rendering
wall_tiny_screen_px=6 -- walls shorter than this many pixels use LOD solid fill

-- rendering configuration
row_stride=1 -- floor/ceiling stride; keep at 1 for correct perspective (governor can relax if needed)
per_cell_floors_enabled=false -- enable per-cell floor type detection (false=render entire scanline with single texture)
-- tline quality flag (0x400) is expensive; keep off unless visual artifacts demand it
tline_high_quality_near=false

-- raycast configuration
far_plane=25.0 -- maximum raycast distance; must be >= fog_far + 2.0 to prevent geometry popping

-- ai and interaction constants
ai_update_rate=2 -- frames between AI updates
interaction_range=0.5 -- proximity for triggers
combat_trigger_range=0.3 -- distance to trigger combat

-- player movement constants
player_rotation_speed=0.008 -- radians per frame when turning (slower, smoother)
player_move_speed=0.04 -- units per frame when moving (reduced)

-- door animation constants
door_anim_speed=0.06 -- door open/close speed per frame
door_close_delay=90 -- frames before door auto-closes

-- floor/ceiling types (tex indexes from gfx/1_surfaces.gfx, offset 32)
planetyps={
 -- stone_tile
 {tex=32,scale=1,height=0.5,lit=true,xvel=0,yvel=0},
 -- dirt
 {tex=33,scale=1,height=0.5,lit=true,xvel=0,yvel=0},
 -- stone_ceiling
 {tex=34,scale=1,height=0.5,lit=false,xvel=0,yvel=0},
 -- sky
 {tex=35,scale=2,height=1,lit=false,xvel=0.01,yvel=0},
 -- night_sky
 {tex=36,scale=2,height=1,lit=false,xvel=0.005,yvel=0}
}

-- wall texture sets (sprite indexes from gfx/0_walls.gfx)
texsets={
 -- none (removed to avoid collision with brick variant 0)
 -- brick
 {base=0,variants={0,1,2,3}},
 -- cobblestone
 {base=4,variants={4,5,6,7}},
 -- wood_plank
 {base=8,variants={8,9,10,11}},
 -- stone
 {base=12,variants={12,13,14,15}},
 -- grass (outdoor)
 {base=16,variants={16,17,18,19}},
 -- earth (outdoor)
 {base=20,variants={20,21,22,23}}
}

-- door types (sprite indexes from gfx/0_walls.gfx)
door_normal=24
door_locked=25
door_stay_open=26

-- helper: check if tile is a door
function is_door(val)
 return val>=door_normal and val<=door_stay_open
end

-- exit types (tile IDs)
exit_start=67
exit_end=68

-- wall fill constant
wall_fill_tile=1

-- generation parameters
gen_params={
 min_rooms=5,
 max_rooms=15,
 min_size=4,
 max_size=12,
 spacing=2,
 corridor_texture=0,
 room_door_prob=0.3,
 erode_amount=50,
 difficulty=1,
 max_difficulty=9,
 max_enemies_per_room=8,
 max_decorations_per_room=12,
 npc_hostile_ratio=0.7,
 items_per_room=2,
 pickup_density=0.1
}

-- helper constants
max_spawn_attempts=50
max_room_attempts=100

-- door testing parameters
test_door_open=nil -- if set to a value 0.0-1.0, forces all doors to this open state for testing
test_door_x=nil -- if set, only affects door at this position
test_door_y=nil -- if set, only affects door at this position

-- object type definitions (mx=sprite index from gfx files, my deprecated, mw/mh use sprite_size)
-- NOTE: my=0 is deprecated and maintained for backward compatibility only; will be removed once rendering code migrates
obj_types={
 player={solid=true,w=0.4,mx=0,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.8,flat=false,lit=nil,framect=nil,animspd=nil,yoffs=nil,kind="player"},
 enemy={solid=true,w=0.4,mx=64,my=0,mw=sprite_size,mh=sprite_size,y=0.1,h=0.8,flat=false,lit=nil,framect=4,animspd=0.25,yoffs={0,-0.01,0,-0.01},kind="hostile_npc",ai_type="follow",follow_speed=0.05,follow_range=20,patrol_speed=0.03},
 item={solid=false,w=0.3,mx=128,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.2,flat=false,lit=nil,framect=nil,animspd=nil,yoffs=nil,kind="direct_pickup",subtype="generic"},
 key={solid=false,w=0.3,mx=129,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.2,flat=false,lit=nil,framect=nil,animspd=nil,yoffs=nil,kind="direct_pickup",subtype="key"},
 heart={solid=false,w=0.3,mx=130,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.2,flat=false,lit=nil,framect=2,animspd=0.1,yoffs={0,0.05},kind="direct_pickup",subtype="heart"},
 decoration={solid=false,w=0.3,mx=148,my=0,mw=sprite_size,mh=sprite_size,y=0.3,h=0.4,flat=false,lit=0,framect=4,animspd=0.25,yoffs=nil,kind="decorative"},
 hostile_npc={solid=true,w=0.4,mx=64,my=0,mw=sprite_size,mh=sprite_size,y=0.1,h=0.8,flat=false,lit=nil,framect=4,animspd=0.25,yoffs={0,-0.01,0,-0.01},kind="hostile_npc",ai_type="follow",follow_speed=0.05,follow_range=20,patrol_speed=0.03},
 non_hostile_npc={solid=false,w=0.4,mx=73,my=0,mw=sprite_size,mh=sprite_size,y=0.1,h=0.8,flat=false,lit=nil,framect=1,animspd=0,yoffs=nil,kind="non_hostile_npc"},
 direct_pickup={solid=false,w=0.2,mx=128,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.2,flat=false,lit=nil,framect=2,animspd=0.1,yoffs={0,0.05},kind="direct_pickup"},
 interactable_chest={solid=false,w=0.3,mx=131,my=0,mw=sprite_size,mh=sprite_size,y=0.3,h=0.3,flat=false,lit=nil,framect=1,animspd=0,yoffs=nil,kind="interactable",subtype="chest"},
 interactable_shrine={solid=false,w=0.4,mx=132,my=0,mw=sprite_size,mh=sprite_size,y=0.3,h=0.5,flat=false,lit=nil,framect=1,animspd=0,yoffs=nil,kind="interactable",subtype="shrine"},
 interactable_trap={solid=false,w=0.2,mx=133,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.1,flat=true,lit=nil,framect=1,animspd=0,yoffs=nil,kind="interactable",subtype="trap"},
 interactable_note={solid=false,w=0.3,mx=134,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.2,flat=true,lit=nil,framect=1,animspd=0,yoffs=nil,kind="interactable",subtype="note"},
 interactable_exit={solid=false,w=0.3,mx=135,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.2,flat=false,lit=nil,framect=1,animspd=0,yoffs=nil,kind="interactable",subtype="exit"}
}

-- enemy type definitions (sprite indexes from gfx/2_characters.gfx, offset 64)
enemy_types={
 {name="rat",difficulty=1,min_count=1,max_count=3,obj_type=obj_types.hostile_npc,sprite=64,hp=1},
 {name="bat",difficulty=2,min_count=1,max_count=4,obj_type=obj_types.hostile_npc,sprite=65,hp=1},
 {name="slime",difficulty=3,min_count=2,max_count=5,obj_type=obj_types.hostile_npc,sprite=66,hp=2},
 {name="skeleton",difficulty=4,min_count=1,max_count=3,obj_type=obj_types.hostile_npc,sprite=67,hp=3},
 {name="goblin",difficulty=5,min_count=2,max_count=4,obj_type=obj_types.hostile_npc,sprite=68,hp=3},
 {name="orc",difficulty=6,min_count=1,max_count=3,obj_type=obj_types.hostile_npc,sprite=69,hp=4},
 {name="troll",difficulty=7,min_count=1,max_count=2,obj_type=obj_types.hostile_npc,sprite=70,hp=5},
 {name="demon",difficulty=8,min_count=1,max_count=2,obj_type=obj_types.hostile_npc,sprite=71,hp=6},
 {name="dragon",difficulty=9,min_count=1,max_count=1,obj_type=obj_types.hostile_npc,sprite=72,hp=10}
}

-- decoration type definitions (sprite indexes from gfx/3_props.gfx, offset 148)
decoration_types={
 {name="torch",difficulty=1,obj_type=obj_types.decoration,gen_tags={"lit","uni"},theme_tags={"dng","lit"},sprite=148},
 {name="barrel",difficulty=1,obj_type=obj_types.decoration,gen_tags={"uni"},theme_tags={"dng","house"},sprite=149},
 {name="crate",difficulty=1,obj_type=obj_types.decoration,gen_tags={"uni2"},theme_tags={"dng","house"},sprite=150},
 {name="pillar",difficulty=2,obj_type=obj_types.decoration,gen_tags={"big"},theme_tags={"dng","dem"},sprite=151},
 {name="statue",difficulty=3,obj_type=obj_types.decoration,gen_tags={"rare"},theme_tags={"dng","dem"},sprite=152},
 {name="chest",difficulty=2,obj_type=obj_types.decoration,gen_tags={"scatter"},theme_tags={"dng","house"},sprite=153},
 {name="tree",difficulty=1,obj_type=obj_types.decoration,gen_tags={"scatter"},theme_tags={"out"},sprite=154},
 {name="rock",difficulty=1,obj_type=obj_types.decoration,gen_tags={"uni"},theme_tags={"out"},sprite=155}
}

-- theme definitions
themes={
 dng={floor="stone_tile",roof="stone_ceiling",decor_prob=0.8},
 out={floor="dirt",roof="sky",decor_prob=0.5},
 dem={floor="stone_tile",roof="night_sky",decor_prob=0.9},
 house={floor="stone_tile",roof="stone_ceiling",decor_prob=0.7},
 dark={floor="stone_tile",roof="night_sky",decor_prob=0.6}
}

-- fog palettes (distance-based)
-- extended to support all 64 colors in Picotron
-- base colors 0-15 are remapped per fog level; colors 16-63 map to their fogged equivalents
pals={
 -- level 0: no fog
 {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63},
 -- level 1
 {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,5,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,5,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,5,48,49,50,51,52,53,54,5,56,57,58,59,60,61,62,5},
 -- level 2
 {0,1,2,3,4,5,6,7,8,9,10,11,12,13,5,5,16,17,18,19,20,21,22,23,24,25,26,27,28,29,5,5,32,33,34,35,36,37,38,39,40,41,42,43,44,45,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,61,5,5},
 -- level 3
 {0,1,2,3,4,5,6,7,8,9,10,11,12,5,5,5,16,17,18,19,20,21,22,23,24,25,26,27,28,5,5,5,32,33,34,35,36,37,38,39,40,41,42,43,44,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 4
 {0,1,2,3,4,5,6,7,8,9,10,11,5,5,5,5,16,17,18,19,20,21,22,23,24,25,26,27,5,5,5,5,32,33,34,35,36,37,38,39,40,41,42,43,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 5
 {0,1,2,3,4,5,6,7,8,9,10,5,5,5,5,5,16,17,18,19,20,21,22,23,24,25,26,5,5,5,5,5,32,33,34,35,36,37,38,39,40,41,42,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 6
 {0,1,2,3,4,5,6,7,8,9,5,5,5,5,5,5,16,17,18,19,20,21,22,23,24,25,5,5,5,5,5,5,32,33,34,35,36,37,38,39,40,41,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 7
 {0,1,2,3,4,5,6,7,8,5,5,5,5,5,5,5,16,17,18,19,20,21,22,23,24,5,5,5,5,5,5,5,32,33,34,35,36,37,38,39,40,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 8
 {0,1,2,3,4,5,6,7,5,5,5,5,5,5,5,5,16,17,18,19,20,21,22,23,5,5,5,5,5,5,5,5,32,33,34,35,36,37,38,39,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 9
 {0,1,2,3,4,5,6,5,5,5,5,5,5,5,5,5,16,17,18,19,20,21,5,5,5,5,5,5,5,5,5,5,32,33,34,35,36,37,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 10
 {0,1,2,3,4,5,5,5,5,5,5,5,5,5,5,5,16,17,18,19,20,21,5,5,5,5,5,5,5,5,5,5,32,33,34,35,36,37,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 11
 {0,1,2,3,4,5,5,5,5,5,5,5,5,5,5,5,16,17,18,19,20,21,5,5,5,5,5,5,5,5,5,5,32,33,34,35,36,37,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 12
 {0,1,2,3,5,5,5,5,5,5,5,5,5,5,5,5,16,17,18,19,5,5,5,5,5,5,5,5,5,5,5,5,32,33,34,35,5,5,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 13
 {0,1,2,5,5,5,5,5,5,5,5,5,5,5,5,5,16,17,18,5,5,5,5,5,5,5,5,5,5,5,5,5,32,33,34,5,5,5,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 14
 {0,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,16,17,5,5,5,5,5,5,5,5,5,5,5,5,5,5,32,33,5,5,5,5,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 15: maximum fog
 {0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,16,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,32,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5}
}

:: src/door_system.lua
--[[pod_format="raw",created="2025-11-07 21:17:14",modified="2025-11-07 21:48:06",revision=1]]
-- door animation system
-- test mode state (to avoid permanent mutation)
test_mode_prev=false
test_mode_saved_state={}

-- create a door
function create_door(x,y,dtype,key_id)
 local door={
  x=x,
  y=y,
  open=0, -- 0=closed, 1=fully open
  opening=false, -- animation state
  timer=0,
  dtype=dtype or door_normal,
  keynum=key_id, -- nil if unlocked, key id if locked
  stayopen=(dtype==door_stay_open) -- doors with door_stay_open dtype stay open
 }
 
 -- prevent duplicates at same grid cell
 local existing = doorgrid[x] and doorgrid[x][y] or nil
 if existing then
  printh("warning: duplicate door at ("..x..","..y..") - replacing")
  del(doors, existing)
 end
 add(doors,door)
 doorgrid[x][y]=door
	-- walls layer already set by generation to door tile ID (authoritative)
 
 return door
end

-- update all doors
function update_doors()
 -- handle test mode transitions to avoid permanent state mutation
 if test_door_mode and not test_mode_prev then
  -- entering test mode: save states
  test_mode_saved_state={}
  for door in all(doors) do
   test_mode_saved_state[door]={open=door.open,opening=door.opening,timer=door.timer}
  end
 elseif (not test_door_mode) and test_mode_prev then
  -- exiting test mode: restore states
  for door in all(doors) do
   local st=test_mode_saved_state[door]
   if st~=nil then
    door.open=st.open
    door.opening=st.opening
    door.timer=st.timer
   end
  end
  test_mode_saved_state={}
 end
 
 -- in test mode, temporarily override open values (restored on exit)
 if test_door_mode then
  for door in all(doors) do
   door.open=test_door_open or 0
  end
  -- keep early return to skip normal animation while testing
  test_mode_prev=true
  return
 end
 
 test_mode_prev=false
 
 for door in all(doors) do
  if door.opening then
   -- play sound on start
   if door.open==0 then
    -- sfx(10) -- door open sound
   end
   -- animate opening
   door.open+=door_anim_speed
   if door.open>1 then
    door.open=1
    door.opening=false
    door.timer=door_close_delay
   end
  else
   -- not opening
   if door.timer>0 then
    door.timer-=1
   elseif not door.stayopen then
    -- close door
    door.open=max(door.open-door_anim_speed,0)
   end
  end
 end
end



-- remove a door
function remove_door(x,y)
 local door=doorgrid[x][y]
 if door then
  del(doors,door)
  doorgrid[x][y]=nil
		set_wall(x,y,0)
 end
end

:: src/dungeon_gen.lua
--[[pod_format="raw",created="2025-11-07 21:17:13",modified="2025-11-07 21:48:06",revision=1]]
-- procedural dungeon generation

-- generation state
gen_rects={}
gen_nodes={}
gen_edges={}
gen_inventory={}
gen_objects={}
-- theme-specific floor id used during carving/eroding; initialized to stone_tile (1)
local gen_floor_id=1

-- helper: check if tile is a wall
function is_wall(val)
 return val>0 and val<door_normal
end

-- helper: check if tile is a door
function is_door(val)
 return val>=door_normal and val<=door_stay_open
end

-- helper: check if tile is an exit
function is_exit(val)
 return val>=exit_start and val<=exit_end
end

-- helper: boundary cell is reserved if it has a door/exit in either layer
function is_reserved_boundary(x,y)
 local w=get_wall(x,y)
 if is_door(w) or is_exit(w) then return true end
 -- defensive: should always be 0 if walls layer is authoritative
 if get_door(x,y)>0 then return true end
 if doorgrid[x] and doorgrid[x][y] then return true end
 return false
end

-- helper: check if rectangles overlap
function rect_overlaps(rect)
 -- reject out-of-bounds rectangles upfront (map is 0..127)
 if rect[1]<0 or rect[3]>=128 or rect[2]<0 or rect[4]>=128 then
  return true
 end
 for r in all(gen_rects) do
  if not (rect[3]+gen_params.spacing<r[1] or rect[1]>r[3]+gen_params.spacing or
          rect[4]+gen_params.spacing<r[2] or rect[2]>r[4]+gen_params.spacing) then
   return true
  end
 end
 return false
end

-- helper: fill rectangle using set_wall
-- Note: Uses Lua loops with userdata:set() calls; potential optimization:
-- batch userdata operations or memset() if available per Picotron guidelines
function fill_rect(rect,val)
 local x0=max(0,rect[1])
 local x1=min(127,rect[3])
 local y0=max(0,rect[2])
 local y1=min(127,rect[4])
 local fill_val=(val or 0)
 for x=x0,x1 do
  for y=y0,y1 do
			map.walls:set(x,y,fill_val)
  end
 end
end

-- helper: try place door with fallback positions
function try_place_door_with_fallback(x,y,dtype)
 local attempts={
  {x,y},
  {x-1,y},{x+1,y},{x,y-1},{x,y+1}
 }
 
 -- evaluate door placement probability once per logical placement
 local should_place_door=rnd(1)<gen_params.room_door_prob
 
 for attempt in all(attempts) do
  local ax,ay=attempt[1],attempt[2]
  if ax>=0 and ax<128 and ay>=0 and ay<128 then
			if is_wall(get_wall(ax,ay)) and should_place_door then
				map.walls:set(ax,ay,(dtype or 0))
    create_door(ax,ay,dtype)
    return true
   end
  end
 end
 return false
end

-- helper: generate random room
function random_room(base_node,is_special)
 local w,h
 if is_special then
  w,h=12,12
 else
  w=flr(rnd(gen_params.max_size-gen_params.min_size+1))+gen_params.min_size
  h=flr(rnd(gen_params.max_size-gen_params.min_size+1))+gen_params.min_size
 end
 
 local x,y
 if base_node then
  x=base_node.midx+flr(rnd(20)-10)
  y=base_node.midy+flr(rnd(20)-10)
 else
  x=flr(rnd(122))+3
  y=flr(rnd(122))+3
 end
 
 return {x,y,x+w-1,y+h-1},gen_params.room_door_prob
end

-- helper: add room to generation state
function add_room(rect,is_junction)
 add(gen_rects,rect)
 local node={
  rect=rect,
  midx=flr((rect[1]+rect[3])/2),
  midy=flr((rect[2]+rect[4])/2),
  edges={},
  is_junction=is_junction or false
 }
 add(gen_nodes,node)
 return node
end

-- helper: determine corridor type between two rooms
function get_corridor_type(r1,r2)
 local ox=not (r1[3]<r2[1] or r1[1]>r2[3])
 local oy=not (r1[4]<r2[2] or r1[2]>r2[4])
 if ox and not oy then return "vert" end
 if oy and not ox then return "horiz" end
 return "l_shape"
end

-- helper: place door at exact boundary wall tile with retry
function place_boundary_door_with_retry(bx,by,dtype,max_attempts)
 max_attempts=max_attempts or 3
 for attempt=1,max_attempts do
  if bx>=0 and bx<128 and by>=0 and by<128 then
   if is_wall(get_wall(bx,by)) then
   map.walls:set(bx,by,(dtype or 0))
    create_door(bx,by,dtype)
    return true
   end
  end
 end
 return false
end

-- helper: place door at exact boundary wall tile
function place_boundary_door(bx,by,dtype)
 -- bx,by = boundary wall tile (between corridor and room)
 if bx>=0 and bx<128 and by>=0 and by<128 then
		if is_wall(get_wall(bx,by)) then
			map.walls:set(bx,by,(dtype or 0))
   create_door(bx,by,dtype)
   return true
  end
 end
 return false
end

-- helper: ensure boundary passage (fallback for failed door placement)
function ensure_boundary_passage(bx,by)
 if bx>=0 and bx<128 and by>=0 and by<128 then
  local tile=get_wall(bx,by)
  -- if wall is still blocking and not a door, clear it
  if tile>0 and not is_door(tile) and not is_exit(tile) then
   map.walls:set(bx,by,0)
   set_floor(bx,by,gen_floor_id)
   printh("fallback: cleared blocking wall at ("..bx..","..by..")")
   return true
  end
 end
 return false
end

-- helper: create corridor between two nodes
function create_corridor(n1,n2)
 local ctype=get_corridor_type(n1.rect,n2.rect)
	local b1,b2
 
 if ctype=="horiz" then
  local x0,x1=min(n1.midx,n2.midx),max(n1.midx,n2.midx)
  local y=n1.midy
  local r1,r2=n1.rect,n2.rect
  
  -- identify boundary wall tiles before carving
  local bx1,bx2
  if r1[1]<=r2[1] then
   bx1=r1[3]+1
   bx2=r2[1]-1
  else
   bx1=r2[3]+1
   bx2=r1[1]-1
  end
  
  -- place doors on boundary walls (robust: retry and fallback to passage)
  local d1_ok=place_boundary_door_with_retry(bx1,y,door_normal,3)
  if not d1_ok then ensure_boundary_passage(bx1,y) end
  local d2_ok=place_boundary_door_with_retry(bx2,y,door_normal,3)
  if not d2_ok then ensure_boundary_passage(bx2,y) end
  
  -- carve corridor between doors (exclusive)
  local x_start=max(0,bx1+1)
  local x_end=min(127,bx2-1)
  local cy=y
  local cfloor_id=gen_floor_id
  for x=x_start,x_end do
				map.walls:set(x,cy,0)
				set_floor(x,cy,cfloor_id)
  end

		-- store boundary tiles
		b1={x=bx1,y=y}
		b2={x=bx2,y=y}
  
 elseif ctype=="vert" then
  local y0,y1=min(n1.midy,n2.midy),max(n1.midy,n2.midy)
  local x=n1.midx
  local r1,r2=n1.rect,n2.rect
  
  -- identify boundary wall tiles before carving
  local by1,by2
  if r1[2]<=r2[2] then
   by1=r1[4]+1
   by2=r2[2]-1
  else
   by1=r2[4]+1
   by2=r1[2]-1
  end
  
  -- place doors on boundary walls (robust: retry and fallback to passage)
  local d1_ok=place_boundary_door_with_retry(x,by1,door_normal,3)
  if not d1_ok then ensure_boundary_passage(x,by1) end
  local d2_ok=place_boundary_door_with_retry(x,by2,door_normal,3)
  if not d2_ok then ensure_boundary_passage(x,by2) end
  
  -- carve corridor between doors (exclusive)
  local y_start=max(0,by1+1)
  local y_end=min(127,by2-1)
  local cx=x
  local cfloor_id=gen_floor_id
  for y=y_start,y_end do
				map.walls:set(cx,y,0)
				set_floor(cx,y,cfloor_id)
  end

		-- store boundary tiles
		b1={x=x,y=by1}
		b2={x=x,y=by2}
  
 else -- l_shape
	local jx,jy=n1.midx,n2.midy
  local jw,jh=3,3
  local jrect={jx-1,jy-1,jx+jw-2,jy+jh-2}
  fill_rect(jrect,0)
  for x=max(0,jrect[1]),min(127,jrect[3]) do
   for y=max(0,jrect[2]),min(127,jrect[4]) do
    set_floor(x, y, gen_floor_id)
   end
  end
  -- tag as junction to skip perimeter wall texturing
  local jnode=add_room(jrect,true)
  
  -- connect n1 to junction (horizontal)
  local x0,x1=min(n1.midx,jx),max(n1.midx,jx)
  local r1=n1.rect
  local bx1_horiz,bx2_horiz
  if r1[1]<=jx then
   bx1_horiz=r1[3]+1
   -- place door on the wall just outside the junction (left side)
   bx2_horiz=jrect[1]-1
  else
   -- place door on the wall just outside the junction (right side)
   bx1_horiz=jrect[3]+1
   bx2_horiz=r1[1]-1
  end
  
  -- place doors on horizontal segment boundaries with retry and fallback
  if bx1_horiz>=0 and bx1_horiz<128 then
   local door1_ok=place_boundary_door_with_retry(bx1_horiz,n1.midy,door_normal,3)
   if not door1_ok then
    printh("warning: failed to place junction door at ("..bx1_horiz..","..n1.midy.."), clearing as passage")
    ensure_boundary_passage(bx1_horiz,n1.midy)
   end
  end
  
  if bx2_horiz>=0 and bx2_horiz<128 then
   local door2_ok=place_boundary_door_with_retry(bx2_horiz,n1.midy,door_normal,3)
   if not door2_ok then
    printh("warning: failed to place junction door at ("..bx2_horiz..","..n1.midy.."), clearing as passage")
    ensure_boundary_passage(bx2_horiz,n1.midy)
   end
  end
  
	-- carve horizontal segment
  local xh_start=max(0,bx1_horiz+1)
  local xh_end=min(127,bx2_horiz-1)
  local hy=n1.midy
  local hfloor_id=gen_floor_id
  for x=xh_start,xh_end do
				map.walls:set(x,hy,0)
				set_floor(x,hy,hfloor_id)
  end
  
  -- connect junction to n2 (vertical)
  local y0,y1=min(jy,n2.midy),max(jy,n2.midy)
  local r2=n2.rect
  local by1_vert,by2_vert
  if jy<=r2[2] then
   -- place door on the wall just outside the junction (bottom side)
   by1_vert=jrect[4]+1
   by2_vert=r2[2]-1
  else
   by1_vert=r2[4]+1
   -- place door on the wall just outside the junction (top side)
   by2_vert=jrect[2]-1
  end
  
  -- place doors on vertical segment boundaries with retry and fallback
  if by1_vert>=0 and by1_vert<128 then
   local door3_ok=place_boundary_door_with_retry(jx,by1_vert,door_normal,3)
   if not door3_ok then
    printh("warning: failed to place junction door at ("..jx..","..by1_vert.."), clearing as passage")
    ensure_boundary_passage(jx,by1_vert)
   end
  end
  
  if by2_vert>=0 and by2_vert<128 then
   local door4_ok=place_boundary_door_with_retry(jx,by2_vert,door_normal,3)
   if not door4_ok then
    printh("warning: failed to place junction door at ("..jx..","..by2_vert.."), clearing as passage")
    ensure_boundary_passage(jx,by2_vert)
   end
  end
  
	-- carve vertical segment
  local yv_start=max(0,by1_vert+1)
  local yv_end=min(127,by2_vert-1)
  local vx=jx
  local vfloor_id=gen_floor_id
  for y=yv_start,yv_end do
				map.walls:set(vx,y,0)
				set_floor(vx,y,vfloor_id)
  end
  
  -- validation: ensure all boundary passages are clear
  ensure_boundary_passage(bx1_horiz,n1.midy)
  ensure_boundary_passage(bx2_horiz,n1.midy)
  ensure_boundary_passage(jx,by1_vert)
  ensure_boundary_passage(jx,by2_vert)

		-- store boundary tiles near rooms
		local near_n1
		if r1[1]<=jx then
			near_n1={x=bx1_horiz,y=n1.midy}
		else
			near_n1={x=bx2_horiz,y=n1.midy}
		end
		local near_n2
		if jy<=r2[2] then
			near_n2={x=jx,y=by2_vert}
		else
			near_n2={x=jx,y=by1_vert}
		end
		b1=near_n1
		b2=near_n2
 end
 
 -- store boundary tiles for progression gating
	local edge={n1=n1,n2=n2,b1=b1,b2=b2}
 add(gen_edges,edge)
 add(n1.edges,n2)
 add(n2.edges,n1)
end

-- helper: try to generate and connect a room
function try_generate_room()
 local base=gen_nodes[flr(rnd(#gen_nodes))+1]
 local rect=random_room(base,false)
 
 if rect[1]<3 or rect[3]>126 or rect[2]<3 or rect[4]>126 then
  return false
 end
 
 if rect_overlaps(rect) then
  return false
 end
 
 local node=add_room(rect)
 fill_rect(rect,0)
 for x=max(0,rect[1]),min(127,rect[3]) do
  for y=max(0,rect[2]),min(127,rect[4]) do
   set_floor(x, y, gen_floor_id)
  end
 end
 create_corridor(base,node)
 return true
end

-- helper: apply wall textures to room perimeter
function apply_room_walls(rect,tex)
 -- ensure tex is never 0
 if tex==0 then tex=1 end
 
 for x=rect[1],rect[3] do
  if rect[2]-1>=0 and rect[2]-1<128 and x>=0 and x<128 then
   -- skip reserved cells (doors/exits in any layer)
		if not is_reserved_boundary(x,rect[2]-1) then
			map.walls:set(x,rect[2]-1,tex)
   end
  end
  if rect[4]+1>=0 and rect[4]+1<128 and x>=0 and x<128 then
   -- skip reserved cells (doors/exits in any layer)
		if not is_reserved_boundary(x,rect[4]+1) then
			map.walls:set(x,rect[4]+1,tex)
   end
  end
 end
 for y=rect[2],rect[4] do
  if rect[1]-1>=0 and rect[1]-1<128 and y>=0 and y<128 then
   -- skip reserved cells (doors/exits in any layer)
		if not is_reserved_boundary(rect[1]-1,y) then
			map.walls:set(rect[1]-1,y,tex)
   end
  end
  if rect[3]+1>=0 and rect[3]+1<128 and y>=0 and y<128 then
   -- skip reserved cells (doors/exits in any layer)
		if not is_reserved_boundary(rect[3]+1,y) then
			map.walls:set(rect[3]+1,y,tex)
   end
  end
 end
end

-- repair step: ensure door tiles exist on walls layer for all logical doors
function enforce_door_tiles()
 for door in all(doors) do
  if not is_door(get_wall(door.x,door.y)) then
   set_wall(door.x,door.y,door.dtype or door_normal)
  end
 end
 
 -- also check doorgrid consistency
 for x=0,map_size-1 do
  if doorgrid[x] then
   for y=0,map_size-1 do
    if doorgrid[x][y] then
     local tile=get_wall(x,y)
     if not is_door(tile) then
      -- restore door tile from doorgrid or use default
      local correct_tile=doorgrid[x][y].tile or door_normal
      set_wall(x,y,correct_tile)
      printh("warning: restored door tile at ("..x..","..y..")")
     end
    end
   end
  end
 end
end

-- border ring enforcement: set outermost ring to walls while preserving doors/exits
function enforce_border_ring()
 -- top and bottom edges (y=0 and y=map_size-1)
 for x=0,map_size-1 do
  -- top edge
  local top_tile=get_wall(x,0)
  if not is_door(top_tile) and not is_exit(top_tile) then
   map.walls:set(x,0,wall_fill_tile)
  end
  
  -- bottom edge
  local bottom_tile=get_wall(x,map_size-1)
  if not is_door(bottom_tile) and not is_exit(bottom_tile) then
   map.walls:set(x,map_size-1,wall_fill_tile)
  end
 end
 
 -- left and right edges (x=0 and x=map_size-1)
 for y=0,map_size-1 do
  -- left edge
  local left_tile=get_wall(0,y)
  if not is_door(left_tile) and not is_exit(left_tile) then
   map.walls:set(0,y,wall_fill_tile)
  end
  
  -- right edge
  local right_tile=get_wall(map_size-1,y)
  if not is_door(right_tile) and not is_exit(right_tile) then
   map.walls:set(map_size-1,y,wall_fill_tile)
  end
 end
end

-- helper: random wall texture (never returns 0)
function random_wall_texture()
 local set=texsets[flr(rnd(#texsets-1))+2] -- skip texsets[1] which is floor
 return set.variants[flr(rnd(#set.variants))+1]
end

-- helper: get theme-appropriate wall texture set
function theme_wall_texture(theme)
 if theme=="out" then
  -- outdoor: grass or earth variants
  -- indices in texsets: 5=grass, 6=earth
  local idx=rnd(1)<0.5 and 5 or 6
  return texsets[idx] or texsets[1]
 elseif theme=="dem" then
  -- demon: stone or cobblestone
  -- indices: 4=stone, 2=cobblestone
  local idx=rnd(1)<0.5 and 4 or 2
  return texsets[idx] or texsets[1]
 elseif theme=="house" then
  -- house: wood plank
  -- index: 3=wood_plank
  return texsets[3] or texsets[1]
 else
  -- default dungeon: brick or cobblestone
  -- indices: 1=brick, 2=cobblestone
  local idx=rnd(1)<0.5 and 1 or 2
  return texsets[idx] or texsets[1]
 end
end

-- helper: find accessible rooms from start via edges
function find_accessible_rooms(start_node,locked_edges)
 local accessible={}
 local queue={start_node}
 local visited={}
 visited[start_node]=true
 
 while #queue>0 do
  local node=queue[1]
  deli(queue,1)
  add(accessible,node)
  
  for edge_node in all(node.edges) do
   if not visited[edge_node] then
    local is_locked=false
    if locked_edges then
     for le in all(locked_edges) do
					if (le.n1==node and le.n2==edge_node) or (le.n1==edge_node and le.n2==node) then
       is_locked=true
       break
      end
     end
    end
    
    if not is_locked then
     visited[edge_node]=true
     add(queue,edge_node)
    end
   end
  end
 end
 
 return accessible
end

-- helper: find spawn point in room
function find_spawn_point(rect)
 for attempt=1,max_spawn_attempts do
  local x=rect[1]+1+flr(rnd(rect[3]-rect[1]-1))
  local y=rect[2]+1+flr(rnd(rect[4]-rect[2]-1))
  
  if x>=0 and x<128 and y>=0 and y<128 and get_wall(x,y)==0 then
   local valid=true
   for obj in all(gen_objects) do
    local ox=obj.pos and obj.pos[1] or obj.x
    local oy=obj.pos and obj.pos[2] or obj.y
    if ox and oy then
     local dx,dy=abs(ox-x),abs(oy-y)
     if dx<1 and dy<1 then
      valid=false
      break
     end
    end
   end
   
   if valid then
    return x+0.5,y+0.5
   end
  end
 end
 return nil,nil
end

-- helper: erode map for organic feel (generalized for all wall types)
function erode_map(amount)
 for i=1,amount do
  local x,y=flr(rnd(128)),flr(rnd(128))
		if is_wall(get_wall(x,y)) then
   local neighbors=0
   for dx=-1,1 do
    for dy=-1,1 do
     local nx,ny=x+dx,y+dy
					if nx>=0 and nx<128 and ny>=0 and ny<128 and get_wall(nx,ny)==0 then
      neighbors+=1
     end
    end
   end
   if neighbors>=3 then
				map.walls:set(x,y,0)
    -- ensure eroded clears become traversable floor with theme-specific type
    set_floor(x,y,gen_floor_id)
   end
  end
 end
end

-- helper: generate exit portal on wall
function generate_exit(rect,exit_type)
 local walls={}
 for x=rect[1],rect[3] do
		if rect[2]-1>=0 and is_wall(get_wall(x,rect[2]-1)) then
   add(walls,{x,rect[2]})
  end
		if rect[4]+1<128 and is_wall(get_wall(x,rect[4]+1)) then
   add(walls,{x,rect[4]})
  end
 end
 for y=rect[2],rect[4] do
		if rect[1]-1>=0 and is_wall(get_wall(rect[1]-1,y)) then
   add(walls,{rect[1],y})
  end
		if rect[3]+1<128 and is_wall(get_wall(rect[3]+1,y)) then
   add(walls,{rect[3],y})
  end
 end
 
 if #walls>0 then
  local pos=walls[flr(rnd(#walls))+1]
  -- write exit tile to map
  local exit_tile=exit_type==3 and exit_start or exit_end
  map.walls:set(pos[1],pos[2],(exit_tile or 0))
  -- also add interactable exit object
  local ob={
   pos={pos[1]+0.5,pos[2]+0.5},
   typ=obj_types.interactable_exit,
   rel={0,0},
   frame=0,
   animloop=true,
   autoanim=false,
   exit_type=exit_type
  }
  add(gen_objects,ob)
 end
end

-- gameplay generation: enemies, items, decorations, npcs
function generate_gameplay()
 -- guard against empty gen_nodes to avoid nil dereference
 if not gen_nodes or #gen_nodes==0 then
  printh("error: generate_gameplay() called with no rooms")
  return
 end
 local start_node=gen_nodes[1]
 local exit_node=gen_nodes[#gen_nodes]
 
 -- place start/exit portals
 generate_exit(start_node.rect,3)
 generate_exit(exit_node.rect,4)
 
 -- erode map
 erode_map(gen_params.erode_amount)
 
 -- populate inventory with health items
 for i=1,3 do
  add(gen_inventory,{type="heart"})
 end
 
 -- generate progression loop (simplified - no locking yet)
 generate_progression_loop(start_node)
 
 -- generate npcs (includes hostile and non-hostile)
 generate_npcs()
 
 -- generate items
 generate_items()
 
 -- generate decorations
 generate_decorations()
end

-- generate progression: items and locked doors
function generate_progression_loop(start_node)
 local locked_edges={}
 local key_counter=1
 
 -- cache accessible rooms for current locked_edges; recompute only after a successful lock
 local full_accessible=find_accessible_rooms(start_node,locked_edges)
 
 -- prepare shuffled edge order to avoid duplicate selection and ensure coverage
 local edges_shuffled={}
 for e in all(gen_edges) do add(edges_shuffled,e) end
 -- fisher-yates shuffle
 for i=#edges_shuffled,2,-1 do
  local j=flr(rnd(i))+1
  edges_shuffled[i],edges_shuffled[j]=edges_shuffled[j],edges_shuffled[i]
 end
 
 -- attempt to create progression gates
 for gate_idx=1,#edges_shuffled do
  if key_counter>3 then break end
  
  -- try to lock an edge
  local edge=edges_shuffled[gate_idx]
  local n1,n2=edge.n1,edge.n2
  
  -- check if this edge would gate content
  local combined_locked={}
  for le in all(locked_edges) do add(combined_locked,le) end
  add(combined_locked,edge)
  local test_accessible=find_accessible_rooms(start_node,combined_locked)
  
		-- if locking this edge hides new rooms, add it as a gate
		if #test_accessible<#full_accessible then
			-- choose the actual corridor boundary door tile
			local candidates={edge.b1,edge.b2}
   local chosen=nil
   for c in all(candidates) do
    if c and c.x and c.y then
     local wt=get_wall(c.x,c.y)
     if is_door(wt) then
      chosen=c
      break
     end
    end
   end
			if chosen then
				local x,y=chosen.x,chosen.y
				local door=doorgrid[x] and doorgrid[x][y] or nil
				if door then
					-- convert existing door to locked
					map.walls:set(x,y,door_locked)
					door.dtype=door_locked
					door.keynum=key_counter
				else
					-- fallback: create a new locked door here
					map.walls:set(x,y,door_locked)
					create_door(x,y,door_locked,key_counter)
				end
				add(locked_edges,edge)
     -- update cached accessibility after modifying locked edges
     full_accessible=find_accessible_rooms(start_node,locked_edges)
				-- add key to inventory
				add(gen_inventory,{type="key",keynum=key_counter})
				key_counter+=1
   else
    printh("warning: no valid boundary door tile for gate; skipping")
			end
		end
 end
 
 -- place inventory items in accessible rooms
 local failed_placements=0
 -- compute accessible rooms once (does not change during item placement)
 local accessible=find_accessible_rooms(start_node,locked_edges)
 while #gen_inventory>0 do
  
  if #accessible>0 then
   local room=accessible[flr(rnd(#accessible))+1]
   local item=gen_inventory[1]
   deli(gen_inventory,1)
   
   local x,y=find_spawn_point(room.rect)
   if x then
    failed_placements=0
   if item.type=="key" then
     local ob={pos={x,y},typ=obj_types.key,rel={0,0},frame=0,animloop=true,autoanim=true,keynum=item.keynum}
     add(gen_objects,ob)
    else
     local ob={pos={x,y},typ=obj_types[item.type],rel={0,0},frame=0,animloop=true,autoanim=true}
     add(gen_objects,ob)
    end
   else
    -- handle failed placement
    if item.type=="key" then
     -- retry a limited number of times across different rooms
     local attempts=0
     local placed=false
     while attempts<15 and not placed do
      local rr=accessible[flr(rnd(#accessible))+1]
      local kx,ky=find_spawn_point(rr.rect)
      if kx then
       local ob={pos={kx,ky},typ=obj_types.key,rel={0,0},frame=0,animloop=true,autoanim=true,keynum=item.keynum}
       add(gen_objects,ob)
       placed=true
       break
      end
      attempts+=1
     end
     if not placed then
      -- fallback: force place in start room (center if needed)
      local sx,sy=find_spawn_point(start_node.rect)
      if not sx then
       sx=start_node.midx+0.5
       sy=start_node.midy+0.5
      end
      local ob={pos={sx,sy},typ=obj_types.key,rel={0,0},frame=0,animloop=true,autoanim=true,keynum=item.keynum}
      add(gen_objects,ob)
     end
    else
     failed_placements+=1
     if failed_placements>10 then
      printh("warning: failed to place items after multiple attempts; stopping")
      break
     end
    end
   end
  else
   break
  end
 end
end

-- generate npcs (hostile and non-hostile) in rooms
function generate_npcs()
 for node in all(gen_nodes) do
  local rect=node.rect
  local num_npcs=flr(rnd(3))+1
  
  for i=1,num_npcs do
   local x,y=find_spawn_point(rect)
   if x then
    -- 70% hostile, 30% non-hostile
    if rnd(1)<gen_params.npc_hostile_ratio then
     -- select enemy type based on current difficulty level
     local available_enemies = {}
     for enemy in all(enemy_types) do
      if enemy.difficulty <= gen_params.difficulty then
       add(available_enemies, enemy)
      end
     end
     -- fallback to rat if no enemies available
     if #available_enemies == 0 then
      available_enemies = {enemy_types[1]}
     end
     local enemy_type = available_enemies[flr(rnd(#available_enemies))+1]
     
     -- hostile npc with patrol or follow behavior
     local ai_type=rnd(1)<0.5 and "patrol" or "follow"
     -- sprite_index from enemy_types configuration (64-72 range)
     local ob={
      pos={x,y},
      typ=obj_types.hostile_npc,
      rel={0,0},
      frame=0,
      animloop=true,
      autoanim=true,
      ai_type=ai_type,
      patrol_index=0,
      patrol_points={},
      sprite_index=enemy_type.sprite
     }
     -- generate patrol points if patrol mode
     if ai_type=="patrol" then
      for j=1,4 do
       local px,py=find_spawn_point(rect)
       if px then
        add(ob.patrol_points,{x=px,y=py})
       end
      end
      if #ob.patrol_points==0 then
       add(ob.patrol_points,{x=x,y=y})
      end
     end
     add(gen_objects,ob)
    else
     -- non-hostile NPCs use sprite 73
     local ob={
      pos={x,y},
      typ=obj_types.non_hostile_npc,
      rel={0,0},
      frame=0,
      animloop=true,
      autoanim=false,
      sprite_index=obj_types.non_hostile_npc.mx
     }
     add(gen_objects,ob)
    end
   end
  end
 end
end

-- generate items (pickups and interactables) in rooms
function generate_items()
 for node in all(gen_nodes) do
  local rect=node.rect
  local num_items=flr(rnd(gen_params.items_per_room))+1
  
  for i=1,num_items do
   local x,y=find_spawn_point(rect)
   if x then
    -- choose item type: 60% pickup, 40% interactable
    if rnd(1)<0.6 then
     -- direct pickup (heart or generic item)
     local pickup_type=rnd(1)<0.5 and "heart" or "direct_pickup"
     local obj_type=pickup_type=="heart" and obj_types.heart or obj_types.direct_pickup
     local ob={
      pos={x,y},
      typ=obj_type,
      rel={0,0},
      frame=0,
      animloop=true,
      autoanim=true
     }
     add(gen_objects,ob)
    else
     -- interactable (chest, shrine, trap, note)
     local subtypes={"chest","shrine","trap","note"}
     local subtype=subtypes[flr(rnd(#subtypes))+1]
     local obj_type
     if subtype=="chest" then
      obj_type=obj_types.interactable_chest
     elseif subtype=="shrine" then
      obj_type=obj_types.interactable_shrine
     elseif subtype=="trap" then
      obj_type=obj_types.interactable_trap
     else
      obj_type=obj_types.interactable_note
     end
     local ob={
      pos={x,y},
      typ=obj_type,
      rel={0,0},
      frame=0,
      animloop=true,
      autoanim=false,
      subtype=subtype
     }
     add(gen_objects,ob)
    end
   end
  end
 end
end

-- generate decorations in rooms
function generate_decorations()
 local current_theme=gen_params.theme or "dng"
 local theme_config=themes[current_theme] or themes.dng
 local decor_prob=theme_config.decor_prob or 0.8
 
 for node in all(gen_nodes) do
  local rect=node.rect
  local w,h=rect[3]-rect[1]+1,rect[4]-rect[2]+1
  local room_decor_count=0
  local max_decor=gen_params.max_decorations_per_room or 12
  
  -- uniform grid pattern
  for dec in all(decoration_types) do
   if room_decor_count>=max_decor then break end
   
   -- filter by theme: check if any theme_tags match current_theme
   local theme_match=false
   if dec.theme_tags then
    for tag in all(dec.theme_tags) do
     if tag==current_theme then
      theme_match=true
      break
     end
    end
   else
    theme_match=true -- no theme_tags means always match
   end
   
   if theme_match and dec.gen_tags then
    for tag in all(dec.gen_tags) do
     if room_decor_count>=max_decor then break end
     
     if tag=="uni" and rnd(1)<0.3*decor_prob then
      for dx=2,w-2,3 do
       for dy=2,h-2,3 do
        if room_decor_count>=max_decor then break end
        if rnd(1)<0.5 then
         local x,y=rect[1]+dx+0.5,rect[2]+dy+0.5
         -- sprite_index from decoration_types configuration (148-155 range)
         local ob={pos={x,y},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,sprite_index=dec.sprite}
         add(gen_objects,ob)
         room_decor_count+=1
        end
       end
       if room_decor_count>=max_decor then break end
      end
      
     elseif tag=="uni2" and rnd(1)<0.4*decor_prob then
      -- denser uniform grid
      for dx=1,w-1,2 do
       for dy=1,h-1,2 do
        if room_decor_count>=max_decor then break end
        if rnd(1)<0.6 then
         local x,y=rect[1]+dx+0.5,rect[2]+dy+0.5
         local ob={pos={x,y},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,sprite_index=dec.sprite}
         add(gen_objects,ob)
         room_decor_count+=1
        end
       end
       if room_decor_count>=max_decor then break end
      end
      
     elseif tag=="scatter" and rnd(1)<0.2*decor_prob then
      local count=flr(rnd(3))+1
      for i=1,count do
       if room_decor_count>=max_decor then break end
       local x,y=find_spawn_point(rect)
       if x then
        local ob={pos={x,y},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,sprite_index=dec.sprite}
        add(gen_objects,ob)
        room_decor_count+=1
       end
      end
      
     elseif tag=="big" and rnd(1)<0.15*decor_prob then
      if room_decor_count>=max_decor then break end
      -- large object: place at room center or corner
      local cx,cy=flr((rect[1]+rect[3])/2)+0.5,flr((rect[2]+rect[4])/2)+0.5
      if rnd(1)<0.5 then
       -- center
       local ob={pos={cx,cy},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,sprite_index=dec.sprite}
       add(gen_objects,ob)
       room_decor_count+=1
      else
       -- random corner
       local corners={{rect[1]+1.5,rect[2]+1.5},{rect[3]-0.5,rect[2]+1.5},{rect[1]+1.5,rect[4]-0.5},{rect[3]-0.5,rect[4]-0.5}}
       local corner=corners[flr(rnd(#corners))+1]
       local ob={pos={corner[1],corner[2]},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,sprite_index=dec.sprite}
       add(gen_objects,ob)
       room_decor_count+=1
      end
      
     elseif tag=="rare" and rnd(1)<0.05*decor_prob then
      if room_decor_count>=max_decor then break end
      -- rare: single spawn
      local x,y=find_spawn_point(rect)
      if x then
       local ob={pos={x,y},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,sprite_index=dec.sprite}
       add(gen_objects,ob)
       room_decor_count+=1
      end
      
     elseif tag=="lit" and rnd(1)<0.25*decor_prob then
      if room_decor_count>=max_decor then break end
      -- lit: bias toward walls or doorways
      local walls={}
      -- collect wall-adjacent floor tiles
      for x=rect[1]+1,rect[3]-1 do
       if get_wall(x,rect[2])>0 then add(walls,{x+0.5,rect[2]+1.5}) end
       if get_wall(x,rect[4])>0 then add(walls,{x+0.5,rect[4]-0.5}) end
      end
      for y=rect[2]+1,rect[4]-1 do
       if get_wall(rect[1],y)>0 then add(walls,{rect[1]+1.5,y+0.5}) end
       if get_wall(rect[3],y)>0 then add(walls,{rect[3]-0.5,y+0.5}) end
      end
      if #walls>0 then
       local pos=walls[flr(rnd(#walls))+1]
       local ob={pos={pos[1],pos[2]},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,sprite_index=dec.sprite}
       add(gen_objects,ob)
       room_decor_count+=1
      end
     end
    end
   end
  end
 end
end

-- generate a complete dungeon
function generate_dungeon()
 local seed=flr(rnd(10000))
 srand(seed)
 
 -- initialize state
 gen_rects={}
 gen_nodes={}
 gen_edges={}
 gen_inventory={}
 gen_objects={}
 
 -- fill with walls (non-zero tile)
 fill_rect({0,0,127,127},wall_fill_tile)
 
 -- assign global theme before carving (ensures theme floor id is available)
 local theme_roll=rnd(1)
 local selected_theme="dng"
 if theme_roll<0.7 then
  selected_theme="dng"
 elseif theme_roll<0.9 then
  selected_theme="out"
 else
  selected_theme="dem"
 end
 gen_params.theme=selected_theme
 local theme_config=themes[selected_theme] or themes.dng
 
 -- set floor and ceiling types based on theme
 local floor_idx=1
 local roof_idx=3
 if theme_config.floor=="stone_tile" then floor_idx=1
 elseif theme_config.floor=="dirt" then floor_idx=2
 end
 if theme_config.roof=="stone_ceiling" then roof_idx=3
 elseif theme_config.roof=="sky" then roof_idx=4
 elseif theme_config.roof=="night_sky" then roof_idx=5
 end
 floor.typ=planetyps[floor_idx]
 roof.typ=planetyps[roof_idx]
 floor.x,floor.y=0,0
 roof.x,roof.y=0,0
 -- theme-specific floor id used by generator when carving/eroding
 gen_floor_id=floor_idx
 
 -- generate first room
 local first_rect=random_room(nil,false)
 local first_node=add_room(first_rect)
 fill_rect(first_rect,0)
 for x=max(0,first_rect[1]),min(127,first_rect[3]) do
  for y=max(0,first_rect[2]),min(127,first_rect[4]) do
   set_floor(x, y, gen_floor_id)
  end
 end
 
 -- generate additional rooms
 local room_count=flr(rnd(gen_params.max_rooms-gen_params.min_rooms+1))+gen_params.min_rooms
 for i=2,room_count do
  for attempt=1,max_room_attempts do
   if try_generate_room() then
    break
   end
  end
 end
 
 -- theme already chosen and floors configured above
 -- apply wall textures based on theme
 for node in all(gen_nodes) do
  -- skip junction rooms to avoid texturing their perimeters
  if not node.is_junction then
   local texset=theme_wall_texture(selected_theme)
   local tex=texset.variants[flr(rnd(#texset.variants))+1]
   apply_room_walls(node.rect,tex)
  end
 end
 
 -- ensure any doors placed earlier remain doors on the walls layer
 enforce_door_tiles()
 
 -- generate gameplay content (now aware of theme)
 generate_gameplay()
 -- gameplay may lock doors; re-assert tiles
 enforce_door_tiles()
 
 -- enforce border ring while preserving doors/exits
 enforce_border_ring()
 -- re-assert door tiles after border enforcement
 enforce_door_tiles()
 printh("Border ring enforced, doors preserved")
 
 -- export objects to global arrays (flat iteration, no spatial grid)
 objects=gen_objects
 
 -- populate animated_objects list for frame updates
 animated_objects={}
 for ob in all(objects) do
  if ob.autoanim then
   add(animated_objects, ob)
  end
 end
 
 -- set player start
 player.x=first_node.midx+0.5
 player.y=first_node.midy+0.5
 
 printh("generated dungeon: "..#gen_nodes.." rooms, "..#gen_objects.." objects, seed "..seed)
 
 return {x=player.x,y=player.y},{rooms=#gen_nodes,objects=#gen_objects,seed=seed}
end

:: src/raycast.lua
--[[pod_format="raw",created="2025-11-07 21:17:12",modified="2025-11-07 21:48:07",revision=1]]
-- raycasting core

-- sign helper
function sgn(n)
 if n<0 then return -1 end
 if n>0 then return 1 end
 return 0
end

-- vector length
function length(x,y)
 x/=16
 y/=16
 return sqrt(x*x+y*y)*16
end

-- vector normalization
function normalise(x,y)
 local l=length(x,y)
 if l<=0.0001 then return 0,1 end
 return x/l,y/l
end

-- dda raycast with z-depth tracking
-- fx,fy represent the forward/depth axis used for perpendicular distance:
--  - In main scene: fx,fy = camera forward = (cos(a), sin(a))
--  - In hitscan:    fx,fy = normalized ray direction
function raycast(x,y,dx,dy,fx,fy)
 -- clamp near-zero components before normalization
 if abs(dx)<0.01 then dx=0.01 end
 if abs(dy)<0.01 then dy=0.01 end
 
 -- normalize direction if forward axis not provided
 if not fx then
  fx,fy=normalise(dx,dy)
 end
 
 -- horizontal ray initialization
 local hx,hy,hdx,hdy=x,y,sgn(dx),dy/abs(dx)
 local hdz,hz=hdx*fx+hdy*fy,0
 
 -- initial step to grid boundary
 local fracx=hx%1
 local hstep
 if hdx>0 then
  hstep=1-fracx
 else
  hstep=fracx
 end
 hx+=hdx*hstep
 hy+=hdy*hstep
 hz+=hdz*hstep
 
 -- vertical ray initialization
 local vx,vy,vdx,vdy=x,y,dx/abs(dy),sgn(dy)
 local vdz,vz=vdx*fx+vdy*fy,0
 
 -- initial step to grid boundary
 local fracy=vy%1
 local vstep
 if vdy>0 then
  vstep=1-fracy
 else
  vstep=fracy
 end
 vx+=vdx*vstep
 vy+=vdy*vstep
 vz+=vdz*vstep
 
 -- compute iteration limit from remaining grid crossings to map edges
 -- compute remaining crossings to nearest boundary per axis based on current positions
 local horizontal_crossings
 if hdx>0 then
  horizontal_crossings=map_size-flr(hx)
 else
  horizontal_crossings=flr(hx)+1
 end
 
 local vertical_crossings
 if vdy>0 then
  vertical_crossings=map_size-flr(vy)
 else
  vertical_crossings=flr(vy)+1
 end
 
 local iteration_limit=min(256,horizontal_crossings+vertical_crossings+10)
 
 -- track DDA steps for diagnostics
 local dda_steps=0
 
 -- ray marching
 for iter=1,iteration_limit do
  -- increment step counter
  dda_steps+=1
  
  -- far-plane check: early-out if both candidates exceed far_plane
  if min(hz, vz) > far_plane then
   -- if debug_mode then
   --  diag_dda_steps_total+=dda_steps
   --  diag_dda_early_outs+=1
   -- end
   return 999,hx,hy,0,0
  end
  
  if hz<vz then
   -- horizontal closer
   -- crossing a vertical gridline (x changes): choose the cell we are entering
   local gx=flr(hx)+(hdx<0 and -1 or 0)
   local gy=flr(hy)
   
   -- irreversible OOB check for horizontal candidate
   if (gx<0 and hdx<0) or (gx>=map_size and hdx>0) or (gy<0 and hdy<0) or (gy>=map_size and hdy>0) then
    -- if debug_mode then
    --  diag_dda_steps_total+=dda_steps
    --  diag_dda_early_outs+=1
    -- end
    return 999,hx,hy,0,0
   end
   
   if gx>=0 and gx<map_size and gy>=0 and gy<map_size then
    local m=get_wall(gx,gy)
    if m>0 then
     -- check if door
     if is_door(m) and doorgrid[gx][gy] then
     local dz=((hx+hdx/2-x)*fx+(hy+hdy/2-y)*fy)
      if dz<=vz then
       local open = test_door_mode and (test_door_open or 0) or doorgrid[gx][gy].open
       local dy_off=(hy+hdy/2)%1-open
       if dy_off>=0 then
        return dz,hx,hy,m,dy_off
       end
      end
     else
      -- wall hit
     -- if debug_mode then
     --  diag_dda_steps_total+=dda_steps
     -- end
     local z=((hx-x)*fx+(hy-y)*fy)
     -- texture coordinate from y-fraction; flip when rayDirX > 0
     local frac=hy-flr(hy)
     local tx=(hdx>0) and (1-frac) or frac
     return z,hx,hy,m,tx
     end
    end
   end
   hx+=hdx
   hy+=hdy
   hz+=hdz
  else
   -- vertical closer or equal
   -- crossing a horizontal gridline (y changes): choose the cell we are entering
   local gx=flr(vx)
   local gy=flr(vy)+(vdy<0 and -1 or 0)
   
   -- irreversible OOB check for vertical candidate
   if (gx<0 and vdx<0) or (gx>=map_size and vdx>0) or (gy<0 and vdy<0) or (gy>=map_size and vdy>0) then
    -- if debug_mode then
    --  diag_dda_steps_total+=dda_steps
    --  diag_dda_early_outs+=1
    -- end
    return 999,vx,vy,0,0
   end
   
   if gx>=0 and gx<map_size and gy>=0 and gy<map_size then
    local m=get_wall(gx,gy)
    if m>0 then
     -- check if door
     if is_door(m) and doorgrid[gx][gy] then
     local dz=((vx+vdx/2-x)*fx+(vy+vdy/2-y)*fy)
      if dz<=hz then
       local open = test_door_mode and (test_door_open or 0) or doorgrid[gx][gy].open
       local dx_off=(vx+vdx/2)%1-open
       if dx_off>=0 then
        return dz,vx,vy,m,dx_off
       end
      end
     else
      -- wall hit
     -- if debug_mode then
     --  diag_dda_steps_total+=dda_steps
     -- end
     local z=((vx-x)*fx+(vy-y)*fy)
     -- texture coordinate from x-fraction; flip when rayDirY < 0
     local frac=vx-flr(vx)
     local tx=(vdy<0) and (1-frac) or frac
     return z,vx,vy,m,tx
     end
    end
   end
   vx+=vdx
   vy+=vdy
   vz+=vdz
  end
 end
 
 -- fallback if iteration limit reached
-- if debug_mode then
--  diag_dda_steps_total+=dda_steps
--  diag_dda_early_outs+=1
-- end
 return 999,hx,hy,0,0
end

-- raycast entire scene
-- Note: ray arrays (ray_z, ray_x0, ray_x1, ray_dx, ray_dy, rbuf_tile, rbuf_tx)
-- use userdata for 24x performance gain per Picotron optimization guidelines
function raycast_scene()
 -- compute projection distance from FOV (fov is half-angle in radians)
 -- sdist = screen_center_x / tan(half_fov) ensures proper perspective mapping
 sdist=screen_center_x/math.tan(fov)
 
 -- classic forward basis: forward = (cos(a), sin(a))
 -- use cached cos/sin from _draw() if available
 local fwdx=(ca_cached or cos(player.a))
 local fwdy=(sa_cached or sin(player.a))
 maxz=0
 
  -- precompute per-ray screen spans (decouples ray_count from screen_width)
  -- only when active_ray_count changes
  local span_count = active_ray_count or ray_count
  if _last_span_count ~= span_count then
    for i=0,span_count-1 do
      ray_x0:set(i, flr(i*screen_width/span_count))
      ray_x1:set(i, max(ray_x0:get(i), flr((i+1)*screen_width/span_count)-1))
      -- precompute pixel center for camera-space offset (eliminates per-frame computation)
      local pixel_x=(ray_x0:get(i)+ray_x1:get(i))/2+0.5
      ray_px_center:set(i, pixel_x)
    end
    _last_span_count = span_count
  end
 
 for i=0,span_count-1 do
  -- use precomputed pixel center for camera-space offset
  local dx=ray_px_center:get(i)-screen_center_x
  local dy=sdist
  
  -- map camera-space to world-space and cache direction
  ray_dx:set(i, (-fwdy)*dx+fwdx*dy)
  ray_dy:set(i, ( fwdx)*dx+fwdy*dy)
  
  -- cast ray using cached direction
  local z,hx,hy,tile,tx=raycast(player.x,player.y,ray_dx:get(i),ray_dy:get(i),fwdx,fwdy)
  
  -- store hit data in dedicated per-ray arrays
  ray_z:set(i, z)
  rbuf_tile:set(i, tile)
  rbuf_tx:set(i, tx)
  
  maxz=max(maxz,z)
 end
 
 -- frustum AABB computation removed; sprite culling now uses distance checks
end

-- compute_frustum_aabb removed (distance-based culling is used instead)

-- hitscan for projectiles/line-of-sight
function hitscan(x,y,dx,dy)
 -- normalize and get wall depth
 local sa,ca=normalise(dx,dy)
 local d,hx,hy,tile,tx=raycast(x,y,dx,dy,sa,ca)
 
 local closest_obj=nil
 local closest_dist=d
 
 -- iterate all objects; check solid intersections before wall hit
 for ob in all(objects) do
  if ob and ob.pos and ob.typ and ob.typ.solid then
   local ox=ob.pos[1]-x
   local oy=ob.pos[2]-y
   local dn=ox*ca-oy*sa
   local dt=ox*sa+oy*ca
   if abs(dn)<= (ob.typ.w or 0)*0.5 and dt>0 and dt<d then
    if dt<closest_dist then
     closest_dist=dt
     closest_obj=ob
    end
   end
  end
 end
 
 return closest_obj,closest_dist
end

:: src/render.lua
--[[pod_format="raw",created="2025-11-07 21:17:11",modified="2025-11-07 21:48:08",revision=1]]
-- rendering pipeline

-- track warned sprite indices to avoid per-frame spam
warned_sprites={}

-- lazy initialization flag for error texture
error_texture_initialized=false

-- persistent caches for textures and average colors across frames
tex_cache={}
avg_color_cache={}
-- Cache size limits to prevent unbounded growth (Picotron optimization guideline)
local CACHE_CAPACITY = 256  -- Max entries per cache (covers all game sprites + buffer)
local tex_cache_index = 0   -- Circular buffer write index for tex_cache
local avg_cache_index = 0   -- Circular buffer write index for avg_color_cache
local tex_cache_keys = {}   -- Array of tile IDs in insertion order (max 256)
local avg_cache_keys = {}   -- Array of tile IDs in insertion order (max 256)

-- bounded cache insert helpers
function cache_tex(tile, src, is_fallback)
 if not tile or not src then return end
 if #tex_cache_keys < CACHE_CAPACITY then
  tex_cache[tile]={src=src,is_fallback=is_fallback}
  add(tex_cache_keys, tile)
 else
  local evict_idx = (tex_cache_index % CACHE_CAPACITY) + 1
  local evict_tile = tex_cache_keys[evict_idx]
  tex_cache[evict_tile] = nil
  tex_cache[tile]={src=src,is_fallback=is_fallback}
  tex_cache_keys[evict_idx] = tile
  tex_cache_index += 1
 end
end

function cache_avg(tile, color)
 if tile==nil or color==nil then return end
 if #avg_cache_keys < CACHE_CAPACITY then
  avg_color_cache[tile]=color
  add(avg_cache_keys, tile)
 else
  local evict_idx = (avg_cache_index % CACHE_CAPACITY) + 1
  local evict_tile = avg_cache_keys[evict_idx]
  avg_color_cache[evict_tile] = nil
  avg_color_cache[tile]=color
  avg_cache_keys[evict_idx] = tile
  avg_cache_index += 1
 end
end

-- clear caches when tiles/floor/ceiling change (e.g., on new floor)
function clear_texture_caches()
 -- Log cache statistics before clearing (useful for tuning CACHE_CAPACITY)
 if enable_diagnostics_logging then
  printh("tex_cache size: "..#tex_cache_keys.." / "..CACHE_CAPACITY)
  printh("avg_color_cache size: "..#avg_cache_keys.." / "..CACHE_CAPACITY)
 end
 tex_cache={}
 avg_color_cache={}
 warned_sprites={}
 
 -- Reset circular buffer tracking
 tex_cache_keys={}
 avg_cache_keys={}
 tex_cache_index=0
 avg_cache_index=0
end

-- initialize error texture on first access (defensive fallback)
function init_error_texture()
 if not error_texture_initialized and not error_texture then
  -- create default error texture if none exists
  error_texture = userdata("u8", 32, 32)
  for y=0,31 do
   for x=0,31 do
    local color = ((flr(x/4) + flr(y/4)) % 2 == 0) and 8 or 14
    error_texture:set(x, y, color)
   end
  end
  error_texture_initialized=true
 end
end

-- get appropriate error texture for object type
function get_error_texture(obj_type)
 if error_textures then
  return error_textures[obj_type] or error_textures.default
 end
 init_error_texture()
 return error_texture
end

-- get individual sprite userdata for tline3d by sprite index
function get_texture_source(sprite_index, obj_type)
 -- default to sprite 0 for backward compatibility
 sprite_index=sprite_index or 0
 obj_type=obj_type or "default"
 
 -- return sprite sheet userdata
 local src=get_spr(sprite_index)
 if not src then
  -- warn once per sprite index to avoid per-frame spam
  if not warned_sprites[sprite_index] then
   printh("warning: sprite "..sprite_index.." not found, using "..obj_type.." error texture")
   warned_sprites[sprite_index]=true
  end
  -- return appropriate error texture for object type
  return get_error_texture(obj_type),true
 end
 return src,false
end



-- =========================
-- Batched tline3d utilities
-- =========================
-- Each row: sprite_index, x0,y0,x1,y1, u0,v0,u1,v1, w0,w1, flags  (13 columns)
local TLINE_COLS=13
local tline_buf_capacity=screen_width*2
local tline_args=userdata("f64", TLINE_COLS, tline_buf_capacity)
local tline_count=0

local function batch_reset()
	tline_count=0
end

local function batch_push(idx,x0,y0,x1,y1,u0,v0,u1,v1,w0,w1,flags)
	if tline_count>=tline_buf_capacity then
		tline3d(tline_args, 0, tline_count, TLINE_COLS)
		tline_count=0
	end
	tline_args:set(0, tline_count, idx, x0, y0, x1, y1, u0, v0, u1, v1, w0 or 1, w1 or 1, flags or 0)
	tline_count+=1
end

local function batch_submit()
	if tline_count>0 then
		tline3d(tline_args, 0, tline_count, TLINE_COLS)
		tline_count=0
	end
end

-- =========================
-- Batched rectfill utility
-- =========================
-- Each row: x0,y0,x1,y1,c (5 columns)
local RECT_COLS=5
local rect_buf_capacity=screen_width*4
local rect_args=userdata("f64", RECT_COLS, rect_buf_capacity)
local rect_count=0
function rbatch_reset() rect_count=0 end
function rbatch_push(x0,y0,x1,y1,c)
	if rect_count>=rect_buf_capacity then
		rectfill(rect_args, 0, rect_count, RECT_COLS)
		rect_count=0
	end
	rect_args:set(0, rect_count, x0, y0, x1, y1, c)
	rect_count+=1
end
function rbatch_submit()
	if rect_count>0 then
		rectfill(rect_args, 0, rect_count, RECT_COLS)
		rect_count=0
	end
end

local function resolve_sprite_index(idx, kind)
	if idx and get_spr(idx) then
		return idx
	end
	if ERROR_IDX then
		if kind=="floor" then return ERROR_IDX.floor
		elseif kind=="ceiling" then return ERROR_IDX.ceiling
		elseif kind=="sprite" then return ERROR_IDX.sprite
		elseif kind=="door" then return ERROR_IDX.door
		else return ERROR_IDX.wall end
	end
	return 0
end

-- preallocated buffers for per-cell floor runs (avoid per-frame table allocations)
local RUN_CAP=1024
local runs_x0=userdata("i16", RUN_CAP)
local runs_x1=userdata("i16", RUN_CAP)
local runs_id=userdata("i16", RUN_CAP)
local merged_x0=userdata("i16", RUN_CAP)
local merged_x1=userdata("i16", RUN_CAP)
local merged_id=userdata("i16", RUN_CAP)

-- Precomputed wall y-ranges for merged rendering (avoid per-scanline recalculation)
local wall_y0 = {}   -- Top y-coordinate for each ray's wall
local wall_y1 = {}   -- Bottom y-coordinate for each ray's wall
local wall_valid = {} -- Boolean: true if ray hit a wall (z<999)
-- Cached per-ray wall draw data to minimize inner-loop work
local wall_tile = {}
local wall_tx = {}
local wall_u0 = {}
local wall_u1 = {}
local wall_spr_idx = {}
local wall_tdy0 = {}
local wall_tdy1 = {}
local wall_tiny = {}
local wall_z = {}

-- render perspective floor/ceiling and walls (flat shading, fog removed)
function render_floor_ceiling()
 palt(0,false)
 
 local fwdx=(ca_cached or cos(player.a))
 local fwdy=(sa_cached or sin(player.a))
 local tex_size=sprite_size or 32
 
 -- Precompute wall y-ranges for all rays (used during scanline iteration)
 local _rc = active_ray_count or ray_count
 for ray_idx=0,_rc-1 do
  local z=ray_z:get(ray_idx)
  if z<999 then
   -- Calculate wall height and y-range
   local h=sdist/z
   local y0 = screen_center_y-h/2
   local y1 = screen_center_y+h/2
   wall_y0[ray_idx]=y0
   wall_y1[ray_idx]=y1
   wall_z[ray_idx]=z
   -- screen-space tiny wall threshold (use LOD when very short)
   local tdy0=ceil(y0)
   local tdy1=min(flr(y1),screen_height-1)
   wall_tdy0[ray_idx]=tdy0
   wall_tdy1[ray_idx]=tdy1
   wall_tiny[ray_idx]=(tdy1 - tdy0) < (wall_tiny_screen_px or 4)
   -- cache texture info
   local tile=rbuf_tile:get(ray_idx)
   local tx=rbuf_tx:get(ray_idx)
   wall_tile[ray_idx]=tile
   wall_tx[ray_idx]=tx
  -- compute base u coordinate and possible interpolation with next ray
  local u0=tx*tex_size
  u0=max(0,min(tex_size-0.001,u0))
   local u1=u0
   if ray_idx<_rc-1 then
    local tile_next=rbuf_tile:get(ray_idx+1)
    if tile_next==tile then
     local tx_next=rbuf_tx:get(ray_idx+1)
    local u1_next=tx_next*tex_size
    u1_next=max(0,min(tex_size-0.001,u1_next))
     u1=u1_next
    end
   end
   wall_u0[ray_idx]=u0
   wall_u1[ray_idx]=u1
   -- resolve sprite once
   local spr_idx=resolve_sprite_index(tile, (is_door and is_door(tile)) and "door" or "wall")
   wall_spr_idx[ray_idx]=spr_idx
   wall_valid[ray_idx]=true
  else
   wall_valid[ray_idx]=false
  end
 end
 
 -- Draw ceiling and floor first so walls overlay them
 batch_reset()
 local roof_typ=roof.typ
 local roof_src,roof_fallback=get_texture_source(roof_typ.tex,"ceiling")
 if roof_fallback then roof_src=get_error_texture("ceiling") end
 draw_rows(roof_src,-screen_center_y,-1,roof_typ.scale,roof_typ.height,cam[1]-roof.x,cam[2]-roof.y,roof_typ.lit,fwdy,fwdx,roof_typ.tex,false)
 
 local floor_typ=floor.typ
 local floor_src,floor_fallback=get_texture_source(floor_typ.tex,"floor")
 if floor_fallback then floor_src=get_error_texture("floor") end
 draw_rows(floor_src,0,screen_center_y-1,floor_typ.scale,floor_typ.height,cam[1]-floor.x,cam[2]-floor.y,floor_typ.lit,fwdy,fwdx,floor_typ.tex,false)
 batch_submit()

 -- Render walls per-ray in a single vertical pass (drawn after floors)
 rbatch_reset()
 batch_reset()
 local any_rect=false
 for ray_idx=0,_rc-1 do
  if wall_valid[ray_idx] then
   -- read cached values
   local z=wall_z[ray_idx]
   local x0=ray_x0:get(ray_idx)
   local x1=ray_x1:get(ray_idx)
   if x0<=x1 then
    local tdy0=wall_tdy0[ray_idx]
    local tdy1=wall_tdy1[ray_idx]
    local tile=wall_tile[ray_idx]
    -- LOD or tiny: solid fill via rect batch
    if z>wall_lod_distance or wall_tiny[ray_idx] then
     local avg_color=avg_color_cache[tile]
     if not avg_color then
      local cached=tex_cache[tile]
      local src,is_fallback
      if cached then
       src,is_fallback=cached.src,cached.is_fallback
      else
       local obj_type=is_door and is_door(tile) and "door" or "wall"
       src,is_fallback=get_texture_source(tile,obj_type)
       cache_tex(tile, src, is_fallback)
      end
      avg_color=5
      if src and src.get then
       avg_color=src:get(16,16) or 5
      end
      cache_avg(tile, avg_color)
     end
     rbatch_push(x0, tdy0, x1, tdy1, avg_color)
     any_rect=true
     -- write zbuf for span
     for x=x0,x1 do
      if zwrite then zwrite(x,z) else zbuf:set(x,z) end
     end
    else
     -- textured vertical columns
     local u0=wall_u0[ray_idx]
     local u1=wall_u1[ray_idx]
     local spr_idx=wall_spr_idx[ray_idx]
     local y0=wall_y0[ray_idx]
     local y1=wall_y1[ray_idx]
     -- compute v0/v1 mapped across clipped span
     local full_h=y1-y0
     local v0=0
     local v1=tex_size
     if full_h>0 and tdy0<y1 then
      v0+=((tdy0-y0)/full_h)*tex_size
      v1=v0+tex_size
     end
     local span_w=max(1,(x1-x0))
     local delta_u=u1-u0
     if delta_u>tex_size*0.5 or delta_u < -tex_size*0.5 then
      delta_u=0
      u1=u0
     end
     local du=delta_u/span_w
     local u_interp=u0
     -- Hardcode flags=0 for consistent fast path (Picotron guideline: minimize tline3d overhead)
     local flags=0
     for x=x0,x1 do
      u_interp=max(0,min(tex_size-0.001,u_interp))
      batch_push(spr_idx, x, tdy0, x, tdy1, u_interp, v0, u_interp, v1, 1, 1, flags)
      if zwrite then zwrite(x, z) else zbuf:set(x,z) end
      u_interp+=du
     end
    end
   end
  end
 end
 if any_rect then
  -- apply dithering pattern and submit
  fillp(0x55aa55aa)
  rbatch_submit()
  fillp()
 end
 batch_submit()
 
 palt()
end

-- draw horizontal scanlines with 32x32 sprite sampling and optional wall rendering (flat shading)
function draw_rows(src,y0,y1,tilesize,height,cx,cy,lit,sa,ca,tex,render_walls)
 local size=sprite_size or 32
 
 for y=y0,y1 do
  -- calculate ray gradient using half-pixel offset (avoid horizon singularity)
  local y_offset
  if y>=0 then
   y_offset=y+0.5
  else
   y_offset=abs(y-0.5)
  end
  local g=y_offset/sdist
  if g<0.0001 then g=0.0001 end
  
  -- calculate z distance
  local z=(height or 0.5)/g
  
  -- calculate map coordinates
  local mx=(cx+z*sa)/tilesize
  local my=(cy+z*ca)/tilesize
  
  -- calculate texture deltas
  local s=sdist/z*tilesize
  local mdx=-ca/s
  local mdy=sa/s
  
  -- offset to left edge
  mx-=screen_center_x*mdx
  my-=screen_center_x*mdy
  
 -- diagnostics removed for production
  
  if per_cell_floors_enabled then
   -- per-cell floor type rendering using preallocated buffers (no per-frame table allocs)
   local sample_interval=12
   local rcount=0
   local cur_id=-1
   local cur_x0=0
   for x=0,screen_width-1,sample_interval do
    local wx=mx+x*mdx
    local wy=my+x*mdy
    local gx=flr(wx)
    local gy=flr(wy)
    local fid=get_floor(gx,gy)
    if cur_id<0 then
     cur_id=fid
     cur_x0=x
    elseif fid~=cur_id then
     if rcount<RUN_CAP then
      runs_x0:set(rcount, cur_x0)
      runs_x1:set(rcount, x-1)
      runs_id:set(rcount, cur_id)
      rcount+=1
     end
     cur_id=fid
     cur_x0=x
    end
   end
   if rcount<RUN_CAP then
    runs_x0:set(rcount, cur_x0)
    runs_x1:set(rcount, screen_width-1)
    runs_id:set(rcount, cur_id)
    rcount+=1
   end
   -- merge short runs into previous using preallocated buffers
   local mcount=0
   for i=0,rcount-1 do
    local x0i=runs_x0:get(i)
    local x1i=runs_x1:get(i)
    local fidi=runs_id:get(i)
    local width=x1i-x0i+1
    if width<4 and mcount>0 then
     local prev_x1=merged_x1:get(mcount-1)
     if x1i>prev_x1 then merged_x1:set(mcount-1, x1i) end
    else
     if mcount<RUN_CAP then
      merged_x0:set(mcount, x0i)
      merged_x1:set(mcount, x1i)
      merged_id:set(mcount, fidi)
      mcount+=1
     end
    end
   end
   -- draw all merged runs with batching
   for i=0,mcount-1 do
    local rx0=merged_x0:get(i)
    local rx1=merged_x1:get(i)
    local fid=merged_id:get(i)
    local run_tex=tex
    if fid>0 and fid<=#planetyps then
     run_tex=planetyps[fid].tex
    end
    local idx=resolve_sprite_index(run_tex,"floor")
    local u0=(mx+rx0*mdx)%1*size
    local v0=(my+rx0*mdy)%1*size
    u0=max(0,min(size-0.001,u0))
    v0=max(0,min(size-0.001,v0))
    local u1=u0+(rx1-rx0)*mdx*size
    local v1=v0+(rx1-rx0)*mdy*size
    batch_push(idx, rx0, screen_center_y+y, rx1, screen_center_y+y, u0, v0, u1, v1, 1, 1)
   end
  else
   -- simplified rendering: draw full scanline with single texture
   local idx=resolve_sprite_index(tex,"floor")
   local u0=(mx)%1*size
   local v0=(my)%1*size
  u0=max(0,min(size-0.001,u0))
  v0=max(0,min(size-0.001,v0))
   local u1=u0+(screen_width-1)*mdx*size
   local v1=v0+(screen_width-1)*mdy*size
   batch_push(idx, 0, screen_center_y+y, screen_width-1, screen_center_y+y, u0, v0, u1, v1, 1, 1)
  end
 end
end


:: src/render_sprite.lua
--[[pod_format="raw",created="2025-11-07 21:17:10",modified="2025-11-07 21:48:08",revision=1]]
-- sprite rendering pipeline

-- global sprite tline batch (12 cols: idx,x0,y0,x1,y1,u0,v0,u1,v1,w0,w1)
local SPR_TLINE_COLS=12
local spr_tline_capacity=screen_width*2
local spr_tline_args=userdata("f64", SPR_TLINE_COLS, spr_tline_capacity)
local spr_tline_count=0
local function sbatch_reset() spr_tline_count=0 end
local function sbatch_push(idx,x0,y0,x1,y1,u0,v0,u1,v1,w0,w1)
 if spr_tline_count>=spr_tline_capacity then
  tline3d(spr_tline_args, 0, spr_tline_count, SPR_TLINE_COLS)
  spr_tline_count=0
 end
 spr_tline_args:set(0, spr_tline_count, idx, x0, y0, x1, y1, u0, v0, u1, v1, w0 or 1, w1 or 1)
 spr_tline_count+=1
end
local function sbatch_submit()
 if spr_tline_count>0 then
  tline3d(spr_tline_args, 0, spr_tline_count, SPR_TLINE_COLS)
  spr_tline_count=0
 end
end

-- persistent depth buckets (0..15) reused each frame
sprite_buckets=sprite_buckets or {}
for i=0,7 do sprite_buckets[i]=sprite_buckets[i] or {} end
local function clear_buckets()
 for i=0,7 do
  local b=sprite_buckets[i]
  for j=#b,1,-1 do b[j]=nil end
 end
end

-- render sprites with z-buffer occlusion (flat array iteration with distance culling)
function render_sprites()
 -- use cached sin/cos from _draw() if available
 local sa,ca=sa_cached or sin(player.a),ca_cached or cos(player.a)
 
 -- frustum bounds check removed (distance-based culling in use)
 
 -- initialize depth buckets for sprite sorting
-- 8 total buckets: 0-7 for all sprites (upright and flat treated uniformly)
-- bucket size = far_plane / 8 (e.g., 25.0 / 8 = 3.125 units per bucket)
-- iterate all objects with distance culling (no spatial grid)
local bucket_size = far_plane / 8
 clear_buckets()
 
 -- iterate all objects with simple distance culling (no spatial grid)
 for ob in all(objects) do
  if ob and ob.pos and ob.typ then
   -- transform to view space
   local rx=ob.pos[1]-player.x
   local ry=ob.pos[2]-player.y
   
   -- simple distance culling using axis-aligned bound
   if abs(rx)>=far_plane or abs(ry)>=far_plane then
    goto skip_sprite
   end
   
   -- rotate to view-aligned coordinates (camera space)
   -- right = (-sin a, cos a), forward = (cos a, sin a)
   local x_cam = -sa*rx + ca*ry
   local z_cam =  ca*rx + sa*ry
   ob.rel[1]=x_cam
   ob.rel[2]=z_cam
   
   -- far-plane culling: skip sprites beyond far_plane
   if ob.rel[2]>far_plane then
    goto skip_sprite
   end
   
   -- depth culling: skip sprites beyond max wall depth
   if ob.rel[2]>=maxz then
    goto skip_sprite
   end
   
   -- cull behind camera and outside frustum
   local t=ob.typ
   local pass_frustum=false
   if ob.rel[2]>0.1 then
    if t.flat then
     -- flat sprites: require minimum distance to prevent z-division issues
     if ob.rel[2]>=t.w/2 then
      pass_frustum=true
     end
    else
     -- upright sprites: horizontal frustum culling
     if abs(ob.rel[1])-(t.w/2)<ob.rel[2]*(screen_center_x/sdist) then
      pass_frustum=true
     end
    end
   end
   
   if pass_frustum then
    -- compute bucket index based on depth
    -- bucket 0 = 0.0-6.25, bucket 1 = 6.25-12.5, ..., bucket 7 = 43.75-50.0+
    local bucket_idx = min(7, flr(ob.rel[2] / bucket_size))
    
    -- add to bucket
    add(sprite_buckets[bucket_idx], ob)
   end
   
   ::skip_sprite::
  end
 end
 
 -- draw sprites back-to-front using bucket iteration
-- bucket 7-0: farthest to nearest (bucket 7 = all sprites at far distance)
 palt(0,false)
 palt(14,true)
 
for bucket_idx=7,0,-1 do
  -- sort non-empty bucket by z descending (far to near) for correct sprite-sprite occlusion
  local bucket = sprite_buckets[bucket_idx]
 if #bucket > 4 then
   -- insertion sort by ob.rel[2] descending
   for i=2,#bucket do
    local ob = bucket[i]
    local z = ob.rel[2]
    local j = i - 1
    while j >= 1 and bucket[j].rel[2] < z do
     bucket[j+1] = bucket[j]
     j = j - 1
    end
    bucket[j+1] = ob
   end
  end
  
  for ob in all(bucket) do
   drawobj_single(ob, sa, ca)
  end
 end
 
 palt()
 clip()
end

-- draw single sprite object with z-buffer occlusion (color 0=opaque, color 14=transparent)
function drawobj_single(ob, sa, ca)
 if not ob or not ob.typ or not ob.rel then
  return
 end
  
  local t=ob.typ
  local x=ob.rel[1]
  local z=ob.rel[2]
  
  -- fetch sprite for this object
  local base_sprite_index = ob.sprite_index or t.mx
  local sprite_index = base_sprite_index
  
  -- handle animation with sequential sprite indexes
  if t.framect then
   local fr=flr(ob.frame or 0)
   if ob.animloop then
    fr=fr%t.framect
   else
    fr=min(fr,t.framect-1)
   end
   sprite_index = base_sprite_index + fr
  end
  
  -- validate sprite exists; if animation overflow, reset to base
  local test_src = get_spr(sprite_index)
  if not test_src then
   if sprite_index ~= base_sprite_index then
    -- animation frame overflow detected
    if not warned_sprites[base_sprite_index] then
     printh("warning: animation frame overflow for sprite "..base_sprite_index..", clamping to base")
     warned_sprites[base_sprite_index]=true
    end
    sprite_index = base_sprite_index
   end
  end
  
  local src,is_fallback = get_texture_source(sprite_index,"sprite")
  if is_fallback then
   src = get_error_texture("sprite")
  end
  
  -- get vertical offset (can be animated)
  local y=ob.y or t.y
  if t.yoffs then
   local frame = ob.frame or 0
   local frame_idx=flr(frame%#t.yoffs)+1
   if frame_idx>0 and frame_idx<=#t.yoffs then
    y+=t.yoffs[frame_idx]
   end
  end
  
  -- LOD: impostor rendering for distant sprites
  local sprite_lod_distance=fog_far*sprite_lod_ratio
  if z>sprite_lod_distance then
   -- sample average color from sprite center (defaults to fog color 5)
   local avg_color=5
   if src and src.get then
    avg_color=src:get(16,16) or 5
   end
   
   -- apply fog uniformly
  -- fog disabled
   
   -- project to screen space
   local f_lod=sdist/z
   local sx_lod=x*f_lod+screen_center_x
   local w_lod=t.w*f_lod
   
   -- compute vertical span
   local y0_lod,y1_lod
   if t.flat then
    local z0=z+t.w/2
    local z1=z-t.w/2
    y0_lod=y*sdist/z0+screen_center_y
    y1_lod=y*sdist/z1+screen_center_y
   else
    local sy_lod=y*f_lod+screen_center_y
    local h_lod=t.h*f_lod
    y0_lod=sy_lod-h_lod/2
    y1_lod=sy_lod+h_lod/2
   end
   
   -- clamp to screen bounds
   local x0=max(0,ceil(sx_lod-w_lod/2))
   local x1=min(screen_width-1,flr(sx_lod+w_lod/2))
   y0_lod=max(0,ceil(y0_lod))
   y1_lod=min(screen_height-1,flr(y1_lod))
   
  -- draw solid impostor columns with z-test (batched rectfill)
   if y1_lod>y0_lod and x1>=x0 then
   rbatch_reset()
   for px=x0,x1 do
    local zb=(zread and zread(px)) or (zbuf.get and zbuf:get(px)) or 999
    if z<zb then
      rbatch_push(px,y0_lod,px,y1_lod,avg_color)
      if zwrite then
       zwrite(px, z)
      elseif zbuf.set then
       zbuf:set(px, z)
      end
    end
   end
   rbatch_submit()
   end
   
   return
  end
  
  -- calculate scale factor (perspective)
  local f=sdist/z
  
  -- project to screen space
  local sx=x*f+screen_center_x
  local w=t.w*f
  
  -- calculate y coordinates (different for flat vs upright)
  local y0,y1
  if t.flat then
   -- floor-aligned sprite
   local z0=z+t.w/2
   local z1=z-t.w/2
   y0=y*sdist/z0+screen_center_y
   y1=y*sdist/z1+screen_center_y
  else
   -- upright sprite (use world-space height t.h, not pixel size sprite_size)
   local sy=y*f+screen_center_y
   local h=t.h*f
   y0=sy-h/2
   y1=sy+h/2
  end
  
  -- map screen dimensions to 32x32 sprite UV space
  local size=sprite_size or 32
  local sxd=size/w
  local syd=size/(y1-y0+0.01)
  
  -- UV coordinates start at (0,0) for top-left of 32x32 sprite
  local u0 = 0
  local v0 = 0
  
  -- compute floating left/top edges for sub-pixel adjustment
  local lx=sx-w/2
  local fy0=y0
  
  -- clamp to screen bounds (0 to screen_width-1 for X, 0 to screen_height-1 for Y)
  local x0=max(0,ceil(lx))
  local x1=min(screen_width-1,flr(sx+w/2))
  -- adjust u0 for x clipping
  if x0>lx then
   u0+=(x0-lx)*sxd
  end
  
  y0=max(0,ceil(fy0))
  y1=min(screen_height-1,flr(y1))
  -- adjust v0 for y clipping
  if y0>fy0 then
   v0+=(y0-fy0)*syd
  end
  
  -- guard against degenerate vertical or horizontal span
  if y1<=y0 or x1<x0 then
   return
  end
  
  -- set fog and palette
  if ob.pal then
   pal(ob.pal)
  else
   -- fog disabled
  end
  
  -- draw sprite column-by-column with z-buffer (no diagonal batching)
  local function resolve_sprite_index(idx, kind)
   if idx and get_spr(idx) then
    return idx
   end
   if ERROR_IDX then
    if kind=="sprite" then return ERROR_IDX.sprite else return ERROR_IDX.default end
   end
   return 0
  end
  local spr_idx=resolve_sprite_index(sprite_index,"sprite")
  sbatch_reset()
  for px=x0,x1 do
  local zb=(zread and zread(px)) or (zbuf.get and zbuf:get(px)) or 999
   if z<zb then
    local u=u0+(px-x0)*sxd
    sbatch_push(spr_idx, px, y0, px, y1, u, v0, u, v0+size, 1, 1)
    -- diagnostics removed for production
    if zwrite then
     zwrite(px, z)
    elseif zbuf.set then
     zbuf:set(px, z)
    end
   end
  end
  sbatch_submit()
  
  -- if a custom palette was applied, restore fog mapping for subsequent draws
  if ob.pal then
   -- fog state removed
  end
end

:: .info.pod
--[[pod,created="2025-11-07 22:14:20",modified="2025-11-10 12:35:37",runtime=21,workspaces={{location="main.lua#828",workspace_index=1}}]]
:: main.lua
b64$LS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNS0xMS0wNyAyMTowNDowNiIsbW9k
aWZpZWQ9IjIwMjUtMTEtMDcgMjI6MTg6NTEiLHJldmlzaW9uPTVdXQotLSBub25ib3kgcmF5Y2Fz
dCBlbmdpbmUgdjEuMAotLSBtYWluIGVudHJ5IHBvaW50CgppbmNsdWRlInNyYy9jb25maWcubHVh
IgppbmNsdWRlInNyYy9yYXljYXN0Lmx1YSIKaW5jbHVkZSJzcmMvcmVuZGVyLmx1YSIKaW5jbHVk
ZSJzcmMvcmVuZGVyX3Nwcml0ZS5sdWEiCmluY2x1ZGUic3JjL2Rvb3Jfc3lzdGVtLmx1YSIKaW5j
bHVkZSJzcmMvZHVuZ2Vvbl9nZW4ubHVhIgoKLS0gY29uc3RhbnRzCnBsYXllcl9jb2xsaXNpb25f
cmFkaXVzPTAuMTUKCmZ1bmN0aW9uIF9pbml0KCkKIHdpbmRvdyhzY3JlZW5fd2lkdGgsc2NyZWVu
X2hlaWdodCkKIAogLS0gcGluIG1hc2tzIHRvIGRlZmF1bHRzIGZvciBzaW5nbGUgY29sb3VyLXRh
YmxlIGZhc3QgcGF0aAogcG9rZSgweDU1MDgsMHgzZikgcG9rZSgweDU1MDksMHgzZikgcG9rZSgw
eDU1MGEsMHgzZikgcG9rZSgweDU1MGIsMHgwMCkKIAogLS0gdGlsZSAwIGRyYXdpbmcgc3RhdGU6
IHZlcmlmaWVkIG5vdCByZXF1aXJlZDsgbGVhdmUgMHg1ZjM2IGF0IGRlZmF1bHQgKG5vIGV4cGxp
Y2l0IHBva2UpCiAtLSBzc3ByKCkgdXNhZ2UgdmVyaWZpZWQ6IE5vbmUgaW4gcHJvZHVjdGlvbiBj
b2RlIChvbmx5IGluIHNhbXBsZSBmaWxlcykKIC0tIFBlciBQaWNvdHJvbiBndWlkZWxpbmVzOiBi
bGl0KCkgaXMgZmFzdGVyOyBIVUQvbWluaW1hcCB1c2UgZGlyZWN0IGRyYXdpbmcKIC0tIGNvbmZp
Z3VyYXRpb24gZ3VhcmQ6IHByZXZlbnQgZm9nIHBvcHBpbmcgYmV5b25kIGZhci1wbGFuZQogYXNz
ZXJ0KGZhcl9wbGFuZT49Zm9nX2ZhcisxLCJjb25maWcgZXJyb3I6IGZhcl9wbGFuZSBtdXN0IGJl
ID49IGZvZ19mYXIgKyAxIikKIAogLS0gZGVmZW5zaXZlIGRlZmF1bHRzIGlmIGNvbmZpZyBpbmNs
dWRlIGZhaWxlZCB0byBzZXQgdGhlbSBmb3IgYW55IHJlYXNvbgogaWYgbm90IG9iamdyaWRfc2l6
ZSB0aGVuIG9iamdyaWRfc2l6ZT01IGVuZAogaWYgbm90IG9iamdyaWRfYXJyYXlfc2l6ZSB0aGVu
IG9iamdyaWRfYXJyYXlfc2l6ZT0yNiBlbmQKIAogLS0gZnJhbWUgY291bnRlciBmb3IgYWkgdGlt
aW5nCiBmcmFtZV9jdD0wCiAKIC0tIHBsYXllciBzdGF0ZQogcGxheWVyPXsKICB4PTY0LHk9NjQs
CiAgYT0wLAogIHNwZD1wbGF5ZXJfbW92ZV9zcGVlZCwKICBrZXlzPXt9LAogIGhwPTEwMAogfQog
CiAtLSBpbnRlcmFjdGlvbiBzdGF0ZQogaW50ZXJhY3Rpb25fYWN0aXZlPWZhbHNlCiBjdXJyZW50
X2ludGVyYWN0PW5pbAogCiAtLSBjb21iYXQgc3RhdGUKIGluX2NvbWJhdD1mYWxzZQogY3VycmVu
dF90YXJnZXQ9bmlsCiAKIC0tIHRyYXAgbWVzc2FnZSB0aW1lcgogdHJhcF9tc2dfdGltZXI9MAog
CiAtLSBjYW1lcmEKIGNhbT17cGxheWVyLngscGxheWVyLnl9CiAKIC0tIG1hcCBhYnN0cmFjdGlv
biB3aXRoIHVzZXJkYXRhIGxheWVycwogbWFwPXt9CiBtYXAud2FsbHM9dXNlcmRhdGEoImkxNiIs
MTI4LDEyOCkKIG1hcC5kb29ycz11c2VyZGF0YSgiaTE2IiwxMjgsMTI4KQogbWFwLmZsb29ycz11
c2VyZGF0YSgiaTE2IiwxMjgsMTI4KQogCiAtLSBoZWxwZXI6IGdldCB3YWxsIHRpbGUKLS0gUHVy
cG9zZTogUmV0cmlldmUgd2FsbCB0aWxlIElEIGF0IGdyaWQgcG9zaXRpb24KIC0tIFBhcmFtZXRl
cnM6IHgsIHkgKGdyaWQgY29vcmRpbmF0ZXMgMC0xMjcpCiAtLSBSZXR1cm5zOiB0aWxlIElEICgw
PWVtcHR5LCA_MD13YWxsL2Rvb3IvZXhpdCkKIGZ1bmN0aW9uIGdldF93YWxsKHgseSkKIGlmIHg_
PTAgYW5kIHg8MTI4IGFuZCB5Pj0wIGFuZCB5PDEyOCB0aGVuCiAgcmV0dXJuIG1hcC53YWxsczpn
ZXQoeCx5KSBvciAwCiBlbmQKIHJldHVybiAwCiBlbmQKIAogLS0gaGVscGVyOiBzZXQgd2FsbCB0
aWxlCiBmdW5jdGlvbiBzZXRfd2FsbCh4LHksdmFsKQogIGlmIHg_PTAgYW5kIHg8MTI4IGFuZCB5
Pj0wIGFuZCB5PDEyOCB0aGVuCgkJbWFwLndhbGxzOnNldCh4LHksdmFsIG9yIDApCiAgZW5kCiBl
bmQKIAogLS0gaGVscGVyOiBnZXQgZG9vciB0aWxlCiBmdW5jdGlvbiBnZXRfZG9vcih4LHkpCiAg
aWYgeD49MCBhbmQgeDwxMjggYW5kIHk_PTAgYW5kIHk8MTI4IHRoZW4KICAgcmV0dXJuIG1hcC5k
b29yczpnZXQoeCx5KSBvciAwCiAgZW5kCiAgcmV0dXJuIDAKIGVuZAogCiAtLSBoZWxwZXI6IHNl
dCBkb29yIHRpbGUKIGZ1bmN0aW9uIHNldF9kb29yKHgseSx2YWwpCiAgaWYgeD49MCBhbmQgeDwx
MjggYW5kIHk_PTAgYW5kIHk8MTI4IHRoZW4KICAgbWFwLmRvb3JzOnNldCh4LHksdmFsIG9yIDAp
CiAgZW5kCiBlbmQKCiAtLSBoZWxwZXI6IGdldCBmbG9vciB0aWxlCiAtLSBQdXJwb3NlOiBSZXRy
aWV2ZSBmbG9vciB0eXBlIElEIGF0IGdyaWQgcG9zaXRpb24KIC0tIFBhcmFtZXRlcnM6IHgsIHkg
KGdyaWQgY29vcmRpbmF0ZXMgMC0xMjcpCiAtLSBSZXR1cm5zOiBmbG9vciB0eXBlIElEICgwPXVz
ZSBnbG9iYWwgZGVmYXVsdCwgMS04PXNwZWNpZmljIGZsb29yIHR5cGUgZnJvbSBwbGFuZXR5cHMp
CiAtLSBOb3RlczogRmxvb3IgdHlwZSBJRHMgbWFwIHRvIGluZGljZXMgaW4gdGhlIHBsYW5ldHlw
cyB0YWJsZSBkZWZpbmVkIGluIGNvbmZpZy5sdWEKIGZ1bmN0aW9uIGdldF9mbG9vcih4LHkpCiAg
aWYgeD49MCBhbmQgeDwxMjggYW5kIHk_PTAgYW5kIHk8MTI4IHRoZW4KICAgcmV0dXJuIG1hcC5m
bG9vcnM6Z2V0KHgseSkgb3IgMAogIGVuZAogIHJldHVybiAwCiBlbmQKCiAtLSBoZWxwZXI6IHNl
dCBmbG9vciB0aWxlCiAtLSBQdXJwb3NlOiBTdG9yZSBwZXItY2VsbCBmbG9vciB0eXBlIElEcyBm
b3IgdmFyaWVkIGZsb29yIHRleHR1cmVzCiAtLSBQYXJhbWV0ZXJzOiB4LCB5IChncmlkIGNvb3Jk
aW5hdGVzIDAtMTI3KSwgdmFsIChmbG9vciB0eXBlIElEIDAtOCkKIC0tIE5vdGVzOiAwPXVzZSBn
bG9iYWwgZGVmYXVsdCBmbG9vciB0eXBlLCAxLTg9c3BlY2lmaWMgZmxvb3IgdHlwZSBmcm9tIHBs
YW5ldHlwcwogZnVuY3Rpb24gc2V0X2Zsb29yKHgseSx2YWwpCiAgaWYgeD49MCBhbmQgeDwxMjgg
YW5kIHk_PTAgYW5kIHk8MTI4IHRoZW4KICAgLS0gbm9ybWFsaXplIHZhbCB0byB2YWxpZCByYW5n
ZSAwLTgKICAgaWYgdHlwZSh2YWwpfj0ibnVtYmVyIiBvciB2YWw9PW5pbCB0aGVuCiAgICB2YWw9
MAogICBlbHNlaWYgdmFsPDAgdGhlbgogICAgdmFsPTAKICAgZWxzZWlmIHZhbD44IHRoZW4KICAg
IHZhbD04CiAgIGVuZAogICBtYXAuZmxvb3JzOnNldCh4LHksdmFsKQogIGVuZAogZW5kCiAKIGRv
b3JncmlkPXt9CiBmb3IgaT0wLDEyNyBkbwogIGRvb3JncmlkW2ldPXt9CiAgZm9yIGo9MCwxMjcg
ZG8KICAgZG9vcmdyaWRbaV1bal09bmlsCiAgZW5kCiBlbmQKIAogLS0gaW5pdGlhbGl6ZSBmbG9v
ciBkYXRhCiBmb3IgaT0wLDEyNyBkbwogIGZvciBqPTAsMTI3IGRvCiAgIHNldF9mbG9vcihpLGos
MCkKICBlbmQKIGVuZAogIAogZG9vcnM9e30KIG9iamVjdHM9e30KIGFuaW1hdGVkX29iamVjdHM9
e30KIAotLSB6LWJ1ZmZlciBhbmQgZnJhbWUtc3RhbXAgYXMgdHlwZWQgdXNlcmRhdGEgZm9yIHNw
ZWVkCi0tIHpidWY6IHBlci1jb2x1bW4gZGVwdGggdmFsdWVzIChvbmUgeiBwZXIgc2NyZWVuIHgp
OyB6c3RhbXA6IGZyYW1lLXN0YW1wIHRvIGF2b2lkIHBlci1mcmFtZSBjbGVhcnMKIHpidWY9dXNl
cmRhdGEoImY2NCIsIHNjcmVlbl93aWR0aCkKIHpzdGFtcD11c2VyZGF0YSgiaTMyIiwgc2NyZWVu
X3dpZHRoKQogZm9yIGk9MCxzY3JlZW5fd2lkdGgtMSBkbwogIC0tIGluaXRpYWxpemUgc3RhbXBz
IHRvIDA7IHogdmFsdWVzIGFyZSBjb25zaWRlcmVkIGludmFsaWQgdW50aWwgc3RhbXBlZAogIHpz
dGFtcDpzZXQoaSwgMCkKIGVuZAogCiAtLSBkeW5hbWljIGJ1ZGdldHMKIGFjdGl2ZV9yYXlfY291
bnQ9cmF5X2NvdW50CiByb3dfc3RyaWRlX2R5bmFtaWM9cm93X3N0cmlkZQogCiAtLSBDb252ZXJ0
IHRvIHVzZXJkYXRhIGZvciAyNHggcGVyZm9ybWFuY2UgZ2FpbiAoUGljb3Ryb24gb3B0aW1pemF0
aW9uIGd1aWRlbGluZSkKIHJheV96ID0gdXNlcmRhdGEoImY2NCIsIHJheV9jb3VudCkKIHJheV94
MCA9IHVzZXJkYXRhKCJpMTYiLCByYXlfY291bnQpCiByYXlfeDEgPSB1c2VyZGF0YSgiaTE2Iiwg
cmF5X2NvdW50KQogcmF5X2R4ID0gdXNlcmRhdGEoImY2NCIsIHJheV9jb3VudCkKIHJheV9keSA9
IHVzZXJkYXRhKCJmNjQiLCByYXlfY291bnQpCiAKIC0tIFByZWNvbXB1dGVkIHBpeGVsIGNlbnRl
cnMgZm9yIGNhbWVyYS1zcGFjZSByYXkgb2Zmc2V0cyAoZWxpbWluYXRlcyBwZXItZnJhbWUgY29t
cHV0YXRpb24pCiByYXlfcHhfY2VudGVyID0gdXNlcmRhdGEoImY2NCIsIHJheV9jb3VudCkKIAog
LS0gSW5pdGlhbGl6ZSB3aXRoIGRlZmF1bHRzCiBmb3IgaT0wLHJheV9jb3VudC0xIGRvCiAgIHJh
eV96OnNldChpLCA5OTkpCiAgIHJheV94MDpzZXQoaSwgMCkKICAgcmF5X3gxOnNldChpLCAwKQog
ICByYXlfZHg6c2V0KGksIDApCiAgIHJheV9keTpzZXQoaSwgMCkKIGVuZAogCiAtLSByYnVmOiB1
c2Ugc2VwYXJhdGUgdXNlcmRhdGEgYXJyYXlzIGZvciB0aWxlIGFuZCB0eCAoYXZvaWQgbmVzdGVk
IHN0cnVjdHVyZXMpCiByYnVmX3RpbGUgPSB1c2VyZGF0YSgiaTE2IiwgcmF5X2NvdW50KQogcmJ1
Zl90eCA9IHVzZXJkYXRhKCJmNjQiLCByYXlfY291bnQpCiBmb3IgaT0wLHJheV9jb3VudC0xIGRv
CiAgIHJidWZfdGlsZTpzZXQoaSwgMCkKICAgcmJ1Zl90eDpzZXQoaSwgMCkKIGVuZAogCiAtLSBm
b2cgc3RhdGUgZm9yIGh5c3RlcmVzaXMKIGxhc3RfZm9nX3o9MAogCiAtLSBwcm9qZWN0aW9uIGNv
bnN0YW50IGRlZmluZWQgaW4gY29uZmlnLmx1YQogCiAtLSBmbG9vciBhbmQgcm9vZiBzdGF0ZQog
Zmxvb3I9e3R5cD1wbGFuZXR5cHNbMV0seD0wLHk9MH0KIHJvb2Y9e3R5cD1wbGFuZXR5cHNbM10s
eD0wLHk9MH0KIAogLS0gZ2VuZXJhdGUgZHVuZ2Vvbgogc3RhcnRfcG9zLGdlbl9zdGF0cz1nZW5l
cmF0ZV9kdW5nZW9uKCkKIAogLS0gbW9kZTogM2Qgb3IgMmQgbWFwCiB2aWV3X21vZGU9IjNkIiAt
LSBvciAiMmQiIGZvciBtaW5pbWFwCiAKIC0tIGRlYnVnIG1vZGUgZm9yIHJheSBjYXN0aW5nCiBk
ZWJ1Z19tb2RlPWZhbHNlCnNob3dfZGlhZ25vc3RpY3M9ZmFsc2UKZW5hYmxlX2RpYWdub3N0aWNz
X2xvZ2dpbmc9ZmFsc2UgIC0tIFBlcm1hbmVudGx5IGRpc2FibGVkIGZvciBwcm9kdWN0aW9uIHBl
cmZvcm1hbmNlCi0tIE9wdGlvbmFsOiByZS1lbmFibGUgYSBub24tcmVuZGVyIENQVSBnb3Zlcm5v
ciAoc2FtcGxlcyBDUFUgb3V0c2lkZSBfZHJhdygpKQplbmFibGVfbm9ucmVuZGVyX2dvdmVybm9y
PWZhbHNlCnJlY2VudF9jcHU9MAogCiAtLSBwZXJmb3JtYW5jZSB2YWxpZGF0aW9uIG1vZGU6IGRp
c2FibGVzIENQVSBnb3Zlcm5vciB0byBzdGFiaWxpemUgbWVhc3VyZW1lbnRzCiBwZXJmX3ZhbGlk
YXRpb249ZmFsc2UKIAogLS0gZGlhZ25vc3RpYyBjb3VudGVycyBmb3IgcGVyZm9ybWFuY2UgdHJh
Y2tpbmcKIGRpYWdfZGRhX3N0ZXBzX3RvdGFsPTAKIGRpYWdfZGRhX2Vhcmx5X291dHM9MAogZGlh
Z19mb2dfc3dpdGNoZXM9MAogZGlhZ193YWxsX3RsaW5lX3N1Ym1pdHM9MAogZGlhZ193YWxsX3Nh
bXBsZXM9MAogZGlhZ193YWxsX3BpeGVscz0wCiBkaWFnX2Zsb29yX3Jvd3M9MAogZGlhZ19mbG9v
cl9kcmF3X2NhbGxzPTAKIGRpYWdfc3ByaXRlX2NvbHVtbnM9MAogZGlhZ19mcmFtZV9jb3VudD0w
CiAKIC0tIHRlc3QgZG9vciBtb2RlCiB0ZXN0X2Rvb3JfbW9kZT1mYWxzZQoKIC0tIGNyZWF0ZSB0
aW50ZWQgZXJyb3IgdGV4dHVyZXMgZm9yIGRpZmZlcmVudCBvYmplY3QgdHlwZXMgKGNoZWNrZXJi
b2FyZCBwYXR0ZXJuKQogLS0gd2FsbHM6IG1hZ2VudGEvcGluayAoOC8xNCksIGZsb29yOiBibHVl
L2N5YW4gKDEyLzEzKSwgY2VpbGluZzogZ3JlZW4vZGFyayBncmVlbiAoMTEvMykKIC0tIHNwcml0
ZXM6IHllbGxvdy9vcmFuZ2UgKDEwLzkpLCBwcm9wczogcmVkL2Jyb3duICg4LzQpCiBlcnJvcl90
ZXh0dXJlcyA9IHsKICB3YWxsID0gdXNlcmRhdGEoInU4IiwgMzIsIDMyKSwKIGRvb3IgPSB1c2Vy
ZGF0YSgidTgiLCAzMiwgMzIpLAogIGZsb29yID0gdXNlcmRhdGEoInU4IiwgMzIsIDMyKSwKICBj
ZWlsaW5nID0gdXNlcmRhdGEoInU4IiwgMzIsIDMyKSwKICBzcHJpdGUgPSB1c2VyZGF0YSgidTgi
LCAzMiwgMzIpLAogIGRlZmF1bHQgPSB1c2VyZGF0YSgidTgiLCAzMiwgMzIpCiB9CiAKIC0tIGdl
bmVyYXRlIHRpbnRlZCBjaGVja2VyYm9hcmRzIGZvciBlYWNoIHR5cGUKIGxvY2FsIHRpbnRzID0g
ewogIHdhbGwgPSB7OCwgMTR9LCAgICAgIC0tIG1hZ2VudGEvcGluawogZG9vciA9IHsyLCA2fSwg
ICAgICAgLS0gcHVycGxlL2JsdWUgKGRpc3RpbmN0IGZyb20gd2FsbHMpCiAgZmxvb3IgPSB7MTIs
IDEzfSwgICAgLS0gYmx1ZS9jeWFuCiAgY2VpbGluZyA9IHsxMSwgM30sICAgLS0gZ3JlZW4vZGFy
ayBncmVlbgogIHNwcml0ZSA9IHsxMCwgOX0sICAgIC0tIHllbGxvdy9vcmFuZ2UKICBkZWZhdWx0
ID0gezgsIDE0fSAgICAtLSBtYWdlbnRhL3BpbmsgKGZhbGxiYWNrKQogfQogCiBmb3IgdHlwZV9u
YW1lLCBjb2xvcnMgaW4gcGFpcnModGludHMpIGRvCiAgZm9yIHk9MCwzMSBkbwogICBmb3IgeD0w
LDMxIGRvCiAgICBsb2NhbCBjb2xvciA9ICgoZmxyKHgvNCkgKyBmbHIoeS80KSkgJSAyID09IDAp
IGFuZCBjb2xvcnNbMV0gb3IgY29sb3JzWzJdCiAgICBlcnJvcl90ZXh0dXJlc1t0eXBlX25hbWVd
OnNldCh4LCB5LCBjb2xvcikKICAgZW5kCiAgZW5kCiBlbmQKIAogLS0gbWFpbnRhaW4gYmFja3dh
cmQgY29tcGF0aWJpbGl0eSB3aXRoIHNpbmdsZSBlcnJvcl90ZXh0dXJlCiBlcnJvcl90ZXh0dXJl
ID0gZXJyb3JfdGV4dHVyZXMuZGVmYXVsdAoKIC0tIHJlc2VydmUgc3ByaXRlIGluZGV4ZXMgZm9y
IGVycm9yIHRleHR1cmVzIChiYXRjaGluZyBwcmVmZXJzIHNwcml0ZSBpbmRleGVzKQogRVJST1Jf
SURYID0geyB3YWxsPTgwMDAsIGRvb3I9ODAwMSwgZmxvb3I9ODAwMiwgY2VpbGluZz04MDAzLCBz
cHJpdGU9ODAwNCwgZGVmYXVsdD04MDA1IH0KIGZvciBuYW1lLCB1ZCBpbiBwYWlycyhlcnJvcl90
ZXh0dXJlcykgZG8KICBsb2NhbCBpZHggPSBFUlJPUl9JRFhbbmFtZV0gb3IgRVJST1JfSURYLmRl
ZmF1bHQKICBzZXRfc3ByKGlkeCwgdWQpCiBlbmQKIAogLS0gUHJlbG9hZCB0ZXh0dXJlIGNhY2hl
IGZvciBjb21tb25seS11c2VkIHNwcml0ZXMgKDAtMjAwKQogLS0gUG9wdWxhdGUgdGV4X2NhY2hl
IGRpcmVjdGx5IHVzaW5nIGdldF9zcHIoKSB0byBhdm9pZCB3YXJuaW5ncwogcHJpbnRoKCJwcmVs
b2FkaW5nIHRleHR1cmUgY2FjaGUuLi4iKQogbG9jYWwgcHJlbG9hZF9zdGFydCA9IHRpbWUoKQog
Zm9yIGk9MCwyMDAgZG8KICBsb2NhbCBzcmM9Z2V0X3NwciBhbmQgZ2V0X3NwcihpKQogIGlmIHNy
YyBhbmQgY2FjaGVfdGV4IHRoZW4KICAgY2FjaGVfdGV4KGksIHNyYywgZmFsc2UpCiAgZW5kCiBl
bmQKIGxvY2FsIHByZWxvYWRfdGltZSA9ICh0aW1lKCkgLSBwcmVsb2FkX3N0YXJ0KSAqIDEwMDAK
IHByaW50aCgidGV4dHVyZSBjYWNoZSBwcmVsb2FkZWQ6ICIuLnByZWxvYWRfdGltZS4uIm1zIikK
IC0tIFRyaWdnZXIgR0MgYWZ0ZXIgcHJlbG9hZGluZyAoUGljb3Ryb24gZ3VpZGVsaW5lOiBzdGF0
KDApIGR1cmluZyBwYXVzZXMgb25seSkKIHN0YXQoMCkKIAogLS0gbG9nZ2luZyBoZWxwZXI6IGNv
bnNvbGUgKyByaW5nIGJ1ZmZlciBmb3Igb3B0aW9uYWwgb24tc2NyZWVuIGVjaG8KIGxvZ19saW5l
cyA9IHt9CiBmdW5jdGlvbiBsb2coc3RyKQogIHByaW50aChzdHIpCiAgYWRkKGxvZ19saW5lcywg
c3RyKQogIGlmICNsb2dfbGluZXMgPiAyMDAgdGhlbiBkZWxpKGxvZ19saW5lcywgMSkgZW5kCiBl
bmQKCiAtLSB2YWxpZGF0ZSBhbGwgY29uZmlndXJlZCBzcHJpdGVzIGV4aXN0IChjb21tZW50IG91
dCBmb3IgcHJvZHVjdGlvbikKIHZhbGlkYXRlX3Nwcml0ZV9jb25maWd1cmF0aW9uKCkKCiBwcmlu
dGgoInBpY290cm9uIHJheWNhc3QgZW5naW5lIHYxLjAiKQplbmQKCi0tIHZhbGlkYXRlIHNwcml0
ZSBjb25maWd1cmF0aW9uIGF0IHN0YXJ0dXAgKG9wdGlvbmFsLCBjYW4gYmUgZGlzYWJsZWQgZm9y
IHBlcmZvcm1hbmNlKQpmdW5jdGlvbiB2YWxpZGF0ZV9zcHJpdGVfY29uZmlndXJhdGlvbigpCiAt
LSBjaGVjayBlbmVteSBzcHJpdGVzCiBmb3IgZW5lbXkgaW4gYWxsKGVuZW15X3R5cGVzKSBkbwog
IGlmIG5vdCBnZXRfc3ByKGVuZW15LnNwcml0ZSkgdGhlbgogICBwcmludGgoIldBUk5JTkc6IGVu
ZW15IHNwcml0ZSAiLi5lbmVteS5zcHJpdGUuLiIgKCIuLmVuZW15Lm5hbWUuLiIpIG5vdCBmb3Vu
ZCBpbiBHRlggZmlsZXMiKQogIGVuZAogZW5kCiAKIC0tIGNoZWNrIGRlY29yYXRpb24gc3ByaXRl
cwogZm9yIGRlYyBpbiBhbGwoZGVjb3JhdGlvbl90eXBlcykgZG8KICBpZiBub3QgZ2V0X3Nwcihk
ZWMuc3ByaXRlKSB0aGVuCiAgIHByaW50aCgiV0FSTklORzogZGVjb3JhdGlvbiBzcHJpdGUgIi4u
ZGVjLnNwcml0ZS4uIiAoIi4uZGVjLm5hbWUuLiIpIG5vdCBmb3VuZCBpbiBHRlggZmlsZXMiKQog
IGVuZAogZW5kCiAKIC0tIGNoZWNrIHdhbGwgdGV4dHVyZSBzcHJpdGVzCiBmb3IgdGV4c2V0IGlu
IGFsbCh0ZXhzZXRzKSBkbwogIGZvciB2YXJpYW50IGluIGFsbCh0ZXhzZXQudmFyaWFudHMpIGRv
CiAgIGlmIG5vdCBnZXRfc3ByKHZhcmlhbnQpIHRoZW4KICAgIHByaW50aCgiV0FSTklORzogd2Fs
bCB0ZXh0dXJlIHNwcml0ZSAiLi52YXJpYW50Li4iIG5vdCBmb3VuZCBpbiBHRlggZmlsZXMiKQog
ICBlbmQKICBlbmQKIGVuZAogCiAtLSBjaGVjayBmbG9vci9jZWlsaW5nIHNwcml0ZXMKIGZvciB0
eXAgaW4gYWxsKHBsYW5ldHlwcykgZG8KICBpZiBub3QgZ2V0X3Nwcih0eXAudGV4KSB0aGVuCiAg
IHByaW50aCgiV0FSTklORzogZmxvb3IvY2VpbGluZyBzcHJpdGUgIi4udHlwLnRleC4uIiBub3Qg
Zm91bmQgaW4gR0ZYIGZpbGVzIikKICBlbmQKIGVuZAplbmQKCmZ1bmN0aW9uIF91cGRhdGUoKQog
LS0gaW5jcmVtZW50IGZyYW1lIGNvdW50ZXIKIGZyYW1lX2N0Kz0xCiAKIC0tIG9wdGlvbmFsOiBz
YW1wbGUgQ1BVIG91dHNpZGUgcmVuZGVyIGZyYW1lIChldmVyeSAzMCBmcmFtZXMpIGZvciBub24t
cmVuZGVyIGdvdmVybm9yCiBpZiBlbmFibGVfbm9ucmVuZGVyX2dvdmVybm9yIGFuZCAoZnJhbWVf
Y3QlMzA9PTApIHRoZW4KICByZWNlbnRfY3B1PXN0YXQoMSkgb3IgMAogZW5kCiAKIC0tIGNvbWJh
dCBnYXRpbmc6IHNraXAgbm9ybWFsIHVwZGF0ZXMgd2hlbiBpbiBjb21iYXQKIGlmIGluX2NvbWJh
dCB0aGVuCiAgdXBkYXRlX2NvbWJhdCgpCiAgcmV0dXJuCiBlbmQKIAogdXBkYXRlX2lucHV0KCkK
IHVwZGF0ZV9kb29ycygpCiAKIC0tIHVwZGF0ZSBucGMgYWkgKHJhdGUgbGltaXRlZCwgZGV0ZXJt
aW5pc3RpYyBmcmFtZSBjaGVjaykKIGlmIGZyYW1lX2N0JWFpX3VwZGF0ZV9yYXRlPT0wIHRoZW4K
ICB1cGRhdGVfbnBjX2FpKCkKIGVuZAogCiBjYW09e3BsYXllci54LHBsYXllci55fQogCiAtLSB1
cGRhdGUgZmxvb3IvY2VpbGluZyBzY3JvbGxpbmcKIGZsb29yLngrPWZsb29yLnR5cC54dmVsIG9y
IDAKIGZsb29yLnkrPWZsb29yLnR5cC55dmVsIG9yIDAKIHJvb2YueCs9cm9vZi50eXAueHZlbCBv
ciAwCiByb29mLnkrPXJvb2YudHlwLnl2ZWwgb3IgMAogCiAtLSB1cGRhdGUgb2JqZWN0IGFuaW1h
dGlvbnMKIGZvciBvYiBpbiBhbGwoYW5pbWF0ZWRfb2JqZWN0cykgZG8KICBpZiBvYi50eXAgYW5k
IG9iLnR5cC5mcmFtZWN0IHRoZW4KICAgb2IuZnJhbWUrPW9iLnR5cC5hbmltc3BkCiAgIGlmIG9i
LmFuaW1sb29wIHRoZW4KICAgIG9iLmZyYW1lPW9iLmZyYW1lJW9iLnR5cC5mcmFtZWN0CiAgIGVs
c2UKICAgIG9iLmZyYW1lPW1pbihvYi5mcmFtZSxvYi50eXAuZnJhbWVjdC0xKQogICBlbmQKICBl
bmQKIGVuZAogCiAtLSB0b2dnbGUgdmlldyBtb2RlIChkZWJ1ZyBvbmx5KQogaWYgZGVidWdfbW9k
ZSBhbmQgKGtleXAoIngiKSBvciBidG5wKDUpKSB0aGVuCiAgdmlld19tb2RlPXZpZXdfbW9kZT09
IjNkIiBhbmQgIjJkIiBvciAiM2QiCiBlbmQKIAogLS0gZGVidWcgbW9kZSB0b2dnbGUgKG1vdmVk
IGZyb20gYnRucCg0KSB0byBhdm9pZCBjb25mbGljdCkKIGlmIGtleXAoInRhYiIpIHRoZW4KICBk
ZWJ1Z19tb2RlPW5vdCBkZWJ1Z19tb2RlCiBlbmQKIAogLS0gZGlhZ25vc3RpY3Mgb3ZlcmxheSBy
ZW1vdmVkOyBtZXJnZWQgaW50byBkZWJ1ZyBwYW5lbCAoVGFiKQogCiAtLSB0b2dnbGUgZGlhZ25v
c3RpY3MgbG9nZ2luZyAoY29udHJvbGxlciBidXR0b24gMTIpCiBpZiBidG5wKDEyKSB0aGVuCiAg
ZW5hYmxlX2RpYWdub3N0aWNzX2xvZ2dpbmc9bm90IGVuYWJsZV9kaWFnbm9zdGljc19sb2dnaW5n
CiAgcHJpbnRoKCJEaWFnbm9zdGljcyBsb2dnaW5nOiAiLi50b3N0cmluZyhlbmFibGVfZGlhZ25v
c3RpY3NfbG9nZ2luZykpCiBlbmQKIAogLS0gZGVjcmVtZW50IHRyYXAgbWVzc2FnZSB0aW1lcgog
aWYgdHJhcF9tc2dfdGltZXI_MCB0aGVuCiAgdHJhcF9tc2dfdGltZXItPTEKIGVuZAogCiAtLSB0
b2dnbGUgdGVzdCBkb29yIG1vZGUgKHdoZW4gbm90IGluIDJkIG1hcCB2aWV3KQogaWYgdmlld19t
b2RlPT0iM2QiIGFuZCAoa2V5cCgidiIpIG9yIGJ0bnAoMTUpKSB0aGVuCiAgdGVzdF9kb29yX21v
ZGU9bm90IHRlc3RfZG9vcl9tb2RlCiBlbmQKIAogLS0gY3ljbGUgdGVzdCBkb29yIG9wZW4gdmFs
dWUgKDAuMCB0byAxLjApCiBpZiB0ZXN0X2Rvb3JfbW9kZSB0aGVuCiAgaWYga2V5cCgiYyIpIHRo
ZW4KICAgdGVzdF9kb29yX29wZW49KHRlc3RfZG9vcl9vcGVuIG9yIDApKzAuMQogICBpZiB0ZXN0
X2Rvb3Jfb3Blbj4xIHRoZW4gdGVzdF9kb29yX29wZW49MCBlbmQKICBlbmQKICBpZiBrZXlwKCJk
IikgdGhlbgogICB0ZXN0X2Rvb3Jfb3Blbj0odGVzdF9kb29yX29wZW4gb3IgMCktMC4xCiAgIGlm
IHRlc3RfZG9vcl9vcGVuPDAgdGhlbiB0ZXN0X2Rvb3Jfb3Blbj0xIGVuZAogIGVuZAogZW5kCiAK
IC0tIGN5Y2xlIGZsb29yIHR5cGUgKGZvciB0ZXN0aW5nKSB3aGVuIG5vdCBpbiBkb29yIHRlc3Qg
bW9kZQogaWYgbm90IHRlc3RfZG9vcl9tb2RlIGFuZCBrZXlwKCJjIikgdGhlbgogIGxvY2FsIGN1
cnJlbnRfaWR4PTEKICBmb3IgaT0xLCNwbGFuZXR5cHMgZG8KICAgaWYgcGxhbmV0eXBzW2ldLnRl
eD09Zmxvb3IudHlwLnRleCB0aGVuCiAgICBjdXJyZW50X2lkeD1pCiAgICBicmVhawogICBlbmQK
ICBlbmQKICBmbG9vci50eXA9cGxhbmV0eXBzWyhjdXJyZW50X2lkeCAlICNwbGFuZXR5cHMpKzFd
CiAgZmxvb3IueCxmbG9vci55PTAsMAogIC0tIFRlc3QgbW9kZTogY2xlYXIgY2FjaGUgd2hlbiBj
eWNsaW5nIGZsb29yIHR5cGVzIChjYW4gYmUgZGlzYWJsZWQgaW4gcHJvZHVjdGlvbikKICBpZiBj
bGVhcl90ZXh0dXJlX2NhY2hlcyB0aGVuIGNsZWFyX3RleHR1cmVfY2FjaGVzKCkgZW5kCiBlbmQK
IAogLS0gY3ljbGUgcm9vZiB0eXBlIChmb3IgdGVzdGluZykgd2hlbiBub3QgaW4gZG9vciB0ZXN0
IG1vZGUKIGlmIG5vdCB0ZXN0X2Rvb3JfbW9kZSBhbmQga2V5cCgiZCIpIHRoZW4KICBsb2NhbCBj
dXJyZW50X2lkeD0xCiAgZm9yIGk9MSwjcGxhbmV0eXBzIGRvCiAgIGlmIHBsYW5ldHlwc1tpXS50
ZXg9PXJvb2YudHlwLnRleCB0aGVuCiAgICBjdXJyZW50X2lkeD1pCiAgICBicmVhawogICBlbmQK
ICBlbmQKICByb29mLnR5cD1wbGFuZXR5cHNbKGN1cnJlbnRfaWR4ICUgI3BsYW5ldHlwcykrMV0K
ICByb29mLngscm9vZi55PTAsMAogIC0tIFRlc3QgbW9kZTogY2xlYXIgY2FjaGUgd2hlbiBjeWNs
aW5nIHJvb2YgdHlwZXMgKGNhbiBiZSBkaXNhYmxlZCBpbiBwcm9kdWN0aW9uKQogIGlmIGNsZWFy
X3RleHR1cmVfY2FjaGVzIHRoZW4gY2xlYXJfdGV4dHVyZV9jYWNoZXMoKSBlbmQKIGVuZAogCiAt
LSBkZWJ1ZyByYXkgY2FzdGluZwogIGlmIGRlYnVnX21vZGUgdGhlbgogICBsb2NhbCBzYSxjYT1z
aW4ocGxheWVyLmEpLGNvcyhwbGF5ZXIuYSkKICAgbG9jYWwgeixoeCxoeSx0aWxlLHR4PXJheWNh
c3QocGxheWVyLngscGxheWVyLnksY2Esc2Esc2EsY2EpCiAgIHByaW50aCgiZGVidWc6IHo9Ii4u
KGZscih6KjEwMCkvMTAwKS4uIiBoeD0iLi4oZmxyKGh4KjEwMCkvMTAwKS4uIiBoeT0iLi4oZmxy
KGh5KjEwMCkvMTAwKS4uIiB0aWxlPSIuLnRpbGUuLiIgdHg9Ii4uKGZscih0eCoxMDApLzEwMCkp
CiAgIGxvY2FsIG9iLGRpc3Q9aGl0c2NhbihwbGF5ZXIueCxwbGF5ZXIueSxjYSxzYSkKICAgaWYg
b2IgdGhlbgogICAgcHJpbnRoKCJkZWJ1Zzogb2JqIGZvdW5kIGF0IGRpc3Q9Ii4uKGZscihkaXN0
KjEwMCkvMTAwKS4uIiBraW5kPSIuLihvYi5raW5kIG9yICJ1bmtub3duIikpCiAgIGVsc2UKICAg
IHByaW50aCgiZGVidWc6IG5vIG9iaiBoaXQiKQogICBlbmQKICBlbmQKZW5kCgpmdW5jdGlvbiBf
ZHJhdygpCiBjbGlwKDAsMCxzY3JlZW5fd2lkdGgsc2NyZWVuX2hlaWdodCkKIGNscygwKQogCiBs
b2NhbCBmcmFtZV9zdGFydD10aW1lKCkKIAogZGlhZ19mcmFtZV9jb3VudCs9MQogCi0tIEVuc3Vy
ZSBhZGFwdGl2ZSBjb250cm9scyBhcmUgaW5pdGlhbGl6ZWQgb25jZQppZiBub3QgYWN0aXZlX3Jh
eV9jb3VudCB0aGVuIGFjdGl2ZV9yYXlfY291bnQ9cmF5X2NvdW50IGVuZAppZiBub3Qgcm93X3N0
cmlkZV9keW5hbWljIHRoZW4gcm93X3N0cmlkZV9keW5hbWljPXJvd19zdHJpZGUgZW5kCgpsb2Nh
bCBmdW5jdGlvbiBhZGp1c3RfcmF5X2J1ZGdldChjcHVfc2FtcGxlKQogbG9jYWwgbWluX3JheXM9
bWF4KDQ4LCBmbHIocmF5X2NvdW50KjAuMjUpKQogaWYgY3B1X3NhbXBsZT4wLjkwIHRoZW4KICBh
Y3RpdmVfcmF5X2NvdW50PW1heChtaW5fcmF5cywgYWN0aXZlX3JheV9jb3VudC0xNikKIGVsc2Vp
ZiBjcHVfc2FtcGxlPDAuNzAgdGhlbgogIGFjdGl2ZV9yYXlfY291bnQ9bWluKHJheV9jb3VudCwg
YWN0aXZlX3JheV9jb3VudCs4KQogZW5kCmVuZAoKLS0gTGlnaHR3ZWlnaHQgQ1BVIHNhbXBsZXIg
aW4gX2RyYXcoKSAoZXZlcnkgNjAgZnJhbWVzKSBmb3IgYWRhcHRpdmUgcXVhbGl0eQppZiBub3Qg
cGVyZl92YWxpZGF0aW9uIGFuZCAoZGlhZ19mcmFtZV9jb3VudCAlIDYwID09IDApIHRoZW4KIGxv
Y2FsIGNwdSA9IHN0YXQoMSkgb3IgMAogaWYgbm90IGVuYWJsZV9ub25yZW5kZXJfZ292ZXJub3Ig
dGhlbgogIGFkanVzdF9yYXlfYnVkZ2V0KGNwdSkKIGVuZAplbmQKCi0tIE9wdGlvbmFsIG5vbi1y
ZW5kZXIgZ292ZXJub3I6IHVzZXMgQ1BVIHNhbXBsZWQgaW4gX3VwZGF0ZSgpLCBuZXZlciBjYWxs
cyBzdGF0KDEpIGhlcmUKaWYgZW5hYmxlX25vbnJlbmRlcl9nb3Zlcm5vciB0aGVuCiBhZGp1c3Rf
cmF5X2J1ZGdldChyZWNlbnRfY3B1IG9yIDApCmVuZAogCiAtLSB6LWJ1ZmZlciBoZWxwZXJzICh1
c2UgZnJhbWUtc3RhbXAsIGRlZmluZWQgb25jZSkKIGlmIG5vdCB6cmVhZCB0aGVuCiAgZnVuY3Rp
b24genJlYWQoeCkKICAgLS0geCBpcyAwLWJhc2VkOyByZXR1cm4gOTk5IHVubGVzcyBzdGFtcGVk
IHRoaXMgZnJhbWUKICAgbG9jYWwgc3RhbXA9enN0YW1wOmdldCh4KSBvciAwCiAgIGlmIHN0YW1w
PT1kaWFnX2ZyYW1lX2NvdW50IHRoZW4KICAgIGxvY2FsIHo9emJ1ZjpnZXQoeCkKICAgIHJldHVy
biB6IG9yIDk5OQogICBlbmQKICAgcmV0dXJuIDk5OQogIGVuZAogIGZ1bmN0aW9uIHp3cml0ZSh4
LHopCiAgIHpidWY6c2V0KHgseikKICAgenN0YW1wOnNldCh4LGRpYWdfZnJhbWVfY291bnQpCiAg
ZW5kCiBlbmQKIAogLS0gY2FjaGUgc2luL2NvcyBmb3IgZW50aXJlIGZyYW1lIHRvIGF2b2lkIHJl
Y29tcHV0YXRpb24KIHNhX2NhY2hlZD1zaW4ocGxheWVyLmEpCiBjYV9jYWNoZWQ9Y29zKHBsYXll
ci5hKQogCiBpZiB2aWV3X21vZGU9PSIzZCIgdGhlbgogIHJheWNhc3Rfc2NlbmUoKQogIGxvY2Fs
IHRfcmF5Y2FzdD10aW1lKCkKICByZW5kZXJfZmxvb3JfY2VpbGluZygpICAtLSBOb3cgaW5jbHVk
ZXMgd2FsbCByZW5kZXJpbmcKICBsb2NhbCB0X2Zsb29yX3dhbGxzPXRpbWUoKQogIHJlbmRlcl9z
cHJpdGVzKCkKICBsb2NhbCB0X3Nwcml0ZXM9dGltZSgpCiAgCiAgbG9jYWwgbXNfcmF5Y2FzdD0o
dF9yYXljYXN0LWZyYW1lX3N0YXJ0KSoxMDAwCiAgbG9jYWwgbXNfZmxvb3Jfd2FsbHM9KHRfZmxv
b3Jfd2FsbHMtdF9yYXljYXN0KSoxMDAwCiAgbG9jYWwgbXNfc3ByaXRlcz0odF9zcHJpdGVzLXRf
Zmxvb3Jfd2FsbHMpKjEwMDAKICBsb2NhbCBmcmFtZV9tcz0odF9zcHJpdGVzLWZyYW1lX3N0YXJ0
KSoxMDAwCiAgCiAgLS0gaHVkCiAgcHJpbnQoInBvczoiLi5mbHIocGxheWVyLngpLi4iLCIuLmZs
cihwbGF5ZXIueSksMiwyLDcpCiAgcHJpbnQoImFuZzoiLi4oZmxyKHBsYXllci5hKjEwMCkvMTAw
KSwyLDEwLDcpCiAgcHJpbnQoImZwczoiLi5zdGF0KDcpLDIsMTgsNykKICBwcmludCgiaHA6Ii4u
cGxheWVyLmhwLDIsMjYsNykKICBsb2NhbCBmcmFtZV9tc19jb2w9KGZyYW1lX21zPDMyIGFuZCAx
MSkgb3IgKGZyYW1lX21zPDQwIGFuZCAxMCkgb3IgOAogIHByaW50KCJmcmFtZV9tczoiLi4oZmxy
KGZyYW1lX21zKjEwKS8xMCkuLiJtcyIsMiw0MixmcmFtZV9tc19jb2wpCiAgaWYgZGVidWdfbW9k
ZSB0aGVuCiAgIHByaW50KCJyYXljYXN0OiIuLihmbHIobXNfcmF5Y2FzdCoxMCkvMTApLi4ibXMi
LDIsNTAsNykKICAgcHJpbnQoImZsb29yK3dhbGxzOiIuLihmbHIobXNfZmxvb3Jfd2FsbHMqMTAp
LzEwKS4uIm1zIiwyLDU4LDcpCiAgIHByaW50KCJzcHJpdGVzOiIuLihmbHIobXNfc3ByaXRlcyox
MCkvMTApLi4ibXMiLDIsNjYsNykKICAgcHJpbnQoIlt4XSB0b2dnbGUgbWFwIiwyLDM0LDcpCiAg
ZW5kCiAgCiAgLS0gaW50ZXJhY3Rpb24gcHJvbXB0CiAgaWYgaW50ZXJhY3Rpb25fYWN0aXZlIGFu
ZCBjdXJyZW50X2ludGVyYWN0IHRoZW4KICAgcHJpbnQoIltFXS9aOiBpbnRlcmFjdCIsc2NyZWVu
X2NlbnRlcl94LTQwLHNjcmVlbl9oZWlnaHQtMjAsMTEpCiAgZW5kCiAgCiAgLS0gdHJhcCBtZXNz
YWdlCiAgaWYgdHJhcF9tc2dfdGltZXI_MCB0aGVuCiAgIHByaW50KCJ0cmFwIHNwcnVuZyEiLHNj
cmVlbl9jZW50ZXJfeC0zMCxzY3JlZW5fY2VudGVyX3ksOCkKICBlbmQKICAKIC0tW1sgREVCVUcg
UEFORUwgUkVNT1ZFRCBGT1IgUFJPRFVDVElPTiBQRVJGT1JNQU5DRQogaWYgZGVidWdfbW9kZSB0
aGVuCiAgLS0gcmVtb3ZlZAogZW5kCiBdXQogIAogLS1bWyBQRVJJT0RJQyBMT0dHSU5HIFJFTU9W
RUQgRk9SIFBST0RVQ1RJT04gUEVSRk9STUFOQ0UKIGlmIGVuYWJsZV9kaWFnbm9zdGljc19sb2dn
aW5nIGFuZCBkaWFnX2ZyYW1lX2NvdW50JTYwPT0wIHRoZW4KICAtLSByZW1vdmVkCiBlbmQKIF1d
CiAgCiAgLS0gbWluaW1hcCBIVUQgb3ZlcmxheQogIGRyYXdfbWluaW1hcF9odWQoKQogZWxzZQog
IGRyYXdfbWluaW1hcCgpCiBlbmQKIAogLS0gY29tYmF0IG92ZXJsYXkKIGlmIGluX2NvbWJhdCB0
aGVuCiAgcmVjdGZpbGwoMCxzY3JlZW5faGVpZ2h0LTQwLHNjcmVlbl93aWR0aCxzY3JlZW5faGVp
Z2h0LDApCiAgcHJpbnQoImVudGVyaW5nIGNvbWJhdC4uLiIsc2NyZWVuX2NlbnRlcl94LTQwLHNj
cmVlbl9jZW50ZXJfeSw4KQogIHByaW50KCJbZW50ZXJdIGV4aXQgKHRlbXApIixzY3JlZW5fY2Vu
dGVyX3gtNDAsc2NyZWVuX2NlbnRlcl95KzEwLDcpCiBlbmQKIAogLS0gcmVzdG9yZSBwYWxldHRl
IGZyb20gZm9nIHJlbWFwcGluZyAoc2luZ2xlIHJlc3RvcmUgcGVyIGZyYW1lKQogcGFsKCkKIC0t
IHJlc2V0IGZvZyBzdGF0ZSBzbyBmaXJzdCBzZXRfZm9nIGFwcGxpZXMgbWFwcGluZyBuZXh0IGZy
YW1lCiBsYXN0X2ZvZ19sZXZlbD0tMQogcHJldl9wYWw9e30KZW5kCgotLSBkcmF3IDJkIG1pbmlt
YXAgZm9yIHRlc3RpbmcKLS0gUHVycG9zZTogUmVuZGVyIDJEIHRvcC1kb3duIGRlYnVnIHZpZXcg
b2YgZHVuZ2VvbgotLSBBbGdvcml0aG06IFNjYWxlIDEyOMOXMTI4IG1hcCB0byAyNTbDlzI1NiBw
aXhlbHMgKHNjYWxlPTIpCi0tIERpc3BsYXlzOiBXYWxscywgcm9vbXMsIGRvb3JzLCBvYmplY3Rz
LCBwbGF5ZXIgcG9zaXRpb24gYW5kIGZhY2luZwotLSBOb3RlczogVG9nZ2xlZCB3aXRoIFggYnV0
dG9uLCB1c2VmdWwgZm9yIGRlYnVnZ2luZyBnZW5lcmF0aW9uCmZ1bmN0aW9uIGRyYXdfbWluaW1h
cCgpCiBsb2NhbCBzY2FsZT0yCiBsb2NhbCBveCxveT0xMCwxMAogCiAtLSBiYXRjaCBhbGwgdGls
ZSBkcmF3aW5nIHRvIHJlZHVjZSBkcmF3IGNhbGwgY291bnQKIHJiYXRjaF9yZXNldCgpCiAKIC0t
IGRyYXcgd2FsbHMgZnJvbSBtYXAud2FsbHMgdXNlcmRhdGEgd2l0aCBmbG9vciBkYXRhIHRvIGRp
c3Rpbmd1aXNoIGNvcnJpZG9ycyBmcm9tIHZvaWQKIGZvciB4PTAsMTI3IGRvCiAgZm9yIHk9MCwx
MjcgZG8KICAgbG9jYWwgd2FsbD1nZXRfd2FsbCh4LHkpCiAgIGxvY2FsIGZsb29yX3ZhbD1nZXRf
Zmxvb3IoeCx5KQogICBsb2NhbCBjb2xvcgogICBpZiB3YWxsPjAgdGhlbgogICAgLS0gd2FsbCB0
aWxlCiAgICBjb2xvcj01CiAgIGVsc2VpZiBmbG9vcl92YWw_MCB0aGVuCiAgICAtLSBjYXJ2ZWQg
Y29ycmlkb3Ivcm9vbSBmbG9vciAoZmxvb3IgdHlwZSBzZXQgZHVyaW5nIGdlbmVyYXRpb24pCiAg
ICBjb2xvcj02CiAgIGVsc2UKICAgIC0tIHVuY2FydmVkIHZvaWQgKHdhbGw9MCwgZmxvb3I9MCkK
ICAgIGNvbG9yPTEKICAgZW5kCiAgIHJiYXRjaF9wdXNoKG94K3gqc2NhbGUsb3kreSpzY2FsZSxv
eCt4KnNjYWxlK3NjYWxlLTEsb3kreSpzY2FsZStzY2FsZS0xLGNvbG9yKQogIGVuZAogZW5kCiAK
IHJiYXRjaF9zdWJtaXQoKQogCiAtLSBkcmF3IHJvb21zCiBmb3Igbm9kZSBpbiBhbGwoZ2VuX25v
ZGVzKSBkbwogIGxvY2FsIHI9bm9kZS5yZWN0CiAgcmVjdChveCtyWzFdKnNjYWxlLG95K3JbMl0q
c2NhbGUsb3grclszXSpzY2FsZSxveStyWzRdKnNjYWxlLDExKQogZW5kCiAKIC0tIGJhdGNoIGRv
b3IgZHJhd2luZwogcmJhdGNoX3Jlc2V0KCkKIGZvciBkb29yIGluIGFsbChkb29ycykgZG8KICBs
b2NhbCBjPWRvb3IuZHR5cGU9PWRvb3JfbG9ja2VkIGFuZCA4IG9yIDEyCiAgcmJhdGNoX3B1c2go
b3grZG9vci54KnNjYWxlLG95K2Rvb3IueSpzY2FsZSxveCtkb29yLngqc2NhbGUrc2NhbGUtMSxv
eStkb29yLnkqc2NhbGUrc2NhbGUtMSxjKQogZW5kCiByYmF0Y2hfc3VibWl0KCkKIAogLS0gZHJh
dyBvYmplY3RzCiBmb3Igb2IgaW4gYWxsKG9iamVjdHMpIGRvCiAgbG9jYWwgYz03CiAgaWYgb2Iu
dHlwIGFuZCBvYi50eXAua2luZD09Imhvc3RpbGVfbnBjIiB0aGVuIGM9OAogIGVsc2VpZiBvYi50
eXAgYW5kIG9iLnR5cC5raW5kPT0iZGlyZWN0X3BpY2t1cCIgdGhlbgogICBpZiBvYi50eXAuc3Vi
dHlwZT09ImhlYXJ0IiB0aGVuIGM9MTQKICAgZWxzZWlmIG9iLnR5cC5zdWJ0eXBlPT0ia2V5IiB0
aGVuIGM9OQogICBlbmQKICBlbHNlaWYgb2IudHlwIGFuZCBvYi50eXAua2luZD09ImludGVyYWN0
YWJsZSIgdGhlbgogICBpZiBvYi50eXAuc3VidHlwZT09ImV4aXQiIHRoZW4gYz0xMiBlbmQKICBl
bHNlaWYgb2IudHlwIGFuZCBvYi50eXAua2luZD09ImRlY29yYXRpdmUiIHRoZW4gYz0xMwogIGVu
ZAogIGxvY2FsIHg9b2IucG9zWzFdCiAgbG9jYWwgeT1vYi5wb3NbMl0KICBjaXJjZmlsbChveCt4
KnNjYWxlLG95K3kqc2NhbGUsMSxjKQogZW5kCiAKIC0tIGRyYXcgcGxheWVyCiBsb2NhbCBweCxw
eT1veCtwbGF5ZXIueCpzY2FsZSxveStwbGF5ZXIueSpzY2FsZQogY2lyY2ZpbGwocHgscHksMiwx
MCkKIGxvY2FsIHNhLGNhPXNpbihwbGF5ZXIuYSksY29zKHBsYXllci5hKQogbGluZShweCxweSxw
eCtjYSo2LHB5K3NhKjYsMTApCiAKIC0tIHN0YXRzCiBwcmludCgiMmQgbWFwIHZpZXciLDEwLDIs
NykKIHByaW50KCJyb29tczogIi4uZ2VuX3N0YXRzLnJvb21zLDEwLDEwLDcpCiBwcmludCgib2Jq
ZWN0czogIi4uZ2VuX3N0YXRzLm9iamVjdHMsMTAsMTgsNykKIHByaW50KCJzZWVkOiAiLi5nZW5f
c3RhdHMuc2VlZCwxMCwyNiw3KQogaWYgZGVidWdfbW9kZSB0aGVuCiAgcHJpbnQoIlt4XSB0b2dn
bGUgM2QiLDEwLDM0LDcpCiBlbmQKZW5kCgotLSBkcmF3IGh1ZCBtaW5pbWFwIG92ZXJsYXkKLS0g
UHVycG9zZTogUmVuZGVyIHNjcm9sbGluZyB2aWV3cG9ydCBtaW5pbWFwIGluIHRvcC1yaWdodCBj
b3JuZXIgZHVyaW5nIDNEIHZpZXcKLS0gQWxnb3JpdGhtOiBQbGF5ZXItY2VudGVyZWQgY2FtZXJh
IHdpdGggY2xpcHBlZCBkcmF3aW5nIG9mIHZpc2libGUgdGlsZXMgb25seQotLSBEaXNwbGF5czog
V2FsbHMsIGZsb29ycywgZG9vcnMsIG9iamVjdHMsIHBsYXllciAoYXV0by1zY3JvbGxzIGFzIHBs
YXllciBtb3ZlcykKLS0gTm90ZXM6IEZpeGVkIDEyMMOXNjhweCB2aWV3cG9ydCBhdCB0b3Atcmln
aHQsIHNjYWxlPTIsIG9ubHkgZHJhd3MgdmlzaWJsZSB0aWxlIHJhbmdlCmZ1bmN0aW9uIGRyYXdf
bWluaW1hcF9odWQoKQogbG9jYWwgaHVkX3c9Y2VpbChzY3JlZW5fd2lkdGgqMC4yNSkKIGxvY2Fs
IGh1ZF9oPWNlaWwoc2NyZWVuX2hlaWdodCowLjI1KQogbG9jYWwgaHVkX3g9c2NyZWVuX3dpZHRo
LWh1ZF93LTgKIGxvY2FsIGh1ZF95PTgKIGxvY2FsIHNjYWxlPTIKIAogLS0gY2FtZXJhIG9mZnNl
dCB0byBjZW50ZXIgcGxheWVyIGluIHZpZXdwb3J0CiBsb2NhbCBjYW1feD1wbGF5ZXIueCpzY2Fs
ZS1odWRfdy8yCiBsb2NhbCBjYW1feT1wbGF5ZXIueSpzY2FsZS1odWRfaC8yCiAKIC0tIGNhbGN1
bGF0ZSB2aXNpYmxlIHRpbGUgcmFuZ2UKIGxvY2FsIHhfbWluPW1heCgwLGZscihjYW1feC9zY2Fs
ZSkpCiBsb2NhbCB4X21heD1taW4oMTI3LGZscigoY2FtX3graHVkX3cpL3NjYWxlKSkKIGxvY2Fs
IHlfbWluPW1heCgwLGZscihjYW1feS9zY2FsZSkpCiBsb2NhbCB5X21heD1taW4oMTI3LGZscigo
Y2FtX3kraHVkX2gpL3NjYWxlKSkKIAogLS0gc2V0IGNsaXAgcmVnaW9uCiBjbGlwKGh1ZF94LGh1
ZF95LGh1ZF93LGh1ZF9oKQogCiAtLSBkcmF3IGJhY2tncm91bmQKIHJlY3RmaWxsKGh1ZF94LGh1
ZF95LGh1ZF94K2h1ZF93LTEsaHVkX3kraHVkX2gtMSwwKQogCiAtLSBiYXRjaCBtYXAgdGlsZXMg
KG9ubHkgdmlzaWJsZSByYW5nZSkKIHJiYXRjaF9yZXNldCgpCiBmb3IgeD14X21pbix4X21heCBk
bwogIGZvciB5PXlfbWluLHlfbWF4IGRvCiAgIGxvY2FsIHN4PWh1ZF94Kyh4KnNjYWxlLWNhbV94
KQogICBsb2NhbCBzeT1odWRfeSsoeSpzY2FsZS1jYW1feSkKICAgCiAgIC0tIGFkZGl0aW9uYWwg
Ym91bmRzIGNoZWNrCiAgIGlmIHN4Pj1odWRfeCBhbmQgc3g8aHVkX3graHVkX3cgYW5kIHN5Pj1o
dWRfeSBhbmQgc3k8aHVkX3kraHVkX2ggdGhlbgogICAgbG9jYWwgd2FsbD1nZXRfd2FsbCh4LHkp
CiAgICBsb2NhbCBmbG9vcl92YWw9Z2V0X2Zsb29yKHgseSkKICAgIGxvY2FsIGNvbG9yCiAgICAK
ICAgIGlmIHdhbGw_MCB0aGVuCiAgICAgY29sb3I9NQogICAgZWxzZWlmIGZsb29yX3ZhbD4wIHRo
ZW4KICAgICBjb2xvcj02CiAgICBlbHNlCiAgICAgY29sb3I9MQogICAgZW5kCiAgICAKICAgIHJi
YXRjaF9wdXNoKHN4LHN5LHN4K3NjYWxlLTEsc3krc2NhbGUtMSxjb2xvcikKICAgZW5kCiAgZW5k
CiBlbmQKIHJiYXRjaF9zdWJtaXQoKQogCiAtLSBiYXRjaCBkb29yIGRyYXdpbmcgdmlhIHNwYXRp
YWwgcXVlcnkgb3ZlciB2aXNpYmxlIHRpbGVzCiByYmF0Y2hfcmVzZXQoKQogZm9yIHg9eF9taW4s
eF9tYXggZG8KICBmb3IgeT15X21pbix5X21heCBkbwogICBsb2NhbCBkb29yPWRvb3JncmlkW3hd
IGFuZCBkb29yZ3JpZFt4XVt5XSBvciBuaWwKICAgaWYgZG9vciB0aGVuCiAgICBsb2NhbCBzeD1o
dWRfeCsoeCpzY2FsZS1jYW1feCkKICAgIGxvY2FsIHN5PWh1ZF95Kyh5KnNjYWxlLWNhbV95KQog
ICAgaWYgc3g_PWh1ZF94IGFuZCBzeDxodWRfeCtodWRfdyBhbmQgc3k_PWh1ZF95IGFuZCBzeTxo
dWRfeStodWRfaCB0aGVuCiAgICAgbG9jYWwgYz1kb29yLmR0eXBlPT1kb29yX2xvY2tlZCBhbmQg
OCBvciAxMgogICAgIHJiYXRjaF9wdXNoKHN4LHN5LHN4K3NjYWxlLTEsc3krc2NhbGUtMSxjKQog
ICAgZW5kCiAgIGVuZAogIGVuZAogZW5kCiByYmF0Y2hfc3VibWl0KCkKIAogLS0gZHJhdyBvYmpl
Y3RzIHZpYSBmbGF0IGFycmF5IGl0ZXJhdGlvbiB3aXRoaW4gdmlld3BvcnQgYm91bmRzCiBmb3Ig
b2IgaW4gYWxsKG9iamVjdHMpIGRvCiAgaWYgb2IucG9zIHRoZW4KICAgbG9jYWwgc3g9aHVkX3gr
KG9iLnBvc1sxXSpzY2FsZS1jYW1feCkKICAgbG9jYWwgc3k9aHVkX3krKG9iLnBvc1syXSpzY2Fs
ZS1jYW1feSkKICAgaWYgc3g_PWh1ZF94IGFuZCBzeDxodWRfeCtodWRfdyBhbmQgc3k_PWh1ZF95
IGFuZCBzeTxodWRfeStodWRfaCB0aGVuCiAgICBsb2NhbCBjPTcKICAgIGlmIG9iLnR5cCBhbmQg
b2IudHlwLmtpbmQ9PSJob3N0aWxlX25wYyIgdGhlbiBjPTgKICAgIGVsc2VpZiBvYi50eXAgYW5k
IG9iLnR5cC5raW5kPT0iZGlyZWN0X3BpY2t1cCIgdGhlbgogICAgIGlmIG9iLnR5cC5zdWJ0eXBl
PT0iaGVhcnQiIHRoZW4gYz0xNAogICAgIGVsc2VpZiBvYi50eXAuc3VidHlwZT09ImtleSIgdGhl
biBjPTkKICAgICBlbmQKICAgIGVsc2VpZiBvYi50eXAgYW5kIG9iLnR5cC5raW5kPT0iaW50ZXJh
Y3RhYmxlIiB0aGVuCiAgICAgaWYgb2IudHlwLnN1YnR5cGU9PSJleGl0IiB0aGVuIGM9MTIgZW5k
CiAgICBlbHNlaWYgb2IudHlwIGFuZCBvYi50eXAua2luZD09ImRlY29yYXRpdmUiIHRoZW4gYz0x
MwogICAgZW5kCiAgICBjaXJjZmlsbChzeCxzeSwxLGMpCiAgIGVuZAogIGVuZAogZW5kCiAKIC0t
IGRyYXcgcGxheWVyIChhbHdheXMgY2VudGVyZWQgYnkgY2FtZXJhIGRlc2lnbikKIGxvY2FsIHB4
PWh1ZF94KyhwbGF5ZXIueCpzY2FsZS1jYW1feCkKIGxvY2FsIHB5PWh1ZF95KyhwbGF5ZXIueSpz
Y2FsZS1jYW1feSkKIGNpcmNmaWxsKHB4LHB5LDIsMTApCiBsaW5lKHB4LHB5LHB4K2NhX2NhY2hl
ZCo2LHB5K3NhX2NhY2hlZCo2LDEwKQogCiAtLSBvcHRpb25hbCBmcmFtZQogcmVjdChodWRfeCxo
dWRfeSxodWRfeCtodWRfdy0xLGh1ZF95K2h1ZF9oLTEsNykKIAogLS0gcmVzZXQgY2xpcAogY2xp
cCgpCmVuZAoKLS0gdW5pZmllZCBjb2xsaXNpb24gY2hlY2sgZm9yIHdhbGxzLCBkb29ycywgYW5k
IG9iamVjdHMKLS0gUHVycG9zZTogVW5pZmllZCBjb2xsaXNpb24gZGV0ZWN0aW9uIGZvciB3YWxs
cywgZG9vcnMsIGFuZCBvYmplY3RzCi0tIFBhcmFtZXRlcnM6IHB4LCBweSAod29ybGQgcG9zaXRp
b24pLCByYWRpdXMgKGNvbGxpc2lvbiByYWRpdXMpLCBvcGVuZG9vcnMgKGF1dG8tb3BlbiBkb29y
cyksIGlzcGxheWVyIChlbmFibGUga2V5IGNoZWNraW5nKQotLSBSZXR1cm5zOiBib29sZWFuICh0
cnVlIGlmIGNvbGxpc2lvbiBkZXRlY3RlZCkKLS0gQWxnb3JpdGhtOiBHcmlkLWJhc2VkIHdhbGwg
Y2hlY2sgKyBzcGF0aWFsIHBhcnRpdGlvbmluZyBmb3Igb2JqZWN0cwotLSBTaWRlIGVmZmVjdHM6
IE9wZW5zIGRvb3JzLCBwcmV2ZW50cyBkb29yIGNsb3Npbmcgd2hlbiBwbGF5ZXIgaW5zaWRlCmZ1
bmN0aW9uIGlzY29sKHB4LHB5LHJhZGl1cyxvcGVuZG9vcnMsaXNwbGF5ZXIpCiBsb2NhbCBjb2w9
ZmFsc2UKIG9wZW5kb29ycz1vcGVuZG9vcnMgb3IgZmFsc2UKIGlzcGxheWVyPWlzcGxheWVyIG9y
IGZhbHNlCiAKIC0tIGNoZWNrIGdyaWQgY2VsbHMgYXJvdW5kIHBvc2l0aW9uCiBmb3IgeD1mbHIo
cHgtcmFkaXVzKSxmbHIocHgrcmFkaXVzKSBkbwogIGZvciB5PWZscihweS1yYWRpdXMpLGZscihw
eStyYWRpdXMpIGRvCiAgIC0tIGJvdW5kcyBjaGVjawogICBpZiB4PDAgb3IgeD49MTI4IG9yIHk8
MCBvciB5Pj0xMjggdGhlbgogICAgY29sPXRydWUKICAgIGJyZWFrCiAgIGVsc2UKICAgIGxvY2Fs
IHRpbGU9Z2V0X3dhbGwoeCx5KQogICAgCiAgICAtLSBjaGVjayBpZiBkb29yIHRpbGUKICAgIGlm
IHRpbGU9PWRvb3Jfbm9ybWFsIG9yIHRpbGU9PWRvb3JfbG9ja2VkIG9yIHRpbGU9PWRvb3Jfc3Rh
eV9vcGVuIHRoZW4KICAgICBsb2NhbCBkb29yPWRvb3JncmlkW3hdW3ldCiAgICAgaWYgZG9vciB0
aGVuCiAgICAgIGlmIGRvb3Iub3Blbj09MSB0aGVuCiAgICAgICAtLSBmdWxseSBvcGVuOiBwcmV2
ZW50IGNsb3NpbmcKICAgICAgIGRvb3Iub3BlbmluZz10cnVlCiAgICAgIGVsc2UKICAgICAgIC0t
IGRvb3IgcGFydGlhbGx5IG9wZW4gb3IgY2xvc2VkOiBjb2xsaXNpb24gZGV0ZWN0ZWQKICAgICAg
IGNvbD10cnVlCiAgICAgICAtLSBoYW5kbGUgdW5sb2NraW5nL29wZW5pbmcgYmVmb3JlIGV4aXRp
bmcgaW5uZXIgbG9vcAogICAgICAgaWYgb3BlbmRvb3JzIHRoZW4KICAgICAgICBpZiBkb29yLmtl
eW51bSB0aGVuCiAgICAgICAgIC0tIGNoZWNrIGludmVudG9yeSBmb3Iga2V5CiAgICAgICAgIGlm
IGlzcGxheWVyIHRoZW4KICAgICAgICAgIGZvciBpLGl0ZW0gaW4gaXBhaXJzKHBsYXllci5rZXlz
KSBkbwogICAgICAgICAgIGlmIGl0ZW0ua2V5bnVtPT1kb29yLmtleW51bSB0aGVuCiAgICAgICAg
ICAgIC0tIHJlbW92ZSBrZXkKICAgICAgICAgICAgZGVsaShwbGF5ZXIua2V5cyxpKQogICAgICAg
ICAgICBkb29yLmtleW51bT1uaWwKICAgICAgICAgICAgZG9vci5vcGVuaW5nPXRydWUKICAgICAg
ICAgICAgLS0ga2VlcCBjb2w9dHJ1ZSwgZG9uJ3QgY2xlYXIgaW1tZWRpYXRlbHkKICAgICAgICAg
ICAgYnJlYWsKICAgICAgICAgICBlbmQKICAgICAgICAgIGVuZAogICAgICAgICBlbmQKICAgICAg
ICBlbHNlCiAgICAgICAgIC0tIHVubG9ja2VkCiAgICAgICAgIGRvb3Iub3BlbmluZz10cnVlCiAg
ICAgICAgIC0tIGtlZXAgY29sPXRydWUsIGRvbid0IGNsZWFyIGltbWVkaWF0ZWx5CiAgICAgICAg
ZW5kCiAgICAgICBlbmQKICAgICAgIC0tIGVhcmx5IGV4aXQgZnJvbSBpbm5lciBsb29wIG9uIGNv
bGxpc2lvbiAoYWZ0ZXIgb3BlbmRvb3JzIGhhbmRsaW5nKQogICAgICAgYnJlYWsKICAgICAgZW5k
CiAgICAgZW5kCiAgICAtLSBjaGVjayBpZiBleGl0IHBvcnRhbAogICAgZWxzZWlmICh0aWxlPT1l
eGl0X3N0YXJ0IG9yIHRpbGU9PWV4aXRfZW5kKSBhbmQgaXNwbGF5ZXIgdGhlbgogICAgIC0tIHBs
YWNlaG9sZGVyIGZvciBsZXZlbCBjb21wbGV0aW9uCiAgICAtLSBjaGVjayBpZiB3YWxsCiAgICBl
bHNlaWYgdGlsZT4wIHRoZW4KICAgICBjb2w9dHJ1ZQogICAgIGJyZWFrCiAgICBlbmQKICAgZW5k
CiAgZW5kCiAgaWYgY29sIHRoZW4gYnJlYWsgZW5kCiBlbmQKIAogLS0gY2hlY2sgc29saWQgb2Jq
ZWN0cyBhcm91bmQgcG9zaXRpb24gdmlhIGZsYXQgYXJyYXkgd2l0aCBlYXJseSBkaXN0YW5jZSBj
dWxsCiBmb3Igb2IgaW4gYWxsKG9iamVjdHMpIGRvCiAgaWYgb2IudHlwIGFuZCBvYi50eXAuc29s
aWQgYW5kIG9iLnBvcyB0aGVuCiAgIGxvY2FsIG94PW9iLnBvc1sxXS1weAogICBsb2NhbCBveT1v
Yi5wb3NbMl0tcHkKICAgLS0gZWFybHkgYXhpcy1hbGlnbmVkIGN1bGwKICAgaWYgYWJzKG94KTwo
cmFkaXVzKyhvYi50eXAudyBvciAwKSkgYW5kIGFicyhveSk8KHJhZGl1cysob2IudHlwLncgb3Ig
MCkpIHRoZW4KICAgIGlmIG1heChhYnMob3gpLGFicyhveSkpPChvYi50eXAudyBvciAwKSB0aGVu
CiAgICAgY29sPXRydWUKICAgICAtLSB0cmlnZ2VyIGludGVyYWN0aW9uIG9uIHNvbGlkIGNvbnRh
Y3QgaWYgcGxheWVyCiAgICAgaWYgaXNwbGF5ZXIgdGhlbgogICAgICBjaGVja19pbnRlcmFjdGlv
bnNfYXQocHgscHkpCiAgICAgZW5kCiAgICAgYnJlYWsKICAgIGVuZAogICBlbmQKICBlbmQKIGVu
ZAogCiByZXR1cm4gY29sCmVuZAoKLS0gbW92ZW1lbnQgd3JhcHBlciB3aXRoIHNsaWRpbmcgY29s
bGlzaW9uCi0tIFB1cnBvc2U6IE1vdmVtZW50IHdpdGggc2xpZGluZyBjb2xsaXNpb24gKHRyeSBk
aWFnb25hbCwgdGhlbiBYLCB0aGVuIFkpCi0tIFBhcmFtZXRlcnM6IHBvcyAodGFibGUgd2l0aCB4
LHkpLCB0YXJnZXRfeCwgdGFyZ2V0X3ksIHJhZGl1cywgb3BlbmRvb3JzLCBpc3BsYXllcgotLSBS
ZXR1cm5zOiBib29sZWFuICh0cnVlIGlmIGFueSBtb3ZlbWVudCBzdWNjZWVkZWQpCi0tIEFsZ29y
aXRobTogVGhyZWUtcGhhc2UgY29sbGlzaW9uIGNoZWNrIGZvciBzbW9vdGggd2FsbCBzbGlkaW5n
CmZ1bmN0aW9uIHRyeW1vdmV0byhwb3MsdGFyZ2V0X3gsdGFyZ2V0X3kscmFkaXVzLG9wZW5kb29y
cyxpc3BsYXllcikKIHJhZGl1cz1yYWRpdXMgb3IgcGxheWVyX2NvbGxpc2lvbl9yYWRpdXMKIG9w
ZW5kb29ycz1vcGVuZG9vcnMgb3IgZmFsc2UKIGlzcGxheWVyPWlzcGxheWVyIG9yIGZhbHNlCiAK
IC0tIHRyeSBkaXJlY3QgbW92ZW1lbnQKIGlmIG5vdCByYWRpdXMgb3Igbm90IGlzY29sKHRhcmdl
dF94LHRhcmdldF95LHJhZGl1cyxvcGVuZG9vcnMsaXNwbGF5ZXIpIHRoZW4KICBwb3MueCxwb3Mu
eT10YXJnZXRfeCx0YXJnZXRfeQogIHJldHVybiB0cnVlCiBlbmQKIAogLS0gdHJ5IHgtb25seSBt
b3ZlbWVudAogaWYgYWJzKHBvcy54LXRhcmdldF94KT4wLjAxIGFuZCBub3QgaXNjb2wodGFyZ2V0
X3gscG9zLnkscmFkaXVzLG9wZW5kb29ycyxpc3BsYXllcikgdGhlbgogIHBvcy54PXRhcmdldF94
CiAgcmV0dXJuIHRydWUKIGVuZAogCiAtLSB0cnkgeS1vbmx5IG1vdmVtZW50CiBpZiBhYnMocG9z
LnktdGFyZ2V0X3kpPjAuMDEgYW5kIG5vdCBpc2NvbChwb3MueCx0YXJnZXRfeSxyYWRpdXMsb3Bl
bmRvb3JzLGlzcGxheWVyKSB0aGVuCiAgcG9zLnk9dGFyZ2V0X3kKICByZXR1cm4gdHJ1ZQogZW5k
CiAKIHJldHVybiBmYWxzZQplbmQKCi0tIG1vdmVtZW50IHdyYXBwZXIgZm9yIHBvc1sxXS9wb3Nb
Ml0gYXJyYXkgcG9zaXRpb25zCmZ1bmN0aW9uIHRyeW1vdmV0b19wb3MocG9zX2FycmF5LHRhcmdl
dF94LHRhcmdldF95LHJhZGl1cyxvcGVuZG9vcnMsaXNwbGF5ZXIpCiByYWRpdXM9cmFkaXVzIG9y
IHBsYXllcl9jb2xsaXNpb25fcmFkaXVzCiBvcGVuZG9vcnM9b3BlbmRvb3JzIG9yIGZhbHNlCiBp
c3BsYXllcj1pc3BsYXllciBvciBmYWxzZQogCiAtLSB0cnkgZGlyZWN0IG1vdmVtZW50CiBpZiBu
b3QgcmFkaXVzIG9yIG5vdCBpc2NvbCh0YXJnZXRfeCx0YXJnZXRfeSxyYWRpdXMsb3BlbmRvb3Jz
LGlzcGxheWVyKSB0aGVuCiAgcG9zX2FycmF5WzFdLHBvc19hcnJheVsyXT10YXJnZXRfeCx0YXJn
ZXRfeQogIHJldHVybiB0cnVlCiBlbmQKIAogLS0gdHJ5IHgtb25seSBtb3ZlbWVudAogaWYgYWJz
KHBvc19hcnJheVsxXS10YXJnZXRfeCk_MC4wMSBhbmQgbm90IGlzY29sKHRhcmdldF94LHBvc19h
cnJheVsyXSxyYWRpdXMsb3BlbmRvb3JzLGlzcGxheWVyKSB0aGVuCiAgcG9zX2FycmF5WzFdPXRh
cmdldF94CiAgcmV0dXJuIHRydWUKIGVuZAogCiAtLSB0cnkgeS1vbmx5IG1vdmVtZW50CiBpZiBh
YnMocG9zX2FycmF5WzJdLXRhcmdldF95KT4wLjAxIGFuZCBub3QgaXNjb2wocG9zX2FycmF5WzFd
LHRhcmdldF95LHJhZGl1cyxvcGVuZG9vcnMsaXNwbGF5ZXIpIHRoZW4KICBwb3NfYXJyYXlbMl09
dGFyZ2V0X3kKICByZXR1cm4gdHJ1ZQogZW5kCiAKIHJldHVybiBmYWxzZQplbmQKCmZ1bmN0aW9u
IHVwZGF0ZV9pbnB1dCgpCiBsb2NhbCBzYSxjYT1zaW4ocGxheWVyLmEpLGNvcyhwbGF5ZXIuYSkK
IAogLS0gbW92ZW1lbnQKIC0tIGNvbWJpbmUga2V5cyB0byBhdm9pZCBkb3VibGUtcHJvY2Vzc2lu
ZyBhbmQgZml4IGRpcmVjdGlvbjoKIC0tIHBvc2l0aXZlIHR1cm4gPSBsZWZ0LCBuZWdhdGl2ZSB0
dXJuID0gcmlnaHQKIGxvY2FsIHR1cm49KGJ0bigwKSBhbmQgMSBvciAwKS0oYnRuKDEpIGFuZCAx
IG9yIDApCiBpZiB0dXJufj0wIHRoZW4KICBwbGF5ZXIuYSs9dHVybipwbGF5ZXJfcm90YXRpb25f
c3BlZWQKIGVuZAogaWYgYnRuKDIpIHRoZW4gLS0gdXAKICBsb2NhbCBueD1wbGF5ZXIueCtjYSpw
bGF5ZXIuc3BkCiAgbG9jYWwgbnk9cGxheWVyLnkrc2EqcGxheWVyLnNwZAogIHRyeW1vdmV0byhw
bGF5ZXIsbngsbnkscGxheWVyX2NvbGxpc2lvbl9yYWRpdXMsdHJ1ZSx0cnVlKQogZW5kCiBpZiBi
dG4oMykgdGhlbiAtLSBkb3duCiAgbG9jYWwgbng9cGxheWVyLngtY2EqcGxheWVyLnNwZAogIGxv
Y2FsIG55PXBsYXllci55LXNhKnBsYXllci5zcGQKICB0cnltb3ZldG8ocGxheWVyLG54LG55LHBs
YXllcl9jb2xsaXNpb25fcmFkaXVzLHRydWUsdHJ1ZSkKIGVuZAogCiAtLSBjaGVjayBmb3IgaW50
ZXJhY3Rpb25zIGV2ZXJ5IGZyYW1lCiBjaGVja19pbnRlcmFjdGlvbnMoKQogCiAtLSBpbnRlcmFj
dGlvbiBpbnB1dDogRSBrZXkgb3IgWiBidXR0b24KIGlmIGtleXAoImUiKSBvciBidG5wKDQpIHRo
ZW4KICBoYW5kbGVfaW50ZXJhY3QoKQogZW5kCmVuZAoKIAoKLS0gY2hlY2sgaW50ZXJhY3Rpb25z
IGFyb3VuZCBwbGF5ZXIgcG9zaXRpb24KLS0gUHVycG9zZTogU2NhbiBuZWFyYnkgb2JqZWN0cyBm
b3IgcHJveGltaXR5LWJhc2VkIGludGVyYWN0aW9ucwotLSBBbGdvcml0aG06IDPDlzMgb2JqZ3Jp
ZCBjZWxsIHNjYW4gYXJvdW5kIHBsYXllcgotLSBTaWRlIGVmZmVjdHM6IEF1dG8tY29sbGVjdHMg
cGlja3VwcywgdHJpZ2dlcnMgY29tYmF0LCBzZXRzIGludGVyYWN0aW9uIGZsYWdzCi0tIE5vdGVz
OiBDYWxsZWQgZXZlcnkgZnJhbWUgaW4gX3VwZGF0ZSgpCmZ1bmN0aW9uIGNoZWNrX2ludGVyYWN0
aW9ucygpCiBjaGVja19pbnRlcmFjdGlvbnNfYXQocGxheWVyLngscGxheWVyLnkpCmVuZAoKLS0g
Y2hlY2sgaW50ZXJhY3Rpb25zIGF0IHNwZWNpZmljIHBvc2l0aW9uIChhdm9pZHMgcmVjdXJzaW9u
KQpmdW5jdGlvbiBjaGVja19pbnRlcmFjdGlvbnNfYXQocHgscHkpCiAtLSBzY2FuIGFsbCBvYmpl
Y3RzIHdpdGggZGlzdGFuY2UgY3VsbGluZwogbG9jYWwgY2xvc2VzdF9pbnRlcmFjdD1uaWwKIGxv
Y2FsIGNsb3Nlc3RfZGlzdD05OTkKIAogZm9yIG9iIGluIGFsbChvYmplY3RzKSBkbwogIGlmIG9i
LnBvcyBhbmQgb2IudHlwIHRoZW4KICAgbG9jYWwgZHg9b2IucG9zWzFdLXB4CiAgIGxvY2FsIGR5
PW9iLnBvc1syXS1weQogICBsb2NhbCBkaXN0PWFicyhkeCkrYWJzKGR5KQogICAKICAgLS0gZGly
ZWN0IHBpY2t1cDogYXV0by1jb2xsZWN0CiAgIGlmIG9iLnR5cC5raW5kPT0iZGlyZWN0X3BpY2t1
cCIgYW5kIGRpc3Q8aW50ZXJhY3Rpb25fcmFuZ2UgdGhlbgogICAgY29sbGVjdF9pdGVtKG9iKQog
ICAgZGVsKG9iamVjdHMsb2IpCiAgICBpZiBvYi5hdXRvYW5pbSB0aGVuIGRlbChhbmltYXRlZF9v
YmplY3RzLG9iKSBlbmQKICAgCiAgIC0tIGhvc3RpbGUgbnBjOiB0cmlnZ2VyIGNvbWJhdAogICBl
bHNlaWYgb2IudHlwLmtpbmQ9PSJob3N0aWxlX25wYyIgYW5kIGRpc3Q8Y29tYmF0X3RyaWdnZXJf
cmFuZ2UgdGhlbgogICAgaW5fY29tYmF0PXRydWUKICAgIGN1cnJlbnRfdGFyZ2V0PW9iCiAgIAog
ICAtLSBpbnRlcmFjdGFibGU6IHNldCBmbGFnIGZvciBjbG9zZXN0CiAgIGVsc2VpZiBvYi50eXAu
a2luZD09ImludGVyYWN0YWJsZSIgYW5kIGRpc3Q8aW50ZXJhY3Rpb25fcmFuZ2UgdGhlbgogICAg
LS0gdHJhcDogaW1tZWRpYXRlIGVmZmVjdAogICAgaWYgb2IudHlwLnN1YnR5cGU9PSJ0cmFwIiB0
aGVuCiAgICAgcGxheWVyLmhwPW1heCgwLHBsYXllci5ocC0xMCkKICAgICB0cmFwX21zZ190aW1l
cj02MAogICAgIGRlbChvYmplY3RzLG9iKQogICAgIGlmIG9iLmF1dG9hbmltIHRoZW4gZGVsKGFu
aW1hdGVkX29iamVjdHMsb2IpIGVuZAogICAgZWxzZWlmIGRpc3Q8Y2xvc2VzdF9kaXN0IHRoZW4K
ICAgICBjbG9zZXN0X2ludGVyYWN0PW9iCiAgICAgY2xvc2VzdF9kaXN0PWRpc3QKICAgIGVuZAog
ICBlbmQKICBlbmQKIGVuZAogCiAtLSB1cGRhdGUgaW50ZXJhY3Rpb24gc3RhdGUKIGlmIGNsb3Nl
c3RfaW50ZXJhY3QgdGhlbgogIGludGVyYWN0aW9uX2FjdGl2ZT10cnVlCiAgY3VycmVudF9pbnRl
cmFjdD1jbG9zZXN0X2ludGVyYWN0CiBlbHNlCiAgaW50ZXJhY3Rpb25fYWN0aXZlPWZhbHNlCiAg
Y3VycmVudF9pbnRlcmFjdD1uaWwKIGVuZAplbmQKCi0tIGNvbGxlY3QgaXRlbSAocGlja3VwKQot
LSBQdXJwb3NlOiBIYW5kbGUgcGlja3VwIGNvbGxlY3Rpb24gYW5kIGludmVudG9yeSB1cGRhdGVz
Ci0tIFBhcmFtZXRlcnM6IG9iIChvYmplY3Qgd2l0aCB0eXAuc3VidHlwZSkKLS0gU2lkZSBlZmZl
Y3RzOiBBZGRzIHRvIHBsYXllci5rZXlzLCBpbmNyZWFzZXMgcGxheWVyLmhwCi0tIE5vdGVzOiBD
YWxsZWQgYnkgY2hlY2tfaW50ZXJhY3Rpb25zX2F0KCkgZm9yIGRpcmVjdF9waWNrdXAgb2JqZWN0
cwpmdW5jdGlvbiBjb2xsZWN0X2l0ZW0ob2IpCiBpZiBvYi50eXAuc3VidHlwZT09ImtleSIgYW5k
IG9iLmtleW51bSB0aGVuCiAgYWRkKHBsYXllci5rZXlzLHtrZXludW09b2Iua2V5bnVtfSkKICBw
cmludGgoImNvbGxlY3RlZCBrZXkgIi4ub2Iua2V5bnVtKQogZWxzZWlmIG9iLnR5cC5zdWJ0eXBl
PT0iaGVhcnQiIHRoZW4KICBwbGF5ZXIuaHA9bWluKDEwMCxwbGF5ZXIuaHArMjApCiAgcHJpbnRo
KCJjb2xsZWN0ZWQgaGVhcnQiKQogZWxzZQogIHByaW50aCgiY29sbGVjdGVkIGl0ZW0iKQogZW5k
CmVuZAoKLS0gaGFuZGxlIGludGVyYWN0aW9uIHdoZW4gcGxheWVyIHByZXNzZXMgRS9aCi0tIFB1
cnBvc2U6IFByb2Nlc3MgcGxheWVyLWluaXRpYXRlZCBpbnRlcmFjdGlvbnMgKEUga2V5IC8gWiBi
dXR0b24pCi0tIEFsZ29yaXRobTogU3dpdGNoIG9uIGN1cnJlbnRfaW50ZXJhY3QudHlwLnN1YnR5
cGUKLS0gU2lkZSBlZmZlY3RzOiBPcGVucyBjaGVzdHMsIGFjdGl2YXRlcyBzaHJpbmVzLCByZWFk
cyBub3RlcywgdHJpZ2dlcnMgZmxvb3IgdHJhbnNpdGlvbgotLSBOb3RlczogT25seSBydW5zIHdo
ZW4gaW50ZXJhY3Rpb25fYWN0aXZlIGZsYWcgaXMgdHJ1ZQpmdW5jdGlvbiBoYW5kbGVfaW50ZXJh
Y3QoKQogaWYgbm90IGludGVyYWN0aW9uX2FjdGl2ZSBvciBub3QgY3VycmVudF9pbnRlcmFjdCB0
aGVuIHJldHVybiBlbmQKIAogbG9jYWwgc3VidHlwZT1jdXJyZW50X2ludGVyYWN0LnR5cCBhbmQg
Y3VycmVudF9pbnRlcmFjdC50eXAuc3VidHlwZSBvciAidW5rbm93biIKIAogaWYgc3VidHlwZT09
ImNoZXN0IiB0aGVuCiAgLS0gb3BlbiBjaGVzdCAocGxhY2Vob2xkZXIpCiAgcGxheWVyLmhwPW1p
bigxMDAscGxheWVyLmhwKzEwKQogIHByaW50aCgib3BlbmVkIGNoZXN0IikKICBkZWwob2JqZWN0
cyxjdXJyZW50X2ludGVyYWN0KQogIGlmIGN1cnJlbnRfaW50ZXJhY3QuYXV0b2FuaW0gdGhlbiBk
ZWwoYW5pbWF0ZWRfb2JqZWN0cyxjdXJyZW50X2ludGVyYWN0KSBlbmQKICAKIGVsc2VpZiBzdWJ0
eXBlPT0ic2hyaW5lIiB0aGVuCiAgLS0gYWN0aXZhdGUgc2hyaW5lIChwbGFjZWhvbGRlcikKICBw
bGF5ZXIuaHA9MTAwCiAgcHJpbnRoKCJhY3RpdmF0ZWQgc2hyaW5lIikKICAKIGVsc2VpZiBzdWJ0
eXBlPT0ibm90ZSIgdGhlbgogIC0tIHJlYWQgbm90ZSAocGxhY2Vob2xkZXIpCiAgcHJpbnRoKCJy
ZWFkIG5vdGUiKQogIGRlbChvYmplY3RzLGN1cnJlbnRfaW50ZXJhY3QpCiAgaWYgY3VycmVudF9p
bnRlcmFjdC5hdXRvYW5pbSB0aGVuIGRlbChhbmltYXRlZF9vYmplY3RzLGN1cnJlbnRfaW50ZXJh
Y3QpIGVuZAogIAogZWxzZWlmIHN1YnR5cGU9PSJleGl0IiB0aGVuCiAgLS0gdHJpZ2dlciBuZXh0
IGZsb29yCiAgcHJpbnRoKCJ1c2luZyBleGl0IHBvcnRhbCIpCiAgZ2VuZXJhdGVfbmV3X2Zsb29y
KCkKICAKIGVuZAogCiAtLSBjbGVhciBpbnRlcmFjdGlvbiBzdGF0ZSBhZnRlciBoYW5kbGluZwog
aW50ZXJhY3Rpb25fYWN0aXZlPWZhbHNlCiBjdXJyZW50X2ludGVyYWN0PW5pbAplbmQKCi0tIGdl
bmVyYXRlIG5ldyBmbG9vciAocmVnZW5lcmF0ZSBkdW5nZW9uKQpmdW5jdGlvbiBnZW5lcmF0ZV9u
ZXdfZmxvb3IoKQogLS0gaW5jcmVtZW50IGRpZmZpY3VsdHkKIGdlbl9wYXJhbXMuZGlmZmljdWx0
eT1taW4oZ2VuX3BhcmFtcy5tYXhfZGlmZmljdWx0eSxnZW5fcGFyYW1zLmRpZmZpY3VsdHkrMSkK
IAogLS0gY2xlYXIgZXhpc3Rpbmcgb2JqZWN0cwogb2JqZWN0cz17fQogYW5pbWF0ZWRfb2JqZWN0
cz17fQogZG9vcnM9e30KIC0tIGFsc28gY2xlYXIgZG9vcmdyaWQgdG8gcHJldmVudCBzdGFsZSBy
ZWZlcmVuY2VzCiBmb3IgaT0wLDEyNyBkbwogIGlmIGRvb3JncmlkW2ldIHRoZW4KICAgZm9yIGo9
MCwxMjcgZG8KICAgIGRvb3JncmlkW2ldW2pdPW5pbAogICBlbmQKICBlbmQKIGVuZAogCiAtLSBy
ZWdlbmVyYXRlIGR1bmdlb24KIHN0YXJ0X3BvcyxnZW5fc3RhdHM9Z2VuZXJhdGVfZHVuZ2Vvbigp
Ci0tIFRyaWdnZXIgR0MgYWZ0ZXIgZHVuZ2VvbiBnZW5lcmF0aW9uIChQaWNvdHJvbiBndWlkZWxp
bmU6IGF2b2lkIG1pZC1nYW1lcGxheSBzdHV0dGVyKQpzdGF0KDApCiAtLSBpbnZhbGlkYXRlIHBl
cnNpc3RlbnQgcmVuZGVyIGNhY2hlcyBmb3IgbmV3IGZsb29yCi0tIFByb2R1Y3Rpb246IGNsZWFy
IGNhY2hlIG9uIGxldmVsIGxvYWQgdG8gcHJldmVudCBzdGFsZSB0ZXh0dXJlIHJlZmVyZW5jZXMK
aWYgY2xlYXJfdGV4dHVyZV9jYWNoZXMgdGhlbiBjbGVhcl90ZXh0dXJlX2NhY2hlcygpIGVuZAog
CiBwcmludGgoImZsb29yIGNvbXBsZXRlISBkaWZmaWN1bHR5OiAiLi5nZW5fcGFyYW1zLmRpZmZp
Y3VsdHkpCiAKIC0tIGxldmVsIGxvYWQgZGlhZ25vc3RpYyBzdW1tYXJ5CiBwcmludGgoIj09PSBM
RVZFTCBMT0FEIERJQUdOT1NUSUNTID09PSIpCiBwcmludGgoIkZsb29yOiAiLi4oY3VycmVudF9m
bG9vciBvciAidW5rbm93biIpKQogcHJpbnRoKCJEaWZmaWN1bHR5OiAiLi5nZW5fcGFyYW1zLmRp
ZmZpY3VsdHkpCiBwcmludGgoIlJvb21zOiAiLi5nZW5fc3RhdHMucm9vbXMpCiBwcmludGgoIk9i
amVjdHM6ICIuLmdlbl9zdGF0cy5vYmplY3RzKQogcHJpbnRoKCJTZWVkOiAiLi5nZW5fc3RhdHMu
c2VlZCkKZW5kCgotLSB1cGRhdGUgY29tYmF0IChwbGFjZWhvbGRlcikKZnVuY3Rpb24gdXBkYXRl
X2NvbWJhdCgpCiAtLSB0ZW1wIGV4aXQ6IHByZXNzIFEgb3IgRW50ZXIKIGlmIGtleXAoInEiKSBv
ciBrZXlwKCJlbnRlciIpIHRoZW4KICBpbl9jb21iYXQ9ZmFsc2UKICBjdXJyZW50X3RhcmdldD1u
aWwKICBwcmludGgoImV4aXRlZCBjb21iYXQiKQogZW5kCmVuZAoKLS0gdXBkYXRlIG5wYyBhaSAo
YmFzaWMgcGF0cm9sIGFuZCBmb2xsb3cpCmZ1bmN0aW9uIHVwZGF0ZV9ucGNfYWkoKQogZm9yIG9i
IGluIGFsbChvYmplY3RzKSBkbwogIGlmIG9iLnR5cCBhbmQgb2IudHlwLmtpbmQ9PSJob3N0aWxl
X25wYyIgYW5kIG9iLmFpX3R5cGUgdGhlbgogICBsb2NhbCBvbGRfeCxvbGRfeT1vYi5wb3NbMV0s
b2IucG9zWzJdCiAgIAogICBpZiBvYi5haV90eXBlPT0icGF0cm9sIiB0aGVuCiAgICAtLSBwYXRy
b2w6IGN5Y2xlIHRocm91Z2ggcGF0cm9sX3BvaW50cwogICAgaWYgb2IucGF0cm9sX3BvaW50cyBh
bmQgI29iLnBhdHJvbF9wb2ludHM_MCB0aGVuCiAgICAgLS0gaW5pdGlhbGl6ZSBwYXRyb2xfaW5k
ZXggaWYgbmlsIG9yIDAKICAgICBpZiBub3Qgb2IucGF0cm9sX2luZGV4IG9yIG9iLnBhdHJvbF9p
bmRleD09MCB0aGVuCiAgICAgIG9iLnBhdHJvbF9pbmRleD0xCiAgICAgZW5kCiAgICAgCiAgICAg
bG9jYWwgdGFyZ2V0PW9iLnBhdHJvbF9wb2ludHNbb2IucGF0cm9sX2luZGV4XQogICAgIGlmIHRh
cmdldCB0aGVuCiAgICAgIGxvY2FsIGR4PXRhcmdldC54LW9iLnBvc1sxXQogICAgICBsb2NhbCBk
eT10YXJnZXQueS1vYi5wb3NbMl0KICAgICAgbG9jYWwgZGlzdD1zcXJ0KGR4KmR4K2R5KmR5KQog
ICAgICAKICAgICAgLS0gcmVhY2hlZCB3YXlwb2ludDogYWR2YW5jZSB0byBuZXh0CiAgICAgIGlm
IGRpc3Q8MC4xIHRoZW4KICAgICAgIG9iLnBhdHJvbF9pbmRleD0ob2IucGF0cm9sX2luZGV4JSNv
Yi5wYXRyb2xfcG9pbnRzKSsxCiAgICAgIGVsc2UKICAgICAgIC0tIG1vdmUgdG93YXJkIGN1cnJl
bnQgd2F5cG9pbnQKICAgICAgIGlmIGRpc3Q_MCB0aGVuCiAgICAgICAgbG9jYWwgc3BkPW9iLnR5
cC5wYXRyb2xfc3BlZWQgb3IgMC4wMwogICAgICAgIGxvY2FsIG54PW9iLnBvc1sxXStkeC9kaXN0
KnNwZAogICAgICAgIGxvY2FsIG55PW9iLnBvc1syXStkeS9kaXN0KnNwZAogICAgICAgIHRyeW1v
dmV0b19wb3Mob2IucG9zLG54LG55LG9iLnR5cC53IG9yIDAuNCxmYWxzZSxmYWxzZSkKICAgICAg
IGVuZAogICAgICBlbmQKICAgICBlbmQKICAgIGVuZAogICAgCiAgIGVsc2VpZiBvYi5haV90eXBl
PT0iZm9sbG93IiB0aGVuCiAgICAtLSBmb2xsb3c6IG1vdmUgdG93YXJkIHBsYXllciBpZiBpbiBy
YW5nZQogICAgbG9jYWwgZHg9cGxheWVyLngtb2IucG9zWzFdCiAgICBsb2NhbCBkeT1wbGF5ZXIu
eS1vYi5wb3NbMl0KICAgIGxvY2FsIGRpc3Q9c3FydChkeCpkeCtkeSpkeSkKICAgIGxvY2FsIGZv
bGxvd19yYW5nZT1vYi50eXAuZm9sbG93X3JhbmdlIG9yIDIwCiAgICBpZiBkaXN0PGZvbGxvd19y
YW5nZSBhbmQgZGlzdD4wLjEgdGhlbgogICAgIGxvY2FsIHNwZD1vYi50eXAuZm9sbG93X3NwZWVk
IG9yIDAuMDUKICAgICBsb2NhbCBueD1vYi5wb3NbMV0rZHgvZGlzdCpzcGQKICAgICBsb2NhbCBu
eT1vYi5wb3NbMl0rZHkvZGlzdCpzcGQKICAgICB0cnltb3ZldG9fcG9zKG9iLnBvcyxueCxueSxv
Yi50eXAudyBvciAwLjQsZmFsc2UsZmFsc2UpCiAgICBlbmQKICAgZW5kCiAgZW5kCiBlbmQKZW5k
:: src/.info.pod
--[[pod,created="2025-11-07 22:14:13",modified="2025-11-12 01:15:56"]]
:: [eoc]
