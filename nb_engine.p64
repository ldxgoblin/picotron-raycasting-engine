picotron cartridge // www.picotron.net
version 2

:: .info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTExLTA3IDIyOjE0OjIwIixtb2RpZmllZD0iMjAyNS0x
MS0xMCAxMjozNTozNyIscnVudGltZT0yMSx3b3Jrc3BhY2VzPXt7bG9jYXRpb249Im1haW4ubHVh
IzgyOCIsd29ya3NwYWNlX2luZGV4PTF9fV1d
:: main.lua
b64$LS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNS0xMS0wNyAyMTowNDowNiIsbW9k
aWZpZWQ9IjIwMjUtMTEtMDcgMjI6MTg6NTEiLHJldmlzaW9uPTVdXQotLSBub25ib3kgcmF5Y2Fz
dCBlbmdpbmUgdjEuMAotLSBtYWluIGVudHJ5IHBvaW50CgppbmNsdWRlInNyYy9jb25maWcubHVh
IgppbmNsdWRlInNyYy9yYXljYXN0Lmx1YSIKaW5jbHVkZSJzcmMvcmVuZGVyLmx1YSIKaW5jbHVk
ZSJzcmMvcmVuZGVyX3Nwcml0ZS5sdWEiCmluY2x1ZGUic3JjL2Rvb3Jfc3lzdGVtLmx1YSIKaW5j
bHVkZSJzcmMvZHVuZ2Vvbl9nZW4ubHVhIgoKLS0gY29uc3RhbnRzCnBsYXllcl9jb2xsaXNpb25f
cmFkaXVzPTAuMTUKCmZ1bmN0aW9uIF9pbml0KCkKIHdpbmRvdyhzY3JlZW5fd2lkdGgsc2NyZWVu
X2hlaWdodCkKIAogLS0gY29uZmlndXJhdGlvbiBndWFyZDogcHJldmVudCBmb2cgcG9wcGluZyBi
ZXlvbmQgZmFyLXBsYW5lCiBhc3NlcnQoZmFyX3BsYW5lPj1mb2dfZmFyKzEsImNvbmZpZyBlcnJv
cjogZmFyX3BsYW5lIG11c3QgYmUgPj0gZm9nX2ZhciArIDEiKQogCiAtLSBkZWZlbnNpdmUgZGVm
YXVsdHMgaWYgY29uZmlnIGluY2x1ZGUgZmFpbGVkIHRvIHNldCB0aGVtIGZvciBhbnkgcmVhc29u
CiBpZiBub3Qgb2JqZ3JpZF9zaXplIHRoZW4gb2JqZ3JpZF9zaXplPTUgZW5kCiBpZiBub3Qgb2Jq
Z3JpZF9hcnJheV9zaXplIHRoZW4gb2JqZ3JpZF9hcnJheV9zaXplPTI2IGVuZAogCiAtLSBmcmFt
ZSBjb3VudGVyIGZvciBhaSB0aW1pbmcKIGZyYW1lX2N0PTAKIAogLS0gcGxheWVyIHN0YXRlCiBw
bGF5ZXI9ewogIHg9NjQseT02NCwKICBhPTAsCiAgc3BkPXBsYXllcl9tb3ZlX3NwZWVkLAogIGtl
eXM9e30sCiAgaHA9MTAwCiB9CiAKIC0tIGludGVyYWN0aW9uIHN0YXRlCiBpbnRlcmFjdGlvbl9h
Y3RpdmU9ZmFsc2UKIGN1cnJlbnRfaW50ZXJhY3Q9bmlsCiAKIC0tIGNvbWJhdCBzdGF0ZQogaW5f
Y29tYmF0PWZhbHNlCiBjdXJyZW50X3RhcmdldD1uaWwKIAogLS0gdHJhcCBtZXNzYWdlIHRpbWVy
CiB0cmFwX21zZ190aW1lcj0wCiAKIC0tIGNhbWVyYQogY2FtPXtwbGF5ZXIueCxwbGF5ZXIueX0K
IAogLS0gbWFwIGFic3RyYWN0aW9uIHdpdGggdXNlcmRhdGEgbGF5ZXJzCiBtYXA9e30KIG1hcC53
YWxscz11c2VyZGF0YSgiaTE2IiwxMjgsMTI4KQogbWFwLmRvb3JzPXVzZXJkYXRhKCJpMTYiLDEy
OCwxMjgpCiBtYXAuZmxvb3JzPXVzZXJkYXRhKCJpMTYiLDEyOCwxMjgpCiAKIC0tIGhlbHBlcjog
Z2V0IHdhbGwgdGlsZQogLS0gUHVycG9zZTogUmV0cmlldmUgd2FsbCB0aWxlIElEIGF0IGdyaWQg
cG9zaXRpb24gd2l0aCBmYWxsYmFjawogLS0gUGFyYW1ldGVyczogeCwgeSAoZ3JpZCBjb29yZGlu
YXRlcyAwLTEyNykKIC0tIFJldHVybnM6IHRpbGUgSUQgKDA9ZW1wdHksID4wPXdhbGwvZG9vci9l
eGl0KQogLS0gTm90ZXM6IENoZWNrcyB1c2VyZGF0YSBmaXJzdCwgZmFsbHMgYmFjayB0byB3YWxs
Z3JpZCB0YWJsZSBmb3IgY29tcGF0aWJpbGl0eQogZnVuY3Rpb24gZ2V0X3dhbGwoeCx5KQogIGlm
IHg_PTAgYW5kIHg8MTI4IGFuZCB5Pj0wIGFuZCB5PDEyOCB0aGVuCiAgIGxvY2FsIHZhbD1tYXAu
d2FsbHM6Z2V0KHgseSkKICAgaWYgdmFsIGFuZCB2YWw_MCB0aGVuIHJldHVybiB2YWwgZW5kCiAg
IC0tIGRlZmVuc2l2ZSBmYWxsYmFjazogY2hlY2sgd2FsbGdyaWQgaWYgbWFwLndhbGxzIGlzIG5p
bCBvciAwCiAgIGlmIHdhbGxncmlkIGFuZCB3YWxsZ3JpZFt4XSBhbmQgd2FsbGdyaWRbeF1beV0_
MCB0aGVuCiAgICByZXR1cm4gd2FsbGdyaWRbeF1beV0KICAgZW5kCiAgIHJldHVybiAwCiAgZW5k
CiAgcmV0dXJuIDAKIGVuZAogCiAtLSBoZWxwZXI6IHNldCB3YWxsIHRpbGUKIGZ1bmN0aW9uIHNl
dF93YWxsKHgseSx2YWwpCiAgaWYgeD49MCBhbmQgeDwxMjggYW5kIHk_PTAgYW5kIHk8MTI4IHRo
ZW4KCQltYXAud2FsbHM6c2V0KHgseSx2YWwgb3IgMCkKCQktLSBrZWVwIEx1YSBtaXJyb3IgaW4g
c3luYyBmb3Igc3lzdGVtcyBzdGlsbCByZWFkaW5nIHdhbGxncmlkIChlLmcuLCBtaW5pbWFwKQoJ
CWlmIHdhbGxncmlkIGFuZCB3YWxsZ3JpZFt4XSB0aGVuIHdhbGxncmlkW3hdW3ldPXZhbCBvciAw
IGVuZAogIGVuZAogZW5kCiAKIC0tIGhlbHBlcjogZ2V0IGRvb3IgdGlsZQogZnVuY3Rpb24gZ2V0
X2Rvb3IoeCx5KQogIGlmIHg_PTAgYW5kIHg8MTI4IGFuZCB5Pj0wIGFuZCB5PDEyOCB0aGVuCiAg
IHJldHVybiBtYXAuZG9vcnM6Z2V0KHgseSkgb3IgMAogIGVuZAogIHJldHVybiAwCiBlbmQKIAog
LS0gaGVscGVyOiBzZXQgZG9vciB0aWxlCiBmdW5jdGlvbiBzZXRfZG9vcih4LHksdmFsKQogIGlm
IHg_PTAgYW5kIHg8MTI4IGFuZCB5Pj0wIGFuZCB5PDEyOCB0aGVuCiAgIG1hcC5kb29yczpzZXQo
eCx5LHZhbCBvciAwKQogIGVuZAogZW5kCgogLS0gaGVscGVyOiBnZXQgZmxvb3IgdGlsZQogLS0g
UHVycG9zZTogUmV0cmlldmUgZmxvb3IgdHlwZSBJRCBhdCBncmlkIHBvc2l0aW9uCiAtLSBQYXJh
bWV0ZXJzOiB4LCB5IChncmlkIGNvb3JkaW5hdGVzIDAtMTI3KQogLS0gUmV0dXJuczogZmxvb3Ig
dHlwZSBJRCAoMD11c2UgZ2xvYmFsIGRlZmF1bHQsIDEtOD1zcGVjaWZpYyBmbG9vciB0eXBlIGZy
b20gcGxhbmV0eXBzKQogLS0gTm90ZXM6IEZsb29yIHR5cGUgSURzIG1hcCB0byBpbmRpY2VzIGlu
IHRoZSBwbGFuZXR5cHMgdGFibGUgZGVmaW5lZCBpbiBjb25maWcubHVhCiBmdW5jdGlvbiBnZXRf
Zmxvb3IoeCx5KQogIGlmIHg_PTAgYW5kIHg8MTI4IGFuZCB5Pj0wIGFuZCB5PDEyOCB0aGVuCiAg
IHJldHVybiBtYXAuZmxvb3JzOmdldCh4LHkpIG9yIDAKICBlbmQKICByZXR1cm4gMAogZW5kCgog
LS0gaGVscGVyOiBzZXQgZmxvb3IgdGlsZQogLS0gUHVycG9zZTogU3RvcmUgcGVyLWNlbGwgZmxv
b3IgdHlwZSBJRHMgZm9yIHZhcmllZCBmbG9vciB0ZXh0dXJlcwogLS0gUGFyYW1ldGVyczogeCwg
eSAoZ3JpZCBjb29yZGluYXRlcyAwLTEyNyksIHZhbCAoZmxvb3IgdHlwZSBJRCAwLTgpCiAtLSBO
b3RlczogMD11c2UgZ2xvYmFsIGRlZmF1bHQgZmxvb3IgdHlwZSwgMS04PXNwZWNpZmljIGZsb29y
IHR5cGUgZnJvbSBwbGFuZXR5cHMKIGZ1bmN0aW9uIHNldF9mbG9vcih4LHksdmFsKQogIGlmIHg_
PTAgYW5kIHg8MTI4IGFuZCB5Pj0wIGFuZCB5PDEyOCB0aGVuCiAgIC0tIG5vcm1hbGl6ZSB2YWwg
dG8gdmFsaWQgcmFuZ2UgMC04CiAgIGlmIHR5cGUodmFsKX49Im51bWJlciIgb3IgdmFsPT1uaWwg
dGhlbgogICAgdmFsPTAKICAgZWxzZWlmIHZhbDwwIHRoZW4KICAgIHZhbD0wCiAgIGVsc2VpZiB2
YWw_OCB0aGVuCiAgICB2YWw9OAogICBlbmQKICAgbWFwLmZsb29yczpzZXQoeCx5LHZhbCkKICBl
bmQKIGVuZAogCiAtLSBjb21wYXRpYmlsaXR5IGxheWVyOiBleHBvc2Ugd2FsbGdyaWQgYXMgdGFi
bGUgZm9yIGR1bmdlb24gZ2VuZXJhdG9yCiB3YWxsZ3JpZD17fQogLS0gZHVhbCBzdG9yYWdlIGRl
c2lnbjoKIC0tIGRvb3JzIGFycmF5IGVuYWJsZXMgZWZmaWNpZW50IGl0ZXJhdGlvbiBmb3IgdXBk
YXRlcy9taW5pbWFwOwogLS0gZG9vcmdyaWQgcHJvdmlkZXMgTygxKSBzcGF0aWFsIGxvb2t1cCBm
b3IgY29sbGlzaW9uL3JheWNhc3QuCiAtLSBCb3RoIHN0cnVjdHVyZXMgbXVzdCByZW1haW4gc3lu
Y2hyb25pemVkIGFjcm9zcyBmbG9vciByZWdlbmVyYXRpb25zLgogZG9vcmdyaWQ9e30KIGZvciBp
PTAsMTI3IGRvCiAgd2FsbGdyaWRbaV09e30KICBkb29yZ3JpZFtpXT17fQogIGZvciBqPTAsMTI3
IGRvCiAgIHdhbGxncmlkW2ldW2pdPTAKICAgZG9vcmdyaWRbaV1bal09bmlsCiAgZW5kCiBlbmQK
IAogLS0gaW5pdGlhbGl6ZSBmbG9vciBkYXRhCiBmb3IgaT0wLDEyNyBkbwogIGZvciBqPTAsMTI3
IGRvCiAgIHNldF9mbG9vcihpLGosMCkKICBlbmQKIGVuZAogIAogZG9vcnM9e30KIG9iamVjdHM9
e30KIGFuaW1hdGVkX29iamVjdHM9e30KIG9iamdyaWQ9e30KIGZvciBneD0wLG9iamdyaWRfYXJy
YXlfc2l6ZSBkbwogIG9iamdyaWRbZ3grMV09e30KICBmb3IgZ3k9MCxvYmpncmlkX2FycmF5X3Np
emUgZG8KICAgb2JqZ3JpZFtneCsxXVtneSsxXT17fQogIGVuZAogZW5kCiB6YnVmPXt9CiBmb3Ig
aT0xLHNjcmVlbl93aWR0aCBkbwogIHpidWZbaV09OTk5CiBlbmQKIAogLS0gcGVyLXJheSBkZXB0
aCBzdG9yYWdlIChkZWNvdXBsZWQgZnJvbSBwZXItcGl4ZWwgemJ1ZikKIHJheV96PXt9CiAKIC0t
IHBlci1yYXkgc3BhbiBib3VuZGFyaWVzIGFuZCB3b3JsZC1zcGFjZSBkaXJlY3Rpb25zCiByYXlf
eDA9e30KIHJheV94MT17fQogcmF5X2R4PXt9CiByYXlfZHk9e30KIGZvciBpPTAscmF5X2NvdW50
LTEgZG8KICByYXlfeltpXT05OTkKICByYXlfeDBbaV09MAogIHJheV94MVtpXT0wCiAgcmF5X2R4
W2ldPTAKICByYXlfZHlbaV09MAogZW5kCiAKIC0tIHBlci1yYXkgaGl0IGRhdGEgKDAtYmFzZWQg
aW5kZXhpbmcgZm9yIHBlci1yYXkgd3JpdGVzKQogcmJ1Zj17fQogZm9yIGk9MCxyYXlfY291bnQt
MSBkbwogIHJidWZbaV09e3RpbGU9MCx0eD0wfQogZW5kCiAKIC0tIGZvZyBzdGF0ZSBmb3IgaHlz
dGVyZXNpcwogbGFzdF9mb2dfej0wCiAKIC0tIHByb2plY3Rpb24gY29uc3RhbnQgZGVmaW5lZCBp
biBjb25maWcubHVhCiAKIC0tIGZsb29yIGFuZCByb29mIHN0YXRlCiBmbG9vcj17dHlwPXBsYW5l
dHlwc1sxXSx4PTAseT0wfQogcm9vZj17dHlwPXBsYW5ldHlwc1szXSx4PTAseT0wfQogCiAtLSBn
ZW5lcmF0ZSBkdW5nZW9uCiBzdGFydF9wb3MsZ2VuX3N0YXRzPWdlbmVyYXRlX2R1bmdlb24oKQog
CiAtLSBtb2RlOiAzZCBvciAyZCBtYXAKIHZpZXdfbW9kZT0iM2QiIC0tIG9yICIyZCIgZm9yIG1p
bmltYXAKIAogLS0gZGVidWcgbW9kZSBmb3IgcmF5IGNhc3RpbmcKIGRlYnVnX21vZGU9ZmFsc2UK
IHNob3dfZGlhZ25vc3RpY3M9ZmFsc2UKIGVuYWJsZV9kaWFnbm9zdGljc19sb2dnaW5nPXRydWUK
IAogLS0gZGlhZ25vc3RpYyBjb3VudGVycyBmb3IgcGVyZm9ybWFuY2UgdHJhY2tpbmcKIGRpYWdf
ZGRhX3N0ZXBzX3RvdGFsPTAKIGRpYWdfZGRhX2Vhcmx5X291dHM9MAogZGlhZ19mb2dfc3dpdGNo
ZXM9MAogZGlhZ193YWxsX2NvbHVtbnM9MAogZGlhZ19mbG9vcl9yb3dzPTAKIGRpYWdfZmxvb3Jf
ZHJhd19jYWxscz0wCiBkaWFnX3Nwcml0ZV9jb2x1bW5zPTAKIGRpYWdfZnJhbWVfY291bnQ9MAog
CiAtLSB0ZXN0IGRvb3IgbW9kZQogdGVzdF9kb29yX21vZGU9ZmFsc2UKCiAtLSBjcmVhdGUgdGlu
dGVkIGVycm9yIHRleHR1cmVzIGZvciBkaWZmZXJlbnQgb2JqZWN0IHR5cGVzIChjaGVja2VyYm9h
cmQgcGF0dGVybikKIC0tIHdhbGxzOiBtYWdlbnRhL3BpbmsgKDgvMTQpLCBmbG9vcjogYmx1ZS9j
eWFuICgxMi8xMyksIGNlaWxpbmc6IGdyZWVuL2RhcmsgZ3JlZW4gKDExLzMpCiAtLSBzcHJpdGVz
OiB5ZWxsb3cvb3JhbmdlICgxMC85KSwgcHJvcHM6IHJlZC9icm93biAoOC80KQogZXJyb3JfdGV4
dHVyZXMgPSB7CiAgd2FsbCA9IHVzZXJkYXRhKCJ1OCIsIDMyLCAzMiksCiBkb29yID0gdXNlcmRh
dGEoInU4IiwgMzIsIDMyKSwKICBmbG9vciA9IHVzZXJkYXRhKCJ1OCIsIDMyLCAzMiksCiAgY2Vp
bGluZyA9IHVzZXJkYXRhKCJ1OCIsIDMyLCAzMiksCiAgc3ByaXRlID0gdXNlcmRhdGEoInU4Iiwg
MzIsIDMyKSwKICBkZWZhdWx0ID0gdXNlcmRhdGEoInU4IiwgMzIsIDMyKQogfQogCiAtLSBnZW5l
cmF0ZSB0aW50ZWQgY2hlY2tlcmJvYXJkcyBmb3IgZWFjaCB0eXBlCiBsb2NhbCB0aW50cyA9IHsK
ICB3YWxsID0gezgsIDE0fSwgICAgICAtLSBtYWdlbnRhL3BpbmsKIGRvb3IgPSB7MiwgNn0sICAg
ICAgIC0tIHB1cnBsZS9ibHVlIChkaXN0aW5jdCBmcm9tIHdhbGxzKQogIGZsb29yID0gezEyLCAx
M30sICAgIC0tIGJsdWUvY3lhbgogIGNlaWxpbmcgPSB7MTEsIDN9LCAgIC0tIGdyZWVuL2Rhcmsg
Z3JlZW4KICBzcHJpdGUgPSB7MTAsIDl9LCAgICAtLSB5ZWxsb3cvb3JhbmdlCiAgZGVmYXVsdCA9
IHs4LCAxNH0gICAgLS0gbWFnZW50YS9waW5rIChmYWxsYmFjaykKIH0KIAogZm9yIHR5cGVfbmFt
ZSwgY29sb3JzIGluIHBhaXJzKHRpbnRzKSBkbwogIGZvciB5PTAsMzEgZG8KICAgZm9yIHg9MCwz
MSBkbwogICAgbG9jYWwgY29sb3IgPSAoKGZscih4LzQpICsgZmxyKHkvNCkpICUgMiA9PSAwKSBh
bmQgY29sb3JzWzFdIG9yIGNvbG9yc1syXQogICAgZXJyb3JfdGV4dHVyZXNbdHlwZV9uYW1lXTpz
ZXQoeCwgeSwgY29sb3IpCiAgIGVuZAogIGVuZAogZW5kCiAKIC0tIG1haW50YWluIGJhY2t3YXJk
IGNvbXBhdGliaWxpdHkgd2l0aCBzaW5nbGUgZXJyb3JfdGV4dHVyZQogZXJyb3JfdGV4dHVyZSA9
IGVycm9yX3RleHR1cmVzLmRlZmF1bHQKCiAtLSB2YWxpZGF0ZSBhbGwgY29uZmlndXJlZCBzcHJp
dGVzIGV4aXN0IChjb21tZW50IG91dCBmb3IgcHJvZHVjdGlvbikKIHZhbGlkYXRlX3Nwcml0ZV9j
b25maWd1cmF0aW9uKCkKCiBwcmludGgoInBpY290cm9uIHJheWNhc3QgZW5naW5lIHYxLjAiKQpl
bmQKCi0tIHZhbGlkYXRlIHNwcml0ZSBjb25maWd1cmF0aW9uIGF0IHN0YXJ0dXAgKG9wdGlvbmFs
LCBjYW4gYmUgZGlzYWJsZWQgZm9yIHBlcmZvcm1hbmNlKQpmdW5jdGlvbiB2YWxpZGF0ZV9zcHJp
dGVfY29uZmlndXJhdGlvbigpCiAtLSBjaGVjayBlbmVteSBzcHJpdGVzCiBmb3IgZW5lbXkgaW4g
YWxsKGVuZW15X3R5cGVzKSBkbwogIGlmIG5vdCBnZXRfc3ByKGVuZW15LnNwcml0ZSkgdGhlbgog
ICBwcmludGgoIldBUk5JTkc6IGVuZW15IHNwcml0ZSAiLi5lbmVteS5zcHJpdGUuLiIgKCIuLmVu
ZW15Lm5hbWUuLiIpIG5vdCBmb3VuZCBpbiBHRlggZmlsZXMiKQogIGVuZAogZW5kCiAKIC0tIGNo
ZWNrIGRlY29yYXRpb24gc3ByaXRlcwogZm9yIGRlYyBpbiBhbGwoZGVjb3JhdGlvbl90eXBlcykg
ZG8KICBpZiBub3QgZ2V0X3NwcihkZWMuc3ByaXRlKSB0aGVuCiAgIHByaW50aCgiV0FSTklORzog
ZGVjb3JhdGlvbiBzcHJpdGUgIi4uZGVjLnNwcml0ZS4uIiAoIi4uZGVjLm5hbWUuLiIpIG5vdCBm
b3VuZCBpbiBHRlggZmlsZXMiKQogIGVuZAogZW5kCiAKIC0tIGNoZWNrIHdhbGwgdGV4dHVyZSBz
cHJpdGVzCiBmb3IgdGV4c2V0IGluIGFsbCh0ZXhzZXRzKSBkbwogIGZvciB2YXJpYW50IGluIGFs
bCh0ZXhzZXQudmFyaWFudHMpIGRvCiAgIGlmIG5vdCBnZXRfc3ByKHZhcmlhbnQpIHRoZW4KICAg
IHByaW50aCgiV0FSTklORzogd2FsbCB0ZXh0dXJlIHNwcml0ZSAiLi52YXJpYW50Li4iIG5vdCBm
b3VuZCBpbiBHRlggZmlsZXMiKQogICBlbmQKICBlbmQKIGVuZAogCiAtLSBjaGVjayBmbG9vci9j
ZWlsaW5nIHNwcml0ZXMKIGZvciB0eXAgaW4gYWxsKHBsYW5ldHlwcykgZG8KICBpZiBub3QgZ2V0
X3Nwcih0eXAudGV4KSB0aGVuCiAgIHByaW50aCgiV0FSTklORzogZmxvb3IvY2VpbGluZyBzcHJp
dGUgIi4udHlwLnRleC4uIiBub3QgZm91bmQgaW4gR0ZYIGZpbGVzIikKICBlbmQKIGVuZAplbmQK
CmZ1bmN0aW9uIF91cGRhdGUoKQogLS0gaW5jcmVtZW50IGZyYW1lIGNvdW50ZXIKIGZyYW1lX2N0
Kz0xCiAKIC0tIGNvbWJhdCBnYXRpbmc6IHNraXAgbm9ybWFsIHVwZGF0ZXMgd2hlbiBpbiBjb21i
YXQKIGlmIGluX2NvbWJhdCB0aGVuCiAgdXBkYXRlX2NvbWJhdCgpCiAgcmV0dXJuCiBlbmQKIAog
dXBkYXRlX2lucHV0KCkKIHVwZGF0ZV9kb29ycygpCiAKIC0tIHVwZGF0ZSBucGMgYWkgKHJhdGUg
bGltaXRlZCwgZGV0ZXJtaW5pc3RpYyBmcmFtZSBjaGVjaykKIGlmIGZyYW1lX2N0JWFpX3VwZGF0
ZV9yYXRlPT0wIHRoZW4KICB1cGRhdGVfbnBjX2FpKCkKIGVuZAogCiBjYW09e3BsYXllci54LHBs
YXllci55fQogCiAtLSB1cGRhdGUgZmxvb3IvY2VpbGluZyBzY3JvbGxpbmcKIGZsb29yLngrPWZs
b29yLnR5cC54dmVsIG9yIDAKIGZsb29yLnkrPWZsb29yLnR5cC55dmVsIG9yIDAKIHJvb2YueCs9
cm9vZi50eXAueHZlbCBvciAwCiByb29mLnkrPXJvb2YudHlwLnl2ZWwgb3IgMAogCiAtLSB1cGRh
dGUgb2JqZWN0IGFuaW1hdGlvbnMKIGZvciBvYiBpbiBhbGwoYW5pbWF0ZWRfb2JqZWN0cykgZG8K
ICBpZiBvYi50eXAgYW5kIG9iLnR5cC5mcmFtZWN0IHRoZW4KICAgb2IuZnJhbWUrPW9iLnR5cC5h
bmltc3BkCiAgIGlmIG9iLmFuaW1sb29wIHRoZW4KICAgIG9iLmZyYW1lPW9iLmZyYW1lJW9iLnR5
cC5mcmFtZWN0CiAgIGVsc2UKICAgIG9iLmZyYW1lPW1pbihvYi5mcmFtZSxvYi50eXAuZnJhbWVj
dC0xKQogICBlbmQKICBlbmQKIGVuZAogCiAtLSB0b2dnbGUgdmlldyBtb2RlIChkZWJ1ZyBvbmx5
KQogaWYgZGVidWdfbW9kZSBhbmQgYnRucCg1KSB0aGVuIC0tIHgga2V5CiAgdmlld19tb2RlPXZp
ZXdfbW9kZT09IjNkIiBhbmQgIjJkIiBvciAiM2QiCiBlbmQKIAogLS0gZGVidWcgbW9kZSB0b2dn
bGUgKG1vdmVkIGZyb20gYnRucCg0KSB0byBhdm9pZCBjb25mbGljdCkKIGlmIGtleXAoInRhYiIp
IHRoZW4KICBkZWJ1Z19tb2RlPW5vdCBkZWJ1Z19tb2RlCiBlbmQKIAogLS0gdG9nZ2xlIGRpYWdu
b3N0aWNzIG92ZXJsYXkgd2l0aCBGMSBrZXkKIGlmIGtleXAoImYxIikgdGhlbgogIHNob3dfZGlh
Z25vc3RpY3M9bm90IHNob3dfZGlhZ25vc3RpY3MKIGVuZAogCiAtLSB0b2dnbGUgZGlhZ25vc3Rp
Y3MgbG9nZ2luZyB3aXRoIEYyIGtleQogaWYga2V5cCgiZjIiKSB0aGVuCiAgZW5hYmxlX2RpYWdu
b3N0aWNzX2xvZ2dpbmc9bm90IGVuYWJsZV9kaWFnbm9zdGljc19sb2dnaW5nCiAgcHJpbnRoKCJE
aWFnbm9zdGljcyBsb2dnaW5nOiAiLi50b3N0cmluZyhlbmFibGVfZGlhZ25vc3RpY3NfbG9nZ2lu
ZykpCiBlbmQKIAogLS0gZGVjcmVtZW50IHRyYXAgbWVzc2FnZSB0aW1lcgogaWYgdHJhcF9tc2df
dGltZXI_MCB0aGVuCiAgdHJhcF9tc2dfdGltZXItPTEKIGVuZAogCiAtLSB0b2dnbGUgdGVzdCBk
b29yIG1vZGUgKHdoZW4gbm90IGluIDJkIG1hcCB2aWV3KQogaWYgdmlld19tb2RlPT0iM2QiIGFu
ZCBidG5wKDgpIHRoZW4gLS0gdiBrZXkgZm9yIGRvb3IgdGVzdCBtb2RlCiAgdGVzdF9kb29yX21v
ZGU9bm90IHRlc3RfZG9vcl9tb2RlCiBlbmQKIAogLS0gY3ljbGUgdGVzdCBkb29yIG9wZW4gdmFs
dWUgKDAuMCB0byAxLjApCiBpZiB0ZXN0X2Rvb3JfbW9kZSB0aGVuCiAgaWYgYnRucCg2KSB0aGVu
IC0tIGMga2V5OiBpbmNyZWFzZQogICB0ZXN0X2Rvb3Jfb3Blbj0odGVzdF9kb29yX29wZW4gb3Ig
MCkrMC4xCiAgIGlmIHRlc3RfZG9vcl9vcGVuPjEgdGhlbiB0ZXN0X2Rvb3Jfb3Blbj0wIGVuZAog
IGVuZAogIGlmIGJ0bnAoNykgdGhlbiAtLSBkIGtleTogZGVjcmVhc2UKICAgdGVzdF9kb29yX29w
ZW49KHRlc3RfZG9vcl9vcGVuIG9yIDApLTAuMQogICBpZiB0ZXN0X2Rvb3Jfb3BlbjwwIHRoZW4g
dGVzdF9kb29yX29wZW49MSBlbmQKICBlbmQKIGVuZAogCiAtLSBjeWNsZSBmbG9vciB0eXBlIChm
b3IgdGVzdGluZykgd2hlbiBub3QgaW4gZG9vciB0ZXN0IG1vZGUKIGlmIG5vdCB0ZXN0X2Rvb3Jf
bW9kZSBhbmQgYnRucCg2KSB0aGVuIC0tIGMga2V5CiAgbG9jYWwgY3VycmVudF9pZHg9MQogIGZv
ciBpPTEsI3BsYW5ldHlwcyBkbwogICBpZiBwbGFuZXR5cHNbaV0udGV4PT1mbG9vci50eXAudGV4
IHRoZW4KICAgIGN1cnJlbnRfaWR4PWkKICAgIGJyZWFrCiAgIGVuZAogIGVuZAogIGZsb29yLnR5
cD1wbGFuZXR5cHNbKGN1cnJlbnRfaWR4ICUgI3BsYW5ldHlwcykrMV0KICBmbG9vci54LGZsb29y
Lnk9MCwwCiAgaWYgY2xlYXJfdGV4dHVyZV9jYWNoZXMgdGhlbiBjbGVhcl90ZXh0dXJlX2NhY2hl
cygpIGVuZAogZW5kCiAKIC0tIGN5Y2xlIHJvb2YgdHlwZSAoZm9yIHRlc3RpbmcpIHdoZW4gbm90
IGluIGRvb3IgdGVzdCBtb2RlCiBpZiBub3QgdGVzdF9kb29yX21vZGUgYW5kIGJ0bnAoNykgdGhl
biAtLSBkIGtleQogIGxvY2FsIGN1cnJlbnRfaWR4PTEKICBmb3IgaT0xLCNwbGFuZXR5cHMgZG8K
ICAgaWYgcGxhbmV0eXBzW2ldLnRleD09cm9vZi50eXAudGV4IHRoZW4KICAgIGN1cnJlbnRfaWR4
PWkKICAgIGJyZWFrCiAgIGVuZAogIGVuZAogIHJvb2YudHlwPXBsYW5ldHlwc1soY3VycmVudF9p
ZHggJSAjcGxhbmV0eXBzKSsxXQogIHJvb2YueCxyb29mLnk9MCwwCiAgaWYgY2xlYXJfdGV4dHVy
ZV9jYWNoZXMgdGhlbiBjbGVhcl90ZXh0dXJlX2NhY2hlcygpIGVuZAogZW5kCiAKIC0tIGRlYnVn
IHJheSBjYXN0aW5nCiAgaWYgZGVidWdfbW9kZSB0aGVuCiAgIGxvY2FsIHNhLGNhPXNpbihwbGF5
ZXIuYSksY29zKHBsYXllci5hKQogICBsb2NhbCB6LGh4LGh5LHRpbGUsdHg9cmF5Y2FzdChwbGF5
ZXIueCxwbGF5ZXIueSxjYSxzYSxzYSxjYSkKICAgcHJpbnRoKCJkZWJ1Zzogej0iLi4oZmxyKHoq
MTAwKS8xMDApLi4iIGh4PSIuLihmbHIoaHgqMTAwKS8xMDApLi4iIGh5PSIuLihmbHIoaHkqMTAw
KS8xMDApLi4iIHRpbGU9Ii4udGlsZS4uIiB0eD0iLi4oZmxyKHR4KjEwMCkvMTAwKSkKICAgbG9j
YWwgb2IsZGlzdD1oaXRzY2FuKHBsYXllci54LHBsYXllci55LGNhLHNhKQogICBpZiBvYiB0aGVu
CiAgICBwcmludGgoImRlYnVnOiBvYmogZm91bmQgYXQgZGlzdD0iLi4oZmxyKGRpc3QqMTAwKS8x
MDApLi4iIGtpbmQ9Ii4uKG9iLmtpbmQgb3IgInVua25vd24iKSkKICAgZWxzZQogICAgcHJpbnRo
KCJkZWJ1Zzogbm8gb2JqIGhpdCIpCiAgIGVuZAogIGVuZAplbmQKCmZ1bmN0aW9uIF9kcmF3KCkK
IGNsaXAoMCwwLHNjcmVlbl93aWR0aCxzY3JlZW5faGVpZ2h0KQogY2xzKDApCiAKIC0tIHJlc2V0
IGRpYWdub3N0aWMgY291bnRlcnMgYXQgZnJhbWUgc3RhcnQKIGRpYWdfZGRhX3N0ZXBzX3RvdGFs
PTAKIGRpYWdfZGRhX2Vhcmx5X291dHM9MAogZGlhZ19mb2dfc3dpdGNoZXM9MAogZGlhZ193YWxs
X2NvbHVtbnM9MAogZGlhZ19mbG9vcl9yb3dzPTAKIGRpYWdfZmxvb3JfZHJhd19jYWxscz0wCiBk
aWFnX3Nwcml0ZV9jb2x1bW5zPTAKIGRpYWdfZnJhbWVfY291bnQrPTEKIAogLS0gY2FjaGUgc2lu
L2NvcyBmb3IgZW50aXJlIGZyYW1lIHRvIGF2b2lkIHJlY29tcHV0YXRpb24KIHNhX2NhY2hlZD1z
aW4ocGxheWVyLmEpCiBjYV9jYWNoZWQ9Y29zKHBsYXllci5hKQogCiBpZiB2aWV3X21vZGU9PSIz
ZCIgdGhlbgogIHJheWNhc3Rfc2NlbmUoKQogIHJlbmRlcl9mbG9vcl9jZWlsaW5nKCkKICByZW5k
ZXJfd2FsbHMoKQogIHJlbmRlcl9zcHJpdGVzKCkKICAKICAtLSBodWQKICBwcmludCgicG9zOiIu
LmZscihwbGF5ZXIueCkuLiIsIi4uZmxyKHBsYXllci55KSwyLDIsNykKICBwcmludCgiYW5nOiIu
LihmbHIocGxheWVyLmEqMTAwKS8xMDApLDIsMTAsNykKICBwcmludCgiZnBzOiIuLnN0YXQoNyks
MiwxOCw3KQogIHByaW50KCJocDoiLi5wbGF5ZXIuaHAsMiwyNiw3KQogIGlmIGRlYnVnX21vZGUg
dGhlbgogICBwcmludCgiW3hdIHRvZ2dsZSBtYXAiLDIsMzQsNykKICBlbmQKICAKICAtLSBpbnRl
cmFjdGlvbiBwcm9tcHQKICBpZiBpbnRlcmFjdGlvbl9hY3RpdmUgYW5kIGN1cnJlbnRfaW50ZXJh
Y3QgdGhlbgogICBwcmludCgiW0VdL1o6IGludGVyYWN0IixzY3JlZW5fY2VudGVyX3gtNDAsc2Ny
ZWVuX2hlaWdodC0yMCwxMSkKICBlbmQKICAKICAtLSB0cmFwIG1lc3NhZ2UKICBpZiB0cmFwX21z
Z190aW1lcj4wIHRoZW4KICAgcHJpbnQoInRyYXAgc3BydW5nISIsc2NyZWVuX2NlbnRlcl94LTMw
LHNjcmVlbl9jZW50ZXJfeSw4KQogIGVuZAogIAogIC0tIGRlYnVnIG92ZXJsYXkKICBpZiBkZWJ1
Z19tb2RlIHRoZW4KICAgbG9jYWwgc2EsY2E9c2luKHBsYXllci5hKSxjb3MocGxheWVyLmEpCiAg
IGxvY2FsIHosaHgsaHksdGlsZSx0eD1yYXljYXN0KHBsYXllci54LHBsYXllci55LGNhLHNhLHNh
LGNhKQogICBwcmludCgiZGVidWcgb24gW3RhYl0iLDIsNDIsMTEpCiAgIHByaW50KCJ6PSIuLihm
bHIoeioxMDApLzEwMCksMiw1MCw3KQogICBwcmludCgidGlsZT0iLi50aWxlLDIsNTgsNykKICAg
cHJpbnQoInR4PSIuLihmbHIodHgqMTAwKS8xMDApLDIsNjYsNykKICAgcHJpbnQoImZsb29yOiAi
Li5mbG9vci50eXAudGV4LDIsNzQsNykKICAgcHJpbnQoInJvb2Y6ICIuLnJvb2YudHlwLnRleCwy
LDgyLDcpCiAgZW5kCiAgCiAgLS0gZGlhZ25vc3RpY3Mgb3ZlcmxheSAoaW5kZXBlbmRlbnQgb2Yg
ZGVidWdfbW9kZSwgdG9nZ2xlZCB3aXRoIEYxKQogIGlmIHNob3dfZGlhZ25vc3RpY3MgdGhlbgog
ICBsb2NhbCBkaWFnX3g9c2NyZWVuX3dpZHRoLTEyMAogICBsb2NhbCBkaWFnX3k9MgogICBwcmlu
dCgiPT09IERJQUdOT1NUSUNTID09PSIsZGlhZ194LGRpYWdfeSwxMSkKICAgZGlhZ195Kz04CiAg
IGxvY2FsIGF2Z19kZGE9cmF5X2NvdW50PjAgYW5kIGZscihkaWFnX2RkYV9zdGVwc190b3RhbC9y
YXlfY291bnQqMTApLzEwIG9yIDAKICAgcHJpbnQoIkREQSBzdGVwcy9yYXk6ICIuLmF2Z19kZGEs
ZGlhZ194LGRpYWdfeSw3KQogICBkaWFnX3krPTgKICAgcHJpbnQoIkVhcmx5LW91dHM6ICIuLmRp
YWdfZGRhX2Vhcmx5X291dHMsZGlhZ194LGRpYWdfeSw3KQogICBkaWFnX3krPTgKICAgcHJpbnQo
IkZvZyBzd2l0Y2hlczogIi4uZGlhZ19mb2dfc3dpdGNoZXMsZGlhZ194LGRpYWdfeSw3KQogICBk
aWFnX3krPTgKICAgcHJpbnQoIldhbGwgY29sdW1uczogIi4uZGlhZ193YWxsX2NvbHVtbnMsZGlh
Z194LGRpYWdfeSw3KQogICBkaWFnX3krPTgKICAgcHJpbnQoIkZsb29yIHJvd3M6ICIuLmRpYWdf
Zmxvb3Jfcm93cyxkaWFnX3gsZGlhZ195LDcpCiAgIGRpYWdfeSs9OAogICBwcmludCgiRmxvb3Ig
ZHJhdyBjYWxsczogIi4uZGlhZ19mbG9vcl9kcmF3X2NhbGxzLGRpYWdfeCxkaWFnX3ksNykKICAg
ZGlhZ195Kz04CiAgIHByaW50KCJTcHJpdGUgY29sdW1uczogIi4uZGlhZ19zcHJpdGVfY29sdW1u
cyxkaWFnX3gsZGlhZ195LDcpCiAgIGRpYWdfeSs9OAogICBwcmludCgiRlBTOiAiLi5zdGF0KDcp
LGRpYWdfeCxkaWFnX3ksNykKICAgZGlhZ195Kz04CiAgIHByaW50KCJGcmFtZTogIi4uZGlhZ19m
cmFtZV9jb3VudCxkaWFnX3gsZGlhZ195LDcpCiAgZW5kCiAgCiAgLS0gcGVyaW9kaWMgcHJpbnRo
IHN1bW1hcnkgKGV2ZXJ5IDYwIGZyYW1lcykgLSBpbmRlcGVuZGVudCBvZiBkZWJ1Z19tb2RlLCBj
b250cm9sbGVkIGJ5IGVuYWJsZV9kaWFnbm9zdGljc19sb2dnaW5nCiAgaWYgZW5hYmxlX2RpYWdu
b3N0aWNzX2xvZ2dpbmcgYW5kIGRpYWdfZnJhbWVfY291bnQlNjA9PTAgdGhlbgogICBsb2NhbCBh
dmdfZGRhPXJheV9jb3VudD4wIGFuZCBmbHIoZGlhZ19kZGFfc3RlcHNfdG90YWwvcmF5X2NvdW50
KjEwKS8xMCBvciAwCiAgIHByaW50aCgiPT09IEZSQU1FICIuLmRpYWdfZnJhbWVfY291bnQuLiIg
RElBR05PU1RJQ1MgPT09IikKICAgcHJpbnRoKCJBdmcgRERBIHN0ZXBzL3JheTogIi4uYXZnX2Rk
YSkKICAgcHJpbnRoKCJFYXJseS1vdXRzOiAiLi5kaWFnX2RkYV9lYXJseV9vdXRzKQogICBwcmlu
dGgoIkZvZyBzd2l0Y2hlczogIi4uZGlhZ19mb2dfc3dpdGNoZXMpCiAgIHByaW50aCgiV2FsbCBj
b2x1bW5zOiAiLi5kaWFnX3dhbGxfY29sdW1ucykKICAgcHJpbnRoKCJGbG9vciByb3dzOiAiLi5k
aWFnX2Zsb29yX3Jvd3MpCiAgIHByaW50aCgiRmxvb3IgZHJhdyBjYWxsczogIi4uZGlhZ19mbG9v
cl9kcmF3X2NhbGxzKQogICBwcmludGgoIlNwcml0ZSBjb2x1bW5zOiAiLi5kaWFnX3Nwcml0ZV9j
b2x1bW5zKQogICBwcmludGgoIkZQUzogIi4uc3RhdCg3KSkKICAgcHJpbnRoKCJDUFU6ICIuLnN0
YXQoMSkuLiIlIikKICBlbmQKICAKICAtLSBtaW5pbWFwIEhVRCBvdmVybGF5CiAgZHJhd19taW5p
bWFwX2h1ZCgpCiBlbHNlCiAgZHJhd19taW5pbWFwKCkKIGVuZAogCiAtLSBjb21iYXQgb3Zlcmxh
eQogaWYgaW5fY29tYmF0IHRoZW4KICByZWN0ZmlsbCgwLHNjcmVlbl9oZWlnaHQtNDAsc2NyZWVu
X3dpZHRoLHNjcmVlbl9oZWlnaHQsMCkKICBwcmludCgiZW50ZXJpbmcgY29tYmF0Li4uIixzY3Jl
ZW5fY2VudGVyX3gtNDAsc2NyZWVuX2NlbnRlcl95LDgpCiAgcHJpbnQoIltlc2NdIGV4aXQgKHRl
bXApIixzY3JlZW5fY2VudGVyX3gtNDAsc2NyZWVuX2NlbnRlcl95KzEwLDcpCiBlbmQKIAogLS0g
cmVzdG9yZSBwYWxldHRlIGZyb20gZm9nIHJlbWFwcGluZyAoc2luZ2xlIHJlc3RvcmUgcGVyIGZy
YW1lKQogcGFsKCkKIC0tIHJlc2V0IGZvZyBzdGF0ZSBzbyBmaXJzdCBzZXRfZm9nIGFwcGxpZXMg
bWFwcGluZyBuZXh0IGZyYW1lCiBsYXN0X2ZvZ19sZXZlbD0tMQogcHJldl9wYWw9e30KZW5kCgot
LSBkcmF3IDJkIG1pbmltYXAgZm9yIHRlc3RpbmcKLS0gUHVycG9zZTogUmVuZGVyIDJEIHRvcC1k
b3duIGRlYnVnIHZpZXcgb2YgZHVuZ2VvbgotLSBBbGdvcml0aG06IFNjYWxlIDEyOMOXMTI4IG1h
cCB0byAyNTbDlzI1NiBwaXhlbHMgKHNjYWxlPTIpCi0tIERpc3BsYXlzOiBXYWxscywgcm9vbXMs
IGRvb3JzLCBvYmplY3RzLCBwbGF5ZXIgcG9zaXRpb24gYW5kIGZhY2luZwotLSBOb3RlczogVG9n
Z2xlZCB3aXRoIFggYnV0dG9uLCB1c2VmdWwgZm9yIGRlYnVnZ2luZyBnZW5lcmF0aW9uCmZ1bmN0
aW9uIGRyYXdfbWluaW1hcCgpCiBsb2NhbCBzY2FsZT0yCiBsb2NhbCBveCxveT0xMCwxMAogCiAt
LSBkcmF3IHdhbGxncmlkIHdpdGggZmxvb3IgZGF0YSB0byBkaXN0aW5ndWlzaCBjb3JyaWRvcnMg
ZnJvbSB2b2lkCiBmb3IgeD0wLDEyNyBkbwogIGZvciB5PTAsMTI3IGRvCiAgIGxvY2FsIHdhbGw9
d2FsbGdyaWRbeF1beV0KICAgbG9jYWwgZmxvb3JfdmFsPWdldF9mbG9vcih4LHkpCiAgIGxvY2Fs
IGNvbG9yCiAgIGlmIHdhbGw_MCB0aGVuCiAgICAtLSB3YWxsIHRpbGUKICAgIGNvbG9yPTUKICAg
ZWxzZWlmIGZsb29yX3ZhbD4wIHRoZW4KICAgIC0tIGNhcnZlZCBjb3JyaWRvci9yb29tIGZsb29y
IChmbG9vciB0eXBlIHNldCBkdXJpbmcgZ2VuZXJhdGlvbikKICAgIGNvbG9yPTYKICAgZWxzZQog
ICAgLS0gdW5jYXJ2ZWQgdm9pZCAod2FsbD0wLCBmbG9vcj0wKQogICAgY29sb3I9MQogICBlbmQK
ICAgcmVjdGZpbGwob3greCpzY2FsZSxveSt5KnNjYWxlLG94K3gqc2NhbGUrc2NhbGUtMSxveSt5
KnNjYWxlK3NjYWxlLTEsY29sb3IpCiAgZW5kCiBlbmQKIAogLS0gZHJhdyByb29tcwogZm9yIG5v
ZGUgaW4gYWxsKGdlbl9ub2RlcykgZG8KICBsb2NhbCByPW5vZGUucmVjdAogIHJlY3Qob3grclsx
XSpzY2FsZSxveStyWzJdKnNjYWxlLG94K3JbM10qc2NhbGUsb3krcls0XSpzY2FsZSwxMSkKIGVu
ZAogCiAtLSBkcmF3IGRvb3JzCiBmb3IgZG9vciBpbiBhbGwoZG9vcnMpIGRvCiAgbG9jYWwgYz1k
b29yLmR0eXBlPT1kb29yX2xvY2tlZCBhbmQgOCBvciAxMgogIHJlY3RmaWxsKG94K2Rvb3IueCpz
Y2FsZSxveStkb29yLnkqc2NhbGUsb3grZG9vci54KnNjYWxlK3NjYWxlLTEsb3krZG9vci55KnNj
YWxlK3NjYWxlLTEsYykKIGVuZAogCiAtLSBkcmF3IG9iamVjdHMKIGZvciBvYiBpbiBhbGwob2Jq
ZWN0cykgZG8KICBsb2NhbCBjPTcKICBpZiBvYi50eXAgYW5kIG9iLnR5cC5raW5kPT0iaG9zdGls
ZV9ucGMiIHRoZW4gYz04CiAgZWxzZWlmIG9iLnR5cCBhbmQgb2IudHlwLmtpbmQ9PSJkaXJlY3Rf
cGlja3VwIiB0aGVuCiAgIGlmIG9iLnR5cC5zdWJ0eXBlPT0iaGVhcnQiIHRoZW4gYz0xNAogICBl
bHNlaWYgb2IudHlwLnN1YnR5cGU9PSJrZXkiIHRoZW4gYz05CiAgIGVuZAogIGVsc2VpZiBvYi50
eXAgYW5kIG9iLnR5cC5raW5kPT0iaW50ZXJhY3RhYmxlIiB0aGVuCiAgIGlmIG9iLnR5cC5zdWJ0
eXBlPT0iZXhpdCIgdGhlbiBjPTEyIGVuZAogIGVsc2VpZiBvYi50eXAgYW5kIG9iLnR5cC5raW5k
PT0iZGVjb3JhdGl2ZSIgdGhlbiBjPTEzCiAgZW5kCiAgbG9jYWwgeD1vYi5wb3NbMV0KICBsb2Nh
bCB5PW9iLnBvc1syXQogIGNpcmNmaWxsKG94K3gqc2NhbGUsb3kreSpzY2FsZSwxLGMpCiBlbmQK
IAogLS0gZHJhdyBwbGF5ZXIKIGxvY2FsIHB4LHB5PW94K3BsYXllci54KnNjYWxlLG95K3BsYXll
ci55KnNjYWxlCiBjaXJjZmlsbChweCxweSwyLDEwKQogbG9jYWwgc2EsY2E9c2luKHBsYXllci5h
KSxjb3MocGxheWVyLmEpCiBsaW5lKHB4LHB5LHB4K2NhKjYscHkrc2EqNiwxMCkKIAogLS0gc3Rh
dHMKIHByaW50KCIyZCBtYXAgdmlldyIsMTAsMiw3KQogcHJpbnQoInJvb21zOiAiLi5nZW5fc3Rh
dHMucm9vbXMsMTAsMTAsNykKIHByaW50KCJvYmplY3RzOiAiLi5nZW5fc3RhdHMub2JqZWN0cywx
MCwxOCw3KQogcHJpbnQoInNlZWQ6ICIuLmdlbl9zdGF0cy5zZWVkLDEwLDI2LDcpCiBpZiBkZWJ1
Z19tb2RlIHRoZW4KICBwcmludCgiW3hdIHRvZ2dsZSAzZCIsMTAsMzQsNykKIGVuZAplbmQKCi0t
IGRyYXcgaHVkIG1pbmltYXAgb3ZlcmxheQotLSBQdXJwb3NlOiBSZW5kZXIgc2Nyb2xsaW5nIHZp
ZXdwb3J0IG1pbmltYXAgaW4gdG9wLXJpZ2h0IGNvcm5lciBkdXJpbmcgM0QgdmlldwotLSBBbGdv
cml0aG06IFBsYXllci1jZW50ZXJlZCBjYW1lcmEgd2l0aCBjbGlwcGVkIGRyYXdpbmcgb2Ygdmlz
aWJsZSB0aWxlcyBvbmx5Ci0tIERpc3BsYXlzOiBXYWxscywgZmxvb3JzLCBkb29ycywgb2JqZWN0
cywgcGxheWVyIChhdXRvLXNjcm9sbHMgYXMgcGxheWVyIG1vdmVzKQotLSBOb3RlczogRml4ZWQg
MTIww5c2OHB4IHZpZXdwb3J0IGF0IHRvcC1yaWdodCwgc2NhbGU9Miwgb25seSBkcmF3cyB2aXNp
YmxlIHRpbGUgcmFuZ2UKZnVuY3Rpb24gZHJhd19taW5pbWFwX2h1ZCgpCiBsb2NhbCBodWRfdz1j
ZWlsKHNjcmVlbl93aWR0aCowLjI1KQogbG9jYWwgaHVkX2g9Y2VpbChzY3JlZW5faGVpZ2h0KjAu
MjUpCiBsb2NhbCBodWRfeD1zY3JlZW5fd2lkdGgtaHVkX3ctOAogbG9jYWwgaHVkX3k9OAogbG9j
YWwgc2NhbGU9MgogCiAtLSBjYW1lcmEgb2Zmc2V0IHRvIGNlbnRlciBwbGF5ZXIgaW4gdmlld3Bv
cnQKIGxvY2FsIGNhbV94PXBsYXllci54KnNjYWxlLWh1ZF93LzIKIGxvY2FsIGNhbV95PXBsYXll
ci55KnNjYWxlLWh1ZF9oLzIKIAogLS0gY2FsY3VsYXRlIHZpc2libGUgdGlsZSByYW5nZQogbG9j
YWwgeF9taW49bWF4KDAsZmxyKGNhbV94L3NjYWxlKSkKIGxvY2FsIHhfbWF4PW1pbigxMjcsZmxy
KChjYW1feCtodWRfdykvc2NhbGUpKQogbG9jYWwgeV9taW49bWF4KDAsZmxyKGNhbV95L3NjYWxl
KSkKIGxvY2FsIHlfbWF4PW1pbigxMjcsZmxyKChjYW1feStodWRfaCkvc2NhbGUpKQogCiAtLSBz
ZXQgY2xpcCByZWdpb24KIGNsaXAoaHVkX3gsaHVkX3ksaHVkX3csaHVkX2gpCiAKIC0tIGRyYXcg
YmFja2dyb3VuZAogcmVjdGZpbGwoaHVkX3gsaHVkX3ksaHVkX3graHVkX3ctMSxodWRfeStodWRf
aC0xLDApCiAKIC0tIGRyYXcgbWFwIHRpbGVzIChvbmx5IHZpc2libGUgcmFuZ2UpCiBmb3IgeD14
X21pbix4X21heCBkbwogIGZvciB5PXlfbWluLHlfbWF4IGRvCiAgIGxvY2FsIHN4PWh1ZF94Kyh4
KnNjYWxlLWNhbV94KQogICBsb2NhbCBzeT1odWRfeSsoeSpzY2FsZS1jYW1feSkKICAgCiAgIC0t
IGFkZGl0aW9uYWwgYm91bmRzIGNoZWNrCiAgIGlmIHN4Pj1odWRfeCBhbmQgc3g8aHVkX3graHVk
X3cgYW5kIHN5Pj1odWRfeSBhbmQgc3k8aHVkX3kraHVkX2ggdGhlbgogICAgbG9jYWwgd2FsbD13
YWxsZ3JpZFt4XVt5XQogICAgbG9jYWwgZmxvb3JfdmFsPWdldF9mbG9vcih4LHkpCiAgICBsb2Nh
bCBjb2xvcgogICAgCiAgICBpZiB3YWxsPjAgdGhlbgogICAgIGNvbG9yPTUKICAgIGVsc2VpZiBm
bG9vcl92YWw_MCB0aGVuCiAgICAgY29sb3I9NgogICAgZWxzZQogICAgIGNvbG9yPTEKICAgIGVu
ZAogICAgCiAgICByZWN0ZmlsbChzeCxzeSxzeCtzY2FsZS0xLHN5K3NjYWxlLTEsY29sb3IpCiAg
IGVuZAogIGVuZAogZW5kCiAKIC0tIGRyYXcgZG9vcnMgdmlhIHNwYXRpYWwgcXVlcnkgb3ZlciB2
aXNpYmxlIHRpbGVzCiBmb3IgeD14X21pbix4X21heCBkbwogIGZvciB5PXlfbWluLHlfbWF4IGRv
CiAgIGxvY2FsIGRvb3I9ZG9vcmdyaWRbeF0gYW5kIGRvb3JncmlkW3hdW3ldIG9yIG5pbAogICBp
ZiBkb29yIHRoZW4KICAgIGxvY2FsIHN4PWh1ZF94Kyh4KnNjYWxlLWNhbV94KQogICAgbG9jYWwg
c3k9aHVkX3krKHkqc2NhbGUtY2FtX3kpCiAgICBpZiBzeD49aHVkX3ggYW5kIHN4PGh1ZF94K2h1
ZF93IGFuZCBzeT49aHVkX3kgYW5kIHN5PGh1ZF95K2h1ZF9oIHRoZW4KICAgICBsb2NhbCBjPWRv
b3IuZHR5cGU9PWRvb3JfbG9ja2VkIGFuZCA4IG9yIDEyCiAgICAgcmVjdGZpbGwoc3gsc3ksc3gr
c2NhbGUtMSxzeStzY2FsZS0xLGMpCiAgICBlbmQKICAgZW5kCiAgZW5kCiBlbmQKIAogLS0gZHJh
dyBvYmplY3RzIHZpYSBzcGF0aWFsIHF1ZXJ5IG92ZXIgdmlzaWJsZSBvYmpncmlkIGNlbGxzCiBs
b2NhbCBneF9taW49ZmxyKHhfbWluL29iamdyaWRfc2l6ZSkKIGxvY2FsIGd4X21heD1mbHIoeF9t
YXgvb2JqZ3JpZF9zaXplKQogbG9jYWwgZ3lfbWluPWZscih5X21pbi9vYmpncmlkX3NpemUpCiBs
b2NhbCBneV9tYXg9ZmxyKHlfbWF4L29iamdyaWRfc2l6ZSkKIGd4X21pbj1tYXgoMCxneF9taW4p
CiBneF9tYXg9bWluKG9iamdyaWRfYXJyYXlfc2l6ZSxneF9tYXgpCiBneV9taW49bWF4KDAsZ3lf
bWluKQogZ3lfbWF4PW1pbihvYmpncmlkX2FycmF5X3NpemUsZ3lfbWF4KQogZm9yIGd4PWd4X21p
bixneF9tYXggZG8KICBmb3IgZ3k9Z3lfbWluLGd5X21heCBkbwogICBmb3Igb2IgaW4gYWxsKG9i
amdyaWRbZ3grMV1bZ3krMV0pIGRvCiAgICBsb2NhbCBzeD1odWRfeCsob2IucG9zWzFdKnNjYWxl
LWNhbV94KQogICAgbG9jYWwgc3k9aHVkX3krKG9iLnBvc1syXSpzY2FsZS1jYW1feSkKICAgIGlm
IHN4Pj1odWRfeCBhbmQgc3g8aHVkX3graHVkX3cgYW5kIHN5Pj1odWRfeSBhbmQgc3k8aHVkX3kr
aHVkX2ggdGhlbgogICAgIGxvY2FsIGM9NwogICAgIGlmIG9iLnR5cCBhbmQgb2IudHlwLmtpbmQ9
PSJob3N0aWxlX25wYyIgdGhlbiBjPTgKICAgICBlbHNlaWYgb2IudHlwIGFuZCBvYi50eXAua2lu
ZD09ImRpcmVjdF9waWNrdXAiIHRoZW4KICAgICAgaWYgb2IudHlwLnN1YnR5cGU9PSJoZWFydCIg
dGhlbiBjPTE0CiAgICAgIGVsc2VpZiBvYi50eXAuc3VidHlwZT09ImtleSIgdGhlbiBjPTkKICAg
ICAgZW5kCiAgICAgZWxzZWlmIG9iLnR5cCBhbmQgb2IudHlwLmtpbmQ9PSJpbnRlcmFjdGFibGUi
IHRoZW4KICAgICAgaWYgb2IudHlwLnN1YnR5cGU9PSJleGl0IiB0aGVuIGM9MTIgZW5kCiAgICAg
ZWxzZWlmIG9iLnR5cCBhbmQgb2IudHlwLmtpbmQ9PSJkZWNvcmF0aXZlIiB0aGVuIGM9MTMKICAg
ICBlbmQKICAgICBjaXJjZmlsbChzeCxzeSwxLGMpCiAgICBlbmQKICAgZW5kCiAgZW5kCiBlbmQK
IAogLS0gZHJhdyBwbGF5ZXIgKGFsd2F5cyBjZW50ZXJlZCBieSBjYW1lcmEgZGVzaWduKQogbG9j
YWwgcHg9aHVkX3grKHBsYXllci54KnNjYWxlLWNhbV94KQogbG9jYWwgcHk9aHVkX3krKHBsYXll
ci55KnNjYWxlLWNhbV95KQogY2lyY2ZpbGwocHgscHksMiwxMCkKIGxpbmUocHgscHkscHgrY2Ff
Y2FjaGVkKjYscHkrc2FfY2FjaGVkKjYsMTApCiAKIC0tIG9wdGlvbmFsIGZyYW1lCiByZWN0KGh1
ZF94LGh1ZF95LGh1ZF94K2h1ZF93LTEsaHVkX3kraHVkX2gtMSw3KQogCiAtLSByZXNldCBjbGlw
CiBjbGlwKCkKZW5kCgotLSB1bmlmaWVkIGNvbGxpc2lvbiBjaGVjayBmb3Igd2FsbHMsIGRvb3Jz
LCBhbmQgb2JqZWN0cwotLSBQdXJwb3NlOiBVbmlmaWVkIGNvbGxpc2lvbiBkZXRlY3Rpb24gZm9y
IHdhbGxzLCBkb29ycywgYW5kIG9iamVjdHMKLS0gUGFyYW1ldGVyczogcHgsIHB5ICh3b3JsZCBw
b3NpdGlvbiksIHJhZGl1cyAoY29sbGlzaW9uIHJhZGl1cyksIG9wZW5kb29ycyAoYXV0by1vcGVu
IGRvb3JzKSwgaXNwbGF5ZXIgKGVuYWJsZSBrZXkgY2hlY2tpbmcpCi0tIFJldHVybnM6IGJvb2xl
YW4gKHRydWUgaWYgY29sbGlzaW9uIGRldGVjdGVkKQotLSBBbGdvcml0aG06IEdyaWQtYmFzZWQg
d2FsbCBjaGVjayArIHNwYXRpYWwgcGFydGl0aW9uaW5nIGZvciBvYmplY3RzCi0tIFNpZGUgZWZm
ZWN0czogT3BlbnMgZG9vcnMsIHByZXZlbnRzIGRvb3IgY2xvc2luZyB3aGVuIHBsYXllciBpbnNp
ZGUKZnVuY3Rpb24gaXNjb2wocHgscHkscmFkaXVzLG9wZW5kb29ycyxpc3BsYXllcikKIGxvY2Fs
IGNvbD1mYWxzZQogb3BlbmRvb3JzPW9wZW5kb29ycyBvciBmYWxzZQogaXNwbGF5ZXI9aXNwbGF5
ZXIgb3IgZmFsc2UKIAogLS0gY2hlY2sgZ3JpZCBjZWxscyBhcm91bmQgcG9zaXRpb24KIGZvciB4
PWZscihweC1yYWRpdXMpLGZscihweCtyYWRpdXMpIGRvCiAgZm9yIHk9ZmxyKHB5LXJhZGl1cyks
ZmxyKHB5K3JhZGl1cykgZG8KICAgLS0gYm91bmRzIGNoZWNrCiAgIGlmIHg8MCBvciB4Pj0xMjgg
b3IgeTwwIG9yIHk_PTEyOCB0aGVuCiAgICBjb2w9dHJ1ZQogICAgYnJlYWsKICAgZWxzZQogICAg
bG9jYWwgdGlsZT1nZXRfd2FsbCh4LHkpCiAgICAKICAgIC0tIGNoZWNrIGlmIGRvb3IgdGlsZQog
ICAgaWYgdGlsZT09ZG9vcl9ub3JtYWwgb3IgdGlsZT09ZG9vcl9sb2NrZWQgb3IgdGlsZT09ZG9v
cl9zdGF5X29wZW4gdGhlbgogICAgIGxvY2FsIGRvb3I9ZG9vcmdyaWRbeF1beV0KICAgICBpZiBk
b29yIHRoZW4KICAgICAgaWYgZG9vci5vcGVuPT0xIHRoZW4KICAgICAgIC0tIGZ1bGx5IG9wZW46
IHByZXZlbnQgY2xvc2luZwogICAgICAgZG9vci5vcGVuaW5nPXRydWUKICAgICAgZWxzZQogICAg
ICAgLS0gZG9vciBwYXJ0aWFsbHkgb3BlbiBvciBjbG9zZWQ6IGNvbGxpc2lvbiBkZXRlY3RlZAog
ICAgICAgY29sPXRydWUKICAgICAgIC0tIGhhbmRsZSB1bmxvY2tpbmcvb3BlbmluZyBiZWZvcmUg
ZXhpdGluZyBpbm5lciBsb29wCiAgICAgICBpZiBvcGVuZG9vcnMgdGhlbgogICAgICAgIGlmIGRv
b3Iua2V5bnVtIHRoZW4KICAgICAgICAgLS0gY2hlY2sgaW52ZW50b3J5IGZvciBrZXkKICAgICAg
ICAgaWYgaXNwbGF5ZXIgdGhlbgogICAgICAgICAgZm9yIGksaXRlbSBpbiBpcGFpcnMocGxheWVy
LmtleXMpIGRvCiAgICAgICAgICAgaWYgaXRlbS5rZXludW09PWRvb3Iua2V5bnVtIHRoZW4KICAg
ICAgICAgICAgLS0gcmVtb3ZlIGtleQogICAgICAgICAgICBkZWxpKHBsYXllci5rZXlzLGkpCiAg
ICAgICAgICAgIGRvb3Iua2V5bnVtPW5pbAogICAgICAgICAgICBkb29yLm9wZW5pbmc9dHJ1ZQog
ICAgICAgICAgICAtLSBrZWVwIGNvbD10cnVlLCBkb24ndCBjbGVhciBpbW1lZGlhdGVseQogICAg
ICAgICAgICBicmVhawogICAgICAgICAgIGVuZAogICAgICAgICAgZW5kCiAgICAgICAgIGVuZAog
ICAgICAgIGVsc2UKICAgICAgICAgLS0gdW5sb2NrZWQKICAgICAgICAgZG9vci5vcGVuaW5nPXRy
dWUKICAgICAgICAgLS0ga2VlcCBjb2w9dHJ1ZSwgZG9uJ3QgY2xlYXIgaW1tZWRpYXRlbHkKICAg
ICAgICBlbmQKICAgICAgIGVuZAogICAgICAgLS0gZWFybHkgZXhpdCBmcm9tIGlubmVyIGxvb3Ag
b24gY29sbGlzaW9uIChhZnRlciBvcGVuZG9vcnMgaGFuZGxpbmcpCiAgICAgICBicmVhawogICAg
ICBlbmQKICAgICBlbmQKICAgIC0tIGNoZWNrIGlmIGV4aXQgcG9ydGFsCiAgICBlbHNlaWYgKHRp
bGU9PWV4aXRfc3RhcnQgb3IgdGlsZT09ZXhpdF9lbmQpIGFuZCBpc3BsYXllciB0aGVuCiAgICAg
LS0gcGxhY2Vob2xkZXIgZm9yIGxldmVsIGNvbXBsZXRpb24KICAgIC0tIGNoZWNrIGlmIHdhbGwK
ICAgIGVsc2VpZiB0aWxlPjAgdGhlbgogICAgIGNvbD10cnVlCiAgICAgYnJlYWsKICAgIGVuZAog
ICBlbmQKICBlbmQKICBpZiBjb2wgdGhlbiBicmVhayBlbmQKIGVuZAogCiAtLSBjaGVjayBzb2xp
ZCBvYmplY3RzIGFyb3VuZCBwb3NpdGlvbiB1c2luZyBvYmpncmlkIHNwYXRpYWwgcXVlcnkKIGxv
Y2FsIGd4X21pbj1mbHIoKHB4LXJhZGl1cykvb2JqZ3JpZF9zaXplKQogbG9jYWwgZ3hfbWF4PWZs
cigocHgrcmFkaXVzKS9vYmpncmlkX3NpemUpCiBsb2NhbCBneV9taW49ZmxyKChweS1yYWRpdXMp
L29iamdyaWRfc2l6ZSkKIGxvY2FsIGd5X21heD1mbHIoKHB5K3JhZGl1cykvb2JqZ3JpZF9zaXpl
KQogCiBneF9taW49bWF4KDAsZ3hfbWluKQogZ3hfbWF4PW1pbihvYmpncmlkX2FycmF5X3NpemUs
Z3hfbWF4KQogZ3lfbWluPW1heCgwLGd5X21pbikKIGd5X21heD1taW4ob2JqZ3JpZF9hcnJheV9z
aXplLGd5X21heCkKIAogZm9yIGd4PWd4X21pbixneF9tYXggZG8KICBmb3IgZ3k9Z3lfbWluLGd5
X21heCBkbwogICBmb3Igb2IgaW4gYWxsKG9iamdyaWRbZ3grMV1bZ3krMV0pIGRvCiAgICBpZiBv
Yi50eXAgYW5kIG9iLnR5cC5zb2xpZCB0aGVuCiAgICAgbG9jYWwgb3g9b2IucG9zWzFdLXB4CiAg
ICAgbG9jYWwgb3k9b2IucG9zWzJdLXB5CiAgICAgaWYgbWF4KGFicyhveCksYWJzKG95KSk8b2Iu
dHlwLncgdGhlbgogICAgICBjb2w9dHJ1ZQogICAgICAtLSB0cmlnZ2VyIGludGVyYWN0aW9uIG9u
IHNvbGlkIGNvbnRhY3QgaWYgcGxheWVyCiAgICAgIGlmIGlzcGxheWVyIHRoZW4KICAgICAgIGNo
ZWNrX2ludGVyYWN0aW9uc19hdChweCxweSkKICAgICAgZW5kCiAgICAgIGJyZWFrCiAgICAgZW5k
CiAgICBlbmQKICAgZW5kCiAgIGlmIGNvbCB0aGVuIGJyZWFrIGVuZAogIGVuZAogIGlmIGNvbCB0
aGVuIGJyZWFrIGVuZAogZW5kCiAKIHJldHVybiBjb2wKZW5kCgotLSBtb3ZlbWVudCB3cmFwcGVy
IHdpdGggc2xpZGluZyBjb2xsaXNpb24KLS0gUHVycG9zZTogTW92ZW1lbnQgd2l0aCBzbGlkaW5n
IGNvbGxpc2lvbiAodHJ5IGRpYWdvbmFsLCB0aGVuIFgsIHRoZW4gWSkKLS0gUGFyYW1ldGVyczog
cG9zICh0YWJsZSB3aXRoIHgseSksIHRhcmdldF94LCB0YXJnZXRfeSwgcmFkaXVzLCBvcGVuZG9v
cnMsIGlzcGxheWVyCi0tIFJldHVybnM6IGJvb2xlYW4gKHRydWUgaWYgYW55IG1vdmVtZW50IHN1
Y2NlZWRlZCkKLS0gQWxnb3JpdGhtOiBUaHJlZS1waGFzZSBjb2xsaXNpb24gY2hlY2sgZm9yIHNt
b290aCB3YWxsIHNsaWRpbmcKZnVuY3Rpb24gdHJ5bW92ZXRvKHBvcyx0YXJnZXRfeCx0YXJnZXRf
eSxyYWRpdXMsb3BlbmRvb3JzLGlzcGxheWVyKQogcmFkaXVzPXJhZGl1cyBvciBwbGF5ZXJfY29s
bGlzaW9uX3JhZGl1cwogb3BlbmRvb3JzPW9wZW5kb29ycyBvciBmYWxzZQogaXNwbGF5ZXI9aXNw
bGF5ZXIgb3IgZmFsc2UKIAogLS0gdHJ5IGRpcmVjdCBtb3ZlbWVudAogaWYgbm90IHJhZGl1cyBv
ciBub3QgaXNjb2wodGFyZ2V0X3gsdGFyZ2V0X3kscmFkaXVzLG9wZW5kb29ycyxpc3BsYXllcikg
dGhlbgogIHBvcy54LHBvcy55PXRhcmdldF94LHRhcmdldF95CiAgcmV0dXJuIHRydWUKIGVuZAog
CiAtLSB0cnkgeC1vbmx5IG1vdmVtZW50CiBpZiBhYnMocG9zLngtdGFyZ2V0X3gpPjAuMDEgYW5k
IG5vdCBpc2NvbCh0YXJnZXRfeCxwb3MueSxyYWRpdXMsb3BlbmRvb3JzLGlzcGxheWVyKSB0aGVu
CiAgcG9zLng9dGFyZ2V0X3gKICByZXR1cm4gdHJ1ZQogZW5kCiAKIC0tIHRyeSB5LW9ubHkgbW92
ZW1lbnQKIGlmIGFicyhwb3MueS10YXJnZXRfeSk_MC4wMSBhbmQgbm90IGlzY29sKHBvcy54LHRh
cmdldF95LHJhZGl1cyxvcGVuZG9vcnMsaXNwbGF5ZXIpIHRoZW4KICBwb3MueT10YXJnZXRfeQog
IHJldHVybiB0cnVlCiBlbmQKIAogcmV0dXJuIGZhbHNlCmVuZAoKLS0gbW92ZW1lbnQgd3JhcHBl
ciBmb3IgcG9zWzFdL3Bvc1syXSBhcnJheSBwb3NpdGlvbnMKZnVuY3Rpb24gdHJ5bW92ZXRvX3Bv
cyhwb3NfYXJyYXksdGFyZ2V0X3gsdGFyZ2V0X3kscmFkaXVzLG9wZW5kb29ycyxpc3BsYXllcikK
IHJhZGl1cz1yYWRpdXMgb3IgcGxheWVyX2NvbGxpc2lvbl9yYWRpdXMKIG9wZW5kb29ycz1vcGVu
ZG9vcnMgb3IgZmFsc2UKIGlzcGxheWVyPWlzcGxheWVyIG9yIGZhbHNlCiAKIC0tIHRyeSBkaXJl
Y3QgbW92ZW1lbnQKIGlmIG5vdCByYWRpdXMgb3Igbm90IGlzY29sKHRhcmdldF94LHRhcmdldF95
LHJhZGl1cyxvcGVuZG9vcnMsaXNwbGF5ZXIpIHRoZW4KICBwb3NfYXJyYXlbMV0scG9zX2FycmF5
WzJdPXRhcmdldF94LHRhcmdldF95CiAgcmV0dXJuIHRydWUKIGVuZAogCiAtLSB0cnkgeC1vbmx5
IG1vdmVtZW50CiBpZiBhYnMocG9zX2FycmF5WzFdLXRhcmdldF94KT4wLjAxIGFuZCBub3QgaXNj
b2wodGFyZ2V0X3gscG9zX2FycmF5WzJdLHJhZGl1cyxvcGVuZG9vcnMsaXNwbGF5ZXIpIHRoZW4K
ICBwb3NfYXJyYXlbMV09dGFyZ2V0X3gKICByZXR1cm4gdHJ1ZQogZW5kCiAKIC0tIHRyeSB5LW9u
bHkgbW92ZW1lbnQKIGlmIGFicyhwb3NfYXJyYXlbMl0tdGFyZ2V0X3kpPjAuMDEgYW5kIG5vdCBp
c2NvbChwb3NfYXJyYXlbMV0sdGFyZ2V0X3kscmFkaXVzLG9wZW5kb29ycyxpc3BsYXllcikgdGhl
bgogIHBvc19hcnJheVsyXT10YXJnZXRfeQogIHJldHVybiB0cnVlCiBlbmQKIAogcmV0dXJuIGZh
bHNlCmVuZAoKZnVuY3Rpb24gdXBkYXRlX2lucHV0KCkKIGxvY2FsIHNhLGNhPXNpbihwbGF5ZXIu
YSksY29zKHBsYXllci5hKQogCiAtLSBtb3ZlbWVudAogLS0gY29tYmluZSBrZXlzIHRvIGF2b2lk
IGRvdWJsZS1wcm9jZXNzaW5nIGFuZCBmaXggZGlyZWN0aW9uOgogLS0gcG9zaXRpdmUgdHVybiA9
IGxlZnQsIG5lZ2F0aXZlIHR1cm4gPSByaWdodAogbG9jYWwgdHVybj0oYnRuKDApIGFuZCAxIG9y
IDApLShidG4oMSkgYW5kIDEgb3IgMCkKIGlmIHR1cm5_PTAgdGhlbgogIHBsYXllci5hKz10dXJu
KnBsYXllcl9yb3RhdGlvbl9zcGVlZAogZW5kCiBpZiBidG4oMikgdGhlbiAtLSB1cAogIGxvY2Fs
IG54PXBsYXllci54K2NhKnBsYXllci5zcGQKICBsb2NhbCBueT1wbGF5ZXIueStzYSpwbGF5ZXIu
c3BkCiAgdHJ5bW92ZXRvKHBsYXllcixueCxueSxwbGF5ZXJfY29sbGlzaW9uX3JhZGl1cyx0cnVl
LHRydWUpCiBlbmQKIGlmIGJ0bigzKSB0aGVuIC0tIGRvd24KICBsb2NhbCBueD1wbGF5ZXIueC1j
YSpwbGF5ZXIuc3BkCiAgbG9jYWwgbnk9cGxheWVyLnktc2EqcGxheWVyLnNwZAogIHRyeW1vdmV0
byhwbGF5ZXIsbngsbnkscGxheWVyX2NvbGxpc2lvbl9yYWRpdXMsdHJ1ZSx0cnVlKQogZW5kCiAK
IC0tIGNoZWNrIGZvciBpbnRlcmFjdGlvbnMgZXZlcnkgZnJhbWUKIGNoZWNrX2ludGVyYWN0aW9u
cygpCiAKIC0tIGludGVyYWN0aW9uIGlucHV0OiBFIGtleSBvciBaIGJ1dHRvbgogaWYga2V5cCgi
ZSIpIG9yIGJ0bnAoNCkgdGhlbgogIGhhbmRsZV9pbnRlcmFjdCgpCiBlbmQKZW5kCgotLSBhZGQg
b2JqZWN0IHRvIG9iamdyaWQKLS0gUHVycG9zZTogQWRkIG9iamVjdCB0byBzcGF0aWFsIHBhcnRp
dGlvbmluZyBncmlkCi0tIFBhcmFtZXRlcnM6IG9iIChvYmplY3Qgd2l0aCBwb3MgYXJyYXkpCi0t
IFNpZGUgZWZmZWN0czogQWRkcyB0byBvYmpncmlkIGNlbGwgYmFzZWQgb24gcG9zaXRpb24sIGFk
ZHMgdG8gYW5pbWF0ZWRfb2JqZWN0cyBpZiBhdXRvYW5pbT10cnVlCi0tIE5vdGVzOiBVc2VkIGR1
cmluZyBkdW5nZW9uIGdlbmVyYXRpb24gYW5kIG9iamVjdCBzcGF3bmluZwpmdW5jdGlvbiBhZGRv
YmplY3Qob2IpCiBpZiBub3Qgb2IucG9zIHRoZW4gcmV0dXJuIGVuZAogbG9jYWwgZ3g9ZmxyKG9i
LnBvc1sxXS9vYmpncmlkX3NpemUpCiBsb2NhbCBneT1mbHIob2IucG9zWzJdL29iamdyaWRfc2l6
ZSkKIGlmIGd4Pj0wIGFuZCBneDw9b2JqZ3JpZF9hcnJheV9zaXplIGFuZCBneT49MCBhbmQgZ3k8
PW9iamdyaWRfYXJyYXlfc2l6ZSB0aGVuCiAgYWRkKG9iamdyaWRbZ3grMV1bZ3krMV0sb2IpCiAg
LS0gYWRkIHRvIGFuaW1hdGVkIGxpc3QgaWYgYXV0b2FuaW0gaXMgdHJ1ZQogIGlmIG9iLmF1dG9h
bmltIHRoZW4KICAgYWRkKGFuaW1hdGVkX29iamVjdHMsb2IpCiAgZW5kCiBlbmQKZW5kCgotLSBy
ZW1vdmUgb2JqZWN0IGZyb20gb2JqZ3JpZApmdW5jdGlvbiByZW1vdmVvYmplY3Qob2IpCiBpZiBu
b3Qgb2IucG9zIHRoZW4gcmV0dXJuIGVuZAogbG9jYWwgZ3g9ZmxyKG9iLnBvc1sxXS9vYmpncmlk
X3NpemUpCiBsb2NhbCBneT1mbHIob2IucG9zWzJdL29iamdyaWRfc2l6ZSkKIGlmIGd4Pj0wIGFu
ZCBneDw9b2JqZ3JpZF9hcnJheV9zaXplIGFuZCBneT49MCBhbmQgZ3k8PW9iamdyaWRfYXJyYXlf
c2l6ZSB0aGVuCiAgZGVsaShvYmpncmlkW2d4KzFdW2d5KzFdLG9iKQogIC0tIGFsc28gcmVtb3Zl
IGZyb20gYW5pbWF0ZWQgbGlzdAogIGlmIG9iLmF1dG9hbmltIHRoZW4KICAgZGVsaShhbmltYXRl
ZF9vYmplY3RzLG9iKQogIGVuZAogZW5kCmVuZAoKLS0gdXBkYXRlIG9iamVjdCBncmlkIGFmdGVy
IHBvc2l0aW9uIGNoYW5nZQpmdW5jdGlvbiB1cGRhdGVfb2JqZWN0X2dyaWQob2Isb2xkX3gsb2xk
X3kpCiBpZiBub3Qgb2IucG9zIHRoZW4gcmV0dXJuIGVuZAogbG9jYWwgb2xkX2d4PWZscihvbGRf
eC9vYmpncmlkX3NpemUpCiBsb2NhbCBvbGRfZ3k9ZmxyKG9sZF95L29iamdyaWRfc2l6ZSkKIGxv
Y2FsIG5ld19neD1mbHIob2IucG9zWzFdL29iamdyaWRfc2l6ZSkKIGxvY2FsIG5ld19neT1mbHIo
b2IucG9zWzJdL29iamdyaWRfc2l6ZSkKIGlmIG9sZF9neH49bmV3X2d4IG9yIG9sZF9neX49bmV3
X2d5IHRoZW4KICBpZiBvbGRfZ3g_PTAgYW5kIG9sZF9neDw9b2JqZ3JpZF9hcnJheV9zaXplIGFu
ZCBvbGRfZ3k_PTAgYW5kIG9sZF9neTw9b2JqZ3JpZF9hcnJheV9zaXplIHRoZW4KICAgZGVsaShv
YmpncmlkW29sZF9neCsxXVtvbGRfZ3krMV0sb2IpCiAgZW5kCiAgaWYgbmV3X2d4Pj0wIGFuZCBu
ZXdfZ3g8PW9iamdyaWRfYXJyYXlfc2l6ZSBhbmQgbmV3X2d5Pj0wIGFuZCBuZXdfZ3k8PW9iamdy
aWRfYXJyYXlfc2l6ZSB0aGVuCiAgIGFkZChvYmpncmlkW25ld19neCsxXVtuZXdfZ3krMV0sb2Ip
CiAgZW5kCiBlbmQKZW5kCgotLSBjaGVjayBpbnRlcmFjdGlvbnMgYXJvdW5kIHBsYXllciBwb3Np
dGlvbgotLSBQdXJwb3NlOiBTY2FuIG5lYXJieSBvYmplY3RzIGZvciBwcm94aW1pdHktYmFzZWQg
aW50ZXJhY3Rpb25zCi0tIEFsZ29yaXRobTogM8OXMyBvYmpncmlkIGNlbGwgc2NhbiBhcm91bmQg
cGxheWVyCi0tIFNpZGUgZWZmZWN0czogQXV0by1jb2xsZWN0cyBwaWNrdXBzLCB0cmlnZ2VycyBj
b21iYXQsIHNldHMgaW50ZXJhY3Rpb24gZmxhZ3MKLS0gTm90ZXM6IENhbGxlZCBldmVyeSBmcmFt
ZSBpbiBfdXBkYXRlKCkKZnVuY3Rpb24gY2hlY2tfaW50ZXJhY3Rpb25zKCkKIGNoZWNrX2ludGVy
YWN0aW9uc19hdChwbGF5ZXIueCxwbGF5ZXIueSkKZW5kCgotLSBjaGVjayBpbnRlcmFjdGlvbnMg
YXQgc3BlY2lmaWMgcG9zaXRpb24gKGF2b2lkcyByZWN1cnNpb24pCmZ1bmN0aW9uIGNoZWNrX2lu
dGVyYWN0aW9uc19hdChweCxweSkKIGxvY2FsIGd4X2NlbnRlcj1mbHIocHgvb2JqZ3JpZF9zaXpl
KQogbG9jYWwgZ3lfY2VudGVyPWZscihweS9vYmpncmlkX3NpemUpCiAKIC0tIHNjYW4gM3gzIGJs
b2NrIGFyb3VuZCBwbGF5ZXIKIGxvY2FsIGNsb3Nlc3RfaW50ZXJhY3Q9bmlsCiBsb2NhbCBjbG9z
ZXN0X2Rpc3Q9OTk5CiAKIGZvciBneD1neF9jZW50ZXItMSxneF9jZW50ZXIrMSBkbwogIGZvciBn
eT1neV9jZW50ZXItMSxneV9jZW50ZXIrMSBkbwogICBpZiBneD49MCBhbmQgZ3g8PW9iamdyaWRf
YXJyYXlfc2l6ZSBhbmQgZ3k_PTAgYW5kIGd5PD1vYmpncmlkX2FycmF5X3NpemUgdGhlbgogICAg
Zm9yIG9iIGluIGFsbChvYmpncmlkW2d4KzFdW2d5KzFdKSBkbwogICAgIGlmIG9iLnBvcyBhbmQg
b2IudHlwIHRoZW4KICAgICAgbG9jYWwgZHg9b2IucG9zWzFdLXB4CiAgICAgIGxvY2FsIGR5PW9i
LnBvc1syXS1weQogICAgICBsb2NhbCBkaXN0PWFicyhkeCkrYWJzKGR5KQogICAgICAKICAgICAg
LS0gZGlyZWN0IHBpY2t1cDogYXV0by1jb2xsZWN0CiAgICAgIGlmIG9iLnR5cC5raW5kPT0iZGly
ZWN0X3BpY2t1cCIgYW5kIGRpc3Q8aW50ZXJhY3Rpb25fcmFuZ2UgdGhlbgogICAgICAgY29sbGVj
dF9pdGVtKG9iKQogICAgICAgcmVtb3Zlb2JqZWN0KG9iKQogICAgICAgZGVsaShvYmplY3RzLG9i
KQogICAgICAKICAgICAgLS0gaG9zdGlsZSBucGM6IHRyaWdnZXIgY29tYmF0CiAgICAgIGVsc2Vp
ZiBvYi50eXAua2luZD09Imhvc3RpbGVfbnBjIiBhbmQgZGlzdDxjb21iYXRfdHJpZ2dlcl9yYW5n
ZSB0aGVuCiAgICAgICBpbl9jb21iYXQ9dHJ1ZQogICAgICAgY3VycmVudF90YXJnZXQ9b2IKICAg
ICAgCiAgICAgIC0tIGludGVyYWN0YWJsZTogc2V0IGZsYWcgZm9yIGNsb3Nlc3QKICAgICAgZWxz
ZWlmIG9iLnR5cC5raW5kPT0iaW50ZXJhY3RhYmxlIiBhbmQgZGlzdDxpbnRlcmFjdGlvbl9yYW5n
ZSB0aGVuCiAgICAgICAtLSB0cmFwOiBpbW1lZGlhdGUgZWZmZWN0CiAgICAgICBpZiBvYi50eXAu
c3VidHlwZT09InRyYXAiIHRoZW4KICAgICAgICBwbGF5ZXIuaHA9bWF4KDAscGxheWVyLmhwLTEw
KQogICAgICAgIHRyYXBfbXNnX3RpbWVyPTYwCiAgICAgICAgcmVtb3Zlb2JqZWN0KG9iKQogICAg
ICAgIGRlbGkob2JqZWN0cyxvYikKICAgICAgIGVsc2VpZiBkaXN0PGNsb3Nlc3RfZGlzdCB0aGVu
CiAgICAgICAgY2xvc2VzdF9pbnRlcmFjdD1vYgogICAgICAgIGNsb3Nlc3RfZGlzdD1kaXN0CiAg
ICAgICBlbmQKICAgICAgZW5kCiAgICAgZW5kCiAgICBlbmQKICAgZW5kCiAgZW5kCiBlbmQKIAog
LS0gdXBkYXRlIGludGVyYWN0aW9uIHN0YXRlCiBpZiBjbG9zZXN0X2ludGVyYWN0IHRoZW4KICBp
bnRlcmFjdGlvbl9hY3RpdmU9dHJ1ZQogIGN1cnJlbnRfaW50ZXJhY3Q9Y2xvc2VzdF9pbnRlcmFj
dAogZWxzZQogIGludGVyYWN0aW9uX2FjdGl2ZT1mYWxzZQogIGN1cnJlbnRfaW50ZXJhY3Q9bmls
CiBlbmQKZW5kCgotLSBjb2xsZWN0IGl0ZW0gKHBpY2t1cCkKLS0gUHVycG9zZTogSGFuZGxlIHBp
Y2t1cCBjb2xsZWN0aW9uIGFuZCBpbnZlbnRvcnkgdXBkYXRlcwotLSBQYXJhbWV0ZXJzOiBvYiAo
b2JqZWN0IHdpdGggdHlwLnN1YnR5cGUpCi0tIFNpZGUgZWZmZWN0czogQWRkcyB0byBwbGF5ZXIu
a2V5cywgaW5jcmVhc2VzIHBsYXllci5ocAotLSBOb3RlczogQ2FsbGVkIGJ5IGNoZWNrX2ludGVy
YWN0aW9uc19hdCgpIGZvciBkaXJlY3RfcGlja3VwIG9iamVjdHMKZnVuY3Rpb24gY29sbGVjdF9p
dGVtKG9iKQogaWYgb2IudHlwLnN1YnR5cGU9PSJrZXkiIGFuZCBvYi5rZXludW0gdGhlbgogIGFk
ZChwbGF5ZXIua2V5cyx7a2V5bnVtPW9iLmtleW51bX0pCiAgcHJpbnRoKCJjb2xsZWN0ZWQga2V5
ICIuLm9iLmtleW51bSkKIGVsc2VpZiBvYi50eXAuc3VidHlwZT09ImhlYXJ0IiB0aGVuCiAgcGxh
eWVyLmhwPW1pbigxMDAscGxheWVyLmhwKzIwKQogIHByaW50aCgiY29sbGVjdGVkIGhlYXJ0IikK
IGVsc2UKICBwcmludGgoImNvbGxlY3RlZCBpdGVtIikKIGVuZAplbmQKCi0tIGhhbmRsZSBpbnRl
cmFjdGlvbiB3aGVuIHBsYXllciBwcmVzc2VzIEUvWgotLSBQdXJwb3NlOiBQcm9jZXNzIHBsYXll
ci1pbml0aWF0ZWQgaW50ZXJhY3Rpb25zIChFIGtleSAvIFogYnV0dG9uKQotLSBBbGdvcml0aG06
IFN3aXRjaCBvbiBjdXJyZW50X2ludGVyYWN0LnR5cC5zdWJ0eXBlCi0tIFNpZGUgZWZmZWN0czog
T3BlbnMgY2hlc3RzLCBhY3RpdmF0ZXMgc2hyaW5lcywgcmVhZHMgbm90ZXMsIHRyaWdnZXJzIGZs
b29yIHRyYW5zaXRpb24KLS0gTm90ZXM6IE9ubHkgcnVucyB3aGVuIGludGVyYWN0aW9uX2FjdGl2
ZSBmbGFnIGlzIHRydWUKZnVuY3Rpb24gaGFuZGxlX2ludGVyYWN0KCkKIGlmIG5vdCBpbnRlcmFj
dGlvbl9hY3RpdmUgb3Igbm90IGN1cnJlbnRfaW50ZXJhY3QgdGhlbiByZXR1cm4gZW5kCiAKIGxv
Y2FsIHN1YnR5cGU9Y3VycmVudF9pbnRlcmFjdC50eXAgYW5kIGN1cnJlbnRfaW50ZXJhY3QudHlw
LnN1YnR5cGUgb3IgInVua25vd24iCiAKIGlmIHN1YnR5cGU9PSJjaGVzdCIgdGhlbgogIC0tIG9w
ZW4gY2hlc3QgKHBsYWNlaG9sZGVyKQogIHBsYXllci5ocD1taW4oMTAwLHBsYXllci5ocCsxMCkK
ICBwcmludGgoIm9wZW5lZCBjaGVzdCIpCiAgcmVtb3Zlb2JqZWN0KGN1cnJlbnRfaW50ZXJhY3Qp
CiAgZGVsaShvYmplY3RzLGN1cnJlbnRfaW50ZXJhY3QpCiAgCiBlbHNlaWYgc3VidHlwZT09InNo
cmluZSIgdGhlbgogIC0tIGFjdGl2YXRlIHNocmluZSAocGxhY2Vob2xkZXIpCiAgcGxheWVyLmhw
PTEwMAogIHByaW50aCgiYWN0aXZhdGVkIHNocmluZSIpCiAgCiBlbHNlaWYgc3VidHlwZT09Im5v
dGUiIHRoZW4KICAtLSByZWFkIG5vdGUgKHBsYWNlaG9sZGVyKQogIHByaW50aCgicmVhZCBub3Rl
IikKICByZW1vdmVvYmplY3QoY3VycmVudF9pbnRlcmFjdCkKICBkZWxpKG9iamVjdHMsY3VycmVu
dF9pbnRlcmFjdCkKICAKIGVsc2VpZiBzdWJ0eXBlPT0iZXhpdCIgdGhlbgogIC0tIHRyaWdnZXIg
bmV4dCBmbG9vcgogIHByaW50aCgidXNpbmcgZXhpdCBwb3J0YWwiKQogIGdlbmVyYXRlX25ld19m
bG9vcigpCiAgCiBlbmQKIAogLS0gY2xlYXIgaW50ZXJhY3Rpb24gc3RhdGUgYWZ0ZXIgaGFuZGxp
bmcKIGludGVyYWN0aW9uX2FjdGl2ZT1mYWxzZQogY3VycmVudF9pbnRlcmFjdD1uaWwKZW5kCgot
LSBnZW5lcmF0ZSBuZXcgZmxvb3IgKHJlZ2VuZXJhdGUgZHVuZ2VvbikKZnVuY3Rpb24gZ2VuZXJh
dGVfbmV3X2Zsb29yKCkKIC0tIGluY3JlbWVudCBkaWZmaWN1bHR5CiBnZW5fcGFyYW1zLmRpZmZp
Y3VsdHk9bWluKGdlbl9wYXJhbXMubWF4X2RpZmZpY3VsdHksZ2VuX3BhcmFtcy5kaWZmaWN1bHR5
KzEpCiAKIC0tIGNsZWFyIGV4aXN0aW5nIG9iamVjdHMKIGZvciBneD0xLG9iamdyaWRfYXJyYXlf
c2l6ZSsxIGRvCiAgZm9yIGd5PTEsb2JqZ3JpZF9hcnJheV9zaXplKzEgZG8KICAgb2JqZ3JpZFtn
eF1bZ3ldPXt9CiAgZW5kCiBlbmQKIG9iamVjdHM9e30KIGFuaW1hdGVkX29iamVjdHM9e30KIGRv
b3JzPXt9CiAtLSBhbHNvIGNsZWFyIGRvb3JncmlkIHRvIHByZXZlbnQgc3RhbGUgcmVmZXJlbmNl
cwogZm9yIGk9MCwxMjcgZG8KICBpZiBkb29yZ3JpZFtpXSB0aGVuCiAgIGZvciBqPTAsMTI3IGRv
CiAgICBkb29yZ3JpZFtpXVtqXT1uaWwKICAgZW5kCiAgZW5kCiBlbmQKIAogLS0gcmVnZW5lcmF0
ZSBkdW5nZW9uCiBzdGFydF9wb3MsZ2VuX3N0YXRzPWdlbmVyYXRlX2R1bmdlb24oKQogLS0gaW52
YWxpZGF0ZSBwZXJzaXN0ZW50IHJlbmRlciBjYWNoZXMgZm9yIG5ldyBmbG9vcgogaWYgY2xlYXJf
dGV4dHVyZV9jYWNoZXMgdGhlbiBjbGVhcl90ZXh0dXJlX2NhY2hlcygpIGVuZAogCiBwcmludGgo
ImZsb29yIGNvbXBsZXRlISBkaWZmaWN1bHR5OiAiLi5nZW5fcGFyYW1zLmRpZmZpY3VsdHkpCiAK
IC0tIGxldmVsIGxvYWQgZGlhZ25vc3RpYyBzdW1tYXJ5CiBwcmludGgoIj09PSBMRVZFTCBMT0FE
IERJQUdOT1NUSUNTID09PSIpCiBwcmludGgoIkZsb29yOiAiLi4oY3VycmVudF9mbG9vciBvciAi
dW5rbm93biIpKQogcHJpbnRoKCJEaWZmaWN1bHR5OiAiLi5nZW5fcGFyYW1zLmRpZmZpY3VsdHkp
CiBwcmludGgoIlJvb21zOiAiLi5nZW5fc3RhdHMucm9vbXMpCiBwcmludGgoIk9iamVjdHM6ICIu
Lmdlbl9zdGF0cy5vYmplY3RzKQogcHJpbnRoKCJTZWVkOiAiLi5nZW5fc3RhdHMuc2VlZCkKZW5k
CgotLSB1cGRhdGUgY29tYmF0IChwbGFjZWhvbGRlcikKZnVuY3Rpb24gdXBkYXRlX2NvbWJhdCgp
CiAtLSB0ZW1wIGV4aXQ6IHByZXNzIGVzY2FwZSBvciBtZW51IGJ1dHRvbgogaWYga2V5cCgiZXNj
YXBlIikgb3IgYnRucCg2KSB0aGVuCiAgaW5fY29tYmF0PWZhbHNlCiAgY3VycmVudF90YXJnZXQ9
bmlsCiAgcHJpbnRoKCJleGl0ZWQgY29tYmF0IikKIGVuZAplbmQKCi0tIHVwZGF0ZSBucGMgYWkg
KGJhc2ljIHBhdHJvbCBhbmQgZm9sbG93KQpmdW5jdGlvbiB1cGRhdGVfbnBjX2FpKCkKIGZvciBn
eD0wLG9iamdyaWRfYXJyYXlfc2l6ZSBkbwogIGZvciBneT0wLG9iamdyaWRfYXJyYXlfc2l6ZSBk
bwogICBmb3Igb2IgaW4gYWxsKG9iamdyaWRbZ3grMV1bZ3krMV0pIGRvCiAgICBpZiBvYi50eXAg
YW5kIG9iLnR5cC5raW5kPT0iaG9zdGlsZV9ucGMiIGFuZCBvYi5haV90eXBlIHRoZW4KICAgICBs
b2NhbCBvbGRfeCxvbGRfeT1vYi5wb3NbMV0sb2IucG9zWzJdCiAgICAgCiAgICAgaWYgb2IuYWlf
dHlwZT09InBhdHJvbCIgdGhlbgogICAgICAtLSBwYXRyb2w6IGN5Y2xlIHRocm91Z2ggcGF0cm9s
X3BvaW50cwogICAgICBpZiBvYi5wYXRyb2xfcG9pbnRzIGFuZCAjb2IucGF0cm9sX3BvaW50cz4w
IHRoZW4KICAgICAgIC0tIGluaXRpYWxpemUgcGF0cm9sX2luZGV4IGlmIG5pbCBvciAwCiAgICAg
ICBpZiBub3Qgb2IucGF0cm9sX2luZGV4IG9yIG9iLnBhdHJvbF9pbmRleD09MCB0aGVuCiAgICAg
ICAgb2IucGF0cm9sX2luZGV4PTEKICAgICAgIGVuZAogICAgICAgCiAgICAgICBsb2NhbCB0YXJn
ZXQ9b2IucGF0cm9sX3BvaW50c1tvYi5wYXRyb2xfaW5kZXhdCiAgICAgICBpZiB0YXJnZXQgdGhl
bgogICAgICAgIGxvY2FsIGR4PXRhcmdldC54LW9iLnBvc1sxXQogICAgICAgIGxvY2FsIGR5PXRh
cmdldC55LW9iLnBvc1syXQogICAgICAgIGxvY2FsIGRpc3Q9c3FydChkeCpkeCtkeSpkeSkKICAg
ICAgICAKICAgICAgICAtLSByZWFjaGVkIHdheXBvaW50OiBhZHZhbmNlIHRvIG5leHQKICAgICAg
ICBpZiBkaXN0PDAuMSB0aGVuCiAgICAgICAgIG9iLnBhdHJvbF9pbmRleD0ob2IucGF0cm9sX2lu
ZGV4JSNvYi5wYXRyb2xfcG9pbnRzKSsxCiAgICAgICAgZWxzZQogICAgICAgICAtLSBtb3ZlIHRv
d2FyZCBjdXJyZW50IHdheXBvaW50CiAgICAgICAgIGlmIGRpc3Q_MCB0aGVuCiAgICAgICAgICBs
b2NhbCBzcGQ9b2IudHlwLnBhdHJvbF9zcGVlZCBvciAwLjAzCiAgICAgICAgICBsb2NhbCBueD1v
Yi5wb3NbMV0rZHgvZGlzdCpzcGQKICAgICAgICAgIGxvY2FsIG55PW9iLnBvc1syXStkeS9kaXN0
KnNwZAogICAgICAgICAgdHJ5bW92ZXRvX3BvcyhvYi5wb3Msbngsbnksb2IudHlwLncgb3IgMC40
LGZhbHNlLGZhbHNlKQogICAgICAgICBlbmQKICAgICAgICBlbmQKICAgICAgIGVuZAogICAgICBl
bmQKICAgICAgCiAgICAgZWxzZWlmIG9iLmFpX3R5cGU9PSJmb2xsb3ciIHRoZW4KICAgICAgLS0g
Zm9sbG93OiBtb3ZlIHRvd2FyZCBwbGF5ZXIgaWYgaW4gcmFuZ2UKICAgICAgbG9jYWwgZHg9cGxh
eWVyLngtb2IucG9zWzFdCiAgICAgIGxvY2FsIGR5PXBsYXllci55LW9iLnBvc1syXQogICAgICBs
b2NhbCBkaXN0PXNxcnQoZHgqZHgrZHkqZHkpCiAgICAgIGxvY2FsIGZvbGxvd19yYW5nZT1vYi50
eXAuZm9sbG93X3JhbmdlIG9yIDIwCiAgICAgIGlmIGRpc3Q8Zm9sbG93X3JhbmdlIGFuZCBkaXN0
PjAuMSB0aGVuCiAgICAgICBsb2NhbCBzcGQ9b2IudHlwLmZvbGxvd19zcGVlZCBvciAwLjA1CiAg
ICAgICBsb2NhbCBueD1vYi5wb3NbMV0rZHgvZGlzdCpzcGQKICAgICAgIGxvY2FsIG55PW9iLnBv
c1syXStkeS9kaXN0KnNwZAogICAgICAgdHJ5bW92ZXRvX3BvcyhvYi5wb3Msbngsbnksb2IudHlw
Lncgb3IgMC40LGZhbHNlLGZhbHNlKQogICAgICBlbmQKICAgICBlbmQKICAgICAKICAgICAtLSB1
cGRhdGUgc3BhdGlhbCBncmlkIGFmdGVyIG1vdmVtZW50CiAgICAgaWYgb2xkX3h_PW9iLnBvc1sx
XSBvciBvbGRfeX49b2IucG9zWzJdIHRoZW4KICAgICAgdXBkYXRlX29iamVjdF9ncmlkKG9iLG9s
ZF94LG9sZF95KQogICAgIGVuZAogICAgZW5kCiAgIGVuZAogIGVuZAogZW5kCmVuZA==
:: src/
:: src/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTExLTA3IDIyOjE0OjEzIixtb2RpZmllZD0iMjAyNS0x
MS0xMCAxMjozNTo1MSJdXQ==
:: src/config.lua
--[[pod_format="raw",created="2025-11-07 21:17:14",modified="2025-11-07 21:48:05",revision=1]]
-- engine configuration

-- screen constants
screen_width=480
screen_height=270
screen_center_x=240
screen_center_y=135
ray_count=128
-- CRITICAL: screen_center_x must equal screen_width/2, screen_center_y must equal screen_height/2
-- ray_count is decoupled from screen_width and can be configured independently for performance tuning
sdist=200 -- default; computed dynamically in raycast_scene() based on fov
map_size=128
objgrid_size=5
objgrid_array_size=26
fov=0.5

-- sprite configuration
sprite_size=32

-- fog configuration (unified linear fog system)
fog_near=5.0 -- near fog distance where fog begins
fog_far=20.0 -- far fog distance where fog is maximum
fog_hysteresis=0.5 -- minimum z change required to update fog level (reduces palette thrashing)
screenbright=1.0 -- screen brightness multiplier (1.0=normal, <1.0=darker for atmosphere)

-- lod configuration (ratios of fog_far)
wall_lod_ratio=0.7 -- ratio of fog_far for wall LOD transition
sprite_lod_ratio=0.8 -- ratio of fog_far for sprite LOD transition
wall_lod_distance=fog_far*wall_lod_ratio -- computed: walls beyond this z use simplified rendering

-- rendering configuration
row_stride=2 -- floor/ceiling rendering stride for performance (1=full quality, 2=half rows)
per_cell_floors_enabled=true -- enable per-cell floor type detection (false=render entire scanline with single texture)

-- raycast configuration
far_plane=25.0 -- maximum raycast distance; must be >= fog_far + 2.0 to prevent geometry popping

-- ai and interaction constants
ai_update_rate=2 -- frames between AI updates
interaction_range=0.5 -- proximity for triggers
combat_trigger_range=0.3 -- distance to trigger combat

-- player movement constants
player_rotation_speed=0.008 -- radians per frame when turning (slower, smoother)
player_move_speed=0.04 -- units per frame when moving (reduced)

-- door animation constants
door_anim_speed=0.06 -- door open/close speed per frame
door_close_delay=90 -- frames before door auto-closes

-- floor/ceiling types (tex indexes from gfx/1_surfaces.gfx, offset 32)
planetyps={
 -- stone_tile
 {tex=32,scale=1,height=0.5,lit=true,xvel=0,yvel=0},
 -- dirt
 {tex=33,scale=1,height=0.5,lit=true,xvel=0,yvel=0},
 -- stone_ceiling
 {tex=34,scale=1,height=0.5,lit=false,xvel=0,yvel=0},
 -- sky
 {tex=35,scale=2,height=1,lit=false,xvel=0.01,yvel=0},
 -- night_sky
 {tex=36,scale=2,height=1,lit=false,xvel=0.005,yvel=0}
}

-- wall texture sets (sprite indexes from gfx/0_walls.gfx)
texsets={
 -- none (removed to avoid collision with brick variant 0)
 -- brick
 {base=0,variants={0,1,2,3}},
 -- cobblestone
 {base=4,variants={4,5,6,7}},
 -- wood_plank
 {base=8,variants={8,9,10,11}},
 -- stone
 {base=12,variants={12,13,14,15}},
 -- grass (outdoor)
 {base=16,variants={16,17,18,19}},
 -- earth (outdoor)
 {base=20,variants={20,21,22,23}}
}

-- door types (sprite indexes from gfx/0_walls.gfx)
door_normal=24
door_locked=25
door_stay_open=26

-- helper: check if tile is a door
function is_door(val)
 return val>=door_normal and val<=door_stay_open
end

-- exit types (tile IDs)
exit_start=67
exit_end=68

-- wall fill constant
wall_fill_tile=1

-- generation parameters
gen_params={
 min_rooms=5,
 max_rooms=15,
 min_size=4,
 max_size=12,
 spacing=2,
 corridor_texture=0,
 room_door_prob=0.3,
 erode_amount=50,
 difficulty=1,
 max_difficulty=9,
 max_enemies_per_room=8,
 max_decorations_per_room=12,
 npc_hostile_ratio=0.7,
 items_per_room=2,
 pickup_density=0.1
}

-- helper constants
max_spawn_attempts=50
max_room_attempts=100

-- door testing parameters
test_door_open=nil -- if set to a value 0.0-1.0, forces all doors to this open state for testing
test_door_x=nil -- if set, only affects door at this position
test_door_y=nil -- if set, only affects door at this position

-- object type definitions (mx=sprite index from gfx files, my deprecated, mw/mh use sprite_size)
-- NOTE: my=0 is deprecated and maintained for backward compatibility only; will be removed once rendering code migrates
obj_types={
 player={solid=true,w=0.4,mx=0,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.8,flat=false,lit=nil,framect=nil,animspd=nil,yoffs=nil,kind="player"},
 enemy={solid=true,w=0.4,mx=64,my=0,mw=sprite_size,mh=sprite_size,y=0.1,h=0.8,flat=false,lit=nil,framect=4,animspd=0.25,yoffs={0,-0.01,0,-0.01},kind="hostile_npc",ai_type="follow",follow_speed=0.05,follow_range=20,patrol_speed=0.03},
 item={solid=false,w=0.3,mx=128,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.2,flat=false,lit=nil,framect=nil,animspd=nil,yoffs=nil,kind="direct_pickup",subtype="generic"},
 key={solid=false,w=0.3,mx=129,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.2,flat=false,lit=nil,framect=nil,animspd=nil,yoffs=nil,kind="direct_pickup",subtype="key"},
 heart={solid=false,w=0.3,mx=130,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.2,flat=false,lit=nil,framect=2,animspd=0.1,yoffs={0,0.05},kind="direct_pickup",subtype="heart"},
 decoration={solid=false,w=0.3,mx=148,my=0,mw=sprite_size,mh=sprite_size,y=0.3,h=0.4,flat=false,lit=0,framect=4,animspd=0.25,yoffs=nil,kind="decorative"},
 hostile_npc={solid=true,w=0.4,mx=64,my=0,mw=sprite_size,mh=sprite_size,y=0.1,h=0.8,flat=false,lit=nil,framect=4,animspd=0.25,yoffs={0,-0.01,0,-0.01},kind="hostile_npc",ai_type="follow",follow_speed=0.05,follow_range=20,patrol_speed=0.03},
 non_hostile_npc={solid=false,w=0.4,mx=73,my=0,mw=sprite_size,mh=sprite_size,y=0.1,h=0.8,flat=false,lit=nil,framect=1,animspd=0,yoffs=nil,kind="non_hostile_npc"},
 direct_pickup={solid=false,w=0.2,mx=128,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.2,flat=false,lit=nil,framect=2,animspd=0.1,yoffs={0,0.05},kind="direct_pickup"},
 interactable_chest={solid=false,w=0.3,mx=131,my=0,mw=sprite_size,mh=sprite_size,y=0.3,h=0.3,flat=false,lit=nil,framect=1,animspd=0,yoffs=nil,kind="interactable",subtype="chest"},
 interactable_shrine={solid=false,w=0.4,mx=132,my=0,mw=sprite_size,mh=sprite_size,y=0.3,h=0.5,flat=false,lit=nil,framect=1,animspd=0,yoffs=nil,kind="interactable",subtype="shrine"},
 interactable_trap={solid=false,w=0.2,mx=133,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.1,flat=true,lit=nil,framect=1,animspd=0,yoffs=nil,kind="interactable",subtype="trap"},
 interactable_note={solid=false,w=0.3,mx=134,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.2,flat=true,lit=nil,framect=1,animspd=0,yoffs=nil,kind="interactable",subtype="note"},
 interactable_exit={solid=false,w=0.3,mx=135,my=0,mw=sprite_size,mh=sprite_size,y=0.4,h=0.2,flat=false,lit=nil,framect=1,animspd=0,yoffs=nil,kind="interactable",subtype="exit"}
}

-- enemy type definitions (sprite indexes from gfx/2_characters.gfx, offset 64)
enemy_types={
 {name="rat",difficulty=1,min_count=1,max_count=3,obj_type=obj_types.hostile_npc,sprite=64,hp=1},
 {name="bat",difficulty=2,min_count=1,max_count=4,obj_type=obj_types.hostile_npc,sprite=65,hp=1},
 {name="slime",difficulty=3,min_count=2,max_count=5,obj_type=obj_types.hostile_npc,sprite=66,hp=2},
 {name="skeleton",difficulty=4,min_count=1,max_count=3,obj_type=obj_types.hostile_npc,sprite=67,hp=3},
 {name="goblin",difficulty=5,min_count=2,max_count=4,obj_type=obj_types.hostile_npc,sprite=68,hp=3},
 {name="orc",difficulty=6,min_count=1,max_count=3,obj_type=obj_types.hostile_npc,sprite=69,hp=4},
 {name="troll",difficulty=7,min_count=1,max_count=2,obj_type=obj_types.hostile_npc,sprite=70,hp=5},
 {name="demon",difficulty=8,min_count=1,max_count=2,obj_type=obj_types.hostile_npc,sprite=71,hp=6},
 {name="dragon",difficulty=9,min_count=1,max_count=1,obj_type=obj_types.hostile_npc,sprite=72,hp=10}
}

-- decoration type definitions (sprite indexes from gfx/3_props.gfx, offset 148)
decoration_types={
 {name="torch",difficulty=1,obj_type=obj_types.decoration,gen_tags={"lit","uni"},theme_tags={"dng","lit"},sprite=148},
 {name="barrel",difficulty=1,obj_type=obj_types.decoration,gen_tags={"uni"},theme_tags={"dng","house"},sprite=149},
 {name="crate",difficulty=1,obj_type=obj_types.decoration,gen_tags={"uni2"},theme_tags={"dng","house"},sprite=150},
 {name="pillar",difficulty=2,obj_type=obj_types.decoration,gen_tags={"big"},theme_tags={"dng","dem"},sprite=151},
 {name="statue",difficulty=3,obj_type=obj_types.decoration,gen_tags={"rare"},theme_tags={"dng","dem"},sprite=152},
 {name="chest",difficulty=2,obj_type=obj_types.decoration,gen_tags={"scatter"},theme_tags={"dng","house"},sprite=153},
 {name="tree",difficulty=1,obj_type=obj_types.decoration,gen_tags={"scatter"},theme_tags={"out"},sprite=154},
 {name="rock",difficulty=1,obj_type=obj_types.decoration,gen_tags={"uni"},theme_tags={"out"},sprite=155}
}

-- theme definitions
themes={
 dng={floor="stone_tile",roof="stone_ceiling",decor_prob=0.8},
 out={floor="dirt",roof="sky",decor_prob=0.5},
 dem={floor="stone_tile",roof="night_sky",decor_prob=0.9},
 house={floor="stone_tile",roof="stone_ceiling",decor_prob=0.7},
 dark={floor="stone_tile",roof="night_sky",decor_prob=0.6}
}

-- fog palettes (distance-based)
-- extended to support all 64 colors in Picotron
-- base colors 0-15 are remapped per fog level; colors 16-63 map to their fogged equivalents
pals={
 -- level 0: no fog
 {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63},
 -- level 1
 {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,5,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,5,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,5,48,49,50,51,52,53,54,5,56,57,58,59,60,61,62,5},
 -- level 2
 {0,1,2,3,4,5,6,7,8,9,10,11,12,13,5,5,16,17,18,19,20,21,22,23,24,25,26,27,28,29,5,5,32,33,34,35,36,37,38,39,40,41,42,43,44,45,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,61,5,5},
 -- level 3
 {0,1,2,3,4,5,6,7,8,9,10,11,12,5,5,5,16,17,18,19,20,21,22,23,24,25,26,27,28,5,5,5,32,33,34,35,36,37,38,39,40,41,42,43,44,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 4
 {0,1,2,3,4,5,6,7,8,9,10,11,5,5,5,5,16,17,18,19,20,21,22,23,24,25,26,27,5,5,5,5,32,33,34,35,36,37,38,39,40,41,42,43,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 5
 {0,1,2,3,4,5,6,7,8,9,10,5,5,5,5,5,16,17,18,19,20,21,22,23,24,25,26,5,5,5,5,5,32,33,34,35,36,37,38,39,40,41,42,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 6
 {0,1,2,3,4,5,6,7,8,9,5,5,5,5,5,5,16,17,18,19,20,21,22,23,24,25,5,5,5,5,5,5,32,33,34,35,36,37,38,39,40,41,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 7
 {0,1,2,3,4,5,6,7,8,5,5,5,5,5,5,5,16,17,18,19,20,21,22,23,24,5,5,5,5,5,5,5,32,33,34,35,36,37,38,39,40,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 8
 {0,1,2,3,4,5,6,7,5,5,5,5,5,5,5,5,16,17,18,19,20,21,22,23,5,5,5,5,5,5,5,5,32,33,34,35,36,37,38,39,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 9
 {0,1,2,3,4,5,6,5,5,5,5,5,5,5,5,5,16,17,18,19,20,21,5,5,5,5,5,5,5,5,5,5,32,33,34,35,36,37,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 10
 {0,1,2,3,4,5,5,5,5,5,5,5,5,5,5,5,16,17,18,19,20,21,5,5,5,5,5,5,5,5,5,5,32,33,34,35,36,37,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 11
 {0,1,2,3,4,5,5,5,5,5,5,5,5,5,5,5,16,17,18,19,20,21,5,5,5,5,5,5,5,5,5,5,32,33,34,35,36,37,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 12
 {0,1,2,3,5,5,5,5,5,5,5,5,5,5,5,5,16,17,18,19,5,5,5,5,5,5,5,5,5,5,5,5,32,33,34,35,5,5,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 13
 {0,1,2,5,5,5,5,5,5,5,5,5,5,5,5,5,16,17,18,5,5,5,5,5,5,5,5,5,5,5,5,5,32,33,34,5,5,5,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 14
 {0,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,16,17,5,5,5,5,5,5,5,5,5,5,5,5,5,5,32,33,5,5,5,5,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 15: maximum fog
 {0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,16,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,32,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5}
}

:: src/door_system.lua
--[[pod_format="raw",created="2025-11-07 21:17:14",modified="2025-11-07 21:48:06",revision=1]]
-- door animation system
-- test mode state (to avoid permanent mutation)
test_mode_prev=false
test_mode_saved_state={}

-- create a door
function create_door(x,y,dtype,key_id)
 local door={
  x=x,
  y=y,
  open=0, -- 0=closed, 1=fully open
  opening=false, -- animation state
  timer=0,
  dtype=dtype or door_normal,
  keynum=key_id, -- nil if unlocked, key id if locked
  stayopen=(dtype==door_stay_open) -- doors with door_stay_open dtype stay open
 }
 
 -- prevent duplicates at same grid cell
 local existing = doorgrid[x] and doorgrid[x][y] or nil
 if existing then
  printh("warning: duplicate door at ("..x..","..y..") - replacing")
  del(doors, existing)
 end
 add(doors,door)
 doorgrid[x][y]=door
	-- walls layer already set by generation to door tile ID (authoritative)
 
 return door
end

-- update all doors
function update_doors()
 -- handle test mode transitions to avoid permanent state mutation
 if test_door_mode and not test_mode_prev then
  -- entering test mode: save states
  test_mode_saved_state={}
  for door in all(doors) do
   test_mode_saved_state[door]={open=door.open,opening=door.opening,timer=door.timer}
  end
 elseif (not test_door_mode) and test_mode_prev then
  -- exiting test mode: restore states
  for door in all(doors) do
   local st=test_mode_saved_state[door]
   if st~=nil then
    door.open=st.open
    door.opening=st.opening
    door.timer=st.timer
   end
  end
  test_mode_saved_state={}
 end
 
 -- in test mode, temporarily override open values (restored on exit)
 if test_door_mode then
  for door in all(doors) do
   door.open=test_door_open or 0
  end
  -- keep early return to skip normal animation while testing
  test_mode_prev=true
  return
 end
 
 test_mode_prev=false
 
 for door in all(doors) do
  if door.opening then
   -- play sound on start
   if door.open==0 then
    -- sfx(10) -- door open sound
   end
   -- animate opening
   door.open+=door_anim_speed
   if door.open>1 then
    door.open=1
    door.opening=false
    door.timer=door_close_delay
   end
  else
   -- not opening
   if door.timer>0 then
    door.timer-=1
   elseif not door.stayopen then
    -- close door
    door.open=max(door.open-door_anim_speed,0)
   end
  end
 end
end



-- remove a door
function remove_door(x,y)
 local door=doorgrid[x][y]
 if door then
  del(doors,door)
  doorgrid[x][y]=nil
		set_wall(x,y,0)
 end
end

:: src/dungeon_gen.lua
--[[pod_format="raw",created="2025-11-07 21:17:13",modified="2025-11-07 21:48:06",revision=1]]
-- procedural dungeon generation

-- generation state
gen_rects={}
gen_nodes={}
gen_edges={}
gen_inventory={}
gen_objects={}
-- theme-specific floor id used during carving/eroding; initialized to stone_tile (1)
local gen_floor_id=1

-- helper: check if tile is a wall
function is_wall(val)
 return val>0 and val<door_normal
end

-- helper: check if tile is a door
function is_door(val)
 return val>=door_normal and val<=door_stay_open
end

-- helper: check if tile is an exit
function is_exit(val)
 return val>=exit_start and val<=exit_end
end

-- helper: boundary cell is reserved if it has a door/exit in either layer
function is_reserved_boundary(x,y)
 local w=get_wall(x,y)
 if is_door(w) or is_exit(w) then return true end
 -- defensive: should always be 0 if walls layer is authoritative
 if get_door(x,y)>0 then return true end
 if doorgrid[x] and doorgrid[x][y] then return true end
 return false
end

-- helper: check if rectangles overlap
function rect_overlaps(rect)
 -- reject out-of-bounds rectangles upfront (map is 0..127)
 if rect[1]<0 or rect[3]>=128 or rect[2]<0 or rect[4]>=128 then
  return true
 end
 for r in all(gen_rects) do
  if not (rect[3]+gen_params.spacing<r[1] or rect[1]>r[3]+gen_params.spacing or
          rect[4]+gen_params.spacing<r[2] or rect[2]>r[4]+gen_params.spacing) then
   return true
  end
 end
 return false
end

-- helper: fill rectangle using set_wall
function fill_rect(rect,val)
 for x=max(0,rect[1]),min(127,rect[3]) do
  for y=max(0,rect[2]),min(127,rect[4]) do
			set_wall(x,y,val)
  end
 end
end

-- helper: try place door with fallback positions
function try_place_door_with_fallback(x,y,dtype)
 local attempts={
  {x,y},
  {x-1,y},{x+1,y},{x,y-1},{x,y+1}
 }
 
 -- evaluate door placement probability once per logical placement
 local should_place_door=rnd(1)<gen_params.room_door_prob
 
 for attempt in all(attempts) do
  local ax,ay=attempt[1],attempt[2]
  if ax>=0 and ax<128 and ay>=0 and ay<128 then
			if is_wall(get_wall(ax,ay)) and should_place_door then
				set_wall(ax,ay,dtype)
    create_door(ax,ay,dtype)
    return true
   end
  end
 end
 return false
end

-- helper: generate random room
function random_room(base_node,is_special)
 local w,h
 if is_special then
  w,h=12,12
 else
  w=flr(rnd(gen_params.max_size-gen_params.min_size+1))+gen_params.min_size
  h=flr(rnd(gen_params.max_size-gen_params.min_size+1))+gen_params.min_size
 end
 
 local x,y
 if base_node then
  x=base_node.midx+flr(rnd(20)-10)
  y=base_node.midy+flr(rnd(20)-10)
 else
  x=flr(rnd(122))+3
  y=flr(rnd(122))+3
 end
 
 return {x,y,x+w-1,y+h-1},gen_params.room_door_prob
end

-- helper: add room to generation state
function add_room(rect,is_junction)
 add(gen_rects,rect)
 local node={
  rect=rect,
  midx=flr((rect[1]+rect[3])/2),
  midy=flr((rect[2]+rect[4])/2),
  edges={},
  is_junction=is_junction or false
 }
 add(gen_nodes,node)
 return node
end

-- helper: determine corridor type between two rooms
function get_corridor_type(r1,r2)
 local ox=not (r1[3]<r2[1] or r1[1]>r2[3])
 local oy=not (r1[4]<r2[2] or r1[2]>r2[4])
 if ox and not oy then return "vert" end
 if oy and not ox then return "horiz" end
 return "l_shape"
end

-- helper: place door at exact boundary wall tile with retry
function place_boundary_door_with_retry(bx,by,dtype,max_attempts)
 max_attempts=max_attempts or 3
 for attempt=1,max_attempts do
  if bx>=0 and bx<128 and by>=0 and by<128 then
   if is_wall(get_wall(bx,by)) then
    set_wall(bx,by,dtype)
    create_door(bx,by,dtype)
    return true
   end
  end
 end
 return false
end

-- helper: place door at exact boundary wall tile
function place_boundary_door(bx,by,dtype)
 -- bx,by = boundary wall tile (between corridor and room)
 if bx>=0 and bx<128 and by>=0 and by<128 then
		if is_wall(get_wall(bx,by)) then
			set_wall(bx,by,dtype)
   create_door(bx,by,dtype)
   return true
  end
 end
 return false
end

-- helper: ensure boundary passage (fallback for failed door placement)
function ensure_boundary_passage(bx,by)
 if bx>=0 and bx<128 and by>=0 and by<128 then
  local tile=get_wall(bx,by)
  -- if wall is still blocking and not a door, clear it
  if tile>0 and not is_door(tile) and not is_exit(tile) then
   set_wall(bx,by,0)
   set_floor(bx,by,gen_floor_id)
   printh("fallback: cleared blocking wall at ("..bx..","..by..")")
   return true
  end
 end
 return false
end

-- helper: create corridor between two nodes
function create_corridor(n1,n2)
 local ctype=get_corridor_type(n1.rect,n2.rect)
	local b1,b2
 
 if ctype=="horiz" then
  local x0,x1=min(n1.midx,n2.midx),max(n1.midx,n2.midx)
  local y=n1.midy
  local r1,r2=n1.rect,n2.rect
  
  -- identify boundary wall tiles before carving
  local bx1,bx2
  if r1[1]<=r2[1] then
   bx1=r1[3]+1
   bx2=r2[1]-1
  else
   bx1=r2[3]+1
   bx2=r1[1]-1
  end
  
  -- place doors on boundary walls (robust: retry and fallback to passage)
  local d1_ok=place_boundary_door_with_retry(bx1,y,door_normal,3)
  if not d1_ok then ensure_boundary_passage(bx1,y) end
  local d2_ok=place_boundary_door_with_retry(bx2,y,door_normal,3)
  if not d2_ok then ensure_boundary_passage(bx2,y) end
  
  -- carve corridor between doors (exclusive)
  for x=bx1+1,bx2-1 do
   if x>=0 and x<128 and y>=0 and y<128 then
				set_wall(x,y,0)
				set_floor(x,y,gen_floor_id)
   end
  end

		-- store boundary tiles
		b1={x=bx1,y=y}
		b2={x=bx2,y=y}
  
 elseif ctype=="vert" then
  local y0,y1=min(n1.midy,n2.midy),max(n1.midy,n2.midy)
  local x=n1.midx
  local r1,r2=n1.rect,n2.rect
  
  -- identify boundary wall tiles before carving
  local by1,by2
  if r1[2]<=r2[2] then
   by1=r1[4]+1
   by2=r2[2]-1
  else
   by1=r2[4]+1
   by2=r1[2]-1
  end
  
  -- place doors on boundary walls (robust: retry and fallback to passage)
  local d1_ok=place_boundary_door_with_retry(x,by1,door_normal,3)
  if not d1_ok then ensure_boundary_passage(x,by1) end
  local d2_ok=place_boundary_door_with_retry(x,by2,door_normal,3)
  if not d2_ok then ensure_boundary_passage(x,by2) end
  
  -- carve corridor between doors (exclusive)
  for y=by1+1,by2-1 do
   if x>=0 and x<128 and y>=0 and y<128 then
				set_wall(x,y,0)
				set_floor(x,y,gen_floor_id)
   end
  end

		-- store boundary tiles
		b1={x=x,y=by1}
		b2={x=x,y=by2}
  
 else -- l_shape
	local jx,jy=n1.midx,n2.midy
  local jw,jh=3,3
  local jrect={jx-1,jy-1,jx+jw-2,jy+jh-2}
  fill_rect(jrect,0)
  for x=max(0,jrect[1]),min(127,jrect[3]) do
   for y=max(0,jrect[2]),min(127,jrect[4]) do
    set_floor(x, y, gen_floor_id)
   end
  end
  -- tag as junction to skip perimeter wall texturing
  local jnode=add_room(jrect,true)
  
  -- connect n1 to junction (horizontal)
  local x0,x1=min(n1.midx,jx),max(n1.midx,jx)
  local r1=n1.rect
  local bx1_horiz,bx2_horiz
  if r1[1]<=jx then
   bx1_horiz=r1[3]+1
   -- place door on the wall just outside the junction (left side)
   bx2_horiz=jrect[1]-1
  else
   -- place door on the wall just outside the junction (right side)
   bx1_horiz=jrect[3]+1
   bx2_horiz=r1[1]-1
  end
  
  -- place doors on horizontal segment boundaries with retry and fallback
  if bx1_horiz>=0 and bx1_horiz<128 then
   local door1_ok=place_boundary_door_with_retry(bx1_horiz,n1.midy,door_normal,3)
   if not door1_ok then
    printh("warning: failed to place junction door at ("..bx1_horiz..","..n1.midy.."), clearing as passage")
    ensure_boundary_passage(bx1_horiz,n1.midy)
   end
  end
  
  if bx2_horiz>=0 and bx2_horiz<128 then
   local door2_ok=place_boundary_door_with_retry(bx2_horiz,n1.midy,door_normal,3)
   if not door2_ok then
    printh("warning: failed to place junction door at ("..bx2_horiz..","..n1.midy.."), clearing as passage")
    ensure_boundary_passage(bx2_horiz,n1.midy)
   end
  end
  
	-- carve horizontal segment
  for x=bx1_horiz+1,bx2_horiz-1 do
   if x>=0 and x<128 and n1.midy>=0 and n1.midy<128 then
				set_wall(x,n1.midy,0)
				set_floor(x,n1.midy,gen_floor_id)
   end
  end
  
  -- connect junction to n2 (vertical)
  local y0,y1=min(jy,n2.midy),max(jy,n2.midy)
  local r2=n2.rect
  local by1_vert,by2_vert
  if jy<=r2[2] then
   -- place door on the wall just outside the junction (bottom side)
   by1_vert=jrect[4]+1
   by2_vert=r2[2]-1
  else
   by1_vert=r2[4]+1
   -- place door on the wall just outside the junction (top side)
   by2_vert=jrect[2]-1
  end
  
  -- place doors on vertical segment boundaries with retry and fallback
  if by1_vert>=0 and by1_vert<128 then
   local door3_ok=place_boundary_door_with_retry(jx,by1_vert,door_normal,3)
   if not door3_ok then
    printh("warning: failed to place junction door at ("..jx..","..by1_vert.."), clearing as passage")
    ensure_boundary_passage(jx,by1_vert)
   end
  end
  
  if by2_vert>=0 and by2_vert<128 then
   local door4_ok=place_boundary_door_with_retry(jx,by2_vert,door_normal,3)
   if not door4_ok then
    printh("warning: failed to place junction door at ("..jx..","..by2_vert.."), clearing as passage")
    ensure_boundary_passage(jx,by2_vert)
   end
  end
  
	-- carve vertical segment
  for y=by1_vert+1,by2_vert-1 do
   if jx>=0 and jx<128 and y>=0 and y<128 then
				set_wall(jx,y,0)
				set_floor(jx,y,gen_floor_id)
   end
  end
  
  -- validation: ensure all boundary passages are clear
  ensure_boundary_passage(bx1_horiz,n1.midy)
  ensure_boundary_passage(bx2_horiz,n1.midy)
  ensure_boundary_passage(jx,by1_vert)
  ensure_boundary_passage(jx,by2_vert)

		-- store boundary tiles near rooms
		local near_n1
		if r1[1]<=jx then
			near_n1={x=bx1_horiz,y=n1.midy}
		else
			near_n1={x=bx2_horiz,y=n1.midy}
		end
		local near_n2
		if jy<=r2[2] then
			near_n2={x=jx,y=by2_vert}
		else
			near_n2={x=jx,y=by1_vert}
		end
		b1=near_n1
		b2=near_n2
 end
 
 -- store boundary tiles for progression gating
	local edge={n1=n1,n2=n2,b1=b1,b2=b2}
 add(gen_edges,edge)
 add(n1.edges,n2)
 add(n2.edges,n1)
end

-- helper: try to generate and connect a room
function try_generate_room()
 local base=gen_nodes[flr(rnd(#gen_nodes))+1]
 local rect=random_room(base,false)
 
 if rect[1]<3 or rect[3]>126 or rect[2]<3 or rect[4]>126 then
  return false
 end
 
 if rect_overlaps(rect) then
  return false
 end
 
 local node=add_room(rect)
 fill_rect(rect,0)
 for x=max(0,rect[1]),min(127,rect[3]) do
  for y=max(0,rect[2]),min(127,rect[4]) do
   set_floor(x, y, gen_floor_id)
  end
 end
 create_corridor(base,node)
 return true
end

-- helper: apply wall textures to room perimeter
function apply_room_walls(rect,tex)
 -- ensure tex is never 0
 if tex==0 then tex=1 end
 
 for x=rect[1],rect[3] do
  if rect[2]-1>=0 and rect[2]-1<128 and x>=0 and x<128 then
   -- skip reserved cells (doors/exits in any layer)
		if not is_reserved_boundary(x,rect[2]-1) then
			set_wall(x,rect[2]-1,tex)
   end
  end
  if rect[4]+1>=0 and rect[4]+1<128 and x>=0 and x<128 then
   -- skip reserved cells (doors/exits in any layer)
		if not is_reserved_boundary(x,rect[4]+1) then
			set_wall(x,rect[4]+1,tex)
   end
  end
 end
 for y=rect[2],rect[4] do
  if rect[1]-1>=0 and rect[1]-1<128 and y>=0 and y<128 then
   -- skip reserved cells (doors/exits in any layer)
		if not is_reserved_boundary(rect[1]-1,y) then
			set_wall(rect[1]-1,y,tex)
   end
  end
  if rect[3]+1>=0 and rect[3]+1<128 and y>=0 and y<128 then
   -- skip reserved cells (doors/exits in any layer)
		if not is_reserved_boundary(rect[3]+1,y) then
			set_wall(rect[3]+1,y,tex)
   end
  end
 end
end

-- repair step: ensure door tiles exist on walls layer for all logical doors
function enforce_door_tiles()
 for door in all(doors) do
  if not is_door(get_wall(door.x,door.y)) then
   set_wall(door.x,door.y,door.dtype or door_normal)
  end
 end
 
 -- also check doorgrid consistency
 for x=0,map_size-1 do
  if doorgrid[x] then
   for y=0,map_size-1 do
    if doorgrid[x][y] then
     local tile=get_wall(x,y)
     if not is_door(tile) then
      -- restore door tile from doorgrid or use default
      local correct_tile=doorgrid[x][y].tile or door_normal
      set_wall(x,y,correct_tile)
      printh("warning: restored door tile at ("..x..","..y..")")
     end
    end
   end
  end
 end
end

-- border ring enforcement: set outermost ring to walls while preserving doors/exits
function enforce_border_ring()
 -- top and bottom edges (y=0 and y=map_size-1)
 for x=0,map_size-1 do
  -- top edge
  local top_tile=get_wall(x,0)
  if not is_door(top_tile) and not is_exit(top_tile) then
   set_wall(x,0,wall_fill_tile)
  end
  
  -- bottom edge
  local bottom_tile=get_wall(x,map_size-1)
  if not is_door(bottom_tile) and not is_exit(bottom_tile) then
   set_wall(x,map_size-1,wall_fill_tile)
  end
 end
 
 -- left and right edges (x=0 and x=map_size-1)
 for y=0,map_size-1 do
  -- left edge
  local left_tile=get_wall(0,y)
  if not is_door(left_tile) and not is_exit(left_tile) then
   set_wall(0,y,wall_fill_tile)
  end
  
  -- right edge
  local right_tile=get_wall(map_size-1,y)
  if not is_door(right_tile) and not is_exit(right_tile) then
   set_wall(map_size-1,y,wall_fill_tile)
  end
 end
end

-- helper: random wall texture (never returns 0)
function random_wall_texture()
 local set=texsets[flr(rnd(#texsets-1))+2] -- skip texsets[1] which is floor
 return set.variants[flr(rnd(#set.variants))+1]
end

-- helper: get theme-appropriate wall texture set
function theme_wall_texture(theme)
 if theme=="out" then
  -- outdoor: grass or earth variants
  -- indices in texsets: 5=grass, 6=earth
  local idx=rnd(1)<0.5 and 5 or 6
  return texsets[idx] or texsets[1]
 elseif theme=="dem" then
  -- demon: stone or cobblestone
  -- indices: 4=stone, 2=cobblestone
  local idx=rnd(1)<0.5 and 4 or 2
  return texsets[idx] or texsets[1]
 elseif theme=="house" then
  -- house: wood plank
  -- index: 3=wood_plank
  return texsets[3] or texsets[1]
 else
  -- default dungeon: brick or cobblestone
  -- indices: 1=brick, 2=cobblestone
  local idx=rnd(1)<0.5 and 1 or 2
  return texsets[idx] or texsets[1]
 end
end

-- helper: find accessible rooms from start via edges
function find_accessible_rooms(start_node,locked_edges)
 local accessible={}
 local queue={start_node}
 local visited={}
 visited[start_node]=true
 
 while #queue>0 do
  local node=queue[1]
  deli(queue,1)
  add(accessible,node)
  
  for edge_node in all(node.edges) do
   if not visited[edge_node] then
    local is_locked=false
    if locked_edges then
     for le in all(locked_edges) do
					if (le.n1==node and le.n2==edge_node) or (le.n1==edge_node and le.n2==node) then
       is_locked=true
       break
      end
     end
    end
    
    if not is_locked then
     visited[edge_node]=true
     add(queue,edge_node)
    end
   end
  end
 end
 
 return accessible
end

-- helper: find spawn point in room
function find_spawn_point(rect)
 for attempt=1,max_spawn_attempts do
  local x=rect[1]+1+flr(rnd(rect[3]-rect[1]-1))
  local y=rect[2]+1+flr(rnd(rect[4]-rect[2]-1))
  
  if x>=0 and x<128 and y>=0 and y<128 and wallgrid[x][y]==0 then
   local valid=true
   for obj in all(gen_objects) do
    local ox=obj.pos and obj.pos[1] or obj.x
    local oy=obj.pos and obj.pos[2] or obj.y
    if ox and oy then
     local dx,dy=abs(ox-x),abs(oy-y)
     if dx<1 and dy<1 then
      valid=false
      break
     end
    end
   end
   
   if valid then
    return x+0.5,y+0.5
   end
  end
 end
 return nil,nil
end

-- helper: erode map for organic feel (generalized for all wall types)
function erode_map(amount)
 for i=1,amount do
  local x,y=flr(rnd(128)),flr(rnd(128))
		if is_wall(get_wall(x,y)) then
   local neighbors=0
   for dx=-1,1 do
    for dy=-1,1 do
     local nx,ny=x+dx,y+dy
					if nx>=0 and nx<128 and ny>=0 and ny<128 and get_wall(nx,ny)==0 then
      neighbors+=1
     end
    end
   end
   if neighbors>=3 then
				set_wall(x,y,0)
    -- ensure eroded clears become traversable floor with theme-specific type
    set_floor(x,y,gen_floor_id)
   end
  end
 end
end

-- helper: generate exit portal on wall
function generate_exit(rect,exit_type)
 local walls={}
 for x=rect[1],rect[3] do
		if rect[2]-1>=0 and is_wall(get_wall(x,rect[2]-1)) then
   add(walls,{x,rect[2]})
  end
		if rect[4]+1<128 and is_wall(get_wall(x,rect[4]+1)) then
   add(walls,{x,rect[4]})
  end
 end
 for y=rect[2],rect[4] do
		if rect[1]-1>=0 and is_wall(get_wall(rect[1]-1,y)) then
   add(walls,{rect[1],y})
  end
		if rect[3]+1<128 and is_wall(get_wall(rect[3]+1,y)) then
   add(walls,{rect[3],y})
  end
 end
 
 if #walls>0 then
  local pos=walls[flr(rnd(#walls))+1]
  -- write exit tile to map
  local exit_tile=exit_type==3 and exit_start or exit_end
  set_wall(pos[1],pos[2],exit_tile)
  -- also add interactable exit object
  local ob={
   pos={pos[1]+0.5,pos[2]+0.5},
   typ=obj_types.interactable_exit,
   rel={0,0},
   frame=0,
   animloop=true,
   autoanim=false,
   exit_type=exit_type
  }
  add(gen_objects,ob)
 end
end

-- gameplay generation: enemies, items, decorations, npcs
function generate_gameplay()
 -- guard against empty gen_nodes to avoid nil dereference
 if not gen_nodes or #gen_nodes==0 then
  printh("error: generate_gameplay() called with no rooms")
  return
 end
 local start_node=gen_nodes[1]
 local exit_node=gen_nodes[#gen_nodes]
 
 -- place start/exit portals
 generate_exit(start_node.rect,3)
 generate_exit(exit_node.rect,4)
 
 -- erode map
 erode_map(gen_params.erode_amount)
 
 -- populate inventory with health items
 for i=1,3 do
  add(gen_inventory,{type="heart"})
 end
 
 -- generate progression loop (simplified - no locking yet)
 generate_progression_loop(start_node)
 
 -- generate npcs (includes hostile and non-hostile)
 generate_npcs()
 
 -- generate items
 generate_items()
 
 -- generate decorations
 generate_decorations()
end

-- generate progression: items and locked doors
function generate_progression_loop(start_node)
 local locked_edges={}
 local key_counter=1
 
 -- cache accessible rooms for current locked_edges; recompute only after a successful lock
 local full_accessible=find_accessible_rooms(start_node,locked_edges)
 
 -- prepare shuffled edge order to avoid duplicate selection and ensure coverage
 local edges_shuffled={}
 for e in all(gen_edges) do add(edges_shuffled,e) end
 -- fisher-yates shuffle
 for i=#edges_shuffled,2,-1 do
  local j=flr(rnd(i))+1
  edges_shuffled[i],edges_shuffled[j]=edges_shuffled[j],edges_shuffled[i]
 end
 
 -- attempt to create progression gates
 for gate_idx=1,#edges_shuffled do
  if key_counter>3 then break end
  
  -- try to lock an edge
  local edge=edges_shuffled[gate_idx]
  local n1,n2=edge.n1,edge.n2
  
  -- check if this edge would gate content
  local combined_locked={}
  for le in all(locked_edges) do add(combined_locked,le) end
  add(combined_locked,edge)
  local test_accessible=find_accessible_rooms(start_node,combined_locked)
  
		-- if locking this edge hides new rooms, add it as a gate
		if #test_accessible<#full_accessible then
			-- choose the actual corridor boundary door tile
			local candidates={edge.b1,edge.b2}
   local chosen=nil
   for c in all(candidates) do
    if c and c.x and c.y then
     local wt=get_wall(c.x,c.y)
     if is_door(wt) then
      chosen=c
      break
     end
    end
   end
			if chosen then
				local x,y=chosen.x,chosen.y
				local door=doorgrid[x] and doorgrid[x][y] or nil
				if door then
					-- convert existing door to locked
					set_wall(x,y,door_locked)
					door.dtype=door_locked
					door.keynum=key_counter
				else
					-- fallback: create a new locked door here
					set_wall(x,y,door_locked)
					create_door(x,y,door_locked,key_counter)
				end
				add(locked_edges,edge)
     -- update cached accessibility after modifying locked edges
     full_accessible=find_accessible_rooms(start_node,locked_edges)
				-- add key to inventory
				add(gen_inventory,{type="key",keynum=key_counter})
				key_counter+=1
   else
    printh("warning: no valid boundary door tile for gate; skipping")
			end
		end
 end
 
 -- place inventory items in accessible rooms
 local failed_placements=0
 -- compute accessible rooms once (does not change during item placement)
 local accessible=find_accessible_rooms(start_node,locked_edges)
 while #gen_inventory>0 do
  
  if #accessible>0 then
   local room=accessible[flr(rnd(#accessible))+1]
   local item=gen_inventory[1]
   deli(gen_inventory,1)
   
   local x,y=find_spawn_point(room.rect)
   if x then
    failed_placements=0
   if item.type=="key" then
     local ob={pos={x,y},typ=obj_types.key,rel={0,0},frame=0,animloop=true,autoanim=true,keynum=item.keynum}
     add(gen_objects,ob)
    else
     local ob={pos={x,y},typ=obj_types[item.type],rel={0,0},frame=0,animloop=true,autoanim=true}
     add(gen_objects,ob)
    end
   else
    -- handle failed placement
    if item.type=="key" then
     -- retry a limited number of times across different rooms
     local attempts=0
     local placed=false
     while attempts<15 and not placed do
      local rr=accessible[flr(rnd(#accessible))+1]
      local kx,ky=find_spawn_point(rr.rect)
      if kx then
       local ob={pos={kx,ky},typ=obj_types.key,rel={0,0},frame=0,animloop=true,autoanim=true,keynum=item.keynum}
       add(gen_objects,ob)
       placed=true
       break
      end
      attempts+=1
     end
     if not placed then
      -- fallback: force place in start room (center if needed)
      local sx,sy=find_spawn_point(start_node.rect)
      if not sx then
       sx=start_node.midx+0.5
       sy=start_node.midy+0.5
      end
      local ob={pos={sx,sy},typ=obj_types.key,rel={0,0},frame=0,animloop=true,autoanim=true,keynum=item.keynum}
      add(gen_objects,ob)
     end
    else
     failed_placements+=1
     if failed_placements>10 then
      printh("warning: failed to place items after multiple attempts; stopping")
      break
     end
    end
   end
  else
   break
  end
 end
end

-- generate npcs (hostile and non-hostile) in rooms
function generate_npcs()
 for node in all(gen_nodes) do
  local rect=node.rect
  local num_npcs=flr(rnd(3))+1
  
  for i=1,num_npcs do
   local x,y=find_spawn_point(rect)
   if x then
    -- 70% hostile, 30% non-hostile
    if rnd(1)<gen_params.npc_hostile_ratio then
     -- select enemy type based on current difficulty level
     local available_enemies = {}
     for enemy in all(enemy_types) do
      if enemy.difficulty <= gen_params.difficulty then
       add(available_enemies, enemy)
      end
     end
     -- fallback to rat if no enemies available
     if #available_enemies == 0 then
      available_enemies = {enemy_types[1]}
     end
     local enemy_type = available_enemies[flr(rnd(#available_enemies))+1]
     
     -- hostile npc with patrol or follow behavior
     local ai_type=rnd(1)<0.5 and "patrol" or "follow"
     -- sprite_index from enemy_types configuration (64-72 range)
     local ob={
      pos={x,y},
      typ=obj_types.hostile_npc,
      rel={0,0},
      frame=0,
      animloop=true,
      autoanim=true,
      ai_type=ai_type,
      patrol_index=0,
      patrol_points={},
      sprite_index=enemy_type.sprite
     }
     -- generate patrol points if patrol mode
     if ai_type=="patrol" then
      for j=1,4 do
       local px,py=find_spawn_point(rect)
       if px then
        add(ob.patrol_points,{x=px,y=py})
       end
      end
      if #ob.patrol_points==0 then
       add(ob.patrol_points,{x=x,y=y})
      end
     end
     add(gen_objects,ob)
    else
     -- non-hostile NPCs use sprite 73
     local ob={
      pos={x,y},
      typ=obj_types.non_hostile_npc,
      rel={0,0},
      frame=0,
      animloop=true,
      autoanim=false,
      sprite_index=obj_types.non_hostile_npc.mx
     }
     add(gen_objects,ob)
    end
   end
  end
 end
end

-- generate items (pickups and interactables) in rooms
function generate_items()
 for node in all(gen_nodes) do
  local rect=node.rect
  local num_items=flr(rnd(gen_params.items_per_room))+1
  
  for i=1,num_items do
   local x,y=find_spawn_point(rect)
   if x then
    -- choose item type: 60% pickup, 40% interactable
    if rnd(1)<0.6 then
     -- direct pickup (heart or generic item)
     local pickup_type=rnd(1)<0.5 and "heart" or "direct_pickup"
     local obj_type=pickup_type=="heart" and obj_types.heart or obj_types.direct_pickup
     local ob={
      pos={x,y},
      typ=obj_type,
      rel={0,0},
      frame=0,
      animloop=true,
      autoanim=true
     }
     add(gen_objects,ob)
    else
     -- interactable (chest, shrine, trap, note)
     local subtypes={"chest","shrine","trap","note"}
     local subtype=subtypes[flr(rnd(#subtypes))+1]
     local obj_type
     if subtype=="chest" then
      obj_type=obj_types.interactable_chest
     elseif subtype=="shrine" then
      obj_type=obj_types.interactable_shrine
     elseif subtype=="trap" then
      obj_type=obj_types.interactable_trap
     else
      obj_type=obj_types.interactable_note
     end
     local ob={
      pos={x,y},
      typ=obj_type,
      rel={0,0},
      frame=0,
      animloop=true,
      autoanim=false,
      subtype=subtype
     }
     add(gen_objects,ob)
    end
   end
  end
 end
end

-- generate decorations in rooms
function generate_decorations()
 local current_theme=gen_params.theme or "dng"
 local theme_config=themes[current_theme] or themes.dng
 local decor_prob=theme_config.decor_prob or 0.8
 
 for node in all(gen_nodes) do
  local rect=node.rect
  local w,h=rect[3]-rect[1]+1,rect[4]-rect[2]+1
  local room_decor_count=0
  local max_decor=gen_params.max_decorations_per_room or 12
  
  -- uniform grid pattern
  for dec in all(decoration_types) do
   if room_decor_count>=max_decor then break end
   
   -- filter by theme: check if any theme_tags match current_theme
   local theme_match=false
   if dec.theme_tags then
    for tag in all(dec.theme_tags) do
     if tag==current_theme then
      theme_match=true
      break
     end
    end
   else
    theme_match=true -- no theme_tags means always match
   end
   
   if theme_match and dec.gen_tags then
    for tag in all(dec.gen_tags) do
     if room_decor_count>=max_decor then break end
     
     if tag=="uni" and rnd(1)<0.3*decor_prob then
      for dx=2,w-2,3 do
       for dy=2,h-2,3 do
        if room_decor_count>=max_decor then break end
        if rnd(1)<0.5 then
         local x,y=rect[1]+dx+0.5,rect[2]+dy+0.5
         -- sprite_index from decoration_types configuration (148-155 range)
         local ob={pos={x,y},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,sprite_index=dec.sprite}
         add(gen_objects,ob)
         room_decor_count+=1
        end
       end
       if room_decor_count>=max_decor then break end
      end
      
     elseif tag=="uni2" and rnd(1)<0.4*decor_prob then
      -- denser uniform grid
      for dx=1,w-1,2 do
       for dy=1,h-1,2 do
        if room_decor_count>=max_decor then break end
        if rnd(1)<0.6 then
         local x,y=rect[1]+dx+0.5,rect[2]+dy+0.5
         local ob={pos={x,y},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,sprite_index=dec.sprite}
         add(gen_objects,ob)
         room_decor_count+=1
        end
       end
       if room_decor_count>=max_decor then break end
      end
      
     elseif tag=="scatter" and rnd(1)<0.2*decor_prob then
      local count=flr(rnd(3))+1
      for i=1,count do
       if room_decor_count>=max_decor then break end
       local x,y=find_spawn_point(rect)
       if x then
        local ob={pos={x,y},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,sprite_index=dec.sprite}
        add(gen_objects,ob)
        room_decor_count+=1
       end
      end
      
     elseif tag=="big" and rnd(1)<0.15*decor_prob then
      if room_decor_count>=max_decor then break end
      -- large object: place at room center or corner
      local cx,cy=flr((rect[1]+rect[3])/2)+0.5,flr((rect[2]+rect[4])/2)+0.5
      if rnd(1)<0.5 then
       -- center
       local ob={pos={cx,cy},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,sprite_index=dec.sprite}
       add(gen_objects,ob)
       room_decor_count+=1
      else
       -- random corner
       local corners={{rect[1]+1.5,rect[2]+1.5},{rect[3]-0.5,rect[2]+1.5},{rect[1]+1.5,rect[4]-0.5},{rect[3]-0.5,rect[4]-0.5}}
       local corner=corners[flr(rnd(#corners))+1]
       local ob={pos={corner[1],corner[2]},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,sprite_index=dec.sprite}
       add(gen_objects,ob)
       room_decor_count+=1
      end
      
     elseif tag=="rare" and rnd(1)<0.05*decor_prob then
      if room_decor_count>=max_decor then break end
      -- rare: single spawn
      local x,y=find_spawn_point(rect)
      if x then
       local ob={pos={x,y},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,sprite_index=dec.sprite}
       add(gen_objects,ob)
       room_decor_count+=1
      end
      
     elseif tag=="lit" and rnd(1)<0.25*decor_prob then
      if room_decor_count>=max_decor then break end
      -- lit: bias toward walls or doorways
      local walls={}
      -- collect wall-adjacent floor tiles
      for x=rect[1]+1,rect[3]-1 do
       if get_wall(x,rect[2])>0 then add(walls,{x+0.5,rect[2]+1.5}) end
       if get_wall(x,rect[4])>0 then add(walls,{x+0.5,rect[4]-0.5}) end
      end
      for y=rect[2]+1,rect[4]-1 do
       if get_wall(rect[1],y)>0 then add(walls,{rect[1]+1.5,y+0.5}) end
       if get_wall(rect[3],y)>0 then add(walls,{rect[3]-0.5,y+0.5}) end
      end
      if #walls>0 then
       local pos=walls[flr(rnd(#walls))+1]
       local ob={pos={pos[1],pos[2]},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,sprite_index=dec.sprite}
       add(gen_objects,ob)
       room_decor_count+=1
      end
     end
    end
   end
  end
 end
end

-- generate a complete dungeon
function generate_dungeon()
 local seed=flr(rnd(10000))
 srand(seed)
 
 -- initialize state
 gen_rects={}
 gen_nodes={}
 gen_edges={}
 gen_inventory={}
 gen_objects={}
 
 -- fill with walls (non-zero tile)
 fill_rect({0,0,127,127},wall_fill_tile)
 
 -- assign global theme before carving (ensures theme floor id is available)
 local theme_roll=rnd(1)
 local selected_theme="dng"
 if theme_roll<0.7 then
  selected_theme="dng"
 elseif theme_roll<0.9 then
  selected_theme="out"
 else
  selected_theme="dem"
 end
 gen_params.theme=selected_theme
 local theme_config=themes[selected_theme] or themes.dng
 
 -- set floor and ceiling types based on theme
 local floor_idx=1
 local roof_idx=3
 if theme_config.floor=="stone_tile" then floor_idx=1
 elseif theme_config.floor=="dirt" then floor_idx=2
 end
 if theme_config.roof=="stone_ceiling" then roof_idx=3
 elseif theme_config.roof=="sky" then roof_idx=4
 elseif theme_config.roof=="night_sky" then roof_idx=5
 end
 floor.typ=planetyps[floor_idx]
 roof.typ=planetyps[roof_idx]
 floor.x,floor.y=0,0
 roof.x,roof.y=0,0
 -- theme-specific floor id used by generator when carving/eroding
 gen_floor_id=floor_idx
 
 -- generate first room
 local first_rect=random_room(nil,false)
 local first_node=add_room(first_rect)
 fill_rect(first_rect,0)
 for x=max(0,first_rect[1]),min(127,first_rect[3]) do
  for y=max(0,first_rect[2]),min(127,first_rect[4]) do
   set_floor(x, y, gen_floor_id)
  end
 end
 
 -- generate additional rooms
 local room_count=flr(rnd(gen_params.max_rooms-gen_params.min_rooms+1))+gen_params.min_rooms
 for i=2,room_count do
  for attempt=1,max_room_attempts do
   if try_generate_room() then
    break
   end
  end
 end
 
 -- theme already chosen and floors configured above
 -- apply wall textures based on theme
 for node in all(gen_nodes) do
  -- skip junction rooms to avoid texturing their perimeters
  if not node.is_junction then
   local texset=theme_wall_texture(selected_theme)
   local tex=texset.variants[flr(rnd(#texset.variants))+1]
   apply_room_walls(node.rect,tex)
  end
 end
 
 -- ensure any doors placed earlier remain doors on the walls layer
 enforce_door_tiles()
 
 -- generate gameplay content (now aware of theme)
 generate_gameplay()
 -- gameplay may lock doors; re-assert tiles
 enforce_door_tiles()
 
 -- enforce border ring while preserving doors/exits
 enforce_border_ring()
 -- re-assert door tiles after border enforcement
 enforce_door_tiles()
 printh("Border ring enforced, doors preserved")
 
 -- populate objgrid from gen_objects
 for ob in all(gen_objects) do
  addobject(ob)
 end
 
 -- export to global objects list
 objects=gen_objects
 
 -- set player start
 player.x=first_node.midx+0.5
 player.y=first_node.midy+0.5
 
 printh("generated dungeon: "..#gen_nodes.." rooms, "..#gen_objects.." objects, seed "..seed)
 
 return {x=player.x,y=player.y},{rooms=#gen_nodes,objects=#gen_objects,seed=seed}
end

:: src/raycast.lua
--[[pod_format="raw",created="2025-11-07 21:17:12",modified="2025-11-07 21:48:07",revision=1]]
-- raycasting core

-- sign helper
function sgn(n)
 if n<0 then return -1 end
 if n>0 then return 1 end
 return 0
end

-- vector length
function length(x,y)
 x/=16
 y/=16
 return sqrt(x*x+y*y)*16
end

-- vector normalization
function normalise(x,y)
 local l=length(x,y)
 if l<=0.0001 then return 0,1 end
 return x/l,y/l
end

-- dda raycast with z-depth tracking
-- fx,fy represent the forward/depth axis used for perpendicular distance:
--  - In main scene: fx,fy = camera forward = (cos(a), sin(a))
--  - In hitscan:    fx,fy = normalized ray direction
function raycast(x,y,dx,dy,fx,fy)
 -- clamp near-zero components before normalization
 if abs(dx)<0.01 then dx=0.01 end
 if abs(dy)<0.01 then dy=0.01 end
 
 -- normalize direction if forward axis not provided
 if not fx then
  fx,fy=normalise(dx,dy)
 end
 
 -- horizontal ray initialization
 local hx,hy,hdx,hdy=x,y,sgn(dx),dy/abs(dx)
 local hdz,hz=hdx*fx+hdy*fy,0
 
 -- initial step to grid boundary
 local fracx=hx%1
 local hstep
 if hdx>0 then
  hstep=1-fracx
 else
  hstep=fracx
 end
 hx+=hdx*hstep
 hy+=hdy*hstep
 hz+=hdz*hstep
 
 -- vertical ray initialization
 local vx,vy,vdx,vdy=x,y,dx/abs(dy),sgn(dy)
 local vdz,vz=vdx*fx+vdy*fy,0
 
 -- initial step to grid boundary
 local fracy=vy%1
 local vstep
 if vdy>0 then
  vstep=1-fracy
 else
  vstep=fracy
 end
 vx+=vdx*vstep
 vy+=vdy*vstep
 vz+=vdz*vstep
 
 -- compute iteration limit from remaining grid crossings to map edges
 -- compute remaining crossings to nearest boundary per axis based on current positions
 local horizontal_crossings
 if hdx>0 then
  horizontal_crossings=map_size-flr(hx)
 else
  horizontal_crossings=flr(hx)+1
 end
 
 local vertical_crossings
 if vdy>0 then
  vertical_crossings=map_size-flr(vy)
 else
  vertical_crossings=flr(vy)+1
 end
 
 local iteration_limit=min(256,horizontal_crossings+vertical_crossings+10)
 
 -- track DDA steps for diagnostics
 local dda_steps=0
 
 -- ray marching
 for iter=1,iteration_limit do
  -- increment step counter
  dda_steps+=1
  
  -- far-plane check: early-out if both candidates exceed far_plane
  if min(hz, vz) > far_plane then
   if debug_mode then
    diag_dda_steps_total+=dda_steps
    diag_dda_early_outs+=1
   end
   return 999,hx,hy,0,0
  end
  
  if hz<vz then
   -- horizontal closer
   -- crossing a vertical gridline (x changes): choose the cell we are entering
   local gx=flr(hx)+(hdx<0 and -1 or 0)
   local gy=flr(hy)
   
   -- irreversible OOB check for horizontal candidate
   if (gx<0 and hdx<0) or (gx>=map_size and hdx>0) or (gy<0 and hdy<0) or (gy>=map_size and hdy>0) then
    if debug_mode then
     diag_dda_steps_total+=dda_steps
     diag_dda_early_outs+=1
    end
    return 999,hx,hy,0,0
   end
   
   if gx>=0 and gx<map_size and gy>=0 and gy<map_size then
    local m=get_wall(gx,gy)
    if m>0 then
     -- check if door
     if is_door(m) and doorgrid[gx][gy] then
     local dz=((hx+hdx/2-x)*fx+(hy+hdy/2-y)*fy)
      if dz<=vz then
       local open = test_door_mode and (test_door_open or 0) or doorgrid[gx][gy].open
       local dy_off=(hy+hdy/2)%1-open
       if dy_off>=0 then
        return dz,hx,hy,m,dy_off
       end
      end
     else
      -- wall hit
     if debug_mode then
      diag_dda_steps_total+=dda_steps
     end
     local z=((hx-x)*fx+(hy-y)*fy)
     -- texture coordinate from y-fraction; flip when rayDirX > 0
     local frac=hy-flr(hy)
     local tx=(hdx>0) and (1-frac) or frac
     return z,hx,hy,m,tx
     end
    end
   end
   hx+=hdx
   hy+=hdy
   hz+=hdz
  else
   -- vertical closer or equal
   -- crossing a horizontal gridline (y changes): choose the cell we are entering
   local gx=flr(vx)
   local gy=flr(vy)+(vdy<0 and -1 or 0)
   
   -- irreversible OOB check for vertical candidate
   if (gx<0 and vdx<0) or (gx>=map_size and vdx>0) or (gy<0 and vdy<0) or (gy>=map_size and vdy>0) then
    if debug_mode then
     diag_dda_steps_total+=dda_steps
     diag_dda_early_outs+=1
    end
    return 999,vx,vy,0,0
   end
   
   if gx>=0 and gx<map_size and gy>=0 and gy<map_size then
    local m=get_wall(gx,gy)
    if m>0 then
     -- check if door
     if is_door(m) and doorgrid[gx][gy] then
     local dz=((vx+vdx/2-x)*fx+(vy+vdy/2-y)*fy)
      if dz<=hz then
       local open = test_door_mode and (test_door_open or 0) or doorgrid[gx][gy].open
       local dx_off=(vx+vdx/2)%1-open
       if dx_off>=0 then
        return dz,vx,vy,m,dx_off
       end
      end
     else
      -- wall hit
     if debug_mode then
      diag_dda_steps_total+=dda_steps
     end
     local z=((vx-x)*fx+(vy-y)*fy)
     -- texture coordinate from x-fraction; flip when rayDirY < 0
     local frac=vx-flr(vx)
     local tx=(vdy<0) and (1-frac) or frac
     return z,vx,vy,m,tx
     end
    end
   end
   vx+=vdx
   vy+=vdy
   vz+=vdz
  end
 end
 
 -- fallback if iteration limit reached
 if debug_mode then
  diag_dda_steps_total+=dda_steps
  diag_dda_early_outs+=1
 end
 return 999,hx,hy,0,0
end

-- raycast entire scene
function raycast_scene()
 -- compute projection distance from FOV (fov is half-angle in radians)
 -- sdist = screen_center_x / tan(half_fov) ensures proper perspective mapping
 sdist=screen_center_x/math.tan(fov)
 
 -- classic forward basis: forward = (cos(a), sin(a))
 -- use cached cos/sin from _draw() if available
 local fwdx=(ca_cached or cos(player.a))
 local fwdy=(sa_cached or sin(player.a))
 minx,maxx=999,-999
 miny,maxy=999,-999
 maxz=0
 
 -- precompute per-ray screen spans (decouples ray_count from screen_width)
 for i=0,ray_count-1 do
  ray_x0[i]=flr(i*screen_width/ray_count)
  ray_x1[i]=max(ray_x0[i], flr((i+1)*screen_width/ray_count)-1)
 end
 
 for i=0,ray_count-1 do
  -- compute pixel center for this ray's span
  local pixel_x=(ray_x0[i]+ray_x1[i])/2+0.5
  local dx=pixel_x-screen_center_x
  local dy=sdist
  
  -- map camera-space to world-space and cache direction
  ray_dx[i]=(-fwdy)*dx+fwdx*dy
  ray_dy[i]=( fwdx)*dx+fwdy*dy
  
  -- cast ray using cached direction
  local z,hx,hy,tile,tx=raycast(player.x,player.y,ray_dx[i],ray_dy[i],fwdx,fwdy)
  
  -- store hit data in dedicated per-ray arrays
  ray_z[i]=z
  rbuf[i].tile=tile
  rbuf[i].tx=tx
  
  -- track bounds for object culling (only update on valid hits)
  if z<999 then
   minx=min(minx,hx)
   maxx=max(maxx,hx)
   miny=min(miny,hy)
   maxy=max(maxy,hy)
  end
  maxz=max(maxz,z)
 end
 
 -- validate and clamp culling bounds to map range
 if minx>maxx or miny>maxy then
  -- degenerate bounds (no valid hits), set to player position
  minx,maxx=player.x,player.x
  miny,maxy=player.y,player.y
 else
  -- clamp to map boundaries [0, map_size-1]
  minx=max(0,minx)
  maxx=min(map_size-1,maxx)
  miny=max(0,miny)
  maxy=min(map_size-1,maxy)
  
  -- add margin for sprite culling (expand by objgrid_size)
  minx=max(0,minx-objgrid_size)
  maxx=min(map_size-1,maxx+objgrid_size)
  miny=max(0,miny-objgrid_size)
  maxy=min(map_size-1,maxy+objgrid_size)
 end
 
 -- compute frustum AABB for sprite culling (independent of wall hits)
 compute_frustum_aabb()
end

-- compute camera-space frustum AABB for sprite culling (independent of wall hits)
-- returns world-space bounding box covering the view frustum out to far_plane
function compute_frustum_aabb()
  -- use cached camera basis
  local fwdx = ca_cached or cos(player.a)
  local fwdy = sa_cached or sin(player.a)
  local rightx = -fwdy  -- right vector perpendicular to forward
  local righty = fwdx
  
  -- compute horizontal extent at far_plane using FOV
  -- half_width = far_plane * tan(fov) = far_plane * (screen_center_x / sdist)
  local half_width = far_plane * (screen_center_x / sdist)
  
  -- compute four frustum corners in camera space:
  -- near-left, near-right, far-left, far-right
  -- (we use a small near distance to avoid player position issues)
  local near_dist = 0.1
  local near_half = near_dist * (screen_center_x / sdist)
  
  -- transform corners to world space and track min/max
  local wx_min = 999
  local wx_max = -999
  local wy_min = 999
  local wy_max = -999
  
  -- near-left corner
  local cx = -near_half
  local cz = near_dist
  local wx = player.x + fwdx * cz + rightx * cx
  local wy = player.y + fwdy * cz + righty * cx
  wx_min = min(wx_min, wx)
  wx_max = max(wx_max, wx)
  wy_min = min(wy_min, wy)
  wy_max = max(wy_max, wy)
  
  -- near-right corner
  cx = near_half
  wx = player.x + fwdx * cz + rightx * cx
  wy = player.y + fwdy * cz + righty * cx
  wx_min = min(wx_min, wx)
  wx_max = max(wx_max, wx)
  wy_min = min(wy_min, wy)
  wy_max = max(wy_max, wy)
  
  -- far-left corner
  cx = -half_width
  cz = far_plane
  wx = player.x + fwdx * cz + rightx * cx
  wy = player.y + fwdy * cz + righty * cx
  wx_min = min(wx_min, wx)
  wx_max = max(wx_max, wx)
  wy_min = min(wy_min, wy)
  wy_max = max(wy_max, wy)
  
  -- far-right corner
  cx = half_width
  wx = player.x + fwdx * cz + rightx * cx
  wy = player.y + fwdy * cz + righty * cx
  wx_min = min(wx_min, wx)
  wx_max = max(wx_max, wx)
  wy_min = min(wy_min, wy)
  wy_max = max(wy_max, wy)
  
  -- clamp to map boundaries and add small margin for sprite width
  local margin = objgrid_size
  frustum_minx = max(0, wx_min - margin)
  frustum_maxx = min(map_size - 1, wx_max + margin)
  frustum_miny = max(0, wy_min - margin)
  frustum_maxy = min(map_size - 1, wy_max + margin)
end

-- hitscan for projectiles/line-of-sight
function hitscan(x,y,dx,dy)
 -- normalize and get wall depth
 local sa,ca=normalise(dx,dy)
 local d,hx,hy,tile,tx=raycast(x,y,dx,dy,sa,ca)
 
 -- determine aabb
 local x0,y0=min(x,hx),min(y,hy)
 local x1,y1=max(x,hx),max(y,hy)
 
 local closest_obj=nil
 local closest_dist=d
 
 -- iterate relevant objgrid cells
 for gx=flr(x0/objgrid_size),flr(x1/objgrid_size) do
  for gy=flr(y0/objgrid_size),flr(y1/objgrid_size) do
   if gx>=0 and gx<=objgrid_array_size and gy>=0 and gy<=objgrid_array_size then
    for ob in all(objgrid[gx+1][gy+1]) do
     -- check if solid object
     if ob.typ and ob.typ.solid then
      -- compute normal and tangential distances
      local ox=ob.pos[1]-x
      local oy=ob.pos[2]-y
      local dn=(ox)*ca-(oy)*sa
      local dt=(ox)*sa+(oy)*ca
      
      -- check if within normal bounds
      if abs(dn)<=ob.typ.w*0.5 then
       -- check if not behind or beyond wall
       if dt>0 and dt<d then
        -- track closest object
        if dt<closest_dist then
         closest_dist=dt
         closest_obj=ob
        end
       end
      end
     end
    end
   end
  end
 end
 
 return closest_obj,closest_dist
end

:: src/render.lua
--[[pod_format="raw",created="2025-11-07 21:17:11",modified="2025-11-07 21:48:08",revision=1]]
-- rendering pipeline

-- track warned sprite indices to avoid per-frame spam
warned_sprites={}

-- lazy initialization flag for error texture
error_texture_initialized=false

-- persistent caches for textures and average colors across frames
tex_cache={}
avg_color_cache={}

-- clear caches when tiles/floor/ceiling change (e.g., on new floor)
function clear_texture_caches()
 tex_cache={}
 avg_color_cache={}
 warned_sprites={}
end

-- initialize error texture on first access (defensive fallback)
function init_error_texture()
 if not error_texture_initialized and not error_texture then
  -- create default error texture if none exists
  error_texture = userdata("u8", 32, 32)
  for y=0,31 do
   for x=0,31 do
    local color = ((flr(x/4) + flr(y/4)) % 2 == 0) and 8 or 14
    error_texture:set(x, y, color)
   end
  end
  error_texture_initialized=true
 end
end

-- get appropriate error texture for object type
function get_error_texture(obj_type)
 if error_textures then
  return error_textures[obj_type] or error_textures.default
 end
 init_error_texture()
 return error_texture
end

-- get individual sprite userdata for tline3d by sprite index
function get_texture_source(sprite_index, obj_type)
 -- default to sprite 0 for backward compatibility
 sprite_index=sprite_index or 0
 obj_type=obj_type or "default"
 
 -- return sprite sheet userdata
 local src=get_spr(sprite_index)
 if not src then
  -- warn once per sprite index to avoid per-frame spam
  if not warned_sprites[sprite_index] then
   printh("warning: sprite "..sprite_index.." not found, using "..obj_type.." error texture")
   warned_sprites[sprite_index]=true
  end
  -- return appropriate error texture for object type
  return get_error_texture(obj_type),true
 end
 return src,false
end

-- track last applied fog level to reduce palette changes
last_fog_level=-1
prev_pal={}

-- apply distance-based fog (with hysteresis caching for performance)
function compute_fog_level(z)
 if z<=0 then
  return -1
 end
 -- guard against degenerate config (prevent division by zero)
 if fog_far<=fog_near+0.000001 then
  return z>fog_far and 15 or 0
 end
 -- unified linear fog: 0 at fog_near, 15 at fog_far
 local t=(z-fog_near)/(fog_far-fog_near)
 -- clamp to [0,1]
 t=max(0,min(1,t))
 -- 16 levels (0..15)
 return flr(t*15)
end

-- apply distance-based fog (with hysteresis caching for performance)
function set_fog(z)
 if z<=0 then
  return  -- invalid depth, skip fog application
 end
 
 local level=compute_fog_level(z)
 
 -- hysteresis: only update if z changed significantly (reduces palette thrashing)
 if abs(z-last_fog_z)<fog_hysteresis and last_fog_level>=0 then
  return
 end
 last_fog_z=z
 
 -- only update palette if fog level changed (reduces palette ops from 320/frame to ~10-20)
 if level~=last_fog_level then
  if debug_mode then
   diag_fog_switches+=1
  end
  local p=pals[level+1]
  for i=0,63 do
   -- incremental update: only apply if value changed
   if p[i+1]~=prev_pal[i] then
    pal(i,p[i+1])
    prev_pal[i]=p[i+1]
   end
  end
  last_fog_level=level
 end
end

-- render textured walls (span-based with per-pixel zbuf and LOD)
function render_walls()
 palt(0,false)
 
 -- cache sprite sources by tile to avoid repeated get_spr() calls
 -- cache LOD average colors per tile to avoid per-frame src:get() sampling
 
 for ray_idx=0,ray_count-1 do
  -- read hit data from dedicated per-ray arrays
  local z=ray_z[ray_idx]
  local t=rbuf[ray_idx]
  
  -- get screen span for this ray
  local x0=ray_x0[ray_idx]
  local x1=ray_x1[ray_idx]
  
  -- skip zero-width or degenerate spans
  if x0>x1 then
   -- degenerate span, skip
  elseif z<999 then
   -- calculate wall height
   local h=sdist/z
   local y0=screen_center_y-h/2
   local y1=screen_center_y+h/2
   
   -- extract texture coordinates from table
   local tile=t.tile
   local tx=t.tx
   
   -- LOD: use simplified rendering for distant walls
   if z>wall_lod_distance then
    -- check cached average color first
    local avg_color=avg_color_cache[tile]
    if not avg_color then
     -- sample average color from texture center for solid fill
     local cached=tex_cache[tile]
     local src,is_fallback
     if cached then
      src,is_fallback=cached.src,cached.is_fallback
     else
      -- choose object type for fallback texture
      local obj_type=is_door and is_door(tile) and "door" or "wall"
      src,is_fallback=get_texture_source(tile,obj_type)
      tex_cache[tile]={src=src,is_fallback=is_fallback}
     end
     
     -- sample center pixel color from texture (u=16, v=16 in 32x32 sprite)
     avg_color=5 -- default fog color if sampling fails
     if src and src.get then
      avg_color=src:get(16,16) or 5
     end
     
     -- cache for subsequent LOD draws
     avg_color_cache[tile]=avg_color
    end
    
    -- apply fog
    set_fog(z)
    
    -- draw solid color across span
    local draw_y0=ceil(y0)
    local draw_y1=min(flr(y1),screen_height-1)
    rectfill(x0,draw_y0,x1,draw_y1,avg_color)
    
    -- count wall columns for diagnostics
    if debug_mode then
     diag_wall_columns+=(x1-x0+1)
    end
    
    -- write zbuf for entire span
    for x=x0,x1 do
     zbuf[x+1]=z
    end
   else
    -- normal rendering with tline3d
    -- fetch sprite for this specific wall/door tile
    local cached=tex_cache[tile]
    local src,is_fallback
    if cached then
     src,is_fallback=cached.src,cached.is_fallback
    else
     -- choose object type for fallback texture
     local obj_type=is_door and is_door(tile) and "door" or "wall"
     src,is_fallback=get_texture_source(tile,obj_type)
     tex_cache[tile]={src=src,is_fallback=is_fallback}
    end
    
    -- compute base u coordinate
    local u0=flr(tx*32)
    u0=max(0,min(31,u0))
    
    -- interpolate u with next ray if same tile
    local u1=u0
    if ray_idx<ray_count-1 then
     local t_next=rbuf[ray_idx+1]
     if t_next.tile==tile then
      local tx_next=t_next.tx
      local u1_next=flr(tx_next*32)
      u1_next=max(0,min(31,u1_next))
      u1=u1_next
     end
    end
    
    -- vertical span clamps
    local draw_y0=ceil(y0)
    local draw_y1=min(flr(y1),screen_height-1)
    
    -- adjust v0 for clipped top to maintain texture continuity
    local v0=0
    local v1=32
    local full_h=y1-y0
    if full_h>0 and draw_y0<y1 then
     v0+=((draw_y0-y0)/full_h)*32
     v1=v0+32
    end
    
    -- apply fog once per ray
    set_fog(z)
    
    -- draw columns across the span with interpolated u
    for x=x0,x1 do
     local u_interp=u0+(u1-u0)*(x-x0)/(x1-x0+0.01)
     u_interp=max(0,min(31,u_interp))
     tline3d(src,x,draw_y0,x,draw_y1,u_interp,v0,u_interp,v1,1,1)
     -- write zbuf per pixel
     zbuf[x+1]=z
    end
    
    -- count wall columns for diagnostics
    if debug_mode then
     diag_wall_columns+=(x1-x0+1)
    end
   end
  else
   -- miss: still write zbuf for the span to maintain occlusion
   for x=x0,x1 do
    zbuf[x+1]=999
   end
  end
 end
 
 -- restore transparency mask to defaults (color 0 transparent, others opaque)
 palt()
end

-- render perspective floor/ceiling with individual 32x32 sprites
function render_floor_ceiling()
 -- classic forward: forward = (cos(a), sin(a))
 -- use cached cos/sin from _draw() if available
 local fwdx=(ca_cached or cos(player.a))
 local fwdy=(sa_cached or sin(player.a))
 
 -- calculate horizon with safeguard against divide-by-zero
 local h
 if maxz<=0 then
  h=screen_height
 else
  h=sdist/maxz
 end
 
 -- fetch and render ceiling (sprites 34-36 from gfx/1_surfaces.gfx)
 local roof_typ=roof.typ
 local roof_src,roof_fallback=get_texture_source(roof_typ.tex,"ceiling")
 if roof_fallback then
  roof_src=get_error_texture("ceiling")
 end
 draw_rows(roof_src,-screen_center_y,-ceil(h/2),roof_typ.scale,roof_typ.height,cam[1]-roof.x,cam[2]-roof.y,roof_typ.lit,fwdx,fwdy,roof_typ.tex)
 
 -- fetch and render floor (sprites 32-33 from gfx/1_surfaces.gfx)
 local floor_typ=floor.typ
 local floor_src,floor_fallback=get_texture_source(floor_typ.tex,"floor")
 if floor_fallback then
  floor_src=get_error_texture("floor")
 end
 draw_rows(floor_src,ceil(h/2),screen_center_y-1,floor_typ.scale,floor_typ.height,cam[1]-floor.x,cam[2]-floor.y,floor_typ.lit,fwdx,fwdy,floor_typ.tex)
end

-- draw horizontal scanlines with 32x32 sprite sampling (optimized fog calls)
function draw_rows(src,y0,y1,tilesize,height,cx,cy,lit,sa,ca,tex)
 local size=sprite_size or 32
 
 -- normalize row_stride to prevent invalid config (guard against 0 or negative)
 local stride=max(1, row_stride or 1)
 
 -- track last applied fog level for this section to reduce calls
 local last_scanline_level=-2
 
 -- cache texture average color for duplication (avoid per-row src:get calls)
 local cached_fill_color=nil
 if stride > 1 and tex then
  cached_fill_color=avg_color_cache[tex]
  if not cached_fill_color then
   -- compute once and cache
   cached_fill_color=5  -- default fog color
   if src and src.get then
    cached_fill_color=src:get(16, 16) or 5
   end
   avg_color_cache[tex]=cached_fill_color
  end
 end
 
 for y=y0,y1,stride do
  -- calculate ray gradient
  local g=abs(y)/sdist
  
  -- calculate z distance
  local z=(height or 0.5)/g
  
  -- calculate map coordinates
  local mx=(cx+z*sa)/tilesize
  local my=(cy+z*ca)/tilesize
  
  -- calculate texture deltas
  local s=sdist/z*tilesize
  local mdx=-ca/s
  local mdy=sa/s
  
  -- offset to left edge
  mx-=screen_center_x*mdx
  my-=screen_center_x*mdy
  
  -- apply fog uniformly (per scanline)
  -- compute expected fog level and only update when it changes
  local level=compute_fog_level(z)
  if level~=last_scanline_level then
   set_fog(z)
   last_scanline_level=level
  end
  
  -- count scanline for diagnostics (once per y iteration, consistent across modes)
  if debug_mode then
   diag_floor_rows+=1
  end
  
  if per_cell_floors_enabled then
   -- per-cell floor type rendering: sample floor types along scanline and build runs
   local runs={}
   local sample_interval=4
   local current_run=nil
   
   for x=0,screen_width-1,sample_interval do
    -- compute world coordinates at this x
    local wx=mx+x*mdx
    local wy=my+x*mdy
    local gx=flr(wx)
    local gy=flr(wy)
    
    -- read floor type from map (0=use global default)
    local floor_id=get_floor(gx,gy)
    
    -- start new run or extend current run
    if not current_run then
     current_run={x0=x,x1=x,floor_id=floor_id}
    elseif current_run.floor_id==floor_id then
     current_run.x1=x
    else
     -- close current run and start new one
     current_run.x1=x-1
     add(runs,current_run)
     current_run={x0=x,x1=x,floor_id=floor_id}
    end
   end
   
   -- close final run
   if current_run then
    current_run.x1=screen_width-1
    add(runs,current_run)
   end
   
   -- merge short runs (width < 4 pixels) into adjacent runs to reduce draw calls
   local merged_runs={}
   for i=1,#runs do
    local run=runs[i]
    local width=run.x1-run.x0+1
    if width<4 and #merged_runs>0 then
     -- merge into previous run
     merged_runs[#merged_runs].x1=run.x1
    else
     add(merged_runs,run)
    end
   end
   
   -- draw each run with appropriate texture
   for run in all(merged_runs) do
    local run_src=src
    local run_fallback=false
    
    -- select texture from planetyps if floor_id is valid
    if run.floor_id>0 and run.floor_id<=#planetyps then
     local floor_type=planetyps[run.floor_id]
     run_src,run_fallback=get_texture_source(floor_type.tex,"floor")
     if run_fallback then
      run_src=get_error_texture("floor")
     end
    end
    
    -- compute UVs for this run segment
    local u0=(mx+run.x0*mdx)%1*size
    local v0=(my+run.x0*mdy)%1*size
    u0=max(0,min(31,u0))
    v0=max(0,min(31,v0))
    local u1=u0+(run.x1-run.x0)*mdx*size
    local v1=v0+(run.x1-run.x0)*mdy*size
    
    -- draw run scanline
    tline3d(run_src,run.x0,screen_center_y+y,run.x1,screen_center_y+y,u0,v0,u1,v1,1,1)
    
    -- count draw calls for diagnostics (per run)
    if debug_mode then
     diag_floor_draw_calls+=1
    end
   end
  else
   -- simplified rendering: draw full scanline with single texture
   local u0=(mx)%1*size
   local v0=(my)%1*size
   u0=max(0,min(31,u0))
   v0=max(0,min(31,v0))
   local u1=u0+(screen_width-1)*mdx*size
   local v1=v0+(screen_width-1)*mdy*size
   
   -- draw full scanline
   tline3d(src,0,screen_center_y+y,screen_width-1,screen_center_y+y,u0,v0,u1,v1,1,1)
   
   -- count draw calls for diagnostics (single draw call per scanline)
   if debug_mode then
    diag_floor_draw_calls+=1
   end
  end
  
  -- duplicate into skipped rows with solid fill for performance
  if stride > 1 and cached_fill_color then
   for dy=1,stride-1 do
    local next_y = y + dy
    if next_y <= y1 then
     rectfill(0, screen_center_y+next_y, screen_width-1, screen_center_y+next_y, cached_fill_color)
    end
   end
  end
 end
end


:: src/render_sprite.lua
--[[pod_format="raw",created="2025-11-07 21:17:10",modified="2025-11-07 21:48:08",revision=1]]
-- sprite rendering pipeline

-- render sprites with z-buffer occlusion (optimized culling)
function render_sprites()
 -- use cached sin/cos from _draw() if available
 local sa,ca=sa_cached or sin(player.a),ca_cached or cos(player.a)
 
 -- early exit if frustum bounds are degenerate
 if frustum_minx>frustum_maxx or frustum_miny>frustum_maxy then
  return
 end
 
 -- initialize depth buckets for sprite sorting
 -- 16 total buckets: 0-7 for upright sprites, 8-15 for flat sprites (offset by 8)
 -- bucket size = far_plane / 8 (e.g., 25.0 / 8 = 3.125 units per bucket)
 local bucket_size = far_plane / 8
 local sprite_buckets = {}
 for i=0,15 do
  sprite_buckets[i] = {}
 end
 
 for gx=flr(frustum_minx/objgrid_size),flr(frustum_maxx/objgrid_size) do
  for gy=flr(frustum_miny/objgrid_size),flr(frustum_maxy/objgrid_size) do
   if gx>=0 and gx<=objgrid_array_size and gy>=0 and gy<=objgrid_array_size then
    for ob in all(objgrid[gx+1][gy+1]) do
     if ob and ob.pos and ob.typ then
      -- transform to view space
      local rx=ob.pos[1]-player.x
      local ry=ob.pos[2]-player.y
      
      -- rotate to view-aligned coordinates (camera space)
      -- right = (-sin a, cos a), forward = (cos a, sin a)
      local x_cam = -sa*rx + ca*ry
      local z_cam =  ca*rx + sa*ry
      ob.rel[1]=x_cam
      ob.rel[2]=z_cam
      
      -- far-plane culling: skip sprites beyond far_plane
      if ob.rel[2]>far_plane then
       goto skip_sprite
      end
      
      -- depth culling: skip sprites beyond max wall depth
      if ob.rel[2]>=maxz then
       goto skip_sprite
      end
      
      -- cull behind camera and outside frustum
      local t=ob.typ
      local pass_frustum=false
      if ob.rel[2]>0.1 then
       if t.flat then
        -- flat sprites: require minimum distance to prevent z-division issues
        if ob.rel[2]>=t.w/2 then
         pass_frustum=true
        end
       else
        -- upright sprites: horizontal frustum culling
        if abs(ob.rel[1])-(t.w/2)<ob.rel[2]*(screen_center_x/sdist) then
         pass_frustum=true
        end
       end
      end
      
      if pass_frustum then
       -- compute bucket index based on depth
       -- bucket 0 = 0.0-3.125, bucket 1 = 3.125-6.25, ..., bucket 7 = 21.875-25.0+
       local bucket_idx = min(7, flr(ob.rel[2] / bucket_size))
       
       -- flat sprites offset by 8 to ensure they render after upright sprites at same depth
       if ob.typ.flat then
        bucket_idx = bucket_idx + 8
       end
       
       -- add to bucket
       add(sprite_buckets[bucket_idx], ob)
      end
      
      ::skip_sprite::
     end
    end
   end
  end
 end
 
 -- draw sprites back-to-front using bucket iteration
 -- bucket 15-0: farthest to nearest (bucket 15 = flat sprites at far distance)
 palt(0,false)
 palt(14,true)
 
 for bucket_idx=15,0,-1 do
  -- sort non-empty bucket by z descending (far to near) for correct sprite-sprite occlusion
  local bucket = sprite_buckets[bucket_idx]
  if #bucket > 1 then
   -- insertion sort by ob.rel[2] descending
   for i=2,#bucket do
    local ob = bucket[i]
    local z = ob.rel[2]
    local j = i - 1
    while j >= 1 and bucket[j].rel[2] < z do
     bucket[j+1] = bucket[j]
     j = j - 1
    end
    bucket[j+1] = ob
   end
  end
  
  for ob in all(bucket) do
   drawobj_single(ob, sa, ca)
  end
 end
 
 palt()
 clip()
end

-- draw single sprite object with z-buffer occlusion (color 0=opaque, color 14=transparent)
function drawobj_single(ob, sa, ca)
 if not ob or not ob.typ or not ob.rel then
  return
 end
  
  local t=ob.typ
  local x=ob.rel[1]
  local z=ob.rel[2]
  
  -- fetch sprite for this object
  local base_sprite_index = ob.sprite_index or t.mx
  local sprite_index = base_sprite_index
  
  -- handle animation with sequential sprite indexes
  if t.framect then
   local fr=flr(ob.frame or 0)
   if ob.animloop then
    fr=fr%t.framect
   else
    fr=min(fr,t.framect-1)
   end
   sprite_index = base_sprite_index + fr
  end
  
  -- validate sprite exists; if animation overflow, reset to base
  local test_src = get_spr(sprite_index)
  if not test_src then
   if sprite_index ~= base_sprite_index then
    -- animation frame overflow detected
    if not warned_sprites[base_sprite_index] then
     printh("warning: animation frame overflow for sprite "..base_sprite_index..", clamping to base")
     warned_sprites[base_sprite_index]=true
    end
    sprite_index = base_sprite_index
   end
  end
  
  local src,is_fallback = get_texture_source(sprite_index,"sprite")
  if is_fallback then
   src = get_error_texture("sprite")
  end
  
  -- get vertical offset (can be animated)
  local y=ob.y or t.y
  if t.yoffs then
   local frame = ob.frame or 0
   local frame_idx=flr(frame%#t.yoffs)+1
   if frame_idx>0 and frame_idx<=#t.yoffs then
    y+=t.yoffs[frame_idx]
   end
  end
  
  -- LOD: impostor rendering for distant sprites
  local sprite_lod_distance=fog_far*sprite_lod_ratio
  if z>sprite_lod_distance then
   -- sample average color from sprite center (defaults to fog color 5)
   local avg_color=5
   if src and src.get then
    avg_color=src:get(16,16) or 5
   end
   
   -- apply fog uniformly
   set_fog(z)
   
   -- project to screen space
   local f_lod=sdist/z
   local sx_lod=x*f_lod+screen_center_x
   local w_lod=t.w*f_lod
   
   -- compute vertical span
   local y0_lod,y1_lod
   if t.flat then
    local z0=z+t.w/2
    local z1=z-t.w/2
    y0_lod=y*sdist/z0+screen_center_y
    y1_lod=y*sdist/z1+screen_center_y
   else
    local sy_lod=y*f_lod+screen_center_y
    local h_lod=t.h*f_lod
    y0_lod=sy_lod-h_lod/2
    y1_lod=sy_lod+h_lod/2
   end
   
   -- clamp to screen bounds
   local x0=max(0,ceil(sx_lod-w_lod/2))
   local x1=min(screen_width-1,flr(sx_lod+w_lod/2))
   y0_lod=max(0,ceil(y0_lod))
   y1_lod=min(screen_height-1,flr(y1_lod))
   
   -- draw solid impostor columns with z-test
   if y1_lod>y0_lod and x1>=x0 then
    for px=x0,x1 do
     if z<zbuf[px+1] then
      rectfill(px,y0_lod,px,y1_lod,avg_color)
      if debug_mode then
       diag_sprite_columns+=1
      end
     end
    end
   end
   
   return
  end
  
  -- calculate scale factor (perspective)
  local f=sdist/z
  
  -- project to screen space
  local sx=x*f+screen_center_x
  local w=t.w*f
  
  -- calculate y coordinates (different for flat vs upright)
  local y0,y1
  if t.flat then
   -- floor-aligned sprite
   local z0=z+t.w/2
   local z1=z-t.w/2
   y0=y*sdist/z0+screen_center_y
   y1=y*sdist/z1+screen_center_y
  else
   -- upright sprite (use world-space height t.h, not pixel size sprite_size)
   local sy=y*f+screen_center_y
   local h=t.h*f
   y0=sy-h/2
   y1=sy+h/2
  end
  
  -- map screen dimensions to 32x32 sprite UV space
  local size=sprite_size or 32
  local sxd=size/w
  local syd=size/(y1-y0+0.01)
  
  -- UV coordinates start at (0,0) for top-left of 32x32 sprite
  local u0 = 0
  local v0 = 0
  
  -- compute floating left/top edges for sub-pixel adjustment
  local lx=sx-w/2
  local fy0=y0
  
  -- clamp to screen bounds (0 to screen_width-1 for X, 0 to screen_height-1 for Y)
  local x0=max(0,ceil(lx))
  local x1=min(screen_width-1,flr(sx+w/2))
  -- adjust u0 for x clipping
  if x0>lx then
   u0+=(x0-lx)*sxd
  end
  
  y0=max(0,ceil(fy0))
  y1=min(screen_height-1,flr(y1))
  -- adjust v0 for y clipping
  if y0>fy0 then
   v0+=(y0-fy0)*syd
  end
  
  -- guard against degenerate vertical or horizontal span
  if y1<=y0 or x1<x0 then
   return
  end
  
  -- set fog and palette
  if ob.pal then
   pal(ob.pal)
  else
   set_fog(z)
  end
  
  -- draw sprite column-by-column with z-buffer (no diagonal batching)
  for px=x0,x1 do
   if z<zbuf[px+1] then
    local u=u0+(px-x0)*sxd
    tline3d(src,px,y0,px,y1,u,v0,u,v0+size,1,1)
    if debug_mode then
     diag_sprite_columns+=1
    end
   end
  end
  
  -- if a custom palette was applied, restore fog mapping for subsequent draws
  if ob.pal then
   last_fog_level=-1
   prev_pal={}
   set_fog(z)
  end
end

:: [eoc]
