picotron cartridge // www.picotron.net
version 2

:: .info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTExLTA3IDIyOjE0OjIwIixtb2RpZmllZD0iMjAyNS0x
MS0wNyAyMjoxODo1MSIscnVudGltZT0yMSx3b3Jrc3BhY2VzPXt7bG9jYXRpb249Im1haW4ubHVh
IzgyOCIsd29ya3NwYWNlX2luZGV4PTF9fV1d
:: main.lua
b64$LS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNS0xMS0wNyAyMTowNDowNiIsbW9k
aWZpZWQ9IjIwMjUtMTEtMDcgMjI6MTg6NTEiLHJldmlzaW9uPTVdXQotLVtbcG9kX2Zvcm1hdD0i
cmF3IixjcmVhdGVkPSIyMDI1LTExLTA3IDIxOjA0OjA2Iixtb2RpZmllZD0iMjAyNS0xMS0wNyAy
MTo0ODowMiIscmV2aXNpb249NF1dCi0tIG5vbmJveSByYXljYXN0IGVuZ2luZSB2MS4wCi0tIG1h
aW4gZW50cnkgcG9pbnQKCmluY2x1ZGUic3JjL2NvbmZpZy5sdWEiCmluY2x1ZGUic3JjL3JheWNh
c3QubHVhIgppbmNsdWRlInNyYy9yZW5kZXIubHVhIgppbmNsdWRlInNyYy9yZW5kZXJfc3ByaXRl
Lmx1YSIKaW5jbHVkZSJzcmMvZG9vcl9zeXN0ZW0ubHVhIgppbmNsdWRlInNyYy9kdW5nZW9uX2dl
bi5sdWEiCgotLSBjb25zdGFudHMKcGxheWVyX2NvbGxpc2lvbl9yYWRpdXM9MC4xNQoKZnVuY3Rp
b24gX2luaXQoKQogd2luZG93KHNjcmVlbl93aWR0aCxzY3JlZW5faGVpZ2h0KQogCiAtLSBmcmFt
ZSBjb3VudGVyIGZvciBhaSB0aW1pbmcKIGZyYW1lX2N0PTAKIAogLS0gcGxheWVyIHN0YXRlCiBw
bGF5ZXI9ewogIHg9NjQseT02NCwKICBhPTAsCiAgc3BkPXBsYXllcl9tb3ZlX3NwZWVkLAogIGtl
eXM9e30sCiAgaHA9MTAwCiB9CiAKIC0tIGludGVyYWN0aW9uIHN0YXRlCiBpbnRlcmFjdGlvbl9h
Y3RpdmU9ZmFsc2UKIGN1cnJlbnRfaW50ZXJhY3Q9bmlsCiAKIC0tIGNvbWJhdCBzdGF0ZQogaW5f
Y29tYmF0PWZhbHNlCiBjdXJyZW50X3RhcmdldD1uaWwKIAogLS0gdHJhcCBtZXNzYWdlIHRpbWVy
CiB0cmFwX21zZ190aW1lcj0wCiAKIC0tIGNhbWVyYQogY2FtPXtwbGF5ZXIueCxwbGF5ZXIueX0K
IAogLS0gbWFwIGFic3RyYWN0aW9uIHdpdGggdXNlcmRhdGEgbGF5ZXJzCiBtYXA9e30KIG1hcC53
YWxscz11c2VyZGF0YSgiaTE2IiwxMjgsMTI4KQogbWFwLmRvb3JzPXVzZXJkYXRhKCJpMTYiLDEy
OCwxMjgpCiAKIC0tIGhlbHBlcjogZ2V0IHdhbGwgdGlsZQogLS0gUHVycG9zZTogUmV0cmlldmUg
d2FsbCB0aWxlIElEIGF0IGdyaWQgcG9zaXRpb24gd2l0aCBmYWxsYmFjawogLS0gUGFyYW1ldGVy
czogeCwgeSAoZ3JpZCBjb29yZGluYXRlcyAwLTEyNykKIC0tIFJldHVybnM6IHRpbGUgSUQgKDA9
ZW1wdHksID4wPXdhbGwvZG9vci9leGl0KQogLS0gTm90ZXM6IENoZWNrcyB1c2VyZGF0YSBmaXJz
dCwgZmFsbHMgYmFjayB0byB3YWxsZ3JpZCB0YWJsZSBmb3IgY29tcGF0aWJpbGl0eQogZnVuY3Rp
b24gZ2V0X3dhbGwoeCx5KQogIGlmIHg_PTAgYW5kIHg8MTI4IGFuZCB5Pj0wIGFuZCB5PDEyOCB0
aGVuCiAgIGxvY2FsIHZhbD1tYXAud2FsbHM6Z2V0KHgseSkKICAgaWYgdmFsIGFuZCB2YWw_MCB0
aGVuIHJldHVybiB2YWwgZW5kCiAgIC0tIGRlZmVuc2l2ZSBmYWxsYmFjazogY2hlY2sgd2FsbGdy
aWQgaWYgbWFwLndhbGxzIGlzIG5pbCBvciAwCiAgIGlmIHdhbGxncmlkIGFuZCB3YWxsZ3JpZFt4
XSBhbmQgd2FsbGdyaWRbeF1beV0_MCB0aGVuCiAgICByZXR1cm4gd2FsbGdyaWRbeF1beV0KICAg
ZW5kCiAgIHJldHVybiAwCiAgZW5kCiAgcmV0dXJuIDAKIGVuZAogCiAtLSBoZWxwZXI6IHNldCB3
YWxsIHRpbGUKIGZ1bmN0aW9uIHNldF93YWxsKHgseSx2YWwpCiAgaWYgeD49MCBhbmQgeDwxMjgg
YW5kIHk_PTAgYW5kIHk8MTI4IHRoZW4KCQltYXAud2FsbHM6c2V0KHgseSx2YWwgb3IgMCkKCQkt
LSBrZWVwIEx1YSBtaXJyb3IgaW4gc3luYyBmb3Igc3lzdGVtcyBzdGlsbCByZWFkaW5nIHdhbGxn
cmlkIChlLmcuLCBtaW5pbWFwKQoJCWlmIHdhbGxncmlkIGFuZCB3YWxsZ3JpZFt4XSB0aGVuIHdh
bGxncmlkW3hdW3ldPXZhbCBvciAwIGVuZAogIGVuZAogZW5kCiAKIC0tIGhlbHBlcjogZ2V0IGRv
b3IgdGlsZQogZnVuY3Rpb24gZ2V0X2Rvb3IoeCx5KQogIGlmIHg_PTAgYW5kIHg8MTI4IGFuZCB5
Pj0wIGFuZCB5PDEyOCB0aGVuCiAgIHJldHVybiBtYXAuZG9vcnM6Z2V0KHgseSkgb3IgMAogIGVu
ZAogIHJldHVybiAwCiBlbmQKIAogLS0gaGVscGVyOiBzZXQgZG9vciB0aWxlCiBmdW5jdGlvbiBz
ZXRfZG9vcih4LHksdmFsKQogIGlmIHg_PTAgYW5kIHg8MTI4IGFuZCB5Pj0wIGFuZCB5PDEyOCB0
aGVuCiAgIG1hcC5kb29yczpzZXQoeCx5LHZhbCBvciAwKQogIGVuZAogZW5kCiAKIC0tIGNvbXBh
dGliaWxpdHkgbGF5ZXI6IGV4cG9zZSB3YWxsZ3JpZCBhcyB0YWJsZSBmb3IgZHVuZ2VvbiBnZW5l
cmF0b3IKIHdhbGxncmlkPXt9CiBkb29yZ3JpZD17fQogZm9yIGk9MCwxMjcgZG8KICB3YWxsZ3Jp
ZFtpXT17fQogIGRvb3JncmlkW2ldPXt9CiAgZm9yIGo9MCwxMjcgZG8KICAgd2FsbGdyaWRbaV1b
al09MAogICBkb29yZ3JpZFtpXVtqXT1uaWwKICBlbmQKIGVuZAogIAogZG9vcnM9e30KIG9iamVj
dHM9e30KIGFuaW1hdGVkX29iamVjdHM9e30KIG9iamdyaWQ9e30KIGZvciBneD0wLG9iamdyaWRf
YXJyYXlfc2l6ZSBkbwogIG9iamdyaWRbZ3grMV09e30KICBmb3IgZ3k9MCxvYmpncmlkX2FycmF5
X3NpemUgZG8KICAgb2JqZ3JpZFtneCsxXVtneSsxXT17fQogIGVuZAogZW5kCiB6YnVmPXt9CiB0
YnVmPXt9CiBmb3IgaT0xLHJheV9jb3VudCBkbwogIHpidWZbaV09OTk5CiAgdGJ1ZltpXT17dGls
ZT0wLHR4PTB9CiBlbmQKIAogLS0gcHJvamVjdGlvbiBjb25zdGFudCBkZWZpbmVkIGluIGNvbmZp
Zy5sdWEKIAogLS0gZmxvb3IgYW5kIHJvb2Ygc3RhdGUKIGZsb29yPXt0eXA9cGxhbmV0eXBzWzFd
LHg9MCx5PTB9CiByb29mPXt0eXA9cGxhbmV0eXBzWzNdLHg9MCx5PTB9CiAKIC0tIGdlbmVyYXRl
IGR1bmdlb24KIHN0YXJ0X3BvcyxnZW5fc3RhdHM9Z2VuZXJhdGVfZHVuZ2VvbigpCiAKIC0tIG1v
ZGU6IDNkIG9yIDJkIG1hcAogdmlld19tb2RlPSIzZCIgLS0gb3IgIjJkIiBmb3IgbWluaW1hcAog
CiAtLSBkZWJ1ZyBtb2RlIGZvciByYXkgY2FzdGluZwogZGVidWdfbW9kZT1mYWxzZQogCiAtLSB0
ZXN0IGRvb3IgbW9kZQogdGVzdF9kb29yX21vZGU9ZmFsc2UKCiBwcmludGgoInBpY290cm9uIHJh
eWNhc3QgZW5naW5lIHYxLjAiKQplbmQKCmZ1bmN0aW9uIF91cGRhdGUoKQogLS0gaW5jcmVtZW50
IGZyYW1lIGNvdW50ZXIKIGZyYW1lX2N0Kz0xCiAKIC0tIGNvbWJhdCBnYXRpbmc6IHNraXAgbm9y
bWFsIHVwZGF0ZXMgd2hlbiBpbiBjb21iYXQKIGlmIGluX2NvbWJhdCB0aGVuCiAgdXBkYXRlX2Nv
bWJhdCgpCiAgcmV0dXJuCiBlbmQKIAogdXBkYXRlX2lucHV0KCkKIHVwZGF0ZV9kb29ycygpCiAK
IC0tIHVwZGF0ZSBucGMgYWkgKHJhdGUgbGltaXRlZCwgZGV0ZXJtaW5pc3RpYyBmcmFtZSBjaGVj
aykKIGlmIGZyYW1lX2N0JWFpX3VwZGF0ZV9yYXRlPT0wIHRoZW4KICB1cGRhdGVfbnBjX2FpKCkK
IGVuZAogCiBjYW09e3BsYXllci54LHBsYXllci55fQogCiAtLSB1cGRhdGUgZmxvb3IvY2VpbGlu
ZyBzY3JvbGxpbmcKIGZsb29yLngrPWZsb29yLnR5cC54dmVsIG9yIDAKIGZsb29yLnkrPWZsb29y
LnR5cC55dmVsIG9yIDAKIHJvb2YueCs9cm9vZi50eXAueHZlbCBvciAwCiByb29mLnkrPXJvb2Yu
dHlwLnl2ZWwgb3IgMAogCiAtLSB1cGRhdGUgb2JqZWN0IGFuaW1hdGlvbnMKIGZvciBvYiBpbiBh
bGwoYW5pbWF0ZWRfb2JqZWN0cykgZG8KICBpZiBvYi50eXAgYW5kIG9iLnR5cC5mcmFtZWN0IHRo
ZW4KICAgb2IuZnJhbWUrPW9iLnR5cC5hbmltc3BkCiAgIGlmIG9iLmFuaW1sb29wIHRoZW4KICAg
IG9iLmZyYW1lPW9iLmZyYW1lJW9iLnR5cC5mcmFtZWN0CiAgIGVsc2UKICAgIG9iLmZyYW1lPW1p
bihvYi5mcmFtZSxvYi50eXAuZnJhbWVjdC0xKQogICBlbmQKICBlbmQKIGVuZAogCiAtLSB0b2dn
bGUgdmlldyBtb2RlCiBpZiBidG5wKDUpIHRoZW4gLS0geCBrZXkKICB2aWV3X21vZGU9dmlld19t
b2RlPT0iM2QiIGFuZCAiMmQiIG9yICIzZCIKIGVuZAogCiAtLSBkZWJ1ZyBtb2RlIHRvZ2dsZSAo
bW92ZWQgZnJvbSBidG5wKDQpIHRvIGF2b2lkIGNvbmZsaWN0KQogaWYga2V5cCgidGFiIikgdGhl
bgogIGRlYnVnX21vZGU9bm90IGRlYnVnX21vZGUKIGVuZAogCiAtLSBkZWNyZW1lbnQgdHJhcCBt
ZXNzYWdlIHRpbWVyCiBpZiB0cmFwX21zZ190aW1lcj4wIHRoZW4KICB0cmFwX21zZ190aW1lci09
MQogZW5kCiAKIC0tIHRvZ2dsZSB0ZXN0IGRvb3IgbW9kZSAod2hlbiBub3QgaW4gMmQgbWFwIHZp
ZXcpCiBpZiB2aWV3X21vZGU9PSIzZCIgYW5kIGJ0bnAoOCkgdGhlbiAtLSB2IGtleSBmb3IgZG9v
ciB0ZXN0IG1vZGUKICB0ZXN0X2Rvb3JfbW9kZT1ub3QgdGVzdF9kb29yX21vZGUKIGVuZAogCiAt
LSBjeWNsZSB0ZXN0IGRvb3Igb3BlbiB2YWx1ZSAoMC4wIHRvIDEuMCkKIGlmIHRlc3RfZG9vcl9t
b2RlIHRoZW4KICBpZiBidG5wKDYpIHRoZW4gLS0gYyBrZXk6IGluY3JlYXNlCiAgIHRlc3RfZG9v
cl9vcGVuPSh0ZXN0X2Rvb3Jfb3BlbiBvciAwKSswLjEKICAgaWYgdGVzdF9kb29yX29wZW4_MSB0
aGVuIHRlc3RfZG9vcl9vcGVuPTAgZW5kCiAgZW5kCiAgaWYgYnRucCg3KSB0aGVuIC0tIGQga2V5
OiBkZWNyZWFzZQogICB0ZXN0X2Rvb3Jfb3Blbj0odGVzdF9kb29yX29wZW4gb3IgMCktMC4xCiAg
IGlmIHRlc3RfZG9vcl9vcGVuPDAgdGhlbiB0ZXN0X2Rvb3Jfb3Blbj0xIGVuZAogIGVuZAogZW5k
CiAKIC0tIGN5Y2xlIGZsb29yIHR5cGUgKGZvciB0ZXN0aW5nKSB3aGVuIG5vdCBpbiBkb29yIHRl
c3QgbW9kZQogaWYgbm90IHRlc3RfZG9vcl9tb2RlIGFuZCBidG5wKDYpIHRoZW4gLS0gYyBrZXkK
ICBsb2NhbCBjdXJyZW50X2lkeD0xCiAgZm9yIGk9MSwjcGxhbmV0eXBzIGRvCiAgIGlmIHBsYW5l
dHlwc1tpXS50ZXg9PWZsb29yLnR5cC50ZXggdGhlbgogICAgY3VycmVudF9pZHg9aQogICAgYnJl
YWsKICAgZW5kCiAgZW5kCiAgZmxvb3IudHlwPXBsYW5ldHlwc1soY3VycmVudF9pZHggJSAjcGxh
bmV0eXBzKSsxXQogIGZsb29yLngsZmxvb3IueT0wLDAKIGVuZAogCiAtLSBjeWNsZSByb29mIHR5
cGUgKGZvciB0ZXN0aW5nKSB3aGVuIG5vdCBpbiBkb29yIHRlc3QgbW9kZQogaWYgbm90IHRlc3Rf
ZG9vcl9tb2RlIGFuZCBidG5wKDcpIHRoZW4gLS0gZCBrZXkKICBsb2NhbCBjdXJyZW50X2lkeD0x
CiAgZm9yIGk9MSwjcGxhbmV0eXBzIGRvCiAgIGlmIHBsYW5ldHlwc1tpXS50ZXg9PXJvb2YudHlw
LnRleCB0aGVuCiAgICBjdXJyZW50X2lkeD1pCiAgICBicmVhawogICBlbmQKICBlbmQKICByb29m
LnR5cD1wbGFuZXR5cHNbKGN1cnJlbnRfaWR4ICUgI3BsYW5ldHlwcykrMV0KICByb29mLngscm9v
Zi55PTAsMAogZW5kCiAKIC0tIGRlYnVnIHJheSBjYXN0aW5nCiAgaWYgZGVidWdfbW9kZSB0aGVu
CiAgIGxvY2FsIHNhLGNhPXNpbihwbGF5ZXIuYSksY29zKHBsYXllci5hKQogICBsb2NhbCB6LGh4
LGh5LHRpbGUsdHg9cmF5Y2FzdChwbGF5ZXIueCxwbGF5ZXIueSxjYSxzYSxzYSxjYSkKICAgcHJp
bnRoKCJkZWJ1Zzogej0iLi4oZmxyKHoqMTAwKS8xMDApLi4iIGh4PSIuLihmbHIoaHgqMTAwKS8x
MDApLi4iIGh5PSIuLihmbHIoaHkqMTAwKS8xMDApLi4iIHRpbGU9Ii4udGlsZS4uIiB0eD0iLi4o
ZmxyKHR4KjEwMCkvMTAwKSkKICAgbG9jYWwgb2IsZGlzdD1oaXRzY2FuKHBsYXllci54LHBsYXll
ci55LGNhLHNhKQogICBpZiBvYiB0aGVuCiAgICBwcmludGgoImRlYnVnOiBvYmogZm91bmQgYXQg
ZGlzdD0iLi4oZmxyKGRpc3QqMTAwKS8xMDApLi4iIGtpbmQ9Ii4uKG9iLmtpbmQgb3IgInVua25v
d24iKSkKICAgZWxzZQogICAgcHJpbnRoKCJkZWJ1Zzogbm8gb2JqIGhpdCIpCiAgIGVuZAogIGVu
ZAplbmQKCmZ1bmN0aW9uIF9kcmF3KCkKIGNsaXAoMCwwLHNjcmVlbl93aWR0aCxzY3JlZW5faGVp
Z2h0KQogY2xzKDApCiAKIGlmIHZpZXdfbW9kZT09IjNkIiB0aGVuCiAgcmF5Y2FzdF9zY2VuZSgp
CiAgcmVuZGVyX2Zsb29yX2NlaWxpbmcoKQogIHJlbmRlcl93YWxscygpCiAgcmVuZGVyX3Nwcml0
ZXMoKQogIAogIC0tIGh1ZAogIHByaW50KCJwb3M6Ii4uZmxyKHBsYXllci54KS4uIiwiLi5mbHIo
cGxheWVyLnkpLDIsMiw3KQogIHByaW50KCJhbmc6Ii4uZmxyKHBsYXllci5hKjEwMCkvMTAwLDIs
MTAsNykKICBwcmludCgiZnBzOiIuLnN0YXQoNyksMiwxOCw3KQogIHByaW50KCJocDoiLi5wbGF5
ZXIuaHAsMiwyNiw3KQogIHByaW50KCJbeF0gdG9nZ2xlIG1hcCIsMiwzNCw3KQogIAogIC0tIGlu
dGVyYWN0aW9uIHByb21wdAogIGlmIGludGVyYWN0aW9uX2FjdGl2ZSBhbmQgY3VycmVudF9pbnRl
cmFjdCB0aGVuCiAgIHByaW50KCJbRV0vWjogaW50ZXJhY3QiLHNjcmVlbl9jZW50ZXJfeC00MCxz
Y3JlZW5faGVpZ2h0LTIwLDExKQogIGVuZAogIAogIC0tIHRyYXAgbWVzc2FnZQogIGlmIHRyYXBf
bXNnX3RpbWVyPjAgdGhlbgogICBwcmludCgidHJhcCBzcHJ1bmchIixzY3JlZW5fY2VudGVyX3gt
MzAsc2NyZWVuX2NlbnRlcl95LDgpCiAgZW5kCiAgCiAgLS0gZGVidWcgb3ZlcmxheQogIGlmIGRl
YnVnX21vZGUgdGhlbgogICBsb2NhbCBzYSxjYT1zaW4ocGxheWVyLmEpLGNvcyhwbGF5ZXIuYSkK
ICAgbG9jYWwgeixoeCxoeSx0aWxlLHR4PXJheWNhc3QocGxheWVyLngscGxheWVyLnksY2Esc2Es
c2EsY2EpCiAgIHByaW50KCJkZWJ1ZyBvbiBbdGFiXSIsMiw0MiwxMSkKICAgcHJpbnQoIno9Ii4u
ZmxyKHoqMTAwKS8xMDAsMiw1MCw3KQogICBwcmludCgidGlsZT0iLi50aWxlLDIsNTgsNykKICAg
cHJpbnQoInR4PSIuLmZscih0eCoxMDApLzEwMCwyLDY2LDcpCiAgIHByaW50KCJmbG9vcjogIi4u
Zmxvb3IudHlwLnRleCwyLDc0LDcpCiAgIHByaW50KCJyb29mOiAiLi5yb29mLnR5cC50ZXgsMiw4
Miw3KQogIGVuZAogZWxzZQogIGRyYXdfbWluaW1hcCgpCiBlbmQKIAogLS0gY29tYmF0IG92ZXJs
YXkKIGlmIGluX2NvbWJhdCB0aGVuCiAgcmVjdGZpbGwoMCxzY3JlZW5faGVpZ2h0LTQwLHNjcmVl
bl93aWR0aCxzY3JlZW5faGVpZ2h0LDApCiAgcHJpbnQoImVudGVyaW5nIGNvbWJhdC4uLiIsc2Ny
ZWVuX2NlbnRlcl94LTQwLHNjcmVlbl9jZW50ZXJfeSw4KQogIHByaW50KCJbZXNjXSBleGl0ICh0
ZW1wKSIsc2NyZWVuX2NlbnRlcl94LTQwLHNjcmVlbl9jZW50ZXJfeSsxMCw3KQogZW5kCmVuZAoK
LS0gZHJhdyAyZCBtaW5pbWFwIGZvciB0ZXN0aW5nCi0tIFB1cnBvc2U6IFJlbmRlciAyRCB0b3At
ZG93biBkZWJ1ZyB2aWV3IG9mIGR1bmdlb24KLS0gQWxnb3JpdGhtOiBTY2FsZSAxMjjDlzEyOCBt
YXAgdG8gMjU2w5cyNTYgcGl4ZWxzIChzY2FsZT0yKQotLSBEaXNwbGF5czogV2FsbHMsIHJvb21z
LCBkb29ycywgb2JqZWN0cywgcGxheWVyIHBvc2l0aW9uIGFuZCBmYWNpbmcKLS0gTm90ZXM6IFRv
Z2dsZWQgd2l0aCBYIGJ1dHRvbiwgdXNlZnVsIGZvciBkZWJ1Z2dpbmcgZ2VuZXJhdGlvbgpmdW5j
dGlvbiBkcmF3X21pbmltYXAoKQogbG9jYWwgc2NhbGU9MgogbG9jYWwgb3gsb3k9MTAsMTAKIAog
LS0gZHJhdyB3YWxsZ3JpZAogZm9yIHg9MCwxMjcgZG8KICBmb3IgeT0wLDEyNyBkbwogICBpZiB3
YWxsZ3JpZFt4XVt5XT4wIHRoZW4KICAgIHJlY3RmaWxsKG94K3gqc2NhbGUsb3kreSpzY2FsZSxv
eCt4KnNjYWxlK3NjYWxlLTEsb3kreSpzY2FsZStzY2FsZS0xLDUpCiAgIGVsc2UKICAgIHJlY3Rm
aWxsKG94K3gqc2NhbGUsb3kreSpzY2FsZSxveCt4KnNjYWxlK3NjYWxlLTEsb3kreSpzY2FsZStz
Y2FsZS0xLDEpCiAgIGVuZAogIGVuZAogZW5kCiAKIC0tIGRyYXcgcm9vbXMKIGZvciBub2RlIGlu
IGFsbChnZW5fbm9kZXMpIGRvCiAgbG9jYWwgcj1ub2RlLnJlY3QKICByZWN0KG94K3JbMV0qc2Nh
bGUsb3krclsyXSpzY2FsZSxveCtyWzNdKnNjYWxlLG95K3JbNF0qc2NhbGUsMTEpCiBlbmQKIAog
LS0gZHJhdyBkb29ycwogZm9yIGRvb3IgaW4gYWxsKGRvb3JzKSBkbwogIGxvY2FsIGM9ZG9vci5k
dHlwZT09ZG9vcl9sb2NrZWQgYW5kIDggb3IgMTIKICByZWN0ZmlsbChveCtkb29yLngqc2NhbGUs
b3krZG9vci55KnNjYWxlLG94K2Rvb3IueCpzY2FsZStzY2FsZS0xLG95K2Rvb3IueSpzY2FsZStz
Y2FsZS0xLGMpCiBlbmQKIAogLS0gZHJhdyBvYmplY3RzCiBmb3Igb2IgaW4gYWxsKG9iamVjdHMp
IGRvCiAgbG9jYWwgYz03CiAgaWYgb2IudHlwIGFuZCBvYi50eXAua2luZD09Imhvc3RpbGVfbnBj
IiB0aGVuIGM9OAogIGVsc2VpZiBvYi50eXAgYW5kIG9iLnR5cC5raW5kPT0iZGlyZWN0X3BpY2t1
cCIgdGhlbgogICBpZiBvYi50eXAuc3VidHlwZT09ImhlYXJ0IiB0aGVuIGM9MTQKICAgZWxzZWlm
IG9iLnR5cC5zdWJ0eXBlPT0ia2V5IiB0aGVuIGM9OQogICBlbmQKICBlbHNlaWYgb2IudHlwIGFu
ZCBvYi50eXAua2luZD09ImludGVyYWN0YWJsZSIgdGhlbgogICBpZiBvYi50eXAuc3VidHlwZT09
ImV4aXQiIHRoZW4gYz0xMiBlbmQKICBlbHNlaWYgb2IudHlwIGFuZCBvYi50eXAua2luZD09ImRl
Y29yYXRpdmUiIHRoZW4gYz0xMwogIGVuZAogIGxvY2FsIHg9b2IucG9zWzFdCiAgbG9jYWwgeT1v
Yi5wb3NbMl0KICBjaXJjZmlsbChveCt4KnNjYWxlLG95K3kqc2NhbGUsMSxjKQogZW5kCiAKIC0t
IGRyYXcgcGxheWVyCiBsb2NhbCBweCxweT1veCtwbGF5ZXIueCpzY2FsZSxveStwbGF5ZXIueSpz
Y2FsZQogY2lyY2ZpbGwocHgscHksMiwxMCkKIGxvY2FsIHNhLGNhPXNpbihwbGF5ZXIuYSksY29z
KHBsYXllci5hKQogbGluZShweCxweSxweCtjYSo2LHB5K3NhKjYsMTApCiAKIC0tIHN0YXRzCiBw
cmludCgiMmQgbWFwIHZpZXciLDEwLDIsNykKIHByaW50KCJyb29tczogIi4uZ2VuX3N0YXRzLnJv
b21zLDEwLDEwLDcpCiBwcmludCgib2JqZWN0czogIi4uZ2VuX3N0YXRzLm9iamVjdHMsMTAsMTgs
NykKIHByaW50KCJzZWVkOiAiLi5nZW5fc3RhdHMuc2VlZCwxMCwyNiw3KQogcHJpbnQoIlt4XSB0
b2dnbGUgM2QiLDEwLDM0LDcpCmVuZAoKLS0gdW5pZmllZCBjb2xsaXNpb24gY2hlY2sgZm9yIHdh
bGxzLCBkb29ycywgYW5kIG9iamVjdHMKLS0gUHVycG9zZTogVW5pZmllZCBjb2xsaXNpb24gZGV0
ZWN0aW9uIGZvciB3YWxscywgZG9vcnMsIGFuZCBvYmplY3RzCi0tIFBhcmFtZXRlcnM6IHB4LCBw
eSAod29ybGQgcG9zaXRpb24pLCByYWRpdXMgKGNvbGxpc2lvbiByYWRpdXMpLCBvcGVuZG9vcnMg
KGF1dG8tb3BlbiBkb29ycyksIGlzcGxheWVyIChlbmFibGUga2V5IGNoZWNraW5nKQotLSBSZXR1
cm5zOiBib29sZWFuICh0cnVlIGlmIGNvbGxpc2lvbiBkZXRlY3RlZCkKLS0gQWxnb3JpdGhtOiBH
cmlkLWJhc2VkIHdhbGwgY2hlY2sgKyBzcGF0aWFsIHBhcnRpdGlvbmluZyBmb3Igb2JqZWN0cwot
LSBTaWRlIGVmZmVjdHM6IE9wZW5zIGRvb3JzLCBwcmV2ZW50cyBkb29yIGNsb3Npbmcgd2hlbiBw
bGF5ZXIgaW5zaWRlCmZ1bmN0aW9uIGlzY29sKHB4LHB5LHJhZGl1cyxvcGVuZG9vcnMsaXNwbGF5
ZXIpCiBsb2NhbCBjb2w9ZmFsc2UKIG9wZW5kb29ycz1vcGVuZG9vcnMgb3IgZmFsc2UKIGlzcGxh
eWVyPWlzcGxheWVyIG9yIGZhbHNlCiAKIC0tIGNoZWNrIGdyaWQgY2VsbHMgYXJvdW5kIHBvc2l0
aW9uCiBmb3IgeD1mbHIocHgtcmFkaXVzKSxmbHIocHgrcmFkaXVzKSBkbwogIGZvciB5PWZscihw
eS1yYWRpdXMpLGZscihweStyYWRpdXMpIGRvCiAgIC0tIGJvdW5kcyBjaGVjawogICBpZiB4PDAg
b3IgeD49MTI4IG9yIHk8MCBvciB5Pj0xMjggdGhlbgogICAgY29sPXRydWUKICAgZWxzZQogICAg
bG9jYWwgdGlsZT1nZXRfd2FsbCh4LHkpCiAgICAKICAgIC0tIGNoZWNrIGlmIGRvb3IgdGlsZQog
ICAgaWYgdGlsZT09ZG9vcl9ub3JtYWwgb3IgdGlsZT09ZG9vcl9sb2NrZWQgb3IgdGlsZT09ZG9v
cl9zdGF5X29wZW4gdGhlbgogICAgIGxvY2FsIGRvb3I9ZG9vcmdyaWRbeF1beV0KICAgICBpZiBk
b29yIHRoZW4KICAgICAgaWYgZG9vci5vcGVuPT0xIHRoZW4KICAgICAgIC0tIGZ1bGx5IG9wZW46
IHByZXZlbnQgY2xvc2luZwogICAgICAgZG9vci5vcGVuaW5nPXRydWUKICAgICAgZWxzZQogICAg
ICAgLS0gZG9vciBwYXJ0aWFsbHkgb3BlbiBvciBjbG9zZWQ6IGNvbGxpc2lvbiBkZXRlY3RlZAog
ICAgICAgY29sPXRydWUKICAgICAgIGlmIG9wZW5kb29ycyB0aGVuCiAgICAgICAgaWYgZG9vci5r
ZXludW0gdGhlbgogICAgICAgICAtLSBjaGVjayBpbnZlbnRvcnkgZm9yIGtleQogICAgICAgICBp
ZiBpc3BsYXllciB0aGVuCiAgICAgICAgICBmb3IgaSxpdGVtIGluIGlwYWlycyhwbGF5ZXIua2V5
cykgZG8KICAgICAgICAgICBpZiBpdGVtLmtleW51bT09ZG9vci5rZXludW0gdGhlbgogICAgICAg
ICAgICAtLSByZW1vdmUga2V5CiAgICAgICAgICAgIGRlbGkocGxheWVyLmtleXMsaSkKICAgICAg
ICAgICAgZG9vci5rZXludW09bmlsCiAgICAgICAgICAgIGRvb3Iub3BlbmluZz10cnVlCiAgICAg
ICAgICAgIC0tIGtlZXAgY29sPXRydWUsIGRvbid0IGNsZWFyIGltbWVkaWF0ZWx5CiAgICAgICAg
ICAgIGJyZWFrCiAgICAgICAgICAgZW5kCiAgICAgICAgICBlbmQKICAgICAgICAgZW5kCiAgICAg
ICAgZWxzZQogICAgICAgICAtLSB1bmxvY2tlZAogICAgICAgICBkb29yLm9wZW5pbmc9dHJ1ZQog
ICAgICAgICAtLSBrZWVwIGNvbD10cnVlLCBkb24ndCBjbGVhciBpbW1lZGlhdGVseQogICAgICAg
IGVuZAogICAgICAgZW5kCiAgICAgIGVuZAogICAgIGVuZAogICAgLS0gY2hlY2sgaWYgZXhpdCBw
b3J0YWwKICAgIGVsc2VpZiAodGlsZT09ZXhpdF9zdGFydCBvciB0aWxlPT1leGl0X2VuZCkgYW5k
IGlzcGxheWVyIHRoZW4KICAgICAtLSBwbGFjZWhvbGRlciBmb3IgbGV2ZWwgY29tcGxldGlvbgog
ICAgLS0gY2hlY2sgaWYgd2FsbAogICAgZWxzZWlmIHRpbGU_MCB0aGVuCiAgICAgY29sPXRydWUK
ICAgIGVuZAogICBlbmQKICBlbmQKIGVuZAogCiAtLSBjaGVjayBzb2xpZCBvYmplY3RzIGFyb3Vu
ZCBwb3NpdGlvbiB1c2luZyBvYmpncmlkIHNwYXRpYWwgcXVlcnkKIGxvY2FsIGd4X21pbj1mbHIo
KHB4LXJhZGl1cykvb2JqZ3JpZF9zaXplKQogbG9jYWwgZ3hfbWF4PWZscigocHgrcmFkaXVzKS9v
YmpncmlkX3NpemUpCiBsb2NhbCBneV9taW49ZmxyKChweS1yYWRpdXMpL29iamdyaWRfc2l6ZSkK
IGxvY2FsIGd5X21heD1mbHIoKHB5K3JhZGl1cykvb2JqZ3JpZF9zaXplKQogCiBneF9taW49bWF4
KDAsZ3hfbWluKQogZ3hfbWF4PW1pbihvYmpncmlkX2FycmF5X3NpemUsZ3hfbWF4KQogZ3lfbWlu
PW1heCgwLGd5X21pbikKIGd5X21heD1taW4ob2JqZ3JpZF9hcnJheV9zaXplLGd5X21heCkKIAog
Zm9yIGd4PWd4X21pbixneF9tYXggZG8KICBmb3IgZ3k9Z3lfbWluLGd5X21heCBkbwogICBmb3Ig
b2IgaW4gYWxsKG9iamdyaWRbZ3grMV1bZ3krMV0pIGRvCiAgICBpZiBvYi50eXAgYW5kIG9iLnR5
cC5zb2xpZCB0aGVuCiAgICAgbG9jYWwgb3g9b2IucG9zWzFdLXB4CiAgICAgbG9jYWwgb3k9b2Iu
cG9zWzJdLXB5CiAgICAgaWYgbWF4KGFicyhveCksYWJzKG95KSk8b2IudHlwLncgdGhlbgogICAg
ICBjb2w9dHJ1ZQogICAgICAtLSB0cmlnZ2VyIGludGVyYWN0aW9uIG9uIHNvbGlkIGNvbnRhY3Qg
aWYgcGxheWVyCiAgICAgIGlmIGlzcGxheWVyIHRoZW4KICAgICAgIGNoZWNrX2ludGVyYWN0aW9u
c19hdChweCxweSkKICAgICAgZW5kCiAgICAgIGJyZWFrCiAgICAgZW5kCiAgICBlbmQKICAgZW5k
CiAgIGlmIGNvbCB0aGVuIGJyZWFrIGVuZAogIGVuZAogIGlmIGNvbCB0aGVuIGJyZWFrIGVuZAog
ZW5kCiAKIC0tIHByZXZlbnQgZG9vcnMgZnJvbSBjbG9zaW5nIHdoZW4gcGxheWVyIGlzIGluc2lk
ZQogaWYgaXNwbGF5ZXIgdGhlbgogIGZvciB4PWZscihweC1yYWRpdXMpLGZscihweCtyYWRpdXMp
IGRvCiAgIGZvciB5PWZscihweS1yYWRpdXMpLGZscihweStyYWRpdXMpIGRvCiAgICBpZiB4Pj0w
IGFuZCB4PDEyOCBhbmQgeT49MCBhbmQgeTwxMjggdGhlbgogICAgIGxvY2FsIHRpbGU9Z2V0X3dh
bGwoeCx5KQogICAgIGlmIHRpbGU9PWRvb3Jfbm9ybWFsIG9yIHRpbGU9PWRvb3JfbG9ja2VkIG9y
IHRpbGU9PWRvb3Jfc3RheV9vcGVuIHRoZW4KICAgICAgbG9jYWwgZG9vcj1kb29yZ3JpZFt4XVt5
XQogICAgICBpZiBkb29yIGFuZCBkb29yLm9wZW4_MCB0aGVuCiAgICAgICBkb29yLm9wZW5pbmc9
dHJ1ZQogICAgICBlbmQKICAgICBlbmQKICAgIGVuZAogICBlbmQKICBlbmQKIGVuZAogCiByZXR1
cm4gY29sCmVuZAoKLS0gbW92ZW1lbnQgd3JhcHBlciB3aXRoIHNsaWRpbmcgY29sbGlzaW9uCi0t
IFB1cnBvc2U6IE1vdmVtZW50IHdpdGggc2xpZGluZyBjb2xsaXNpb24gKHRyeSBkaWFnb25hbCwg
dGhlbiBYLCB0aGVuIFkpCi0tIFBhcmFtZXRlcnM6IHBvcyAodGFibGUgd2l0aCB4LHkpLCB0YXJn
ZXRfeCwgdGFyZ2V0X3ksIHJhZGl1cywgb3BlbmRvb3JzLCBpc3BsYXllcgotLSBSZXR1cm5zOiBi
b29sZWFuICh0cnVlIGlmIGFueSBtb3ZlbWVudCBzdWNjZWVkZWQpCi0tIEFsZ29yaXRobTogVGhy
ZWUtcGhhc2UgY29sbGlzaW9uIGNoZWNrIGZvciBzbW9vdGggd2FsbCBzbGlkaW5nCmZ1bmN0aW9u
IHRyeW1vdmV0byhwb3MsdGFyZ2V0X3gsdGFyZ2V0X3kscmFkaXVzLG9wZW5kb29ycyxpc3BsYXll
cikKIHJhZGl1cz1yYWRpdXMgb3IgcGxheWVyX2NvbGxpc2lvbl9yYWRpdXMKIG9wZW5kb29ycz1v
cGVuZG9vcnMgb3IgZmFsc2UKIGlzcGxheWVyPWlzcGxheWVyIG9yIGZhbHNlCiAKIC0tIHRyeSBk
aXJlY3QgbW92ZW1lbnQKIGlmIG5vdCByYWRpdXMgb3Igbm90IGlzY29sKHRhcmdldF94LHRhcmdl
dF95LHJhZGl1cyxvcGVuZG9vcnMsaXNwbGF5ZXIpIHRoZW4KICBwb3MueCxwb3MueT10YXJnZXRf
eCx0YXJnZXRfeQogIHJldHVybiB0cnVlCiBlbmQKIAogLS0gdHJ5IHgtb25seSBtb3ZlbWVudAog
aWYgYWJzKHBvcy54LXRhcmdldF94KT4wLjAxIGFuZCBub3QgaXNjb2wodGFyZ2V0X3gscG9zLnks
cmFkaXVzLG9wZW5kb29ycyxpc3BsYXllcikgdGhlbgogIHBvcy54PXRhcmdldF94CiAgcmV0dXJu
IHRydWUKIGVuZAogCiAtLSB0cnkgeS1vbmx5IG1vdmVtZW50CiBpZiBhYnMocG9zLnktdGFyZ2V0
X3kpPjAuMDEgYW5kIG5vdCBpc2NvbChwb3MueCx0YXJnZXRfeSxyYWRpdXMsb3BlbmRvb3JzLGlz
cGxheWVyKSB0aGVuCiAgcG9zLnk9dGFyZ2V0X3kKICByZXR1cm4gdHJ1ZQogZW5kCiAKIHJldHVy
biBmYWxzZQplbmQKCi0tIG1vdmVtZW50IHdyYXBwZXIgZm9yIHBvc1sxXS9wb3NbMl0gYXJyYXkg
cG9zaXRpb25zCmZ1bmN0aW9uIHRyeW1vdmV0b19wb3MocG9zX2FycmF5LHRhcmdldF94LHRhcmdl
dF95LHJhZGl1cyxvcGVuZG9vcnMsaXNwbGF5ZXIpCiByYWRpdXM9cmFkaXVzIG9yIHBsYXllcl9j
b2xsaXNpb25fcmFkaXVzCiBvcGVuZG9vcnM9b3BlbmRvb3JzIG9yIGZhbHNlCiBpc3BsYXllcj1p
c3BsYXllciBvciBmYWxzZQogCiAtLSB0cnkgZGlyZWN0IG1vdmVtZW50CiBpZiBub3QgcmFkaXVz
IG9yIG5vdCBpc2NvbCh0YXJnZXRfeCx0YXJnZXRfeSxyYWRpdXMsb3BlbmRvb3JzLGlzcGxheWVy
KSB0aGVuCiAgcG9zX2FycmF5WzFdLHBvc19hcnJheVsyXT10YXJnZXRfeCx0YXJnZXRfeQogIHJl
dHVybiB0cnVlCiBlbmQKIAogLS0gdHJ5IHgtb25seSBtb3ZlbWVudAogaWYgYWJzKHBvc19hcnJh
eVsxXS10YXJnZXRfeCk_MC4wMSBhbmQgbm90IGlzY29sKHRhcmdldF94LHBvc19hcnJheVsyXSxy
YWRpdXMsb3BlbmRvb3JzLGlzcGxheWVyKSB0aGVuCiAgcG9zX2FycmF5WzFdPXRhcmdldF94CiAg
cmV0dXJuIHRydWUKIGVuZAogCiAtLSB0cnkgeS1vbmx5IG1vdmVtZW50CiBpZiBhYnMocG9zX2Fy
cmF5WzJdLXRhcmdldF95KT4wLjAxIGFuZCBub3QgaXNjb2wocG9zX2FycmF5WzFdLHRhcmdldF95
LHJhZGl1cyxvcGVuZG9vcnMsaXNwbGF5ZXIpIHRoZW4KICBwb3NfYXJyYXlbMl09dGFyZ2V0X3kK
ICByZXR1cm4gdHJ1ZQogZW5kCiAKIHJldHVybiBmYWxzZQplbmQKCmZ1bmN0aW9uIHVwZGF0ZV9p
bnB1dCgpCiBsb2NhbCBzYSxjYT1zaW4ocGxheWVyLmEpLGNvcyhwbGF5ZXIuYSkKIAogLS0gbW92
ZW1lbnQKIGlmIGJ0bigwKSB0aGVuIC0tIGxlZnQKICBwbGF5ZXIuYS09cGxheWVyX3JvdGF0aW9u
X3NwZWVkCiBlbmQKIGlmIGJ0bigxKSB0aGVuIC0tIHJpZ2h0CiAgcGxheWVyLmErPXBsYXllcl9y
b3RhdGlvbl9zcGVlZAogZW5kCiBpZiBidG4oMikgdGhlbiAtLSB1cAogIGxvY2FsIG54PXBsYXll
ci54K2NhKnBsYXllci5zcGQKICBsb2NhbCBueT1wbGF5ZXIueStzYSpwbGF5ZXIuc3BkCiAgdHJ5
bW92ZXRvKHBsYXllcixueCxueSxwbGF5ZXJfY29sbGlzaW9uX3JhZGl1cyx0cnVlLHRydWUpCiBl
bmQKIGlmIGJ0bigzKSB0aGVuIC0tIGRvd24KICBsb2NhbCBueD1wbGF5ZXIueC1jYSpwbGF5ZXIu
c3BkCiAgbG9jYWwgbnk9cGxheWVyLnktc2EqcGxheWVyLnNwZAogIHRyeW1vdmV0byhwbGF5ZXIs
bngsbnkscGxheWVyX2NvbGxpc2lvbl9yYWRpdXMsdHJ1ZSx0cnVlKQogZW5kCiAKIC0tIGNoZWNr
IGZvciBpbnRlcmFjdGlvbnMgZXZlcnkgZnJhbWUKIGNoZWNrX2ludGVyYWN0aW9ucygpCiAKIC0t
IGludGVyYWN0aW9uIGlucHV0OiBFIGtleSBvciBaIGJ1dHRvbgogaWYga2V5cCgiZSIpIG9yIGJ0
bnAoNCkgdGhlbgogIGhhbmRsZV9pbnRlcmFjdCgpCiBlbmQKZW5kCgotLSBhZGQgb2JqZWN0IHRv
IG9iamdyaWQKLS0gUHVycG9zZTogQWRkIG9iamVjdCB0byBzcGF0aWFsIHBhcnRpdGlvbmluZyBn
cmlkCi0tIFBhcmFtZXRlcnM6IG9iIChvYmplY3Qgd2l0aCBwb3MgYXJyYXkpCi0tIFNpZGUgZWZm
ZWN0czogQWRkcyB0byBvYmpncmlkIGNlbGwgYmFzZWQgb24gcG9zaXRpb24sIGFkZHMgdG8gYW5p
bWF0ZWRfb2JqZWN0cyBpZiBhdXRvYW5pbT10cnVlCi0tIE5vdGVzOiBVc2VkIGR1cmluZyBkdW5n
ZW9uIGdlbmVyYXRpb24gYW5kIG9iamVjdCBzcGF3bmluZwpmdW5jdGlvbiBhZGRvYmplY3Qob2Ip
CiBpZiBub3Qgb2IucG9zIHRoZW4gcmV0dXJuIGVuZAogbG9jYWwgZ3g9ZmxyKG9iLnBvc1sxXS9v
YmpncmlkX3NpemUpCiBsb2NhbCBneT1mbHIob2IucG9zWzJdL29iamdyaWRfc2l6ZSkKIGlmIGd4
Pj0wIGFuZCBneDw9b2JqZ3JpZF9hcnJheV9zaXplIGFuZCBneT49MCBhbmQgZ3k8PW9iamdyaWRf
YXJyYXlfc2l6ZSB0aGVuCiAgYWRkKG9iamdyaWRbZ3grMV1bZ3krMV0sb2IpCiAgLS0gYWRkIHRv
IGFuaW1hdGVkIGxpc3QgaWYgYXV0b2FuaW0gaXMgdHJ1ZQogIGlmIG9iLmF1dG9hbmltIHRoZW4K
ICAgYWRkKGFuaW1hdGVkX29iamVjdHMsb2IpCiAgZW5kCiBlbmQKZW5kCgotLSByZW1vdmUgb2Jq
ZWN0IGZyb20gb2JqZ3JpZApmdW5jdGlvbiByZW1vdmVvYmplY3Qob2IpCiBpZiBub3Qgb2IucG9z
IHRoZW4gcmV0dXJuIGVuZAogbG9jYWwgZ3g9ZmxyKG9iLnBvc1sxXS9vYmpncmlkX3NpemUpCiBs
b2NhbCBneT1mbHIob2IucG9zWzJdL29iamdyaWRfc2l6ZSkKIGlmIGd4Pj0wIGFuZCBneDw9b2Jq
Z3JpZF9hcnJheV9zaXplIGFuZCBneT49MCBhbmQgZ3k8PW9iamdyaWRfYXJyYXlfc2l6ZSB0aGVu
CiAgZGVsaShvYmpncmlkW2d4KzFdW2d5KzFdLG9iKQogIC0tIGFsc28gcmVtb3ZlIGZyb20gYW5p
bWF0ZWQgbGlzdAogIGlmIG9iLmF1dG9hbmltIHRoZW4KICAgZGVsaShhbmltYXRlZF9vYmplY3Rz
LG9iKQogIGVuZAogZW5kCmVuZAoKLS0gdXBkYXRlIG9iamVjdCBncmlkIGFmdGVyIHBvc2l0aW9u
IGNoYW5nZQpmdW5jdGlvbiB1cGRhdGVfb2JqZWN0X2dyaWQob2Isb2xkX3gsb2xkX3kpCiBpZiBu
b3Qgb2IucG9zIHRoZW4gcmV0dXJuIGVuZAogbG9jYWwgb2xkX2d4PWZscihvbGRfeC9vYmpncmlk
X3NpemUpCiBsb2NhbCBvbGRfZ3k9ZmxyKG9sZF95L29iamdyaWRfc2l6ZSkKIGxvY2FsIG5ld19n
eD1mbHIob2IucG9zWzFdL29iamdyaWRfc2l6ZSkKIGxvY2FsIG5ld19neT1mbHIob2IucG9zWzJd
L29iamdyaWRfc2l6ZSkKIGlmIG9sZF9neH49bmV3X2d4IG9yIG9sZF9neX49bmV3X2d5IHRoZW4K
ICBpZiBvbGRfZ3g_PTAgYW5kIG9sZF9neDw9b2JqZ3JpZF9hcnJheV9zaXplIGFuZCBvbGRfZ3k_
PTAgYW5kIG9sZF9neTw9b2JqZ3JpZF9hcnJheV9zaXplIHRoZW4KICAgZGVsaShvYmpncmlkW29s
ZF9neCsxXVtvbGRfZ3krMV0sb2IpCiAgZW5kCiAgaWYgbmV3X2d4Pj0wIGFuZCBuZXdfZ3g8PW9i
amdyaWRfYXJyYXlfc2l6ZSBhbmQgbmV3X2d5Pj0wIGFuZCBuZXdfZ3k8PW9iamdyaWRfYXJyYXlf
c2l6ZSB0aGVuCiAgIGFkZChvYmpncmlkW25ld19neCsxXVtuZXdfZ3krMV0sb2IpCiAgZW5kCiBl
bmQKZW5kCgotLSBjaGVjayBpbnRlcmFjdGlvbnMgYXJvdW5kIHBsYXllciBwb3NpdGlvbgotLSBQ
dXJwb3NlOiBTY2FuIG5lYXJieSBvYmplY3RzIGZvciBwcm94aW1pdHktYmFzZWQgaW50ZXJhY3Rp
b25zCi0tIEFsZ29yaXRobTogM8OXMyBvYmpncmlkIGNlbGwgc2NhbiBhcm91bmQgcGxheWVyCi0t
IFNpZGUgZWZmZWN0czogQXV0by1jb2xsZWN0cyBwaWNrdXBzLCB0cmlnZ2VycyBjb21iYXQsIHNl
dHMgaW50ZXJhY3Rpb24gZmxhZ3MKLS0gTm90ZXM6IENhbGxlZCBldmVyeSBmcmFtZSBpbiBfdXBk
YXRlKCkKZnVuY3Rpb24gY2hlY2tfaW50ZXJhY3Rpb25zKCkKIGNoZWNrX2ludGVyYWN0aW9uc19h
dChwbGF5ZXIueCxwbGF5ZXIueSkKZW5kCgotLSBjaGVjayBpbnRlcmFjdGlvbnMgYXQgc3BlY2lm
aWMgcG9zaXRpb24gKGF2b2lkcyByZWN1cnNpb24pCmZ1bmN0aW9uIGNoZWNrX2ludGVyYWN0aW9u
c19hdChweCxweSkKIGxvY2FsIGd4X2NlbnRlcj1mbHIocHgvb2JqZ3JpZF9zaXplKQogbG9jYWwg
Z3lfY2VudGVyPWZscihweS9vYmpncmlkX3NpemUpCiAKIC0tIHNjYW4gM3gzIGJsb2NrIGFyb3Vu
ZCBwbGF5ZXIKIGxvY2FsIGNsb3Nlc3RfaW50ZXJhY3Q9bmlsCiBsb2NhbCBjbG9zZXN0X2Rpc3Q9
OTk5CiAKIGZvciBneD1neF9jZW50ZXItMSxneF9jZW50ZXIrMSBkbwogIGZvciBneT1neV9jZW50
ZXItMSxneV9jZW50ZXIrMSBkbwogICBpZiBneD49MCBhbmQgZ3g8PW9iamdyaWRfYXJyYXlfc2l6
ZSBhbmQgZ3k_PTAgYW5kIGd5PD1vYmpncmlkX2FycmF5X3NpemUgdGhlbgogICAgZm9yIG9iIGlu
IGFsbChvYmpncmlkW2d4KzFdW2d5KzFdKSBkbwogICAgIGlmIG9iLnBvcyBhbmQgb2IudHlwIHRo
ZW4KICAgICAgbG9jYWwgZHg9b2IucG9zWzFdLXB4CiAgICAgIGxvY2FsIGR5PW9iLnBvc1syXS1w
eQogICAgICBsb2NhbCBkaXN0PWFicyhkeCkrYWJzKGR5KQogICAgICAKICAgICAgLS0gZGlyZWN0
IHBpY2t1cDogYXV0by1jb2xsZWN0CiAgICAgIGlmIG9iLnR5cC5raW5kPT0iZGlyZWN0X3BpY2t1
cCIgYW5kIGRpc3Q8aW50ZXJhY3Rpb25fcmFuZ2UgdGhlbgogICAgICAgY29sbGVjdF9pdGVtKG9i
KQogICAgICAgcmVtb3Zlb2JqZWN0KG9iKQogICAgICAgZGVsaShvYmplY3RzLG9iKQogICAgICAK
ICAgICAgLS0gaG9zdGlsZSBucGM6IHRyaWdnZXIgY29tYmF0CiAgICAgIGVsc2VpZiBvYi50eXAu
a2luZD09Imhvc3RpbGVfbnBjIiBhbmQgZGlzdDxjb21iYXRfdHJpZ2dlcl9yYW5nZSB0aGVuCiAg
ICAgICBpbl9jb21iYXQ9dHJ1ZQogICAgICAgY3VycmVudF90YXJnZXQ9b2IKICAgICAgCiAgICAg
IC0tIGludGVyYWN0YWJsZTogc2V0IGZsYWcgZm9yIGNsb3Nlc3QKICAgICAgZWxzZWlmIG9iLnR5
cC5raW5kPT0iaW50ZXJhY3RhYmxlIiBhbmQgZGlzdDxpbnRlcmFjdGlvbl9yYW5nZSB0aGVuCiAg
ICAgICAtLSB0cmFwOiBpbW1lZGlhdGUgZWZmZWN0CiAgICAgICBpZiBvYi50eXAuc3VidHlwZT09
InRyYXAiIHRoZW4KICAgICAgICBwbGF5ZXIuaHA9bWF4KDAscGxheWVyLmhwLTEwKQogICAgICAg
IHRyYXBfbXNnX3RpbWVyPTYwCiAgICAgICAgcmVtb3Zlb2JqZWN0KG9iKQogICAgICAgIGRlbGko
b2JqZWN0cyxvYikKICAgICAgIGVsc2VpZiBkaXN0PGNsb3Nlc3RfZGlzdCB0aGVuCiAgICAgICAg
Y2xvc2VzdF9pbnRlcmFjdD1vYgogICAgICAgIGNsb3Nlc3RfZGlzdD1kaXN0CiAgICAgICBlbmQK
ICAgICAgZW5kCiAgICAgZW5kCiAgICBlbmQKICAgZW5kCiAgZW5kCiBlbmQKIAogLS0gdXBkYXRl
IGludGVyYWN0aW9uIHN0YXRlCiBpZiBjbG9zZXN0X2ludGVyYWN0IHRoZW4KICBpbnRlcmFjdGlv
bl9hY3RpdmU9dHJ1ZQogIGN1cnJlbnRfaW50ZXJhY3Q9Y2xvc2VzdF9pbnRlcmFjdAogZWxzZQog
IGludGVyYWN0aW9uX2FjdGl2ZT1mYWxzZQogIGN1cnJlbnRfaW50ZXJhY3Q9bmlsCiBlbmQKZW5k
CgotLSBjb2xsZWN0IGl0ZW0gKHBpY2t1cCkKLS0gUHVycG9zZTogSGFuZGxlIHBpY2t1cCBjb2xs
ZWN0aW9uIGFuZCBpbnZlbnRvcnkgdXBkYXRlcwotLSBQYXJhbWV0ZXJzOiBvYiAob2JqZWN0IHdp
dGggdHlwLnN1YnR5cGUpCi0tIFNpZGUgZWZmZWN0czogQWRkcyB0byBwbGF5ZXIua2V5cywgaW5j
cmVhc2VzIHBsYXllci5ocAotLSBOb3RlczogQ2FsbGVkIGJ5IGNoZWNrX2ludGVyYWN0aW9uc19h
dCgpIGZvciBkaXJlY3RfcGlja3VwIG9iamVjdHMKZnVuY3Rpb24gY29sbGVjdF9pdGVtKG9iKQog
aWYgb2IudHlwLnN1YnR5cGU9PSJrZXkiIGFuZCBvYi5rZXludW0gdGhlbgogIGFkZChwbGF5ZXIu
a2V5cyx7a2V5bnVtPW9iLmtleW51bX0pCiAgcHJpbnRoKCJjb2xsZWN0ZWQga2V5ICIuLm9iLmtl
eW51bSkKIGVsc2VpZiBvYi50eXAuc3VidHlwZT09ImhlYXJ0IiB0aGVuCiAgcGxheWVyLmhwPW1p
bigxMDAscGxheWVyLmhwKzIwKQogIHByaW50aCgiY29sbGVjdGVkIGhlYXJ0IikKIGVsc2UKICBw
cmludGgoImNvbGxlY3RlZCBpdGVtIikKIGVuZAplbmQKCi0tIGhhbmRsZSBpbnRlcmFjdGlvbiB3
aGVuIHBsYXllciBwcmVzc2VzIEUvWgotLSBQdXJwb3NlOiBQcm9jZXNzIHBsYXllci1pbml0aWF0
ZWQgaW50ZXJhY3Rpb25zIChFIGtleSAvIFogYnV0dG9uKQotLSBBbGdvcml0aG06IFN3aXRjaCBv
biBjdXJyZW50X2ludGVyYWN0LnR5cC5zdWJ0eXBlCi0tIFNpZGUgZWZmZWN0czogT3BlbnMgY2hl
c3RzLCBhY3RpdmF0ZXMgc2hyaW5lcywgcmVhZHMgbm90ZXMsIHRyaWdnZXJzIGZsb29yIHRyYW5z
aXRpb24KLS0gTm90ZXM6IE9ubHkgcnVucyB3aGVuIGludGVyYWN0aW9uX2FjdGl2ZSBmbGFnIGlz
IHRydWUKZnVuY3Rpb24gaGFuZGxlX2ludGVyYWN0KCkKIGlmIG5vdCBpbnRlcmFjdGlvbl9hY3Rp
dmUgb3Igbm90IGN1cnJlbnRfaW50ZXJhY3QgdGhlbiByZXR1cm4gZW5kCiAKIGxvY2FsIHN1YnR5
cGU9Y3VycmVudF9pbnRlcmFjdC50eXAgYW5kIGN1cnJlbnRfaW50ZXJhY3QudHlwLnN1YnR5cGUg
b3IgInVua25vd24iCiAKIGlmIHN1YnR5cGU9PSJjaGVzdCIgdGhlbgogIC0tIG9wZW4gY2hlc3Qg
KHBsYWNlaG9sZGVyKQogIHBsYXllci5ocD1taW4oMTAwLHBsYXllci5ocCsxMCkKICBwcmludGgo
Im9wZW5lZCBjaGVzdCIpCiAgcmVtb3Zlb2JqZWN0KGN1cnJlbnRfaW50ZXJhY3QpCiAgZGVsaShv
YmplY3RzLGN1cnJlbnRfaW50ZXJhY3QpCiAgCiBlbHNlaWYgc3VidHlwZT09InNocmluZSIgdGhl
bgogIC0tIGFjdGl2YXRlIHNocmluZSAocGxhY2Vob2xkZXIpCiAgcGxheWVyLmhwPTEwMAogIHBy
aW50aCgiYWN0aXZhdGVkIHNocmluZSIpCiAgCiBlbHNlaWYgc3VidHlwZT09Im5vdGUiIHRoZW4K
ICAtLSByZWFkIG5vdGUgKHBsYWNlaG9sZGVyKQogIHByaW50aCgicmVhZCBub3RlIikKICByZW1v
dmVvYmplY3QoY3VycmVudF9pbnRlcmFjdCkKICBkZWxpKG9iamVjdHMsY3VycmVudF9pbnRlcmFj
dCkKICAKIGVsc2VpZiBzdWJ0eXBlPT0iZXhpdCIgdGhlbgogIC0tIHRyaWdnZXIgbmV4dCBmbG9v
cgogIHByaW50aCgidXNpbmcgZXhpdCBwb3J0YWwiKQogIGdlbmVyYXRlX25ld19mbG9vcigpCiAg
CiBlbmQKIAogLS0gY2xlYXIgaW50ZXJhY3Rpb24gc3RhdGUgYWZ0ZXIgaGFuZGxpbmcKIGludGVy
YWN0aW9uX2FjdGl2ZT1mYWxzZQogY3VycmVudF9pbnRlcmFjdD1uaWwKZW5kCgotLSBnZW5lcmF0
ZSBuZXcgZmxvb3IgKHJlZ2VuZXJhdGUgZHVuZ2VvbikKZnVuY3Rpb24gZ2VuZXJhdGVfbmV3X2Zs
b29yKCkKIC0tIGluY3JlbWVudCBkaWZmaWN1bHR5CiBnZW5fcGFyYW1zLmRpZmZpY3VsdHk9bWlu
KGdlbl9wYXJhbXMubWF4X2RpZmZpY3VsdHksZ2VuX3BhcmFtcy5kaWZmaWN1bHR5KzEpCiAKIC0t
IGNsZWFyIGV4aXN0aW5nIG9iamVjdHMKIGZvciBneD0xLG9iamdyaWRfYXJyYXlfc2l6ZSsxIGRv
CiAgZm9yIGd5PTEsb2JqZ3JpZF9hcnJheV9zaXplKzEgZG8KICAgb2JqZ3JpZFtneF1bZ3ldPXt9
CiAgZW5kCiBlbmQKIG9iamVjdHM9e30KIGFuaW1hdGVkX29iamVjdHM9e30KIGRvb3JzPXt9CiAK
IC0tIHJlZ2VuZXJhdGUgZHVuZ2Vvbgogc3RhcnRfcG9zLGdlbl9zdGF0cz1nZW5lcmF0ZV9kdW5n
ZW9uKCkKIAogcHJpbnRoKCJmbG9vciBjb21wbGV0ZSEgZGlmZmljdWx0eTogIi4uZ2VuX3BhcmFt
cy5kaWZmaWN1bHR5KQplbmQKCi0tIHVwZGF0ZSBjb21iYXQgKHBsYWNlaG9sZGVyKQpmdW5jdGlv
biB1cGRhdGVfY29tYmF0KCkKIC0tIHRlbXAgZXhpdDogcHJlc3MgZXNjYXBlIG9yIG1lbnUgYnV0
dG9uCiBpZiBrZXlwKCJlc2NhcGUiKSBvciBidG5wKDYpIHRoZW4KICBpbl9jb21iYXQ9ZmFsc2UK
ICBjdXJyZW50X3RhcmdldD1uaWwKICBwcmludGgoImV4aXRlZCBjb21iYXQiKQogZW5kCmVuZAoK
LS0gdXBkYXRlIG5wYyBhaSAoYmFzaWMgcGF0cm9sIGFuZCBmb2xsb3cpCmZ1bmN0aW9uIHVwZGF0
ZV9ucGNfYWkoKQogZm9yIG9iIGluIGFsbChvYmplY3RzKSBkbwogIGlmIG9iLnR5cCBhbmQgb2Iu
dHlwLmtpbmQ9PSJob3N0aWxlX25wYyIgYW5kIG9iLmFpX3R5cGUgdGhlbgogICBsb2NhbCBvbGRf
eCxvbGRfeT1vYi5wb3NbMV0sb2IucG9zWzJdCiAgIAogICBpZiBvYi5haV90eXBlPT0icGF0cm9s
IiB0aGVuCiAgICAtLSBwYXRyb2w6IGN5Y2xlIHRocm91Z2ggcGF0cm9sX3BvaW50cwogICAgaWYg
b2IucGF0cm9sX3BvaW50cyBhbmQgI29iLnBhdHJvbF9wb2ludHM_MCB0aGVuCiAgICAgLS0gaW5p
dGlhbGl6ZSBwYXRyb2xfaW5kZXggaWYgbmlsIG9yIDAKICAgICBpZiBub3Qgb2IucGF0cm9sX2lu
ZGV4IG9yIG9iLnBhdHJvbF9pbmRleD09MCB0aGVuCiAgICAgIG9iLnBhdHJvbF9pbmRleD0xCiAg
ICAgZW5kCiAgICAgCiAgICAgbG9jYWwgdGFyZ2V0PW9iLnBhdHJvbF9wb2ludHNbb2IucGF0cm9s
X2luZGV4XQogICAgIGlmIHRhcmdldCB0aGVuCiAgICAgIGxvY2FsIGR4PXRhcmdldC54LW9iLnBv
c1sxXQogICAgICBsb2NhbCBkeT10YXJnZXQueS1vYi5wb3NbMl0KICAgICAgbG9jYWwgZGlzdD1z
cXJ0KGR4KmR4K2R5KmR5KQogICAgICAKICAgICAgLS0gcmVhY2hlZCB3YXlwb2ludDogYWR2YW5j
ZSB0byBuZXh0CiAgICAgIGlmIGRpc3Q8MC4xIHRoZW4KICAgICAgIG9iLnBhdHJvbF9pbmRleD0o
b2IucGF0cm9sX2luZGV4JSNvYi5wYXRyb2xfcG9pbnRzKSsxCiAgICAgIGVsc2UKICAgICAgIC0t
IG1vdmUgdG93YXJkIGN1cnJlbnQgd2F5cG9pbnQKICAgICAgIGlmIGRpc3Q_MCB0aGVuCiAgICAg
ICAgbG9jYWwgc3BkPW9iLnR5cC5wYXRyb2xfc3BlZWQgb3IgMC4wMwogICAgICAgIGxvY2FsIG54
PW9iLnBvc1sxXStkeC9kaXN0KnNwZAogICAgICAgIGxvY2FsIG55PW9iLnBvc1syXStkeS9kaXN0
KnNwZAogICAgICAgIHRyeW1vdmV0b19wb3Mob2IucG9zLG54LG55LG9iLnR5cC53IG9yIDAuNCxm
YWxzZSxmYWxzZSkKICAgICAgIGVuZAogICAgICBlbmQKICAgICBlbmQKICAgIGVuZAogICAgCiAg
IGVsc2VpZiBvYi5haV90eXBlPT0iZm9sbG93IiB0aGVuCiAgICAtLSBmb2xsb3c6IG1vdmUgdG93
YXJkIHBsYXllciBpZiBpbiByYW5nZQogICAgbG9jYWwgZHg9cGxheWVyLngtb2IucG9zWzFdCiAg
ICBsb2NhbCBkeT1wbGF5ZXIueS1vYi5wb3NbMl0KICAgIGxvY2FsIGRpc3Q9c3FydChkeCpkeCtk
eSpkeSkKICAgIGxvY2FsIGZvbGxvd19yYW5nZT1vYi50eXAuZm9sbG93X3JhbmdlIG9yIDIwCiAg
ICBpZiBkaXN0PGZvbGxvd19yYW5nZSBhbmQgZGlzdD4wLjEgdGhlbgogICAgIGxvY2FsIHNwZD1v
Yi50eXAuZm9sbG93X3NwZWVkIG9yIDAuMDUKICAgICBsb2NhbCBueD1vYi5wb3NbMV0rZHgvZGlz
dCpzcGQKICAgICBsb2NhbCBueT1vYi5wb3NbMl0rZHkvZGlzdCpzcGQKICAgICB0cnltb3ZldG9f
cG9zKG9iLnBvcyxueCxueSxvYi50eXAudyBvciAwLjQsZmFsc2UsZmFsc2UpCiAgICBlbmQKICAg
ZW5kCiAgIAogICAtLSB1cGRhdGUgc3BhdGlhbCBncmlkIGFmdGVyIG1vdmVtZW50CiAgIGlmIG9s
ZF94fj1vYi5wb3NbMV0gb3Igb2xkX3l_PW9iLnBvc1syXSB0aGVuCiAgICB1cGRhdGVfb2JqZWN0
X2dyaWQob2Isb2xkX3gsb2xkX3kpCiAgIGVuZAogIGVuZAogZW5kCmVuZAo=
:: src/
:: src/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTExLTA3IDIyOjE0OjEzIixtb2RpZmllZD0iMjAyNS0x
MS0wNyAyMjoxODo1MSJdXQ==
:: src/config.lua
--[[pod_format="raw",created="2025-11-07 21:17:14",modified="2025-11-07 21:48:05",revision=1]]
-- engine configuration

-- screen constants
screen_width=480
screen_height=270
screen_center_x=160
screen_center_y=90
ray_count=320
sdist=200 -- default; computed dynamically in raycast_scene() based on fov
map_size=128
objgrid_size=5
objgrid_array_size=26
fov=0.5

-- fog configuration (optional enhancements)
fogdist=250 -- fog distance parameter for quadratic falloff (scaled from PICO-8's 100-150)
screenbright=1.0 -- screen brightness multiplier (1.0=normal, <1.0=darker for atmosphere)
use_quadratic_fog=false -- flag to enable/disable quadratic fog (default to simple linear fog)

-- ai and interaction constants
ai_update_rate=2 -- frames between AI updates
interaction_range=0.5 -- proximity for triggers
combat_trigger_range=0.3 -- distance to trigger combat

-- player movement constants
player_rotation_speed=0.02 -- radians per frame when turning
player_move_speed=0.1 -- units per frame when moving

-- door animation constants
door_anim_speed=0.06 -- door open/close speed per frame
door_close_delay=90 -- frames before door auto-closes

-- floor/ceiling types
planetyps={
 -- stone_tile
 {tex=0,scale=1,height=0.5,lit=true,xvel=0,yvel=0},
 -- dirt
 {tex=1,scale=1,height=0.5,lit=true,xvel=0,yvel=0},
 -- stone_ceiling
 {tex=2,scale=1,height=0.5,lit=false,xvel=0,yvel=0},
 -- sky
 {tex=8,scale=2,height=1,lit=false,xvel=0.01,yvel=0},
 -- night_sky
 {tex=9,scale=2,height=1,lit=false,xvel=0.005,yvel=0}
}

-- wall texture sets
texsets={
 -- none (for empty space)
 {base=0,variants={0}},
 -- brick
 {base=1,variants={1,2,3,4}},
 -- cobblestone
 {base=5,variants={5,6,7,8}},
 -- wood_plank
 {base=9,variants={9,10,11,12}},
 -- stone
 {base=13,variants={13,14,15,16}},
 -- grass (outdoor)
 {base=17,variants={17,18,19,20}},
 -- earth (outdoor)
 {base=21,variants={21,22,23,24}}
}

-- door types (tile IDs, must not overlap with floor 0)
door_normal=64
door_locked=65
door_stay_open=66

-- helper: check if tile is a door
function is_door(val)
 return val>=door_normal and val<=door_stay_open
end

-- exit types (tile IDs)
exit_start=67
exit_end=68

-- wall fill constant
wall_fill_tile=1

-- generation parameters
gen_params={
 min_rooms=5,
 max_rooms=15,
 min_size=4,
 max_size=12,
 spacing=2,
 corridor_texture=0,
 room_door_prob=0.3,
 erode_amount=50,
 difficulty=1,
 max_difficulty=9,
 max_enemies_per_room=8,
 max_decorations_per_room=12,
 npc_hostile_ratio=0.7,
 items_per_room=2,
 pickup_density=0.1
}

-- helper constants
max_spawn_attempts=50
max_room_attempts=100

-- door testing parameters
test_door_open=nil -- if set to a value 0.0-1.0, forces all doors to this open state for testing
test_door_x=nil -- if set, only affects door at this position
test_door_y=nil -- if set, only affects door at this position

-- object type definitions
obj_types={
 player={solid=true,w=0.4,mx=98,my=9,mw=8,mh=8,y=0.4,h=0.8,flat=false,lit=nil,framect=nil,animspd=nil,yoffs=nil,kind="player"},
 enemy={solid=true,w=0.4,mx=103,my=0,mw=16,mh=40,y=0.1,h=0.8,flat=false,lit=nil,framect=4,animspd=0.25,yoffs={0,-0.01,0,-0.01},kind="hostile_npc",ai_type="follow",follow_speed=0.05,follow_range=20,patrol_speed=0.03},
 item={solid=false,w=0.3,mx=80,my=0,mw=8,mh=8,y=0.4,h=0.2,flat=false,lit=nil,framect=nil,animspd=nil,yoffs=nil,kind="direct_pickup",subtype="generic"},
 key={solid=false,w=0.3,mx=98,my=10,mw=8,mh=8,y=0.4,h=0.2,flat=false,lit=nil,framect=nil,animspd=nil,yoffs=nil,kind="direct_pickup",subtype="key"},
 heart={solid=false,w=0.3,mx=88,my=0,mw=8,mh=8,y=0.4,h=0.2,flat=false,lit=nil,framect=2,animspd=0.1,yoffs={0,0.05},kind="direct_pickup",subtype="heart"},
 decoration={solid=false,w=0.3,mx=92,my=0,mw=8,mh=16,y=0.3,h=0.4,flat=false,lit=0,framect=4,animspd=0.25,yoffs=nil,kind="decorative"},
 hostile_npc={solid=true,w=0.4,mx=103,my=0,mw=16,mh=40,y=0.1,h=0.8,flat=false,lit=nil,framect=4,animspd=0.25,yoffs={0,-0.01,0,-0.01},kind="hostile_npc",ai_type="follow",follow_speed=0.05,follow_range=20,patrol_speed=0.03},
 non_hostile_npc={solid=false,w=0.4,mx=110,my=0,mw=16,mh=40,y=0.1,h=0.8,flat=false,lit=nil,framect=1,animspd=0,yoffs=nil,kind="non_hostile_npc"},
 direct_pickup={solid=false,w=0.2,mx=80,my=0,mw=8,mh=8,y=0.4,h=0.2,flat=false,lit=nil,framect=2,animspd=0.1,yoffs={0,0.05},kind="direct_pickup"},
 interactable_chest={solid=false,w=0.3,mx=85,my=0,mw=8,mh=8,y=0.3,h=0.3,flat=false,lit=nil,framect=1,animspd=0,yoffs=nil,kind="interactable",subtype="chest"},
 interactable_shrine={solid=false,w=0.4,mx=90,my=0,mw=8,mh=16,y=0.3,h=0.5,flat=false,lit=nil,framect=1,animspd=0,yoffs=nil,kind="interactable",subtype="shrine"},
 interactable_trap={solid=false,w=0.2,mx=95,my=0,mw=8,mh=8,y=0.4,h=0.1,flat=true,lit=nil,framect=1,animspd=0,yoffs=nil,kind="interactable",subtype="trap"},
 interactable_note={solid=false,w=0.3,mx=100,my=0,mw=8,mh=8,y=0.4,h=0.2,flat=true,lit=nil,framect=1,animspd=0,yoffs=nil,kind="interactable",subtype="note"},
 interactable_exit={solid=false,w=0.3,mx=100,my=0,mw=8,mh=8,y=0.4,h=0.2,flat=false,lit=nil,framect=1,animspd=0,yoffs=nil,kind="interactable",subtype="exit"}
}

-- enemy type definitions
enemy_types={
 {name="rat",difficulty=1,min_count=1,max_count=3,obj_type=obj_types.hostile_npc,sprite=1,hp=1},
 {name="bat",difficulty=2,min_count=1,max_count=4,obj_type=obj_types.hostile_npc,sprite=2,hp=1},
 {name="slime",difficulty=3,min_count=2,max_count=5,obj_type=obj_types.hostile_npc,sprite=3,hp=2},
 {name="skeleton",difficulty=4,min_count=1,max_count=3,obj_type=obj_types.hostile_npc,sprite=4,hp=3},
 {name="goblin",difficulty=5,min_count=2,max_count=4,obj_type=obj_types.hostile_npc,sprite=5,hp=3},
 {name="orc",difficulty=6,min_count=1,max_count=3,obj_type=obj_types.hostile_npc,sprite=6,hp=4},
 {name="troll",difficulty=7,min_count=1,max_count=2,obj_type=obj_types.hostile_npc,sprite=7,hp=5},
 {name="demon",difficulty=8,min_count=1,max_count=2,obj_type=obj_types.hostile_npc,sprite=8,hp=6},
 {name="dragon",difficulty=9,min_count=1,max_count=1,obj_type=obj_types.hostile_npc,sprite=9,hp=10}
}

-- decoration type definitions
decoration_types={
 {name="torch",difficulty=1,obj_type=obj_types.decoration,gen_tags={"lit","uni"},theme_tags={"dng","lit"},sprite=10},
 {name="barrel",difficulty=1,obj_type=obj_types.decoration,gen_tags={"uni"},theme_tags={"dng","house"},sprite=11},
 {name="crate",difficulty=1,obj_type=obj_types.decoration,gen_tags={"uni2"},theme_tags={"dng","house"},sprite=12},
 {name="pillar",difficulty=2,obj_type=obj_types.decoration,gen_tags={"big"},theme_tags={"dng","dem"},sprite=13},
 {name="statue",difficulty=3,obj_type=obj_types.decoration,gen_tags={"rare"},theme_tags={"dng","dem"},sprite=14},
 {name="chest",difficulty=2,obj_type=obj_types.decoration,gen_tags={"scatter"},theme_tags={"dng","house"},sprite=15},
 {name="tree",difficulty=1,obj_type=obj_types.decoration,gen_tags={"scatter"},theme_tags={"out"},sprite=16},
 {name="rock",difficulty=1,obj_type=obj_types.decoration,gen_tags={"uni"},theme_tags={"out"},sprite=17}
}

-- theme definitions
themes={
 dng={floor="stone_tile",roof="stone_ceiling",decor_prob=0.8},
 out={floor="dirt",roof="sky",decor_prob=0.5},
 dem={floor="stone_tile",roof="night_sky",decor_prob=0.9},
 house={floor="stone_tile",roof="stone_ceiling",decor_prob=0.7},
 dark={floor="stone_tile",roof="night_sky",decor_prob=0.6}
}

-- fog palettes (distance-based)
-- extended to support all 64 colors in Picotron
-- base colors 0-15 are remapped per fog level; colors 16-63 map to their fogged equivalents
pals={
 -- level 0: no fog
 {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63},
 -- level 1
 {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,5,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,5,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,5,48,49,50,51,52,53,54,5,56,57,58,59,60,61,62,5},
 -- level 2
 {0,1,2,3,4,5,6,7,8,9,10,11,12,13,5,5,16,17,18,19,20,21,22,23,24,25,26,27,28,29,5,5,32,33,34,35,36,37,38,39,40,41,42,43,44,45,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,61,5,5},
 -- level 3
 {0,1,2,3,4,5,6,7,8,9,10,11,12,5,5,5,16,17,18,19,20,21,22,23,24,25,26,27,28,5,5,5,32,33,34,35,36,37,38,39,40,41,42,43,44,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 4
 {0,1,2,3,4,5,6,7,8,9,10,11,5,5,5,5,16,17,18,19,20,21,22,23,24,25,26,27,5,5,5,5,32,33,34,35,36,37,38,39,40,41,42,43,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 5
 {0,1,2,3,4,5,6,7,8,9,10,5,5,5,5,5,16,17,18,19,20,21,22,23,24,25,26,5,5,5,5,5,32,33,34,35,36,37,38,39,40,41,42,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 6
 {0,1,2,3,4,5,6,7,8,9,5,5,5,5,5,5,16,17,18,19,20,21,22,23,24,25,5,5,5,5,5,5,32,33,34,35,36,37,38,39,40,41,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 7
 {0,1,2,3,4,5,6,7,8,5,5,5,5,5,5,5,16,17,18,19,20,21,22,23,24,5,5,5,5,5,5,5,32,33,34,35,36,37,38,39,40,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 8
 {0,1,2,3,4,5,6,7,5,5,5,5,5,5,5,5,16,17,18,19,20,21,22,23,5,5,5,5,5,5,5,5,32,33,34,35,36,37,38,39,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 9
 {0,1,2,3,4,5,6,5,5,5,5,5,5,5,5,5,16,17,18,19,20,21,5,5,5,5,5,5,5,5,5,5,32,33,34,35,36,37,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 10
 {0,1,2,3,4,5,5,5,5,5,5,5,5,5,5,5,16,17,18,19,20,21,5,5,5,5,5,5,5,5,5,5,32,33,34,35,36,37,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 11
 {0,1,2,3,4,5,5,5,5,5,5,5,5,5,5,5,16,17,18,19,20,21,5,5,5,5,5,5,5,5,5,5,32,33,34,35,36,37,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 12
 {0,1,2,3,5,5,5,5,5,5,5,5,5,5,5,5,16,17,18,19,5,5,5,5,5,5,5,5,5,5,5,5,32,33,34,35,5,5,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 13
 {0,1,2,5,5,5,5,5,5,5,5,5,5,5,5,5,16,17,18,5,5,5,5,5,5,5,5,5,5,5,5,5,32,33,34,5,5,5,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 14
 {0,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,16,17,5,5,5,5,5,5,5,5,5,5,5,5,5,5,32,33,5,5,5,5,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5},
 -- level 15: maximum fog
 {0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,16,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,32,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,48,49,50,51,52,53,54,5,56,57,58,59,60,5,5,5}
}

:: src/door_system.lua
--[[pod_format="raw",created="2025-11-07 21:17:14",modified="2025-11-07 21:48:06",revision=1]]
-- door animation system

-- create a door
function create_door(x,y,dtype,key_id)
 local door={
  x=x,
  y=y,
  open=0, -- 0=closed, 1=fully open
  opening=false, -- animation state
  timer=0,
  dtype=dtype or door_normal,
  keynum=key_id, -- nil if unlocked, key id if locked
  stayopen=(dtype==door_stay_open) -- doors with door_stay_open dtype stay open
 }
 
 add(doors,door)
 doorgrid[x][y]=door
	-- mirror to doors layer userdata
	set_door(x,y,door.dtype)
	-- wall userdata already set by generation to door tile ID
 
 return door
end

-- update all doors
function update_doors()
 -- in test mode, force all doors to test_door_open value
 if test_door_mode then
  for door in all(doors) do
   door.open=test_door_open or 0
  end
  return
 end
 
 for door in all(doors) do
  if door.opening then
   -- play sound on start
   if door.open==0 then
    -- sfx(10) -- door open sound
   end
   -- animate opening
   door.open+=door_anim_speed
   if door.open>1 then
    door.open=1
    door.opening=false
    door.timer=door_close_delay
   end
  else
   -- not opening
   if door.timer>0 then
    door.timer-=1
   elseif not door.stayopen then
    -- close door
    door.open=max(door.open-door_anim_speed,0)
   end
  end
 end
end



-- remove a door
function remove_door(x,y)
 local door=doorgrid[x][y]
 if door then
  del(doors,door)
  doorgrid[x][y]=nil
		set_door(x,y,0)
		set_wall(x,y,0)
 end
end

:: src/dungeon_gen.lua
--[[pod_format="raw",created="2025-11-07 21:17:13",modified="2025-11-07 21:48:06",revision=1]]
-- procedural dungeon generation

-- generation state
gen_rects={}
gen_nodes={}
gen_edges={}
gen_inventory={}
gen_objects={}

-- helper: check if tile is a wall
function is_wall(val)
 return val>0 and val<door_normal
end

-- helper: check if tile is a door
function is_door(val)
 return val>=door_normal and val<=door_stay_open
end

-- helper: check if tile is an exit
function is_exit(val)
 return val>=exit_start and val<=exit_end
end

-- helper: check if rectangles overlap
function rect_overlaps(rect)
 for r in all(gen_rects) do
  if not (rect[3]+gen_params.spacing<r[1] or rect[1]>r[3]+gen_params.spacing or
          rect[4]+gen_params.spacing<r[2] or rect[2]>r[4]+gen_params.spacing) then
   return true
  end
 end
 return false
end

-- helper: fill rectangle using set_wall
function fill_rect(rect,val)
 for x=max(0,rect[1]),min(127,rect[3]) do
  for y=max(0,rect[2]),min(127,rect[4]) do
			set_wall(x,y,val)
  end
 end
end

-- helper: try place door with fallback positions
function try_place_door_with_fallback(x,y,dtype)
 local attempts={
  {x,y},
  {x-1,y},{x+1,y},{x,y-1},{x,y+1}
 }
 
 for attempt in all(attempts) do
  local ax,ay=attempt[1],attempt[2]
  if ax>=0 and ax<128 and ay>=0 and ay<128 then
			if is_wall(get_wall(ax,ay)) and rnd(1)<gen_params.room_door_prob then
				set_wall(ax,ay,dtype)
    create_door(ax,ay,dtype)
    return true
   end
  end
 end
 return false
end

-- helper: generate random room
function random_room(base_node,is_special)
 local w,h
 if is_special then
  w,h=12,12
 else
  w=flr(rnd(gen_params.max_size-gen_params.min_size+1))+gen_params.min_size
  h=flr(rnd(gen_params.max_size-gen_params.min_size+1))+gen_params.min_size
 end
 
 local x,y
 if base_node then
  x=base_node.midx+flr(rnd(20)-10)
  y=base_node.midy+flr(rnd(20)-10)
 else
  x=flr(rnd(122))+3
  y=flr(rnd(122))+3
 end
 
 return {x,y,x+w-1,y+h-1},gen_params.room_door_prob
end

-- helper: add room to generation state
function add_room(rect)
 add(gen_rects,rect)
 local node={
  rect=rect,
  midx=flr((rect[1]+rect[3])/2),
  midy=flr((rect[2]+rect[4])/2),
  edges={}
 }
 add(gen_nodes,node)
 return node
end

-- helper: determine corridor type between two rooms
function get_corridor_type(r1,r2)
 local ox=not (r1[3]<r2[1] or r1[1]>r2[3])
 local oy=not (r1[4]<r2[2] or r1[2]>r2[4])
 if ox and not oy then return "vert" end
 if oy and not ox then return "horiz" end
 return "l_shape"
end

-- helper: place door at exact boundary wall tile
function place_boundary_door(bx,by,dtype)
 -- bx,by = boundary wall tile (between corridor and room)
 if bx>=0 and bx<128 and by>=0 and by<128 then
		if is_wall(get_wall(bx,by)) then
			set_wall(bx,by,dtype)
   create_door(bx,by,dtype)
   return true
  end
 end
 return false
end

-- helper: create corridor between two nodes
function create_corridor(n1,n2)
 local ctype=get_corridor_type(n1.rect,n2.rect)
	local b1,b2
 
 if ctype=="horiz" then
  local x0,x1=min(n1.midx,n2.midx),max(n1.midx,n2.midx)
  local y=n1.midy
  local r1,r2=n1.rect,n2.rect
  
  -- identify boundary wall tiles before carving
  local bx1,bx2
  if r1[1]<=r2[1] then
   bx1=r1[3]+1
   bx2=r2[1]-1
  else
   bx1=r2[3]+1
   bx2=r1[1]-1
  end
  
  -- place doors on boundary walls
  place_boundary_door(bx1,y,door_normal)
  place_boundary_door(bx2,y,door_normal)
  
  -- carve corridor between doors (exclusive)
  for x=bx1+1,bx2-1 do
   if x>=0 and x<128 and y>=0 and y<128 then
				set_wall(x,y,0)
				set_floor(x,y,1)
   end
  end

		-- store boundary tiles
		b1={x=bx1,y=y}
		b2={x=bx2,y=y}
  
 elseif ctype=="vert" then
  local y0,y1=min(n1.midy,n2.midy),max(n1.midy,n2.midy)
  local x=n1.midx
  local r1,r2=n1.rect,n2.rect
  
  -- identify boundary wall tiles before carving
  local by1,by2
  if r1[2]<=r2[2] then
   by1=r1[4]+1
   by2=r2[2]-1
  else
   by1=r2[4]+1
   by2=r1[2]-1
  end
  
  -- place doors on boundary walls
  place_boundary_door(x,by1,door_normal)
  place_boundary_door(x,by2,door_normal)
  
  -- carve corridor between doors (exclusive)
  for y=by1+1,by2-1 do
   if x>=0 and x<128 and y>=0 and y<128 then
				set_wall(x,y,0)
				set_floor(x,y,1)
   end
  end

		-- store boundary tiles
		b1={x=x,y=by1}
		b2={x=x,y=by2}
  
 else -- l_shape
	local jx,jy=n1.midx,n2.midy
  local jw,jh=3,3
  local jrect={jx-1,jy-1,jx+jw-2,jy+jh-2}
  fill_rect(jrect,0)
  local jnode=add_room(jrect)
  
  -- connect n1 to junction (horizontal)
  local x0,x1=min(n1.midx,jx),max(n1.midx,jx)
  local r1=n1.rect
  local bx1_horiz,bx2_horiz
  if r1[1]<=jx then
   bx1_horiz=r1[3]+1
   bx2_horiz=jrect[1]-1
  else
   bx1_horiz=jrect[3]+1
   bx2_horiz=r1[1]-1
  end
  
  -- place doors on horizontal segment boundaries
  place_boundary_door(bx1_horiz,n1.midy,door_normal)
  place_boundary_door(bx2_horiz,n1.midy,door_normal)
  
	-- carve horizontal segment
  for x=bx1_horiz+1,bx2_horiz-1 do
   if x>=0 and x<128 and n1.midy>=0 and n1.midy<128 then
				set_wall(x,n1.midy,0)
				set_floor(x,n1.midy,1)
   end
  end
  
  -- connect junction to n2 (vertical)
  local y0,y1=min(jy,n2.midy),max(jy,n2.midy)
  local r2=n2.rect
  local by1_vert,by2_vert
  if jy<=r2[2] then
   by1_vert=jrect[4]+1
   by2_vert=r2[2]-1
  else
   by1_vert=r2[4]+1
   by2_vert=jrect[2]-1
  end
  
  -- place doors on vertical segment boundaries
  place_boundary_door(jx,by1_vert,door_normal)
  place_boundary_door(jx,by2_vert,door_normal)
  
	-- carve vertical segment
  for y=by1_vert+1,by2_vert-1 do
   if jx>=0 and jx<128 and y>=0 and y<128 then
				set_wall(jx,y,0)
				set_floor(jx,y,1)
   end
  end

		-- store boundary tiles near rooms
		local near_n1
		if r1[1]<=jx then
			near_n1={x=bx1_horiz,y=n1.midy}
		else
			near_n1={x=bx2_horiz,y=n1.midy}
		end
		local near_n2
		if jy<=r2[2] then
			near_n2={x=jx,y=by2_vert}
		else
			near_n2={x=jx,y=by1_vert}
		end
		b1=near_n1
		b2=near_n2
 end
 
 -- store boundary tiles for progression gating
	local edge={n1=n1,n2=n2,b1=b1,b2=b2}
 add(gen_edges,edge)
 add(n1.edges,n2)
 add(n2.edges,n1)
end

-- helper: try to generate and connect a room
function try_generate_room()
 local base=gen_nodes[flr(rnd(#gen_nodes))+1]
 local rect=random_room(base,false)
 
 if rect[1]<3 or rect[3]>126 or rect[2]<3 or rect[4]>126 then
  return false
 end
 
 if rect_overlaps(rect) then
  return false
 end
 
 local node=add_room(rect)
 fill_rect(rect,0)
 create_corridor(base,node)
 return true
end

-- helper: apply wall textures to room perimeter
function apply_room_walls(rect,tex)
 -- ensure tex is never 0
 if tex==0 then tex=1 end
 
 for x=rect[1],rect[3] do
  if rect[2]-1>=0 and rect[2]-1<128 and x>=0 and x<128 then
   -- skip if door or exit tile
		if not (is_door(get_wall(x,rect[2]-1)) or is_exit(get_wall(x,rect[2]-1))) then
			set_wall(x,rect[2]-1,tex)
   end
  end
  if rect[4]+1>=0 and rect[4]+1<128 and x>=0 and x<128 then
   -- skip if door or exit tile
		if not (is_door(get_wall(x,rect[4]+1)) or is_exit(get_wall(x,rect[4]+1))) then
			set_wall(x,rect[4]+1,tex)
   end
  end
 end
 for y=rect[2],rect[4] do
  if rect[1]-1>=0 and rect[1]-1<128 and y>=0 and y<128 then
   -- skip if door or exit tile
		if not (is_door(get_wall(rect[1]-1,y)) or is_exit(get_wall(rect[1]-1,y))) then
			set_wall(rect[1]-1,y,tex)
   end
  end
  if rect[3]+1>=0 and rect[3]+1<128 and y>=0 and y<128 then
   -- skip if door or exit tile
		if not (is_door(get_wall(rect[3]+1,y)) or is_exit(get_wall(rect[3]+1,y))) then
			set_wall(rect[3]+1,y,tex)
   end
  end
 end
end

-- helper: random wall texture (never returns 0)
function random_wall_texture()
 local set=texsets[flr(rnd(#texsets-1))+2] -- skip texsets[1] which is floor
 return set.variants[flr(rnd(#set.variants))+1]
end

-- helper: get theme-appropriate wall texture set
function theme_wall_texture(theme)
 if theme=="out" then
  -- outdoor: grass or earth variants
  local idx=rnd(1)<0.5 and 6 or 7 -- grass or earth
  return texsets[idx]
 elseif theme=="dem" then
  -- demon: stone or cobblestone
  local idx=rnd(1)<0.5 and 3 or 5
  return texsets[idx]
 elseif theme=="house" then
  -- house: wood plank
  return texsets[4]
 else
  -- default dungeon: brick or cobblestone
  local idx=rnd(1)<0.5 and 2 or 3
  return texsets[idx]
 end
end

-- helper: find accessible rooms from start via edges
function find_accessible_rooms(start_node,locked_edges)
 local accessible={}
 local queue={start_node}
 local visited={}
 visited[start_node]=true
 
 while #queue>0 do
  local node=queue[1]
  deli(queue,1)
  add(accessible,node)
  
  for edge_node in all(node.edges) do
   if not visited[edge_node] then
    local is_locked=false
    if locked_edges then
     for le in all(locked_edges) do
					if (le.n1==node and le.n2==edge_node) or (le.n1==edge_node and le.n2==node) then
       is_locked=true
       break
      end
     end
    end
    
    if not is_locked then
     visited[edge_node]=true
     add(queue,edge_node)
    end
   end
  end
 end
 
 return accessible
end

-- helper: find spawn point in room
function find_spawn_point(rect)
 for attempt=1,max_spawn_attempts do
  local x=rect[1]+1+flr(rnd(rect[3]-rect[1]-1))
  local y=rect[2]+1+flr(rnd(rect[4]-rect[2]-1))
  
  if x>=0 and x<128 and y>=0 and y<128 and wallgrid[x][y]==0 then
   local valid=true
   for obj in all(gen_objects) do
    local dx,dy=abs(obj.x-x),abs(obj.y-y)
    if dx<1 and dy<1 then
     valid=false
     break
    end
   end
   
   if valid then
    return x+0.5,y+0.5
   end
  end
 end
 return nil,nil
end

-- helper: erode map for organic feel (generalized for all wall types)
function erode_map(amount)
 for i=1,amount do
  local x,y=flr(rnd(128)),flr(rnd(128))
		if is_wall(get_wall(x,y)) then
   local neighbors=0
   for dx=-1,1 do
    for dy=-1,1 do
     local nx,ny=x+dx,y+dy
					if nx>=0 and nx<128 and ny>=0 and ny<128 and get_wall(nx,ny)==0 then
      neighbors+=1
     end
    end
   end
   if neighbors>=3 then
				set_wall(x,y,0)
   end
  end
 end
end

-- helper: generate exit portal on wall
function generate_exit(rect,exit_type)
 local walls={}
 for x=rect[1],rect[3] do
		if rect[2]-1>=0 and is_wall(get_wall(x,rect[2]-1)) then
   add(walls,{x,rect[2]})
  end
		if rect[4]+1<128 and is_wall(get_wall(x,rect[4]+1)) then
   add(walls,{x,rect[4]})
  end
 end
 for y=rect[2],rect[4] do
		if rect[1]-1>=0 and is_wall(get_wall(rect[1]-1,y)) then
   add(walls,{rect[1],y})
  end
		if rect[3]+1<128 and is_wall(get_wall(rect[3]+1,y)) then
   add(walls,{rect[3],y})
  end
 end
 
 if #walls>0 then
  local pos=walls[flr(rnd(#walls))+1]
  -- write exit tile to map
  local exit_tile=exit_type==3 and exit_start or exit_end
  set_wall(pos[1],pos[2],exit_tile)
  -- also add interactable exit object
  local ob={
   pos={pos[1]+0.5,pos[2]+0.5},
   typ=obj_types.interactable_exit,
   rel={0,0},
   frame=0,
   animloop=true,
   autoanim=false,
   exit_type=exit_type
  }
  add(gen_objects,ob)
 end
end

-- gameplay generation: enemies, items, decorations, npcs
function generate_gameplay()
 local start_node=gen_nodes[1]
 local exit_node=gen_nodes[#gen_nodes]
 
 -- place start/exit portals
 generate_exit(start_node.rect,3)
 generate_exit(exit_node.rect,4)
 
 -- erode map
 erode_map(gen_params.erode_amount)
 
 -- populate inventory with health items
 for i=1,3 do
  add(gen_inventory,{type="heart"})
 end
 
 -- generate progression loop (simplified - no locking yet)
 generate_progression_loop(start_node)
 
 -- generate npcs (includes hostile and non-hostile)
 generate_npcs()
 
 -- generate items
 generate_items()
 
 -- generate decorations
 generate_decorations()
end

-- generate progression: items and locked doors
function generate_progression_loop(start_node)
 local locked_edges={}
 local key_counter=1
 
 -- attempt to create progression gates
 for gate_idx=1,#gen_edges do
  if key_counter>3 then break end
  
  -- try to lock an edge
  local edge=gen_edges[flr(rnd(#gen_edges))+1]
  local n1,n2=edge.n1,edge.n2
  
  -- check if this edge would gate content
  local test_locked={edge}
  local test_accessible=find_accessible_rooms(start_node,test_locked)
  local full_accessible=find_accessible_rooms(start_node,locked_edges)
  
		-- if locking this edge hides new rooms, add it as a gate
		if #test_accessible<#full_accessible then
			-- choose the actual corridor boundary door tile
			local candidates={edge.b1,edge.b2}
			local chosen=nil
			for c in all(candidates) do
				if c and c.x and c.y then
					chosen=c
					break
				end
			end
			if chosen then
				local x,y=chosen.x,chosen.y
				local door=doorgrid[x] and doorgrid[x][y] or nil
				if door then
					-- convert existing door to locked
					set_wall(x,y,door_locked)
					set_door(x,y,door_locked)
					door.dtype=door_locked
					door.keynum=key_counter
				else
					-- fallback: create a new locked door here
					set_wall(x,y,door_locked)
					create_door(x,y,door_locked,key_counter)
				end
				add(locked_edges,edge)
				-- add key to inventory
				add(gen_inventory,{type="key",keynum=key_counter})
				key_counter+=1
			end
		end
 end
 
 -- place inventory items in accessible rooms
 while #gen_inventory>0 do
  local accessible=find_accessible_rooms(start_node,locked_edges)
  
  if #accessible>0 then
   local room=accessible[flr(rnd(#accessible))+1]
   local item=gen_inventory[1]
   deli(gen_inventory,1)
   
   local x,y=find_spawn_point(room.rect)
   if x then
   if item.type=="key" then
     local ob={pos={x,y},typ=obj_types.key,rel={0,0},frame=0,animloop=true,autoanim=true,keynum=item.keynum}
     add(gen_objects,ob)
    else
     local ob={pos={x,y},typ=obj_types[item.type],rel={0,0},frame=0,animloop=true,autoanim=true}
     add(gen_objects,ob)
    end
   end
  else
   break
  end
 end
end

-- generate npcs (hostile and non-hostile) in rooms
function generate_npcs()
 for node in all(gen_nodes) do
  local rect=node.rect
  local num_npcs=flr(rnd(3))+1
  
  for i=1,num_npcs do
   local x,y=find_spawn_point(rect)
   if x then
    -- 70% hostile, 30% non-hostile
    if rnd(1)<gen_params.npc_hostile_ratio then
     -- hostile npc with patrol or follow behavior
     local ai_type=rnd(1)<0.5 and "patrol" or "follow"
     local ob={
      pos={x,y},
      typ=obj_types.hostile_npc,
      rel={0,0},
      frame=0,
      animloop=true,
      autoanim=true,
      ai_type=ai_type,
      patrol_index=0,
      patrol_points={}
     }
     -- generate patrol points if patrol mode
     if ai_type=="patrol" then
      for j=1,4 do
       local px,py=find_spawn_point(rect)
       if px then
        add(ob.patrol_points,{x=px,y=py})
       end
      end
      if #ob.patrol_points==0 then
       add(ob.patrol_points,{x=x,y=y})
      end
     end
     add(gen_objects,ob)
    else
     -- non-hostile npc
     local ob={
      pos={x,y},
      typ=obj_types.non_hostile_npc,
      rel={0,0},
      frame=0,
      animloop=true,
      autoanim=false
     }
     add(gen_objects,ob)
    end
   end
  end
 end
end

-- generate items (pickups and interactables) in rooms
function generate_items()
 for node in all(gen_nodes) do
  local rect=node.rect
  local num_items=flr(rnd(gen_params.items_per_room))+1
  
  for i=1,num_items do
   local x,y=find_spawn_point(rect)
   if x then
    -- choose item type: 60% pickup, 40% interactable
    if rnd(1)<0.6 then
     -- direct pickup (heart or generic item)
     local pickup_type=rnd(1)<0.5 and "heart" or "direct_pickup"
     local obj_type=pickup_type=="heart" and obj_types.heart or obj_types.direct_pickup
     local ob={
      pos={x,y},
      typ=obj_type,
      rel={0,0},
      frame=0,
      animloop=true,
      autoanim=true
     }
     add(gen_objects,ob)
    else
     -- interactable (chest, shrine, trap, note)
     local subtypes={"chest","shrine","trap","note"}
     local subtype=subtypes[flr(rnd(#subtypes))+1]
     local obj_type
     if subtype=="chest" then
      obj_type=obj_types.interactable_chest
     elseif subtype=="shrine" then
      obj_type=obj_types.interactable_shrine
     elseif subtype=="trap" then
      obj_type=obj_types.interactable_trap
     else
      obj_type=obj_types.interactable_note
     end
     local ob={
      pos={x,y},
      typ=obj_type,
      rel={0,0},
      frame=0,
      animloop=true,
      autoanim=false,
      subtype=subtype
     }
     add(gen_objects,ob)
    end
   end
  end
 end
end

-- generate decorations in rooms
function generate_decorations()
 local current_theme=gen_params.theme or "dng"
 local theme_config=themes[current_theme] or themes.dng
 local decor_prob=theme_config.decor_prob or 0.8
 
 for node in all(gen_nodes) do
  local rect=node.rect
  local w,h=rect[3]-rect[1]+1,rect[4]-rect[2]+1
  local room_decor_count=0
  local max_decor=gen_params.max_decorations_per_room or 12
  
  -- uniform grid pattern
  for dec in all(decoration_types) do
   if room_decor_count>=max_decor then break end
   
   -- filter by theme: check if any theme_tags match current_theme
   local theme_match=false
   if dec.theme_tags then
    for tag in all(dec.theme_tags) do
     if tag==current_theme then
      theme_match=true
      break
     end
    end
   else
    theme_match=true -- no theme_tags means always match
   end
   
   if theme_match and dec.gen_tags then
    for tag in all(dec.gen_tags) do
     if room_decor_count>=max_decor then break end
     
     if tag=="uni" and rnd(1)<0.3*decor_prob then
      for dx=2,w-2,3 do
       for dy=2,h-2,3 do
        if room_decor_count>=max_decor then break end
        if rnd(1)<0.5 then
         local x,y=rect[1]+dx+0.5,rect[2]+dy+0.5
         local ob={pos={x,y},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,decoration_type=dec}
         add(gen_objects,ob)
         room_decor_count+=1
        end
       end
       if room_decor_count>=max_decor then break end
      end
      
     elseif tag=="uni2" and rnd(1)<0.4*decor_prob then
      -- denser uniform grid
      for dx=1,w-1,2 do
       for dy=1,h-1,2 do
        if room_decor_count>=max_decor then break end
        if rnd(1)<0.6 then
         local x,y=rect[1]+dx+0.5,rect[2]+dy+0.5
         local ob={pos={x,y},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,decoration_type=dec}
         add(gen_objects,ob)
         room_decor_count+=1
        end
       end
       if room_decor_count>=max_decor then break end
      end
      
     elseif tag=="scatter" and rnd(1)<0.2*decor_prob then
      local count=flr(rnd(3))+1
      for i=1,count do
       if room_decor_count>=max_decor then break end
       local x,y=find_spawn_point(rect)
       if x then
        local ob={pos={x,y},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,decoration_type=dec}
        add(gen_objects,ob)
        room_decor_count+=1
       end
      end
      
     elseif tag=="big" and rnd(1)<0.15*decor_prob then
      if room_decor_count>=max_decor then break end
      -- large object: place at room center or corner
      local cx,cy=flr((rect[1]+rect[3])/2)+0.5,flr((rect[2]+rect[4])/2)+0.5
      if rnd(1)<0.5 then
       -- center
       local ob={pos={cx,cy},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,decoration_type=dec}
       add(gen_objects,ob)
       room_decor_count+=1
      else
       -- random corner
       local corners={{rect[1]+1.5,rect[2]+1.5},{rect[3]-0.5,rect[2]+1.5},{rect[1]+1.5,rect[4]-0.5},{rect[3]-0.5,rect[4]-0.5}}
       local corner=corners[flr(rnd(#corners))+1]
       local ob={pos={corner[1],corner[2]},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,decoration_type=dec}
       add(gen_objects,ob)
       room_decor_count+=1
      end
      
     elseif tag=="rare" and rnd(1)<0.05*decor_prob then
      if room_decor_count>=max_decor then break end
      -- rare: single spawn
      local x,y=find_spawn_point(rect)
      if x then
       local ob={pos={x,y},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,decoration_type=dec}
       add(gen_objects,ob)
       room_decor_count+=1
      end
      
     elseif tag=="lit" and rnd(1)<0.25*decor_prob then
      if room_decor_count>=max_decor then break end
      -- lit: bias toward walls or doorways
      local walls={}
      -- collect wall-adjacent floor tiles
      for x=rect[1]+1,rect[3]-1 do
       if get_wall(x,rect[2])>0 then add(walls,{x+0.5,rect[2]+1.5}) end
       if get_wall(x,rect[4])>0 then add(walls,{x+0.5,rect[4]-0.5}) end
      end
      for y=rect[2]+1,rect[4]-1 do
       if get_wall(rect[1],y)>0 then add(walls,{rect[1]+1.5,y+0.5}) end
       if get_wall(rect[3],y)>0 then add(walls,{rect[3]-0.5,y+0.5}) end
      end
      if #walls>0 then
       local pos=walls[flr(rnd(#walls))+1]
       local ob={pos={pos[1],pos[2]},typ=dec.obj_type,rel={0,0},frame=0,animloop=true,autoanim=true,decoration_type=dec}
       add(gen_objects,ob)
       room_decor_count+=1
      end
     end
    end
   end
  end
 end
end

-- generate a complete dungeon
function generate_dungeon()
 local seed=flr(rnd(10000))
 srand(seed)
 
 -- initialize state
 gen_rects={}
 gen_nodes={}
 gen_edges={}
 gen_inventory={}
 gen_objects={}
 
 -- fill with walls (non-zero tile)
 fill_rect({0,0,127,127},wall_fill_tile)
 
 -- generate first room
 local first_rect=random_room(nil,false)
 local first_node=add_room(first_rect)
 fill_rect(first_rect,0)
 
 -- generate additional rooms
 local room_count=flr(rnd(gen_params.max_rooms-gen_params.min_rooms+1))+gen_params.min_rooms
 for i=2,room_count do
  for attempt=1,max_room_attempts do
   if try_generate_room() then
    break
   end
  end
 end
 
 -- assign global theme before gameplay generation
 local theme_roll=rnd(1)
 local selected_theme="dng"
 if theme_roll<0.7 then
  selected_theme="dng"
 elseif theme_roll<0.9 then
  selected_theme="out"
 else
  selected_theme="dem"
 end
 gen_params.theme=selected_theme
 local theme_config=themes[selected_theme] or themes.dng
 
 -- set floor and ceiling types based on theme
 local floor_idx=1
 local roof_idx=3
 if theme_config.floor=="stone_tile" then floor_idx=1
 elseif theme_config.floor=="dirt" then floor_idx=2
 end
 if theme_config.roof=="stone_ceiling" then roof_idx=3
 elseif theme_config.roof=="sky" then roof_idx=4
 elseif theme_config.roof=="night_sky" then roof_idx=5
 end
 floor.typ=planetyps[floor_idx]
 roof.typ=planetyps[roof_idx]
 floor.x,floor.y=0,0
 roof.x,roof.y=0,0
 
 -- apply wall textures based on theme
 for node in all(gen_nodes) do
  local texset=theme_wall_texture(selected_theme)
  local tex=texset.variants[flr(rnd(#texset.variants))+1]
  apply_room_walls(node.rect,tex)
 end
 
 -- generate gameplay content (now aware of theme)
 generate_gameplay()
 
 -- populate objgrid from gen_objects
 for ob in all(gen_objects) do
  addobject(ob)
 end
 
 -- export to global objects list
 objects=gen_objects
 
 -- set player start
 player.x=first_node.midx+0.5
 player.y=first_node.midy+0.5
 
 printh("generated dungeon: "..#gen_nodes.." rooms, "..#gen_objects.." objects, seed "..seed)
 
 return {x=player.x,y=player.y},{rooms=#gen_nodes,objects=#gen_objects,seed=seed}
end

:: src/raycast.lua
--[[pod_format="raw",created="2025-11-07 21:17:12",modified="2025-11-07 21:48:07",revision=1]]
-- raycasting core

-- sign helper
function sgn(n)
 if n<0 then return -1 end
 if n>0 then return 1 end
 return 0
end

-- vector length
function length(x,y)
 x/=16
 y/=16
 return sqrt(x*x+y*y)*16
end

-- vector normalization
function normalise(x,y)
 local l=length(x,y)
 if l<=0.0001 then return 0,1 end
 return x/l,y/l
end

-- dda raycast with z-depth tracking
function raycast(x,y,dx,dy,sa,ca)
 -- clamp near-zero components before normalization
 if abs(dx)<0.01 then dx=0.01 end
 if abs(dy)<0.01 then dy=0.01 end
 
 -- normalize direction if camera angles not provided
 if not sa then
  sa,ca=normalise(dx,dy)
 end
 
 -- horizontal ray initialization
 local hx,hy,hdx,hdy=x,y,sgn(dx),dy/abs(dx)
 local hdz,hz=hdx*sa+hdy*ca,0
 
 -- initial step to grid boundary
 local hstep=hx%1
 if hdx>0 then
  hstep=(1-hstep)
 else
  hx-=1
  hstep=(1-hstep)
 end
 hy+=hdy*hstep
 hz+=hdz*hstep
 
 -- vertical ray initialization
 local vx,vy,vdx,vdy=x,y,dx/abs(dy),sgn(dy)
 local vdz,vz=vdx*sa+vdy*ca,0
 
 -- initial step to grid boundary
 local vstep=vy%1
 if vdy>0 then
  vstep=(1-vstep)
 else
  vy-=1
  vstep=(1-vstep)
 end
 vx+=vdx*vstep
 vz+=vdz*vstep
 
 -- ray marching
 for iter=1,256 do
  if hz<vz then
   -- horizontal closer
   local gx,gy=flr(hx),flr(hy)
   if gx>=0 and gx<map_size and gy>=0 and gy<map_size then
    local m=get_wall(gx,gy)
    if m>0 then
     -- check if door
     if is_door(m) and doorgrid[gx][gy] then
      local dz=hz+hdz/2
      if dz<vz then
       local open=test_door_mode and test_door_open or doorgrid[gx][gy].open
       local dy_off=(hy+hdy/2)%1-open
       if dy_off>=0 then
        return dz,hx,hy,m,dy_off
       end
      end
     else
      -- wall hit
      return hz,hx,hy,m,(hy*hdx)%1
     end
    end
   end
   hx+=hdx
   hy+=hdy
   hz+=hdz
  else
   -- vertical closer or equal
   local gx,gy=flr(vx),flr(vy)
   if gx>=0 and gx<map_size and gy>=0 and gy<map_size then
    local m=get_wall(gx,gy)
    if m>0 then
     -- check if door
     if is_door(m) and doorgrid[gx][gy] then
      local dz=vz+vdz/2
      if dz<hz then
       local open=test_door_mode and test_door_open or doorgrid[gx][gy].open
       local dx_off=(vx+vdx/2)%1-open
       if dx_off>=0 then
        return dz,vx,vy,m,dx_off
       end
      end
     else
      -- wall hit
      return vz,vx,vy,m,(vx*-vdy)%1
     end
    end
   end
   vx+=vdx
   vy+=vdy
   vz+=vdz
  end
 end
 
 -- fallback if iteration limit reached
 return 999,hx,hy,0,0
end

-- raycast entire scene
function raycast_scene()
 -- compute projection distance from FOV (fov is half-angle in radians)
 -- sdist = screen_center_x / tan(half_fov) ensures proper perspective mapping
 sdist=screen_center_x/tan(fov)
 
 local sa,ca=sin(player.a),cos(player.a)
 minx,maxx=999,-999
 miny,maxy=999,-999
 maxz=0
 
 for i=0,ray_count-1 do
  local dx=screen_center_x-i
  local dy=sdist
  
  -- rotate by camera angle
  local rdx=ca*dx+sa*dy
  local rdy=ca*dy-sa*dx
  
  local z,hx,hy,tile,tx=raycast(player.x,player.y,rdx,rdy,sa,ca)
  
  zbuf[i+1]=z
  tbuf[i+1]={tile=tile,tx=tx}
  
  -- track bounds for object culling
  minx=min(minx,hx)
  maxx=max(maxx,hx)
  miny=min(miny,hy)
  maxy=max(maxy,hy)
  maxz=max(maxz,z)
 end
end

-- hitscan for projectiles/line-of-sight
function hitscan(x,y,dx,dy)
 -- normalize and get wall depth
 local sa,ca=normalise(dx,dy)
 local d,hx,hy,tile,tx=raycast(x,y,dx,dy,sa,ca)
 
 -- determine aabb
 local x0,y0=min(x,hx),min(y,hy)
 local x1,y1=max(x,hx),max(y,hy)
 
 local closest_obj=nil
 local closest_dist=d
 
 -- iterate relevant objgrid cells
 for gx=flr(x0/objgrid_size),flr(x1/objgrid_size) do
  for gy=flr(y0/objgrid_size),flr(y1/objgrid_size) do
   if gx>=0 and gx<=objgrid_array_size and gy>=0 and gy<=objgrid_array_size then
    for ob in all(objgrid[gx+1][gy+1]) do
     -- check if solid object
     if ob.typ and ob.typ.solid then
      -- compute normal and tangential distances
      local ox=ob.pos[1]-x
      local oy=ob.pos[2]-y
      local dn=(ox)*ca-(oy)*sa
      local dt=(ox)*sa+(oy)*ca
      
      -- check if within normal bounds
      if abs(dn)<=ob.typ.w*0.5 then
       -- check if not behind or beyond wall
       if dt>0 and dt<d then
        -- track closest object
        if dt<closest_dist then
         closest_dist=dt
         closest_obj=ob
        end
       end
      end
     end
    end
   end
  end
 end
 
 return closest_obj,closest_dist
end

:: src/render.lua
--[[pod_format="raw",created="2025-11-07 21:17:11",modified="2025-11-07 21:48:08",revision=1]]
-- rendering pipeline

-- get sprite sheet for tline3d
function get_texture_source()
 -- return sprite sheet userdata (index 0)
 local src=get_spr(0)
 if not src then
  printh("warning: sprite sheet 0 not found")
  return userdata("u8",128,128)
 end
 return src
end

-- track last applied fog level to reduce palette changes
last_fog_level=-1
prev_pal={}

-- apply distance-based fog (with caching for performance)
function set_fog(z)
 if z<=0 then
  pal()
  last_fog_level=-1
  prev_pal={}
  return
 end
 
 local level
 if use_quadratic_fog then
  -- quadratic falloff with brightness adjustment
  local i=min(z,100)^2/fogdist
  i=min(1-(1-i)*screenbright,0.9999)
  level=flr(i*#pals)
 else
  -- simple linear distance fallback
  level=flr(min(z/8,15))
 end
 
 -- only update palette if fog level changed (reduces palette ops from 320/frame to ~10-20)
 if level~=last_fog_level then
  local p=pals[level+1]
  for i=0,63 do
   -- incremental update: only apply if value changed
   if p[i+1]~=prev_pal[i] then
    pal(i,p[i+1])
    prev_pal[i]=p[i+1]
   end
  end
  last_fog_level=level
 end
end

-- render textured walls
function render_walls()
 palt(0,false)
 local src=get_texture_source()
 
 for x=0,ray_count-1 do
  local z=zbuf[x+1]
  local t=tbuf[x+1]
  
  if z<999 then
   -- calculate wall height
   local h=sdist/z
   local y0=screen_center_y-h/2
   local y1=screen_center_y+h/2
   
   -- extract texture coordinates from table
   local tile=t.tile
   local tx=t.tx
   
   -- compute pixel UV in spritesheet (8x8 tiles)
   -- current approach: tile x,y position in 16-tile-wide sheet
   -- functionally equivalent to reference's ((t\8)+t%1)*4 encoding
   -- but more maintainable for Picotron's tile-based system
   local tile_x=tile%16
   local tile_y=flr(tile/16)
   -- pixel u is tile_x*8 + fractional offset tx*8 (clamped 0-7)
   local u0=tile_x*8+flr(tx*8)
   local v0=tile_y*8
   local u1=u0
   local v1=v0+8
   
   -- sub-pixel adjustment with texture v adjustment
   local yadj=ceil(y0)-y0
   y0+=yadj
   -- adjust v0 to maintain texture continuity when top is clipped
   if y1>y0 then
    v0+=(yadj/(y1-y0))*8
    v1=v0+8
   end
   
   -- clamp
   y1=min(flr(y1),screen_height-1)
   
   -- apply fog
   set_fog(z)
   
   -- draw textured column (vertical sample u0==u1)
   tline3d(src,x,y0,x,y1,u0,v0,u1,v1,1,1)
  end
 end
 
 pal()
end

-- render perspective floor/ceiling
function render_floor_ceiling()
 local sa,ca=sin(player.a),cos(player.a)
 local src=get_texture_source()
 
 -- calculate horizon with safeguard against divide-by-zero
 local h
 if maxz<=0 then
  h=screen_height
 else
  h=sdist/maxz
 end
 
 -- render ceiling
 local roof_typ=roof.typ
 draw_rows(src,-screen_center_y,-ceil(h/2),roof_typ.scale,roof_typ.height,cam[1]-roof.x,cam[2]-roof.y,roof_typ.lit,sa,ca,roof_typ.tex)
 
 -- render floor
 local floor_typ=floor.typ
 draw_rows(src,ceil(h/2),screen_center_y-1,floor_typ.scale,floor_typ.height,cam[1]-floor.x,cam[2]-floor.y,floor_typ.lit,sa,ca,floor_typ.tex)
 
 pal()
end

-- draw horizontal scanlines
function draw_rows(src,y0,y1,tilesize,height,cx,cy,lit,sa,ca,tex)
 for y=y0,y1 do
  -- calculate ray gradient
  local g=abs(y)/sdist
  
  -- calculate z distance
  local z=(height or 0.5)/g
  
  -- calculate map coordinates
  local mx=(cx+z*sa)/tilesize
  local my=(cy+z*ca)/tilesize
  
  -- calculate texture deltas
  local s=sdist/z*tilesize
  local mdx=-ca/s
  local mdy=sa/s
  
  -- offset to left edge
  mx-=screen_center_x*mdx
  my-=screen_center_x*mdy
  
  -- apply fog
  set_fog(lit and 0 or z)
  
  -- texture coordinates (pixel UVs in 8x8 tile)
  local tile_x=tex%16
  local tile_y=flr(tex/16)
  local base_u=tile_x*8
  local base_v=tile_y*8
  
  -- map fractional position to pixel offset within tile
  local u0=base_u+(mx%1)*8
  local v0=base_v+(my%1)*8
  -- calculate end UVs based on texture delta across scanline
  local u1=u0+screen_width*mdx*8
  local v1=v0+screen_width*mdy*8
  
  -- draw scanline
  tline3d(src,0,screen_center_y+y,screen_width-1,screen_center_y+y,u0,v0,u1,v1,1,1)
 end
end


:: src/render_sprite.lua
--[[pod_format="raw",created="2025-11-07 21:17:10",modified="2025-11-07 21:48:08",revision=1]]
-- sprite rendering pipeline

-- render sprites with z-buffer occlusion
function render_sprites()
 palt(0,false)
 palt(14,true)
 local src=get_texture_source()
 
 local sa,ca=sin(player.a),cos(player.a)
 local vvolg=screen_center_x/sdist
 
 -- transform and cull objects
 local sobj={}
 
 for gx=flr(minx/objgrid_size),flr(maxx/objgrid_size) do
  for gy=flr(miny/objgrid_size),flr(maxy/objgrid_size) do
   if gx>=0 and gx<=objgrid_array_size and gy>=0 and gy<=objgrid_array_size then
    for ob in all(objgrid[gx+1][gy+1]) do
     if ob and ob.pos and ob.typ then
      -- transform to view space
      local rx=ob.pos[1]-player.x
      local ry=ob.pos[2]-player.y
      
      -- rotate to view-aligned coordinates
      ob.rel[1]=-ca*rx-sa*ry
      ob.rel[2]=ca*ry-sa*rx
      
      -- cull behind camera and outside frustum
      local t=ob.typ
      local pass_frustum=false
      if ob.rel[2]>0.1 then
       if t.flat then
        -- flat sprites: require minimum distance to prevent z-division issues
        if ob.rel[2]>=t.w/2 then
         pass_frustum=true
        end
       else
        -- upright sprites: horizontal frustum culling
        if abs(ob.rel[1])-t.w<ob.rel[2]*(screen_center_x/sdist) then
         pass_frustum=true
        end
       end
      end
      
      if pass_frustum then
       -- compute sort order (depth)
       ob.sortorder=ob.rel[2]
       
       -- flat sprites sort differently (on ground plane)
       if ob.typ.flat then
        ob.sortorder+=1000
       end
       
       -- insertion sort into sobj (back-to-front)
       local inserted=false
       for i=1,#sobj do
        if ob.sortorder>sobj[i].sortorder then
         -- manual array insertion
         for j=#sobj,i,-1 do
          sobj[j+1]=sobj[j]
         end
         sobj[i]=ob
         inserted=true
         break
        end
       end
       if not inserted then
        add(sobj,ob)
       end
      end
     end
    end
   end
  end
 end
 
 -- draw sprites back-to-front
 drawobjs(sobj,sa,ca,src)
 
 clip()
 pal()
end

-- draw objects from sorted list
function drawobjs(sobj,sa,ca,src)
 for ob in all(sobj) do
  if not ob or not ob.typ or not ob.rel then
   goto skip_obj
  end
  
  local t=ob.typ
  local x=ob.rel[1]
  local z=ob.rel[2]
  
  -- get vertical offset (can be animated)
  local y=ob.y or t.y
  if t.yoffs then
   local frame_idx=flr(ob.frame%#t.yoffs)+1
   if frame_idx>0 and frame_idx<=#t.yoffs then
    y+=t.yoffs[frame_idx]
   end
  end
  
  -- calculate scale factor (perspective)
  local f=sdist/z
  
  -- project to screen space
  local sx=x*f+screen_center_x
  local w=t.w*f
  
  -- calculate y coordinates (different for flat vs upright)
  local y0,y1
  if t.flat then
   -- floor-aligned sprite
   local z0=z+t.w/2
   local z1=z-t.w/2
   y0=y*sdist/z0+screen_center_y
   y1=y*sdist/z1+screen_center_y
  else
   -- upright sprite
   local sy=y*f+screen_center_y
   local h=t.h*f
   y0=sy-h/2
   y1=sy+h/2
  end
  
  -- calculate sprite sheet coordinates
  local sx_sheet=t.mx
  local sy_sheet=t.my
  local sxd=t.mw/w
  local syd=t.mh/(y1-y0+0.01)
  
  -- handle animation
  if t.framect then
   local fr=flr(ob.frame)
   if ob.animloop then
    fr=fr%t.framect
   else
    fr=min(fr,t.framect-1)
   end
   sx_sheet+=fr*t.mw
  end
  
  -- compute floating left/top edges for sub-pixel adjustment
  local lx=sx-w/2
  local fy0=y0
  
  -- clamp to screen bounds
  local x0=max(0,ceil(lx))
  local x1=min(ray_count-1,flr(sx+w/2))
  -- adjust sx_sheet for x clipping
  if x0>lx then
   sx_sheet+=(x0-lx)*sxd
  end
  
  y0=max(0,ceil(fy0))
  y1=min(screen_height-1,flr(y1))
  -- adjust sy_sheet for y clipping
  if y0>fy0 then
   sy_sheet+=(y0-fy0)*syd
  end
  
  -- set fog and palette
  if ob.pal then
   pal(ob.pal)
  else
   set_fog(z*(t.lit or 1))
  end
  
  -- draw sprite column by column with z-buffer
  for px=x0,x1 do
   if z<zbuf[px+1] then
    -- not occluded, draw column
    local u_offset=sx_sheet+(px-x0)*sxd
    tline3d(src,px,y0,px,y1,u_offset,sy_sheet,u_offset,sy_sheet+t.mh,1,1)
   end
  end
  
  ::skip_obj::
 end
end

:: [eoc]
